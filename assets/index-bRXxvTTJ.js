function zj(n,t){for(var e=0;e<t.length;e++){const s=t[e];if(typeof s!="string"&&!Array.isArray(s)){for(const i in s)if(i!=="default"&&!(i in n)){const r=Object.getOwnPropertyDescriptor(s,i);r&&Object.defineProperty(n,i,r.get?r:{enumerable:!0,get:()=>s[i]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const a of r.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function e(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(i){if(i.ep)return;i.ep=!0;const r=e(i);fetch(i.href,r)}})();function _x(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function Uj(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var t=n.default;if(typeof t=="function"){var e=function s(){return this instanceof s?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};e.prototype=t.prototype}else e={};return Object.defineProperty(e,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var i=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(e,s,i.get?i:{enumerable:!0,get:function(){return n[s]}})}),e}var cM={exports:{}},yb={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var kL;function Bj(){if(kL)return yb;kL=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function e(s,i,r){var a=null;if(r!==void 0&&(a=""+r),i.key!==void 0&&(a=""+i.key),"key"in i){r={};for(var o in i)o!=="key"&&(r[o]=i[o])}else r=i;return i=r.ref,{$$typeof:n,type:s,key:a,ref:i!==void 0?i:null,props:r}}return yb.Fragment=t,yb.jsx=e,yb.jsxs=e,yb}var OL;function Pj(){return OL||(OL=1,cM.exports=Bj()),cM.exports}var ge=Pj(),uM={exports:{}},In={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var $L;function Vj(){if($L)return In;$L=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),e=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),r=Symbol.for("react.consumer"),a=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),f=Symbol.for("react.activity"),p=Symbol.iterator;function g(X){return X===null||typeof X!="object"?null:(X=p&&X[p]||X["@@iterator"],typeof X=="function"?X:null)}var v={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},_=Object.assign,S={};function b(X,it,ct){this.props=X,this.context=it,this.refs=S,this.updater=ct||v}b.prototype.isReactComponent={},b.prototype.setState=function(X,it){if(typeof X!="object"&&typeof X!="function"&&X!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,X,it,"setState")},b.prototype.forceUpdate=function(X){this.updater.enqueueForceUpdate(this,X,"forceUpdate")};function T(){}T.prototype=b.prototype;function C(X,it,ct){this.props=X,this.context=it,this.refs=S,this.updater=ct||v}var A=C.prototype=new T;A.constructor=C,_(A,b.prototype),A.isPureReactComponent=!0;var I=Array.isArray;function D(){}var F={H:null,A:null,T:null,S:null},z=Object.prototype.hasOwnProperty;function k(X,it,ct){var yt=ct.ref;return{$$typeof:n,type:X,key:it,ref:yt!==void 0?yt:null,props:ct}}function O(X,it){return k(X.type,it,X.props)}function L(X){return typeof X=="object"&&X!==null&&X.$$typeof===n}function H(X){var it={"=":"=0",":":"=2"};return"$"+X.replace(/[=:]/g,function(ct){return it[ct]})}var q=/\/+/g;function K(X,it){return typeof X=="object"&&X!==null&&X.key!=null?H(""+X.key):it.toString(36)}function Y(X){switch(X.status){case"fulfilled":return X.value;case"rejected":throw X.reason;default:switch(typeof X.status=="string"?X.then(D,D):(X.status="pending",X.then(function(it){X.status==="pending"&&(X.status="fulfilled",X.value=it)},function(it){X.status==="pending"&&(X.status="rejected",X.reason=it)})),X.status){case"fulfilled":return X.value;case"rejected":throw X.reason}}throw X}function P(X,it,ct,yt,Rt){var ft=typeof X;(ft==="undefined"||ft==="boolean")&&(X=null);var _t=!1;if(X===null)_t=!0;else switch(ft){case"bigint":case"string":case"number":_t=!0;break;case"object":switch(X.$$typeof){case n:case t:_t=!0;break;case h:return _t=X._init,P(_t(X._payload),it,ct,yt,Rt)}}if(_t)return Rt=Rt(X),_t=yt===""?"."+K(X,0):yt,I(Rt)?(ct="",_t!=null&&(ct=_t.replace(q,"$&/")+"/"),P(Rt,it,ct,"",function(se){return se})):Rt!=null&&(L(Rt)&&(Rt=O(Rt,ct+(Rt.key==null||X&&X.key===Rt.key?"":(""+Rt.key).replace(q,"$&/")+"/")+_t)),it.push(Rt)),1;_t=0;var qt=yt===""?".":yt+":";if(I(X))for(var Qt=0;Qt<X.length;Qt++)yt=X[Qt],ft=qt+K(yt,Qt),_t+=P(yt,it,ct,ft,Rt);else if(Qt=g(X),typeof Qt=="function")for(X=Qt.call(X),Qt=0;!(yt=X.next()).done;)yt=yt.value,ft=qt+K(yt,Qt++),_t+=P(yt,it,ct,ft,Rt);else if(ft==="object"){if(typeof X.then=="function")return P(Y(X),it,ct,yt,Rt);throw it=String(X),Error("Objects are not valid as a React child (found: "+(it==="[object Object]"?"object with keys {"+Object.keys(X).join(", ")+"}":it)+"). If you meant to render a collection of children, use an array instead.")}return _t}function W(X,it,ct){if(X==null)return X;var yt=[],Rt=0;return P(X,yt,"","",function(ft){return it.call(ct,ft,Rt++)}),yt}function j(X){if(X._status===-1){var it=X._result;it=it(),it.then(function(ct){(X._status===0||X._status===-1)&&(X._status=1,X._result=ct)},function(ct){(X._status===0||X._status===-1)&&(X._status=2,X._result=ct)}),X._status===-1&&(X._status=0,X._result=it)}if(X._status===1)return X._result.default;throw X._result}var st=typeof reportError=="function"?reportError:function(X){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var it=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof X=="object"&&X!==null&&typeof X.message=="string"?String(X.message):String(X),error:X});if(!window.dispatchEvent(it))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",X);return}console.error(X)},ot={map:W,forEach:function(X,it,ct){W(X,function(){it.apply(this,arguments)},ct)},count:function(X){var it=0;return W(X,function(){it++}),it},toArray:function(X){return W(X,function(it){return it})||[]},only:function(X){if(!L(X))throw Error("React.Children.only expected to receive a single React element child.");return X}};return In.Activity=f,In.Children=ot,In.Component=b,In.Fragment=e,In.Profiler=i,In.PureComponent=C,In.StrictMode=s,In.Suspense=l,In.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=F,In.__COMPILER_RUNTIME={__proto__:null,c:function(X){return F.H.useMemoCache(X)}},In.cache=function(X){return function(){return X.apply(null,arguments)}},In.cacheSignal=function(){return null},In.cloneElement=function(X,it,ct){if(X==null)throw Error("The argument must be a React element, but you passed "+X+".");var yt=_({},X.props),Rt=X.key;if(it!=null)for(ft in it.key!==void 0&&(Rt=""+it.key),it)!z.call(it,ft)||ft==="key"||ft==="__self"||ft==="__source"||ft==="ref"&&it.ref===void 0||(yt[ft]=it[ft]);var ft=arguments.length-2;if(ft===1)yt.children=ct;else if(1<ft){for(var _t=Array(ft),qt=0;qt<ft;qt++)_t[qt]=arguments[qt+2];yt.children=_t}return k(X.type,Rt,yt)},In.createContext=function(X){return X={$$typeof:a,_currentValue:X,_currentValue2:X,_threadCount:0,Provider:null,Consumer:null},X.Provider=X,X.Consumer={$$typeof:r,_context:X},X},In.createElement=function(X,it,ct){var yt,Rt={},ft=null;if(it!=null)for(yt in it.key!==void 0&&(ft=""+it.key),it)z.call(it,yt)&&yt!=="key"&&yt!=="__self"&&yt!=="__source"&&(Rt[yt]=it[yt]);var _t=arguments.length-2;if(_t===1)Rt.children=ct;else if(1<_t){for(var qt=Array(_t),Qt=0;Qt<_t;Qt++)qt[Qt]=arguments[Qt+2];Rt.children=qt}if(X&&X.defaultProps)for(yt in _t=X.defaultProps,_t)Rt[yt]===void 0&&(Rt[yt]=_t[yt]);return k(X,ft,Rt)},In.createRef=function(){return{current:null}},In.forwardRef=function(X){return{$$typeof:o,render:X}},In.isValidElement=L,In.lazy=function(X){return{$$typeof:h,_payload:{_status:-1,_result:X},_init:j}},In.memo=function(X,it){return{$$typeof:c,type:X,compare:it===void 0?null:it}},In.startTransition=function(X){var it=F.T,ct={};F.T=ct;try{var yt=X(),Rt=F.S;Rt!==null&&Rt(ct,yt),typeof yt=="object"&&yt!==null&&typeof yt.then=="function"&&yt.then(D,st)}catch(ft){st(ft)}finally{it!==null&&ct.types!==null&&(it.types=ct.types),F.T=it}},In.unstable_useCacheRefresh=function(){return F.H.useCacheRefresh()},In.use=function(X){return F.H.use(X)},In.useActionState=function(X,it,ct){return F.H.useActionState(X,it,ct)},In.useCallback=function(X,it){return F.H.useCallback(X,it)},In.useContext=function(X){return F.H.useContext(X)},In.useDebugValue=function(){},In.useDeferredValue=function(X,it){return F.H.useDeferredValue(X,it)},In.useEffect=function(X,it){return F.H.useEffect(X,it)},In.useEffectEvent=function(X){return F.H.useEffectEvent(X)},In.useId=function(){return F.H.useId()},In.useImperativeHandle=function(X,it,ct){return F.H.useImperativeHandle(X,it,ct)},In.useInsertionEffect=function(X,it){return F.H.useInsertionEffect(X,it)},In.useLayoutEffect=function(X,it){return F.H.useLayoutEffect(X,it)},In.useMemo=function(X,it){return F.H.useMemo(X,it)},In.useOptimistic=function(X,it){return F.H.useOptimistic(X,it)},In.useReducer=function(X,it,ct){return F.H.useReducer(X,it,ct)},In.useRef=function(X){return F.H.useRef(X)},In.useState=function(X){return F.H.useState(X)},In.useSyncExternalStore=function(X,it,ct){return F.H.useSyncExternalStore(X,it,ct)},In.useTransition=function(){return F.H.useTransition()},In.version="19.2.3",In}var LL;function Dg(){return LL||(LL=1,uM.exports=Vj()),uM.exports}var be=Dg();const OD=_x(be);var hM={exports:{}},xb={},fM={exports:{}},dM={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var FL;function Gj(){return FL||(FL=1,(function(n){function t(P,W){var j=P.length;P.push(W);t:for(;0<j;){var st=j-1>>>1,ot=P[st];if(0<i(ot,W))P[st]=W,P[j]=ot,j=st;else break t}}function e(P){return P.length===0?null:P[0]}function s(P){if(P.length===0)return null;var W=P[0],j=P.pop();if(j!==W){P[0]=j;t:for(var st=0,ot=P.length,X=ot>>>1;st<X;){var it=2*(st+1)-1,ct=P[it],yt=it+1,Rt=P[yt];if(0>i(ct,j))yt<ot&&0>i(Rt,ct)?(P[st]=Rt,P[yt]=j,st=yt):(P[st]=ct,P[it]=j,st=it);else if(yt<ot&&0>i(Rt,j))P[st]=Rt,P[yt]=j,st=yt;else break t}}return W}function i(P,W){var j=P.sortIndex-W.sortIndex;return j!==0?j:P.id-W.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var r=performance;n.unstable_now=function(){return r.now()}}else{var a=Date,o=a.now();n.unstable_now=function(){return a.now()-o}}var l=[],c=[],h=1,f=null,p=3,g=!1,v=!1,_=!1,S=!1,b=typeof setTimeout=="function"?setTimeout:null,T=typeof clearTimeout=="function"?clearTimeout:null,C=typeof setImmediate<"u"?setImmediate:null;function A(P){for(var W=e(c);W!==null;){if(W.callback===null)s(c);else if(W.startTime<=P)s(c),W.sortIndex=W.expirationTime,t(l,W);else break;W=e(c)}}function I(P){if(_=!1,A(P),!v)if(e(l)!==null)v=!0,D||(D=!0,H());else{var W=e(c);W!==null&&Y(I,W.startTime-P)}}var D=!1,F=-1,z=5,k=-1;function O(){return S?!0:!(n.unstable_now()-k<z)}function L(){if(S=!1,D){var P=n.unstable_now();k=P;var W=!0;try{t:{v=!1,_&&(_=!1,T(F),F=-1),g=!0;var j=p;try{e:{for(A(P),f=e(l);f!==null&&!(f.expirationTime>P&&O());){var st=f.callback;if(typeof st=="function"){f.callback=null,p=f.priorityLevel;var ot=st(f.expirationTime<=P);if(P=n.unstable_now(),typeof ot=="function"){f.callback=ot,A(P),W=!0;break e}f===e(l)&&s(l),A(P)}else s(l);f=e(l)}if(f!==null)W=!0;else{var X=e(c);X!==null&&Y(I,X.startTime-P),W=!1}}break t}finally{f=null,p=j,g=!1}W=void 0}}finally{W?H():D=!1}}}var H;if(typeof C=="function")H=function(){C(L)};else if(typeof MessageChannel<"u"){var q=new MessageChannel,K=q.port2;q.port1.onmessage=L,H=function(){K.postMessage(null)}}else H=function(){b(L,0)};function Y(P,W){F=b(function(){P(n.unstable_now())},W)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(P){P.callback=null},n.unstable_forceFrameRate=function(P){0>P||125<P?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):z=0<P?Math.floor(1e3/P):5},n.unstable_getCurrentPriorityLevel=function(){return p},n.unstable_next=function(P){switch(p){case 1:case 2:case 3:var W=3;break;default:W=p}var j=p;p=W;try{return P()}finally{p=j}},n.unstable_requestPaint=function(){S=!0},n.unstable_runWithPriority=function(P,W){switch(P){case 1:case 2:case 3:case 4:case 5:break;default:P=3}var j=p;p=P;try{return W()}finally{p=j}},n.unstable_scheduleCallback=function(P,W,j){var st=n.unstable_now();switch(typeof j=="object"&&j!==null?(j=j.delay,j=typeof j=="number"&&0<j?st+j:st):j=st,P){case 1:var ot=-1;break;case 2:ot=250;break;case 5:ot=1073741823;break;case 4:ot=1e4;break;default:ot=5e3}return ot=j+ot,P={id:h++,callback:W,priorityLevel:P,startTime:j,expirationTime:ot,sortIndex:-1},j>st?(P.sortIndex=j,t(c,P),e(l)===null&&P===e(c)&&(_?(T(F),F=-1):_=!0,Y(I,j-st))):(P.sortIndex=ot,t(l,P),v||g||(v=!0,D||(D=!0,H()))),P},n.unstable_shouldYield=O,n.unstable_wrapCallback=function(P){var W=p;return function(){var j=p;p=W;try{return P.apply(this,arguments)}finally{p=j}}}})(dM)),dM}var zL;function Hj(){return zL||(zL=1,fM.exports=Gj()),fM.exports}var pM={exports:{}},Ia={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var UL;function Wj(){if(UL)return Ia;UL=1;var n=Dg();function t(l){var c="https://react.dev/errors/"+l;if(1<arguments.length){c+="?args[]="+encodeURIComponent(arguments[1]);for(var h=2;h<arguments.length;h++)c+="&args[]="+encodeURIComponent(arguments[h])}return"Minified React error #"+l+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function e(){}var s={d:{f:e,r:function(){throw Error(t(522))},D:e,C:e,L:e,m:e,X:e,S:e,M:e},p:0,findDOMNode:null},i=Symbol.for("react.portal");function r(l,c,h){var f=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:i,key:f==null?null:""+f,children:l,containerInfo:c,implementation:h}}var a=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(l,c){if(l==="font")return"";if(typeof c=="string")return c==="use-credentials"?c:""}return Ia.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,Ia.createPortal=function(l,c){var h=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!c||c.nodeType!==1&&c.nodeType!==9&&c.nodeType!==11)throw Error(t(299));return r(l,c,null,h)},Ia.flushSync=function(l){var c=a.T,h=s.p;try{if(a.T=null,s.p=2,l)return l()}finally{a.T=c,s.p=h,s.d.f()}},Ia.preconnect=function(l,c){typeof l=="string"&&(c?(c=c.crossOrigin,c=typeof c=="string"?c==="use-credentials"?c:"":void 0):c=null,s.d.C(l,c))},Ia.prefetchDNS=function(l){typeof l=="string"&&s.d.D(l)},Ia.preinit=function(l,c){if(typeof l=="string"&&c&&typeof c.as=="string"){var h=c.as,f=o(h,c.crossOrigin),p=typeof c.integrity=="string"?c.integrity:void 0,g=typeof c.fetchPriority=="string"?c.fetchPriority:void 0;h==="style"?s.d.S(l,typeof c.precedence=="string"?c.precedence:void 0,{crossOrigin:f,integrity:p,fetchPriority:g}):h==="script"&&s.d.X(l,{crossOrigin:f,integrity:p,fetchPriority:g,nonce:typeof c.nonce=="string"?c.nonce:void 0})}},Ia.preinitModule=function(l,c){if(typeof l=="string")if(typeof c=="object"&&c!==null){if(c.as==null||c.as==="script"){var h=o(c.as,c.crossOrigin);s.d.M(l,{crossOrigin:h,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0})}}else c==null&&s.d.M(l)},Ia.preload=function(l,c){if(typeof l=="string"&&typeof c=="object"&&c!==null&&typeof c.as=="string"){var h=c.as,f=o(h,c.crossOrigin);s.d.L(l,h,{crossOrigin:f,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0,type:typeof c.type=="string"?c.type:void 0,fetchPriority:typeof c.fetchPriority=="string"?c.fetchPriority:void 0,referrerPolicy:typeof c.referrerPolicy=="string"?c.referrerPolicy:void 0,imageSrcSet:typeof c.imageSrcSet=="string"?c.imageSrcSet:void 0,imageSizes:typeof c.imageSizes=="string"?c.imageSizes:void 0,media:typeof c.media=="string"?c.media:void 0})}},Ia.preloadModule=function(l,c){if(typeof l=="string")if(c){var h=o(c.as,c.crossOrigin);s.d.m(l,{as:typeof c.as=="string"&&c.as!=="script"?c.as:void 0,crossOrigin:h,integrity:typeof c.integrity=="string"?c.integrity:void 0})}else s.d.m(l)},Ia.requestFormReset=function(l){s.d.r(l)},Ia.unstable_batchedUpdates=function(l,c){return l(c)},Ia.useFormState=function(l,c,h){return a.H.useFormState(l,c,h)},Ia.useFormStatus=function(){return a.H.useHostTransitionStatus()},Ia.version="19.2.3",Ia}var BL;function qj(){if(BL)return pM.exports;BL=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),pM.exports=Wj(),pM.exports}/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var PL;function Xj(){if(PL)return xb;PL=1;var n=Hj(),t=Dg(),e=qj();function s(u){var d="https://react.dev/errors/"+u;if(1<arguments.length){d+="?args[]="+encodeURIComponent(arguments[1]);for(var x=2;x<arguments.length;x++)d+="&args[]="+encodeURIComponent(arguments[x])}return"Minified React error #"+u+"; visit "+d+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function i(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)}function r(u){var d=u,x=u;if(u.alternate)for(;d.return;)d=d.return;else{u=d;do d=u,(d.flags&4098)!==0&&(x=d.return),u=d.return;while(u)}return d.tag===3?x:null}function a(u){if(u.tag===13){var d=u.memoizedState;if(d===null&&(u=u.alternate,u!==null&&(d=u.memoizedState)),d!==null)return d.dehydrated}return null}function o(u){if(u.tag===31){var d=u.memoizedState;if(d===null&&(u=u.alternate,u!==null&&(d=u.memoizedState)),d!==null)return d.dehydrated}return null}function l(u){if(r(u)!==u)throw Error(s(188))}function c(u){var d=u.alternate;if(!d){if(d=r(u),d===null)throw Error(s(188));return d!==u?null:u}for(var x=u,w=d;;){var N=x.return;if(N===null)break;var R=N.alternate;if(R===null){if(w=N.return,w!==null){x=w;continue}break}if(N.child===R.child){for(R=N.child;R;){if(R===x)return l(N),u;if(R===w)return l(N),d;R=R.sibling}throw Error(s(188))}if(x.return!==w.return)x=N,w=R;else{for(var V=!1,Q=N.child;Q;){if(Q===x){V=!0,x=N,w=R;break}if(Q===w){V=!0,w=N,x=R;break}Q=Q.sibling}if(!V){for(Q=R.child;Q;){if(Q===x){V=!0,x=R,w=N;break}if(Q===w){V=!0,w=R,x=N;break}Q=Q.sibling}if(!V)throw Error(s(189))}}if(x.alternate!==w)throw Error(s(190))}if(x.tag!==3)throw Error(s(188));return x.stateNode.current===x?u:d}function h(u){var d=u.tag;if(d===5||d===26||d===27||d===6)return u;for(u=u.child;u!==null;){if(d=h(u),d!==null)return d;u=u.sibling}return null}var f=Object.assign,p=Symbol.for("react.element"),g=Symbol.for("react.transitional.element"),v=Symbol.for("react.portal"),_=Symbol.for("react.fragment"),S=Symbol.for("react.strict_mode"),b=Symbol.for("react.profiler"),T=Symbol.for("react.consumer"),C=Symbol.for("react.context"),A=Symbol.for("react.forward_ref"),I=Symbol.for("react.suspense"),D=Symbol.for("react.suspense_list"),F=Symbol.for("react.memo"),z=Symbol.for("react.lazy"),k=Symbol.for("react.activity"),O=Symbol.for("react.memo_cache_sentinel"),L=Symbol.iterator;function H(u){return u===null||typeof u!="object"?null:(u=L&&u[L]||u["@@iterator"],typeof u=="function"?u:null)}var q=Symbol.for("react.client.reference");function K(u){if(u==null)return null;if(typeof u=="function")return u.$$typeof===q?null:u.displayName||u.name||null;if(typeof u=="string")return u;switch(u){case _:return"Fragment";case b:return"Profiler";case S:return"StrictMode";case I:return"Suspense";case D:return"SuspenseList";case k:return"Activity"}if(typeof u=="object")switch(u.$$typeof){case v:return"Portal";case C:return u.displayName||"Context";case T:return(u._context.displayName||"Context")+".Consumer";case A:var d=u.render;return u=u.displayName,u||(u=d.displayName||d.name||"",u=u!==""?"ForwardRef("+u+")":"ForwardRef"),u;case F:return d=u.displayName||null,d!==null?d:K(u.type)||"Memo";case z:d=u._payload,u=u._init;try{return K(u(d))}catch{}}return null}var Y=Array.isArray,P=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,W=e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,j={pending:!1,data:null,method:null,action:null},st=[],ot=-1;function X(u){return{current:u}}function it(u){0>ot||(u.current=st[ot],st[ot]=null,ot--)}function ct(u,d){ot++,st[ot]=u.current,u.current=d}var yt=X(null),Rt=X(null),ft=X(null),_t=X(null);function qt(u,d){switch(ct(ft,d),ct(Rt,u),ct(yt,null),d.nodeType){case 9:case 11:u=(u=d.documentElement)&&(u=u.namespaceURI)?nL(u):0;break;default:if(u=d.tagName,d=d.namespaceURI)d=nL(d),u=sL(d,u);else switch(u){case"svg":u=1;break;case"math":u=2;break;default:u=0}}it(yt),ct(yt,u)}function Qt(){it(yt),it(Rt),it(ft)}function se(u){u.memoizedState!==null&&ct(_t,u);var d=yt.current,x=sL(d,u.type);d!==x&&(ct(Rt,u),ct(yt,x))}function Ee(u){Rt.current===u&&(it(yt),it(Rt)),_t.current===u&&(it(_t),db._currentValue=j)}var He,Ae;function Ht(u){if(He===void 0)try{throw Error()}catch(x){var d=x.stack.trim().match(/\n( *(at )?)/);He=d&&d[1]||"",Ae=-1<x.stack.indexOf(`
    at`)?" (<anonymous>)":-1<x.stack.indexOf("@")?"@unknown:0:0":""}return`
`+He+u+Ae}var Jt=!1;function Xt(u,d){if(!u||Jt)return"";Jt=!0;var x=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var w={DetermineComponentFrameRoot:function(){try{if(d){var le=function(){throw Error()};if(Object.defineProperty(le.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(le,[])}catch(jt){var Ut=jt}Reflect.construct(u,[],le)}else{try{le.call()}catch(jt){Ut=jt}u.call(le.prototype)}}else{try{throw Error()}catch(jt){Ut=jt}(le=u())&&typeof le.catch=="function"&&le.catch(function(){})}}catch(jt){if(jt&&Ut&&typeof jt.stack=="string")return[jt.stack,Ut.stack]}return[null,null]}};w.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var N=Object.getOwnPropertyDescriptor(w.DetermineComponentFrameRoot,"name");N&&N.configurable&&Object.defineProperty(w.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var R=w.DetermineComponentFrameRoot(),V=R[0],Q=R[1];if(V&&Q){var gt=V.split(`
`),$t=Q.split(`
`);for(N=w=0;w<gt.length&&!gt[w].includes("DetermineComponentFrameRoot");)w++;for(;N<$t.length&&!$t[N].includes("DetermineComponentFrameRoot");)N++;if(w===gt.length||N===$t.length)for(w=gt.length-1,N=$t.length-1;1<=w&&0<=N&&gt[w]!==$t[N];)N--;for(;1<=w&&0<=N;w--,N--)if(gt[w]!==$t[N]){if(w!==1||N!==1)do if(w--,N--,0>N||gt[w]!==$t[N]){var ee=`
`+gt[w].replace(" at new "," at ");return u.displayName&&ee.includes("<anonymous>")&&(ee=ee.replace("<anonymous>",u.displayName)),ee}while(1<=w&&0<=N);break}}}finally{Jt=!1,Error.prepareStackTrace=x}return(x=u?u.displayName||u.name:"")?Ht(x):""}function ce(u,d){switch(u.tag){case 26:case 27:case 5:return Ht(u.type);case 16:return Ht("Lazy");case 13:return u.child!==d&&d!==null?Ht("Suspense Fallback"):Ht("Suspense");case 19:return Ht("SuspenseList");case 0:case 15:return Xt(u.type,!1);case 11:return Xt(u.type.render,!1);case 1:return Xt(u.type,!0);case 31:return Ht("Activity");default:return""}}function rt(u){try{var d="",x=null;do d+=ce(u,x),x=u,u=u.return;while(u);return d}catch(w){return`
Error generating stack: `+w.message+`
`+w.stack}}var Fe=Object.prototype.hasOwnProperty,he=n.unstable_scheduleCallback,Pe=n.unstable_cancelCallback,pe=n.unstable_shouldYield,nt=n.unstable_requestPaint,G=n.unstable_now,vt=n.unstable_getCurrentPriorityLevel,Vt=n.unstable_ImmediatePriority,te=n.unstable_UserBlockingPriority,Pt=n.unstable_NormalPriority,Ue=n.unstable_LowPriority,we=n.unstable_IdlePriority,ze=n.log,nn=n.unstable_setDisableYieldValue,ae=null,de=null;function Ne(u){if(typeof ze=="function"&&nn(u),de&&typeof de.setStrictMode=="function")try{de.setStrictMode(ae,u)}catch{}}var ut=Math.clz32?Math.clz32:dt,kt=Math.log,Se=Math.LN2;function dt(u){return u>>>=0,u===0?32:31-(kt(u)/Se|0)|0}var ye=256,fe=262144,Ce=4194304;function ue(u){var d=u&42;if(d!==0)return d;switch(u&-u){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return u&261888;case 262144:case 524288:case 1048576:case 2097152:return u&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return u&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return u}}function ie(u,d,x){var w=u.pendingLanes;if(w===0)return 0;var N=0,R=u.suspendedLanes,V=u.pingedLanes;u=u.warmLanes;var Q=w&134217727;return Q!==0?(w=Q&~R,w!==0?N=ue(w):(V&=Q,V!==0?N=ue(V):x||(x=Q&~u,x!==0&&(N=ue(x))))):(Q=w&~R,Q!==0?N=ue(Q):V!==0?N=ue(V):x||(x=w&~u,x!==0&&(N=ue(x)))),N===0?0:d!==0&&d!==N&&(d&R)===0&&(R=N&-N,x=d&-d,R>=x||R===32&&(x&4194048)!==0)?d:N}function ve(u,d){return(u.pendingLanes&~(u.suspendedLanes&~u.pingedLanes)&d)===0}function Je(u,d){switch(u){case 1:case 2:case 4:case 8:case 64:return d+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return d+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function zn(){var u=Ce;return Ce<<=1,(Ce&62914560)===0&&(Ce=4194304),u}function Mn(u){for(var d=[],x=0;31>x;x++)d.push(u);return d}function li(u,d){u.pendingLanes|=d,d!==268435456&&(u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0)}function wr(u,d,x,w,N,R){var V=u.pendingLanes;u.pendingLanes=x,u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0,u.expiredLanes&=x,u.entangledLanes&=x,u.errorRecoveryDisabledLanes&=x,u.shellSuspendCounter=0;var Q=u.entanglements,gt=u.expirationTimes,$t=u.hiddenUpdates;for(x=V&~x;0<x;){var ee=31-ut(x),le=1<<ee;Q[ee]=0,gt[ee]=-1;var Ut=$t[ee];if(Ut!==null)for($t[ee]=null,ee=0;ee<Ut.length;ee++){var jt=Ut[ee];jt!==null&&(jt.lane&=-536870913)}x&=~le}w!==0&&Ep(u,w,0),R!==0&&N===0&&u.tag!==0&&(u.suspendedLanes|=R&~(V&~d))}function Ep(u,d,x){u.pendingLanes|=d,u.suspendedLanes&=~d;var w=31-ut(d);u.entangledLanes|=d,u.entanglements[w]=u.entanglements[w]|1073741824|x&261930}function _h(u,d){var x=u.entangledLanes|=d;for(u=u.entanglements;x;){var w=31-ut(x),N=1<<w;N&d|u[w]&d&&(u[w]|=d),x&=~N}}function du(u,d){var x=d&-d;return x=(x&42)!==0?1:Io(x),(x&(u.suspendedLanes|d))!==0?0:x}function Io(u){switch(u){case 2:u=1;break;case 8:u=4;break;case 32:u=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:u=128;break;case 268435456:u=134217728;break;default:u=0}return u}function wh(u){return u&=-u,2<u?8<u?(u&134217727)!==0?32:268435456:8:2}function Ro(){var u=W.p;return u!==0?u:(u=window.event,u===void 0?32:CL(u.type))}function lr(u,d){var x=W.p;try{return W.p=u,d()}finally{W.p=x}}var ia=Math.random().toString(36).slice(2),$n="__reactFiber$"+ia,Zi="__reactProps$"+ia,Ka="__reactContainer$"+ia,Th="__reactEvents$"+ia,Eh="__reactListeners$"+ia,Zg="__reactHandles$"+ia,Ch="__reactResources$"+ia,yc="__reactMarker$"+ia;function Ah(u){delete u[$n],delete u[Zi],delete u[Th],delete u[Eh],delete u[Zg]}function Ei(u){var d=u[$n];if(d)return d;for(var x=u.parentNode;x;){if(d=x[Ka]||x[$n]){if(x=d.alternate,d.child!==null||x!==null&&x.child!==null)for(u=uL(u);u!==null;){if(x=u[$n])return x;u=uL(u)}return d}u=x,x=u.parentNode}return null}function Us(u){if(u=u[$n]||u[Ka]){var d=u.tag;if(d===5||d===6||d===13||d===31||d===26||d===27||d===3)return u}return null}function il(u){var d=u.tag;if(d===5||d===26||d===27||d===6)return u.stateNode;throw Error(s(33))}function rl(u){var d=u[Ch];return d||(d=u[Ch]={hoistableStyles:new Map,hoistableScripts:new Map}),d}function Z(u){u[yc]=!0}var Et=new Set,Gt={};function Ft(u,d){Dt(u,d),Dt(u+"Capture",d)}function Dt(u,d){for(Gt[u]=d,u=0;u<d.length;u++)Et.add(d[u])}var Me=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),We={},De={};function qe(u){return Fe.call(De,u)?!0:Fe.call(We,u)?!1:Me.test(u)?De[u]=!0:(We[u]=!0,!1)}function Ke(u,d,x){if(qe(d))if(x===null)u.removeAttribute(d);else{switch(typeof x){case"undefined":case"function":case"symbol":u.removeAttribute(d);return;case"boolean":var w=d.toLowerCase().slice(0,5);if(w!=="data-"&&w!=="aria-"){u.removeAttribute(d);return}}u.setAttribute(d,""+x)}}function cn(u,d,x){if(x===null)u.removeAttribute(d);else{switch(typeof x){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(d);return}u.setAttribute(d,""+x)}}function Xe(u,d,x,w){if(w===null)u.removeAttribute(x);else{switch(typeof w){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(x);return}u.setAttributeNS(d,x,""+w)}}function fn(u){switch(typeof u){case"bigint":case"boolean":case"number":case"string":case"undefined":return u;case"object":return u;default:return""}}function gs(u){var d=u.type;return(u=u.nodeName)&&u.toLowerCase()==="input"&&(d==="checkbox"||d==="radio")}function Zs(u,d,x){var w=Object.getOwnPropertyDescriptor(u.constructor.prototype,d);if(!u.hasOwnProperty(d)&&typeof w<"u"&&typeof w.get=="function"&&typeof w.set=="function"){var N=w.get,R=w.set;return Object.defineProperty(u,d,{configurable:!0,get:function(){return N.call(this)},set:function(V){x=""+V,R.call(this,V)}}),Object.defineProperty(u,d,{enumerable:w.enumerable}),{getValue:function(){return x},setValue:function(V){x=""+V},stopTracking:function(){u._valueTracker=null,delete u[d]}}}}function Bs(u){if(!u._valueTracker){var d=gs(u)?"checked":"value";u._valueTracker=Zs(u,d,""+u[d])}}function ys(u){if(!u)return!1;var d=u._valueTracker;if(!d)return!0;var x=d.getValue(),w="";return u&&(w=gs(u)?u.checked?"true":"false":u.value),u=w,u!==x?(d.setValue(u),!0):!1}function tn(u){if(u=u||(typeof document<"u"?document:void 0),typeof u>"u")return null;try{return u.activeElement||u.body}catch{return u.body}}var ds=/[\n"\\]/g;function wn(u){return u.replace(ds,function(d){return"\\"+d.charCodeAt(0).toString(16)+" "})}function cr(u,d,x,w,N,R,V,Q){u.name="",V!=null&&typeof V!="function"&&typeof V!="symbol"&&typeof V!="boolean"?u.type=V:u.removeAttribute("type"),d!=null?V==="number"?(d===0&&u.value===""||u.value!=d)&&(u.value=""+fn(d)):u.value!==""+fn(d)&&(u.value=""+fn(d)):V!=="submit"&&V!=="reset"||u.removeAttribute("value"),d!=null?ur(u,V,fn(d)):x!=null?ur(u,V,fn(x)):w!=null&&u.removeAttribute("value"),N==null&&R!=null&&(u.defaultChecked=!!R),N!=null&&(u.checked=N&&typeof N!="function"&&typeof N!="symbol"),Q!=null&&typeof Q!="function"&&typeof Q!="symbol"&&typeof Q!="boolean"?u.name=""+fn(Q):u.removeAttribute("name")}function $l(u,d,x,w,N,R,V,Q){if(R!=null&&typeof R!="function"&&typeof R!="symbol"&&typeof R!="boolean"&&(u.type=R),d!=null||x!=null){if(!(R!=="submit"&&R!=="reset"||d!=null)){Bs(u);return}x=x!=null?""+fn(x):"",d=d!=null?""+fn(d):x,Q||d===u.value||(u.value=d),u.defaultValue=d}w=w??N,w=typeof w!="function"&&typeof w!="symbol"&&!!w,u.checked=Q?u.checked:!!w,u.defaultChecked=!!w,V!=null&&typeof V!="function"&&typeof V!="symbol"&&typeof V!="boolean"&&(u.name=V),Bs(u)}function ur(u,d,x){d==="number"&&tn(u.ownerDocument)===u||u.defaultValue===""+x||(u.defaultValue=""+x)}function Do(u,d,x,w){if(u=u.options,d){d={};for(var N=0;N<x.length;N++)d["$"+x[N]]=!0;for(x=0;x<u.length;x++)N=d.hasOwnProperty("$"+u[x].value),u[x].selected!==N&&(u[x].selected=N),N&&w&&(u[x].defaultSelected=!0)}else{for(x=""+fn(x),d=null,N=0;N<u.length;N++){if(u[N].value===x){u[N].selected=!0,w&&(u[N].defaultSelected=!0);return}d!==null||u[N].disabled||(d=u[N])}d!==null&&(d.selected=!0)}}function Ss(u,d,x){if(d!=null&&(d=""+fn(d),d!==u.value&&(u.value=d),x==null)){u.defaultValue!==d&&(u.defaultValue=d);return}u.defaultValue=x!=null?""+fn(x):""}function pi(u,d,x,w){if(d==null){if(w!=null){if(x!=null)throw Error(s(92));if(Y(w)){if(1<w.length)throw Error(s(93));w=w[0]}x=w}x==null&&(x=""),d=x}x=fn(d),u.defaultValue=x,w=u.textContent,w===x&&w!==""&&w!==null&&(u.value=w),Bs(u)}function $i(u,d){if(d){var x=u.firstChild;if(x&&x===u.lastChild&&x.nodeType===3){x.nodeValue=d;return}}u.textContent=d}var Li=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function Fi(u,d,x){var w=d.indexOf("--")===0;x==null||typeof x=="boolean"||x===""?w?u.setProperty(d,""):d==="float"?u.cssFloat="":u[d]="":w?u.setProperty(d,x):typeof x!="number"||x===0||Li.has(d)?d==="float"?u.cssFloat=x:u[d]=(""+x).trim():u[d]=x+"px"}function Nh(u,d,x){if(d!=null&&typeof d!="object")throw Error(s(62));if(u=u.style,x!=null){for(var w in x)!x.hasOwnProperty(w)||d!=null&&d.hasOwnProperty(w)||(w.indexOf("--")===0?u.setProperty(w,""):w==="float"?u.cssFloat="":u[w]="");for(var N in d)w=d[N],d.hasOwnProperty(N)&&x[N]!==w&&Fi(u,N,w)}else for(var R in d)d.hasOwnProperty(R)&&Fi(u,R,d[R])}function Ya(u){if(u.indexOf("-")===-1)return!1;switch(u){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var I_=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),R_=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Cp(u){return R_.test(""+u)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":u}function Ll(){}var Ap=null;function Qg(u){return u=u.target||u.srcElement||window,u.correspondingUseElement&&(u=u.correspondingUseElement),u.nodeType===3?u.parentNode:u}var Mh=null,pu=null;function jx(u){var d=Us(u);if(d&&(u=d.stateNode)){var x=u[Zi]||null;t:switch(u=d.stateNode,d.type){case"input":if(cr(u,x.value,x.defaultValue,x.defaultValue,x.checked,x.defaultChecked,x.type,x.name),d=x.name,x.type==="radio"&&d!=null){for(x=u;x.parentNode;)x=x.parentNode;for(x=x.querySelectorAll('input[name="'+wn(""+d)+'"][type="radio"]'),d=0;d<x.length;d++){var w=x[d];if(w!==u&&w.form===u.form){var N=w[Zi]||null;if(!N)throw Error(s(90));cr(w,N.value,N.defaultValue,N.defaultValue,N.checked,N.defaultChecked,N.type,N.name)}}for(d=0;d<x.length;d++)w=x[d],w.form===u.form&&ys(w)}break t;case"textarea":Ss(u,x.value,x.defaultValue);break t;case"select":d=x.value,d!=null&&Do(u,!!x.multiple,d,!1)}}}var Jg=!1;function Kx(u,d,x){if(Jg)return u(d,x);Jg=!0;try{var w=u(d);return w}finally{if(Jg=!1,(Mh!==null||pu!==null)&&(tt(),Mh&&(d=Mh,u=pu,pu=Mh=null,jx(d),u)))for(d=0;d<u.length;d++)jx(u[d])}}function Ih(u,d){var x=u.stateNode;if(x===null)return null;var w=x[Zi]||null;if(w===null)return null;x=w[d];t:switch(d){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(w=!w.disabled)||(u=u.type,w=!(u==="button"||u==="input"||u==="select"||u==="textarea")),u=!w;break t;default:u=!1}if(u)return null;if(x&&typeof x!="function")throw Error(s(231,d,typeof x));return x}var Fl=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),t0=!1;if(Fl)try{var Np={};Object.defineProperty(Np,"passive",{get:function(){t0=!0}}),window.addEventListener("test",Np,Np),window.removeEventListener("test",Np,Np)}catch{t0=!1}var mu=null,e0=null,gu=null;function n0(){if(gu)return gu;var u,d=e0,x=d.length,w,N="value"in mu?mu.value:mu.textContent,R=N.length;for(u=0;u<x&&d[u]===N[u];u++);var V=x-u;for(w=1;w<=V&&d[x-w]===N[R-w];w++);return gu=N.slice(u,1<w?1-w:void 0)}function Rh(u){var d=u.keyCode;return"charCode"in u?(u=u.charCode,u===0&&d===13&&(u=13)):u=d,u===10&&(u=13),32<=u||u===13?u:0}function Mp(){return!0}function Yx(){return!1}function Ur(u){function d(x,w,N,R,V){this._reactName=x,this._targetInst=N,this.type=w,this.nativeEvent=R,this.target=V,this.currentTarget=null;for(var Q in u)u.hasOwnProperty(Q)&&(x=u[Q],this[Q]=x?x(R):R[Q]);return this.isDefaultPrevented=(R.defaultPrevented!=null?R.defaultPrevented:R.returnValue===!1)?Mp:Yx,this.isPropagationStopped=Yx,this}return f(d.prototype,{preventDefault:function(){this.defaultPrevented=!0;var x=this.nativeEvent;x&&(x.preventDefault?x.preventDefault():typeof x.returnValue!="unknown"&&(x.returnValue=!1),this.isDefaultPrevented=Mp)},stopPropagation:function(){var x=this.nativeEvent;x&&(x.stopPropagation?x.stopPropagation():typeof x.cancelBubble!="unknown"&&(x.cancelBubble=!0),this.isPropagationStopped=Mp)},persist:function(){},isPersistent:Mp}),d}var yu={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(u){return u.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Ip=Ur(yu),al=f({},yu,{view:0,detail:0}),s0=Ur(al),i0,Rp,zf,Dp=f({},al,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Op,button:0,buttons:0,relatedTarget:function(u){return u.relatedTarget===void 0?u.fromElement===u.srcElement?u.toElement:u.fromElement:u.relatedTarget},movementX:function(u){return"movementX"in u?u.movementX:(u!==zf&&(zf&&u.type==="mousemove"?(i0=u.screenX-zf.screenX,Rp=u.screenY-zf.screenY):Rp=i0=0,zf=u),i0)},movementY:function(u){return"movementY"in u?u.movementY:Rp}}),D_=Ur(Dp),Tr=f({},Dp,{dataTransfer:0}),k_=Ur(Tr),O_=f({},al,{relatedTarget:0}),r0=Ur(O_),$_=f({},yu,{animationName:0,elapsedTime:0,pseudoElement:0}),L_=Ur($_),kp=f({},yu,{clipboardData:function(u){return"clipboardData"in u?u.clipboardData:window.clipboardData}}),Zx=Ur(kp),F_=f({},yu,{data:0}),Qx=Ur(F_),z_={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Jx={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},tv={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function U_(u){var d=this.nativeEvent;return d.getModifierState?d.getModifierState(u):(u=tv[u])?!!d[u]:!1}function Op(){return U_}var ev=f({},al,{key:function(u){if(u.key){var d=z_[u.key]||u.key;if(d!=="Unidentified")return d}return u.type==="keypress"?(u=Rh(u),u===13?"Enter":String.fromCharCode(u)):u.type==="keydown"||u.type==="keyup"?Jx[u.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Op,charCode:function(u){return u.type==="keypress"?Rh(u):0},keyCode:function(u){return u.type==="keydown"||u.type==="keyup"?u.keyCode:0},which:function(u){return u.type==="keypress"?Rh(u):u.type==="keydown"||u.type==="keyup"?u.keyCode:0}}),nv=Ur(ev),B_=f({},Dp,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),a0=Ur(B_),P_=f({},al,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Op}),xc=Ur(P_),sv=f({},yu,{propertyName:0,elapsedTime:0,pseudoElement:0}),NN=Ur(sv),V_=f({},Dp,{deltaX:function(u){return"deltaX"in u?u.deltaX:"wheelDeltaX"in u?-u.wheelDeltaX:0},deltaY:function(u){return"deltaY"in u?u.deltaY:"wheelDeltaY"in u?-u.wheelDeltaY:"wheelDelta"in u?-u.wheelDelta:0},deltaZ:0,deltaMode:0}),xu=Ur(V_),vc=f({},yu,{newState:0,oldState:0}),iv=Ur(vc),rv=[9,13,27,32],Dh=Fl&&"CompositionEvent"in window,vu=null;Fl&&"documentMode"in document&&(vu=document.documentMode);var kh=Fl&&"TextEvent"in window&&!vu,Er=Fl&&(!Dh||vu&&8<vu&&11>=vu),$p=" ",av=!1;function o0(u,d){switch(u){case"keyup":return rv.indexOf(d.keyCode)!==-1;case"keydown":return d.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Uf(u){return u=u.detail,typeof u=="object"&&"data"in u?u.data:null}var bu=!1;function l0(u,d){switch(u){case"compositionend":return Uf(d);case"keypress":return d.which!==32?null:(av=!0,$p);case"textInput":return u=d.data,u===$p&&av?null:u;default:return null}}function G_(u,d){if(bu)return u==="compositionend"||!Dh&&o0(u,d)?(u=n0(),gu=e0=mu=null,bu=!1,u):null;switch(u){case"paste":return null;case"keypress":if(!(d.ctrlKey||d.altKey||d.metaKey)||d.ctrlKey&&d.altKey){if(d.char&&1<d.char.length)return d.char;if(d.which)return String.fromCharCode(d.which)}return null;case"compositionend":return Er&&d.locale!=="ko"?null:d.data;default:return null}}var Za={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function ov(u){var d=u&&u.nodeName&&u.nodeName.toLowerCase();return d==="input"?!!Za[u.type]:d==="textarea"}function c0(u,d,x,w){Mh?pu?pu.push(w):pu=[w]:Mh=w,d=Ow(d,"onChange"),0<d.length&&(x=new Ip("onChange","change",null,x,w),u.push({event:x,listeners:d}))}var Bf=null,Pf=null;function lv(u){Y$(u,0)}function Vf(u){var d=il(u);if(ys(d))return u}function cv(u,d){if(u==="change")return d}var Lp=!1;if(Fl){var Oh;if(Fl){var Qs="oninput"in document;if(!Qs){var H_=document.createElement("div");H_.setAttribute("oninput","return;"),Qs=typeof H_.oninput=="function"}Oh=Qs}else Oh=!1;Lp=Oh&&(!document.documentMode||9<document.documentMode)}function W_(){Bf&&(Bf.detachEvent("onpropertychange",uv),Pf=Bf=null)}function uv(u){if(u.propertyName==="value"&&Vf(Pf)){var d=[];c0(d,Pf,u,Qg(u)),Kx(lv,d)}}function Fp(u,d,x){u==="focusin"?(W_(),Bf=d,Pf=x,Bf.attachEvent("onpropertychange",uv)):u==="focusout"&&W_()}function Su(u){if(u==="selectionchange"||u==="keyup"||u==="keydown")return Vf(Pf)}function q_(u,d){if(u==="click")return Vf(d)}function X_(u,d){if(u==="input"||u==="change")return Vf(d)}function $h(u,d){return u===d&&(u!==0||1/u===1/d)||u!==u&&d!==d}var Js=typeof Object.is=="function"?Object.is:$h;function Gf(u,d){if(Js(u,d))return!0;if(typeof u!="object"||u===null||typeof d!="object"||d===null)return!1;var x=Object.keys(u),w=Object.keys(d);if(x.length!==w.length)return!1;for(w=0;w<x.length;w++){var N=x[w];if(!Fe.call(d,N)||!Js(u[N],d[N]))return!1}return!0}function hv(u){for(;u&&u.firstChild;)u=u.firstChild;return u}function fv(u,d){var x=hv(u);u=0;for(var w;x;){if(x.nodeType===3){if(w=u+x.textContent.length,u<=d&&w>=d)return{node:x,offset:d-u};u=w}t:{for(;x;){if(x.nextSibling){x=x.nextSibling;break t}x=x.parentNode}x=void 0}x=hv(x)}}function u0(u,d){return u&&d?u===d?!0:u&&u.nodeType===3?!1:d&&d.nodeType===3?u0(u,d.parentNode):"contains"in u?u.contains(d):u.compareDocumentPosition?!!(u.compareDocumentPosition(d)&16):!1:!1}function h0(u){u=u!=null&&u.ownerDocument!=null&&u.ownerDocument.defaultView!=null?u.ownerDocument.defaultView:window;for(var d=tn(u.document);d instanceof u.HTMLIFrameElement;){try{var x=typeof d.contentWindow.location.href=="string"}catch{x=!1}if(x)u=d.contentWindow;else break;d=tn(u.document)}return d}function Hf(u){var d=u&&u.nodeName&&u.nodeName.toLowerCase();return d&&(d==="input"&&(u.type==="text"||u.type==="search"||u.type==="tel"||u.type==="url"||u.type==="password")||d==="textarea"||u.contentEditable==="true")}var j_=Fl&&"documentMode"in document&&11>=document.documentMode,Wf=null,f0=null,qf=null,Qa=!1;function d0(u,d,x){var w=x.window===x?x.document:x.nodeType===9?x:x.ownerDocument;Qa||Wf==null||Wf!==tn(w)||(w=Wf,"selectionStart"in w&&Hf(w)?w={start:w.selectionStart,end:w.selectionEnd}:(w=(w.ownerDocument&&w.ownerDocument.defaultView||window).getSelection(),w={anchorNode:w.anchorNode,anchorOffset:w.anchorOffset,focusNode:w.focusNode,focusOffset:w.focusOffset}),qf&&Gf(qf,w)||(qf=w,w=Ow(f0,"onSelect"),0<w.length&&(d=new Ip("onSelect","select",null,d,x),u.push({event:d,listeners:w}),d.target=Wf)))}function _u(u,d){var x={};return x[u.toLowerCase()]=d.toLowerCase(),x["Webkit"+u]="webkit"+d,x["Moz"+u]="moz"+d,x}var Xf={animationend:_u("Animation","AnimationEnd"),animationiteration:_u("Animation","AnimationIteration"),animationstart:_u("Animation","AnimationStart"),transitionrun:_u("Transition","TransitionRun"),transitionstart:_u("Transition","TransitionStart"),transitioncancel:_u("Transition","TransitionCancel"),transitionend:_u("Transition","TransitionEnd")},zp={},ra={};Fl&&(ra=document.createElement("div").style,"AnimationEvent"in window||(delete Xf.animationend.animation,delete Xf.animationiteration.animation,delete Xf.animationstart.animation),"TransitionEvent"in window||delete Xf.transitionend.transition);function wu(u){if(zp[u])return zp[u];if(!Xf[u])return u;var d=Xf[u],x;for(x in d)if(d.hasOwnProperty(x)&&x in ra)return zp[u]=d[x];return u}var va=wu("animationend"),dv=wu("animationiteration"),zl=wu("animationstart"),jf=wu("transitionrun"),Tu=wu("transitionstart"),pv=wu("transitioncancel"),p0=wu("transitionend"),bc=new Map,m0="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");m0.push("scrollEnd");function Br(u,d){bc.set(u,d),Ft(d,[u])}var Eu=typeof reportError=="function"?reportError:function(u){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var d=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof u=="object"&&u!==null&&typeof u.message=="string"?String(u.message):String(u),error:u});if(!window.dispatchEvent(d))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",u);return}console.error(u)},hr=[],Lh=0,g0=0;function Cu(){for(var u=Lh,d=g0=Lh=0;d<u;){var x=hr[d];hr[d++]=null;var w=hr[d];hr[d++]=null;var N=hr[d];hr[d++]=null;var R=hr[d];if(hr[d++]=null,w!==null&&N!==null){var V=w.pending;V===null?N.next=N:(N.next=V.next,V.next=N),w.pending=N}R!==0&&y0(x,N,R)}}function Up(u,d,x,w){hr[Lh++]=u,hr[Lh++]=d,hr[Lh++]=x,hr[Lh++]=w,g0|=w,u.lanes|=w,u=u.alternate,u!==null&&(u.lanes|=w)}function Kf(u,d,x,w){return Up(u,d,x,w),Yf(u)}function Au(u,d){return Up(u,null,null,d),Yf(u)}function y0(u,d,x){u.lanes|=x;var w=u.alternate;w!==null&&(w.lanes|=x);for(var N=!1,R=u.return;R!==null;)R.childLanes|=x,w=R.alternate,w!==null&&(w.childLanes|=x),R.tag===22&&(u=R.stateNode,u===null||u._visibility&1||(N=!0)),u=R,R=R.return;return u.tag===3?(R=u.stateNode,N&&d!==null&&(N=31-ut(x),u=R.hiddenUpdates,w=u[N],w===null?u[N]=[d]:w.push(d),d.lane=x|536870912),R):null}function Yf(u){if(50<Jh)throw Jh=0,tf=null,Error(s(185));for(var d=u.return;d!==null;)u=d,d=u.return;return u.tag===3?u.stateNode:null}var Nu={};function K_(u,d,x,w){this.tag=u,this.key=x,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=d,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=w,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function aa(u,d,x,w){return new K_(u,d,x,w)}function oa(u){return u=u.prototype,!(!u||!u.isReactComponent)}function Ul(u,d){var x=u.alternate;return x===null?(x=aa(u.tag,d,u.key,u.mode),x.elementType=u.elementType,x.type=u.type,x.stateNode=u.stateNode,x.alternate=u,u.alternate=x):(x.pendingProps=d,x.type=u.type,x.flags=0,x.subtreeFlags=0,x.deletions=null),x.flags=u.flags&65011712,x.childLanes=u.childLanes,x.lanes=u.lanes,x.child=u.child,x.memoizedProps=u.memoizedProps,x.memoizedState=u.memoizedState,x.updateQueue=u.updateQueue,d=u.dependencies,x.dependencies=d===null?null:{lanes:d.lanes,firstContext:d.firstContext},x.sibling=u.sibling,x.index=u.index,x.ref=u.ref,x.refCleanup=u.refCleanup,x}function Pr(u,d){u.flags&=65011714;var x=u.alternate;return x===null?(u.childLanes=0,u.lanes=d,u.child=null,u.subtreeFlags=0,u.memoizedProps=null,u.memoizedState=null,u.updateQueue=null,u.dependencies=null,u.stateNode=null):(u.childLanes=x.childLanes,u.lanes=x.lanes,u.child=x.child,u.subtreeFlags=0,u.deletions=null,u.memoizedProps=x.memoizedProps,u.memoizedState=x.memoizedState,u.updateQueue=x.updateQueue,u.type=x.type,d=x.dependencies,u.dependencies=d===null?null:{lanes:d.lanes,firstContext:d.firstContext}),u}function Bp(u,d,x,w,N,R){var V=0;if(w=u,typeof u=="function")oa(u)&&(V=1);else if(typeof u=="string")V=Cj(u,x,yt.current)?26:u==="html"||u==="head"||u==="body"?27:5;else t:switch(u){case k:return u=aa(31,x,d,N),u.elementType=k,u.lanes=R,u;case _:return Sc(x.children,N,R,d);case S:V=8,N|=24;break;case b:return u=aa(12,x,d,N|2),u.elementType=b,u.lanes=R,u;case I:return u=aa(13,x,d,N),u.elementType=I,u.lanes=R,u;case D:return u=aa(19,x,d,N),u.elementType=D,u.lanes=R,u;default:if(typeof u=="object"&&u!==null)switch(u.$$typeof){case C:V=10;break t;case T:V=9;break t;case A:V=11;break t;case F:V=14;break t;case z:V=16,w=null;break t}V=29,x=Error(s(130,u===null?"null":typeof u,"")),w=null}return d=aa(V,x,d,N),d.elementType=u,d.type=w,d.lanes=R,d}function Sc(u,d,x,w){return u=aa(7,u,w,d),u.lanes=x,u}function x0(u,d,x){return u=aa(6,u,null,d),u.lanes=x,u}function Y_(u){var d=aa(18,null,null,0);return d.stateNode=u,d}function ol(u,d,x){return d=aa(4,u.children!==null?u.children:[],u.key,d),d.lanes=x,d.stateNode={containerInfo:u.containerInfo,pendingChildren:null,implementation:u.implementation},d}var mv=new WeakMap;function ba(u,d){if(typeof u=="object"&&u!==null){var x=mv.get(u);return x!==void 0?x:(d={value:u,source:d,stack:rt(d)},mv.set(u,d),d)}return{value:u,source:d,stack:rt(d)}}var ll=[],Fh=0,Pp=null,Zf=0,Ja=[],Sa=0,Bl=null,Pl=1,Vl="";function _c(u,d){ll[Fh++]=Zf,ll[Fh++]=Pp,Pp=u,Zf=d}function gv(u,d,x){Ja[Sa++]=Pl,Ja[Sa++]=Vl,Ja[Sa++]=Bl,Bl=u;var w=Pl;u=Vl;var N=32-ut(w)-1;w&=~(1<<N),x+=1;var R=32-ut(d)+N;if(30<R){var V=N-N%5;R=(w&(1<<V)-1).toString(32),w>>=V,N-=V,Pl=1<<32-ut(d)+N|x<<N|w,Vl=R+u}else Pl=1<<R|x<<N|w,Vl=u}function v0(u){u.return!==null&&(_c(u,1),gv(u,1,0))}function Mu(u){for(;u===Pp;)Pp=ll[--Fh],ll[Fh]=null,Zf=ll[--Fh],ll[Fh]=null;for(;u===Bl;)Bl=Ja[--Sa],Ja[Sa]=null,Vl=Ja[--Sa],Ja[Sa]=null,Pl=Ja[--Sa],Ja[Sa]=null}function Vp(u,d){Ja[Sa++]=Pl,Ja[Sa++]=Vl,Ja[Sa++]=Bl,Pl=d.id,Vl=d.overflow,Bl=u}var fr=null,qs=null,Yn=!1,wc=null,dr=!1,b0=Error(s(519));function jn(u){var d=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Gp(ba(d,u)),b0}function S0(u){var d=u.stateNode,x=u.type,w=u.memoizedProps;switch(d[$n]=u,d[Zi]=w,x){case"dialog":Zn("cancel",d),Zn("close",d);break;case"iframe":case"object":case"embed":Zn("load",d);break;case"video":case"audio":for(x=0;x<lb.length;x++)Zn(lb[x],d);break;case"source":Zn("error",d);break;case"img":case"image":case"link":Zn("error",d),Zn("load",d);break;case"details":Zn("toggle",d);break;case"input":Zn("invalid",d),$l(d,w.value,w.defaultValue,w.checked,w.defaultChecked,w.type,w.name,!0);break;case"select":Zn("invalid",d);break;case"textarea":Zn("invalid",d),pi(d,w.value,w.defaultValue,w.children)}x=w.children,typeof x!="string"&&typeof x!="number"&&typeof x!="bigint"||d.textContent===""+x||w.suppressHydrationWarning===!0||tL(d.textContent,x)?(w.popover!=null&&(Zn("beforetoggle",d),Zn("toggle",d)),w.onScroll!=null&&Zn("scroll",d),w.onScrollEnd!=null&&Zn("scrollend",d),w.onClick!=null&&(d.onclick=Ll),d=!0):d=!1,d||jn(u,!0)}function Z_(u){for(fr=u.return;fr;)switch(fr.tag){case 5:case 31:case 13:dr=!1;return;case 27:case 3:dr=!0;return;default:fr=fr.return}}function zh(u){if(u!==fr)return!1;if(!Yn)return Z_(u),Yn=!0,!1;var d=u.tag,x;if((x=d!==3&&d!==27)&&((x=d===5)&&(x=u.type,x=!(x!=="form"&&x!=="button")||jN(u.type,u.memoizedProps)),x=!x),x&&qs&&jn(u),Z_(u),d===13){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(317));qs=cL(u)}else if(d===31){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(317));qs=cL(u)}else d===27?(d=qs,gd(u.type)?(u=JN,JN=null,qs=u):qs=d):qs=fr?Jl(u.stateNode.nextSibling):null;return!0}function Uh(){qs=fr=null,Yn=!1}function yv(){var u=wc;return u!==null&&(Xr===null?Xr=u:Xr.push.apply(Xr,u),wc=null),u}function Gp(u){wc===null?wc=[u]:wc.push(u)}var xv=X(null),Tc=null,Vr=null;function Ec(u,d,x){ct(xv,d._currentValue),d._currentValue=x}function ko(u){u._currentValue=xv.current,it(xv)}function Cc(u,d,x){for(;u!==null;){var w=u.alternate;if((u.childLanes&d)!==d?(u.childLanes|=d,w!==null&&(w.childLanes|=d)):w!==null&&(w.childLanes&d)!==d&&(w.childLanes|=d),u===x)break;u=u.return}}function _0(u,d,x,w){var N=u.child;for(N!==null&&(N.return=u);N!==null;){var R=N.dependencies;if(R!==null){var V=N.child;R=R.firstContext;t:for(;R!==null;){var Q=R;R=N;for(var gt=0;gt<d.length;gt++)if(Q.context===d[gt]){R.lanes|=x,Q=R.alternate,Q!==null&&(Q.lanes|=x),Cc(R.return,x,u),w||(V=null);break t}R=Q.next}}else if(N.tag===18){if(V=N.return,V===null)throw Error(s(341));V.lanes|=x,R=V.alternate,R!==null&&(R.lanes|=x),Cc(V,x,u),V=null}else V=N.child;if(V!==null)V.return=N;else for(V=N;V!==null;){if(V===u){V=null;break}if(N=V.sibling,N!==null){N.return=V.return,V=N;break}V=V.return}N=V}}function Iu(u,d,x,w){u=null;for(var N=d,R=!1;N!==null;){if(!R){if((N.flags&524288)!==0)R=!0;else if((N.flags&262144)!==0)break}if(N.tag===10){var V=N.alternate;if(V===null)throw Error(s(387));if(V=V.memoizedProps,V!==null){var Q=N.type;Js(N.pendingProps.value,V.value)||(u!==null?u.push(Q):u=[Q])}}else if(N===_t.current){if(V=N.alternate,V===null)throw Error(s(387));V.memoizedState.memoizedState!==N.memoizedState.memoizedState&&(u!==null?u.push(db):u=[db])}N=N.return}u!==null&&_0(d,u,x,w),d.flags|=262144}function Qf(u){for(u=u.firstContext;u!==null;){if(!Js(u.context._currentValue,u.memoizedValue))return!0;u=u.next}return!1}function Bh(u){Tc=u,Vr=null,u=u.dependencies,u!==null&&(u.firstContext=null)}function pr(u){return vv(Tc,u)}function Hp(u,d){return Tc===null&&Bh(u),vv(u,d)}function vv(u,d){var x=d._currentValue;if(d={context:d,memoizedValue:x,next:null},Vr===null){if(u===null)throw Error(s(308));Vr=d,u.dependencies={lanes:0,firstContext:d},u.flags|=524288}else Vr=Vr.next=d;return x}var Q_=typeof AbortController<"u"?AbortController:function(){var u=[],d=this.signal={aborted:!1,addEventListener:function(x,w){u.push(w)}};this.abort=function(){d.aborted=!0,u.forEach(function(x){return x()})}},J_=n.unstable_scheduleCallback,bv=n.unstable_NormalPriority,rn={$$typeof:C,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Sv(){return{controller:new Q_,data:new Map,refCount:0}}function Cr(u){u.refCount--,u.refCount===0&&J_(bv,function(){u.controller.abort()})}var Ph=null,_v=0,Ac=0,cl=null;function Jf(u,d){if(Ph===null){var x=Ph=[];_v=0,Ac=UN(),cl={status:"pending",value:void 0,then:function(w){x.push(w)}}}return _v++,d.then(wv,wv),d}function wv(){if(--_v===0&&Ph!==null){cl!==null&&(cl.status="fulfilled");var u=Ph;Ph=null,Ac=0,cl=null;for(var d=0;d<u.length;d++)(0,u[d])()}}function Tv(u,d){var x=[],w={status:"pending",value:null,reason:null,then:function(N){x.push(N)}};return u.then(function(){w.status="fulfilled",w.value=d;for(var N=0;N<x.length;N++)(0,x[N])(d)},function(N){for(w.status="rejected",w.reason=N,N=0;N<x.length;N++)(0,x[N])(void 0)}),w}var tw=P.S;P.S=function(u,d){dd=G(),typeof d=="object"&&d!==null&&typeof d.then=="function"&&Jf(u,d),tw!==null&&tw(u,d)};var Ru=X(null);function Gl(){var u=Ru.current;return u!==null?u:ws.pooledCache}function td(u,d){d===null?ct(Ru,Ru.current):ct(Ru,d.pool)}function w0(){var u=Gl();return u===null?null:{parent:rn._currentValue,pool:u}}var Du=Error(s(460)),Wp=Error(s(474)),ul=Error(s(542)),qp={then:function(){}};function ew(u){return u=u.status,u==="fulfilled"||u==="rejected"}function Ev(u,d,x){switch(x=u[x],x===void 0?u.push(d):x!==d&&(d.then(Ll,Ll),d=x),d.status){case"fulfilled":return d.value;case"rejected":throw u=d.reason,Cv(u),u;default:if(typeof d.status=="string")d.then(Ll,Ll);else{if(u=ws,u!==null&&100<u.shellSuspendCounter)throw Error(s(482));u=d,u.status="pending",u.then(function(w){if(d.status==="pending"){var N=d;N.status="fulfilled",N.value=w}},function(w){if(d.status==="pending"){var N=d;N.status="rejected",N.reason=w}})}switch(d.status){case"fulfilled":return d.value;case"rejected":throw u=d.reason,Cv(u),u}throw dn=d,Du}}function Vh(u){try{var d=u._init;return d(u._payload)}catch(x){throw x!==null&&typeof x=="object"&&typeof x.then=="function"?(dn=x,Du):x}}var dn=null;function T0(){if(dn===null)throw Error(s(459));var u=dn;return dn=null,u}function Cv(u){if(u===Du||u===ul)throw Error(s(483))}var ku=null,Ou=0;function E0(u){var d=Ou;return Ou+=1,ku===null&&(ku=[]),Ev(ku,u,d)}function Xp(u,d){d=d.props.ref,u.ref=d!==void 0?d:null}function jp(u,d){throw d.$$typeof===p?Error(s(525)):(u=Object.prototype.toString.call(d),Error(s(31,u==="[object Object]"?"object with keys {"+Object.keys(d).join(", ")+"}":u)))}function ed(u){function d(Mt,St){if(u){var Ot=Mt.deletions;Ot===null?(Mt.deletions=[St],Mt.flags|=16):Ot.push(St)}}function x(Mt,St){if(!u)return null;for(;St!==null;)d(Mt,St),St=St.sibling;return null}function w(Mt){for(var St=new Map;Mt!==null;)Mt.key!==null?St.set(Mt.key,Mt):St.set(Mt.index,Mt),Mt=Mt.sibling;return St}function N(Mt,St){return Mt=Ul(Mt,St),Mt.index=0,Mt.sibling=null,Mt}function R(Mt,St,Ot){return Mt.index=Ot,u?(Ot=Mt.alternate,Ot!==null?(Ot=Ot.index,Ot<St?(Mt.flags|=67108866,St):Ot):(Mt.flags|=67108866,St)):(Mt.flags|=1048576,St)}function V(Mt){return u&&Mt.alternate===null&&(Mt.flags|=67108866),Mt}function Q(Mt,St,Ot,re){return St===null||St.tag!==6?(St=x0(Ot,Mt.mode,re),St.return=Mt,St):(St=N(St,Ot),St.return=Mt,St)}function gt(Mt,St,Ot,re){var hn=Ot.type;return hn===_?ee(Mt,St,Ot.props.children,re,Ot.key):St!==null&&(St.elementType===hn||typeof hn=="object"&&hn!==null&&hn.$$typeof===z&&Vh(hn)===St.type)?(St=N(St,Ot.props),Xp(St,Ot),St.return=Mt,St):(St=Bp(Ot.type,Ot.key,Ot.props,null,Mt.mode,re),Xp(St,Ot),St.return=Mt,St)}function $t(Mt,St,Ot,re){return St===null||St.tag!==4||St.stateNode.containerInfo!==Ot.containerInfo||St.stateNode.implementation!==Ot.implementation?(St=ol(Ot,Mt.mode,re),St.return=Mt,St):(St=N(St,Ot.children||[]),St.return=Mt,St)}function ee(Mt,St,Ot,re,hn){return St===null||St.tag!==7?(St=Sc(Ot,Mt.mode,re,hn),St.return=Mt,St):(St=N(St,Ot),St.return=Mt,St)}function le(Mt,St,Ot){if(typeof St=="string"&&St!==""||typeof St=="number"||typeof St=="bigint")return St=x0(""+St,Mt.mode,Ot),St.return=Mt,St;if(typeof St=="object"&&St!==null){switch(St.$$typeof){case g:return Ot=Bp(St.type,St.key,St.props,null,Mt.mode,Ot),Xp(Ot,St),Ot.return=Mt,Ot;case v:return St=ol(St,Mt.mode,Ot),St.return=Mt,St;case z:return St=Vh(St),le(Mt,St,Ot)}if(Y(St)||H(St))return St=Sc(St,Mt.mode,Ot,null),St.return=Mt,St;if(typeof St.then=="function")return le(Mt,E0(St),Ot);if(St.$$typeof===C)return le(Mt,Hp(Mt,St),Ot);jp(Mt,St)}return null}function Ut(Mt,St,Ot,re){var hn=St!==null?St.key:null;if(typeof Ot=="string"&&Ot!==""||typeof Ot=="number"||typeof Ot=="bigint")return hn!==null?null:Q(Mt,St,""+Ot,re);if(typeof Ot=="object"&&Ot!==null){switch(Ot.$$typeof){case g:return Ot.key===hn?gt(Mt,St,Ot,re):null;case v:return Ot.key===hn?$t(Mt,St,Ot,re):null;case z:return Ot=Vh(Ot),Ut(Mt,St,Ot,re)}if(Y(Ot)||H(Ot))return hn!==null?null:ee(Mt,St,Ot,re,null);if(typeof Ot.then=="function")return Ut(Mt,St,E0(Ot),re);if(Ot.$$typeof===C)return Ut(Mt,St,Hp(Mt,Ot),re);jp(Mt,Ot)}return null}function jt(Mt,St,Ot,re,hn){if(typeof re=="string"&&re!==""||typeof re=="number"||typeof re=="bigint")return Mt=Mt.get(Ot)||null,Q(St,Mt,""+re,hn);if(typeof re=="object"&&re!==null){switch(re.$$typeof){case g:return Mt=Mt.get(re.key===null?Ot:re.key)||null,gt(St,Mt,re,hn);case v:return Mt=Mt.get(re.key===null?Ot:re.key)||null,$t(St,Mt,re,hn);case z:return re=Vh(re),jt(Mt,St,Ot,re,hn)}if(Y(re)||H(re))return Mt=Mt.get(Ot)||null,ee(St,Mt,re,hn,null);if(typeof re.then=="function")return jt(Mt,St,Ot,E0(re),hn);if(re.$$typeof===C)return jt(Mt,St,Ot,Hp(St,re),hn);jp(St,re)}return null}function Ye(Mt,St,Ot,re){for(var hn=null,Es=null,en=St,Bn=St=0,ns=null;en!==null&&Bn<Ot.length;Bn++){en.index>Bn?(ns=en,en=null):ns=en.sibling;var Cs=Ut(Mt,en,Ot[Bn],re);if(Cs===null){en===null&&(en=ns);break}u&&en&&Cs.alternate===null&&d(Mt,en),St=R(Cs,St,Bn),Es===null?hn=Cs:Es.sibling=Cs,Es=Cs,en=ns}if(Bn===Ot.length)return x(Mt,en),Yn&&_c(Mt,Bn),hn;if(en===null){for(;Bn<Ot.length;Bn++)en=le(Mt,Ot[Bn],re),en!==null&&(St=R(en,St,Bn),Es===null?hn=en:Es.sibling=en,Es=en);return Yn&&_c(Mt,Bn),hn}for(en=w(en);Bn<Ot.length;Bn++)ns=jt(en,Mt,Bn,Ot[Bn],re),ns!==null&&(u&&ns.alternate!==null&&en.delete(ns.key===null?Bn:ns.key),St=R(ns,St,Bn),Es===null?hn=ns:Es.sibling=ns,Es=ns);return u&&en.forEach(function(Sd){return d(Mt,Sd)}),Yn&&_c(Mt,Bn),hn}function gn(Mt,St,Ot,re){if(Ot==null)throw Error(s(151));for(var hn=null,Es=null,en=St,Bn=St=0,ns=null,Cs=Ot.next();en!==null&&!Cs.done;Bn++,Cs=Ot.next()){en.index>Bn?(ns=en,en=null):ns=en.sibling;var Sd=Ut(Mt,en,Cs.value,re);if(Sd===null){en===null&&(en=ns);break}u&&en&&Sd.alternate===null&&d(Mt,en),St=R(Sd,St,Bn),Es===null?hn=Sd:Es.sibling=Sd,Es=Sd,en=ns}if(Cs.done)return x(Mt,en),Yn&&_c(Mt,Bn),hn;if(en===null){for(;!Cs.done;Bn++,Cs=Ot.next())Cs=le(Mt,Cs.value,re),Cs!==null&&(St=R(Cs,St,Bn),Es===null?hn=Cs:Es.sibling=Cs,Es=Cs);return Yn&&_c(Mt,Bn),hn}for(en=w(en);!Cs.done;Bn++,Cs=Ot.next())Cs=jt(en,Mt,Bn,Cs.value,re),Cs!==null&&(u&&Cs.alternate!==null&&en.delete(Cs.key===null?Bn:Cs.key),St=R(Cs,St,Bn),Es===null?hn=Cs:Es.sibling=Cs,Es=Cs);return u&&en.forEach(function(Fj){return d(Mt,Fj)}),Yn&&_c(Mt,Bn),hn}function Ks(Mt,St,Ot,re){if(typeof Ot=="object"&&Ot!==null&&Ot.type===_&&Ot.key===null&&(Ot=Ot.props.children),typeof Ot=="object"&&Ot!==null){switch(Ot.$$typeof){case g:t:{for(var hn=Ot.key;St!==null;){if(St.key===hn){if(hn=Ot.type,hn===_){if(St.tag===7){x(Mt,St.sibling),re=N(St,Ot.props.children),re.return=Mt,Mt=re;break t}}else if(St.elementType===hn||typeof hn=="object"&&hn!==null&&hn.$$typeof===z&&Vh(hn)===St.type){x(Mt,St.sibling),re=N(St,Ot.props),Xp(re,Ot),re.return=Mt,Mt=re;break t}x(Mt,St);break}else d(Mt,St);St=St.sibling}Ot.type===_?(re=Sc(Ot.props.children,Mt.mode,re,Ot.key),re.return=Mt,Mt=re):(re=Bp(Ot.type,Ot.key,Ot.props,null,Mt.mode,re),Xp(re,Ot),re.return=Mt,Mt=re)}return V(Mt);case v:t:{for(hn=Ot.key;St!==null;){if(St.key===hn)if(St.tag===4&&St.stateNode.containerInfo===Ot.containerInfo&&St.stateNode.implementation===Ot.implementation){x(Mt,St.sibling),re=N(St,Ot.children||[]),re.return=Mt,Mt=re;break t}else{x(Mt,St);break}else d(Mt,St);St=St.sibling}re=ol(Ot,Mt.mode,re),re.return=Mt,Mt=re}return V(Mt);case z:return Ot=Vh(Ot),Ks(Mt,St,Ot,re)}if(Y(Ot))return Ye(Mt,St,Ot,re);if(H(Ot)){if(hn=H(Ot),typeof hn!="function")throw Error(s(150));return Ot=hn.call(Ot),gn(Mt,St,Ot,re)}if(typeof Ot.then=="function")return Ks(Mt,St,E0(Ot),re);if(Ot.$$typeof===C)return Ks(Mt,St,Hp(Mt,Ot),re);jp(Mt,Ot)}return typeof Ot=="string"&&Ot!==""||typeof Ot=="number"||typeof Ot=="bigint"?(Ot=""+Ot,St!==null&&St.tag===6?(x(Mt,St.sibling),re=N(St,Ot),re.return=Mt,Mt=re):(x(Mt,St),re=x0(Ot,Mt.mode,re),re.return=Mt,Mt=re),V(Mt)):x(Mt,St)}return function(Mt,St,Ot,re){try{Ou=0;var hn=Ks(Mt,St,Ot,re);return ku=null,hn}catch(en){if(en===Du||en===ul)throw en;var Es=aa(29,en,null,Mt.mode);return Es.lanes=re,Es.return=Mt,Es}finally{}}}var Gh=ed(!0),nw=ed(!1),$u=!1;function Av(u){u.updateQueue={baseState:u.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Nv(u,d){u=u.updateQueue,d.updateQueue===u&&(d.updateQueue={baseState:u.baseState,firstBaseUpdate:u.firstBaseUpdate,lastBaseUpdate:u.lastBaseUpdate,shared:u.shared,callbacks:null})}function Hl(u){return{lane:u,tag:0,payload:null,callback:null,next:null}}function Nc(u,d,x){var w=u.updateQueue;if(w===null)return null;if(w=w.shared,(ts&2)!==0){var N=w.pending;return N===null?d.next=d:(d.next=N.next,N.next=d),w.pending=d,d=Yf(u),y0(u,null,x),d}return Up(u,w,d,x),Yf(u)}function Lu(u,d,x){if(d=d.updateQueue,d!==null&&(d=d.shared,(x&4194048)!==0)){var w=d.lanes;w&=u.pendingLanes,x|=w,d.lanes=x,_h(u,x)}}function C0(u,d){var x=u.updateQueue,w=u.alternate;if(w!==null&&(w=w.updateQueue,x===w)){var N=null,R=null;if(x=x.firstBaseUpdate,x!==null){do{var V={lane:x.lane,tag:x.tag,payload:x.payload,callback:null,next:null};R===null?N=R=V:R=R.next=V,x=x.next}while(x!==null);R===null?N=R=d:R=R.next=d}else N=R=d;x={baseState:w.baseState,firstBaseUpdate:N,lastBaseUpdate:R,shared:w.shared,callbacks:w.callbacks},u.updateQueue=x;return}u=x.lastBaseUpdate,u===null?x.firstBaseUpdate=d:u.next=d,x.lastBaseUpdate=d}var Mv=!1;function Kp(){if(Mv){var u=cl;if(u!==null)throw u}}function Hh(u,d,x,w){Mv=!1;var N=u.updateQueue;$u=!1;var R=N.firstBaseUpdate,V=N.lastBaseUpdate,Q=N.shared.pending;if(Q!==null){N.shared.pending=null;var gt=Q,$t=gt.next;gt.next=null,V===null?R=$t:V.next=$t,V=gt;var ee=u.alternate;ee!==null&&(ee=ee.updateQueue,Q=ee.lastBaseUpdate,Q!==V&&(Q===null?ee.firstBaseUpdate=$t:Q.next=$t,ee.lastBaseUpdate=gt))}if(R!==null){var le=N.baseState;V=0,ee=$t=gt=null,Q=R;do{var Ut=Q.lane&-536870913,jt=Ut!==Q.lane;if(jt?(Kn&Ut)===Ut:(w&Ut)===Ut){Ut!==0&&Ut===Ac&&(Mv=!0),ee!==null&&(ee=ee.next={lane:0,tag:Q.tag,payload:Q.payload,callback:null,next:null});t:{var Ye=u,gn=Q;Ut=d;var Ks=x;switch(gn.tag){case 1:if(Ye=gn.payload,typeof Ye=="function"){le=Ye.call(Ks,le,Ut);break t}le=Ye;break t;case 3:Ye.flags=Ye.flags&-65537|128;case 0:if(Ye=gn.payload,Ut=typeof Ye=="function"?Ye.call(Ks,le,Ut):Ye,Ut==null)break t;le=f({},le,Ut);break t;case 2:$u=!0}}Ut=Q.callback,Ut!==null&&(u.flags|=64,jt&&(u.flags|=8192),jt=N.callbacks,jt===null?N.callbacks=[Ut]:jt.push(Ut))}else jt={lane:Ut,tag:Q.tag,payload:Q.payload,callback:Q.callback,next:null},ee===null?($t=ee=jt,gt=le):ee=ee.next=jt,V|=Ut;if(Q=Q.next,Q===null){if(Q=N.shared.pending,Q===null)break;jt=Q,Q=jt.next,jt.next=null,N.lastBaseUpdate=jt,N.shared.pending=null}}while(!0);ee===null&&(gt=le),N.baseState=gt,N.firstBaseUpdate=$t,N.lastBaseUpdate=ee,R===null&&(N.shared.lanes=0),uo|=V,u.lanes=V,u.memoizedState=le}}function Wl(u,d){if(typeof u!="function")throw Error(s(191,u));u.call(d)}function Ar(u,d){var x=u.callbacks;if(x!==null)for(u.callbacks=null,u=0;u<x.length;u++)Wl(x[u],d)}var to=X(null),la=X(0);function Iv(u,d){u=Ii,ct(la,u),ct(to,d),Ii=u|d.baseLanes}function Rv(){ct(la,Ii),ct(to,to.current)}function Gr(){Ii=la.current,it(to),it(la)}var Qi=X(null),Oo=null;function Fu(u){var d=u.alternate;ct(mi,mi.current&1),ct(Qi,u),Oo===null&&(d===null||to.current!==null||d.memoizedState!==null)&&(Oo=u)}function Dv(u){ct(mi,mi.current),ct(Qi,u),Oo===null&&(Oo=u)}function sw(u){u.tag===22?(ct(mi,mi.current),ct(Qi,u),Oo===null&&(Oo=u)):Mc()}function Mc(){ct(mi,mi.current),ct(Qi,Qi.current)}function eo(u){it(Qi),Oo===u&&(Oo=null),it(mi)}var mi=X(0);function A0(u){for(var d=u;d!==null;){if(d.tag===13){var x=d.memoizedState;if(x!==null&&(x=x.dehydrated,x===null||ZN(x)||QN(x)))return d}else if(d.tag===19&&(d.memoizedProps.revealOrder==="forwards"||d.memoizedProps.revealOrder==="backwards"||d.memoizedProps.revealOrder==="unstable_legacy-backwards"||d.memoizedProps.revealOrder==="together")){if((d.flags&128)!==0)return d}else if(d.child!==null){d.child.return=d,d=d.child;continue}if(d===u)break;for(;d.sibling===null;){if(d.return===null||d.return===u)return null;d=d.return}d.sibling.return=d.return,d=d.sibling}return null}var _a=0,xn=null,Os=null,zi=null,N0=!1,ql=!1,Wh=!1,M0=0,Yp=0,Xl=null,MN=0;function gi(){throw Error(s(321))}function kv(u,d){if(d===null)return!1;for(var x=0;x<d.length&&x<u.length;x++)if(!Js(u[x],d[x]))return!1;return!0}function Ov(u,d,x,w,N,R){return _a=R,xn=d,d.memoizedState=null,d.updateQueue=null,d.lanes=0,P.H=u===null||u.memoizedState===null?ww:id,Wh=!1,R=x(w,N),Wh=!1,ql&&(R=rw(d,x,w,N)),iw(u),R}function iw(u){P.H=em;var d=Os!==null&&Os.next!==null;if(_a=0,zi=Os=xn=null,N0=!1,Yp=0,Xl=null,d)throw Error(s(300));u===null||ti||(u=u.dependencies,u!==null&&Qf(u)&&(ti=!0))}function rw(u,d,x,w){xn=u;var N=0;do{if(ql&&(Xl=null),Yp=0,ql=!1,25<=N)throw Error(s(301));if(N+=1,zi=Os=null,u.updateQueue!=null){var R=u.updateQueue;R.lastEffect=null,R.events=null,R.stores=null,R.memoCache!=null&&(R.memoCache.index=0)}P.H=nm,R=d(x,w)}while(ql);return R}function IN(){var u=P.H,d=u.useState()[0];return d=typeof d.then=="function"?Qp(d):d,u=u.useState()[0],(Os!==null?Os.memoizedState:null)!==u&&(xn.flags|=1024),d}function $v(){var u=M0!==0;return M0=0,u}function Lv(u,d,x){d.updateQueue=u.updateQueue,d.flags&=-2053,u.lanes&=~x}function Fv(u){if(N0){for(u=u.memoizedState;u!==null;){var d=u.queue;d!==null&&(d.pending=null),u=u.next}N0=!1}_a=0,zi=Os=xn=null,ql=!1,Yp=M0=0,Xl=null}function ca(){var u={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return zi===null?xn.memoizedState=zi=u:zi=zi.next=u,zi}function Ci(){if(Os===null){var u=xn.alternate;u=u!==null?u.memoizedState:null}else u=Os.next;var d=zi===null?xn.memoizedState:zi.next;if(d!==null)zi=d,Os=u;else{if(u===null)throw xn.alternate===null?Error(s(467)):Error(s(310));Os=u,u={memoizedState:Os.memoizedState,baseState:Os.baseState,baseQueue:Os.baseQueue,queue:Os.queue,next:null},zi===null?xn.memoizedState=zi=u:zi=zi.next=u}return zi}function Zp(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Qp(u){var d=Yp;return Yp+=1,Xl===null&&(Xl=[]),u=Ev(Xl,u,d),d=xn,(zi===null?d.memoizedState:zi.next)===null&&(d=d.alternate,P.H=d===null||d.memoizedState===null?ww:id),u}function I0(u){if(u!==null&&typeof u=="object"){if(typeof u.then=="function")return Qp(u);if(u.$$typeof===C)return pr(u)}throw Error(s(438,String(u)))}function zv(u){var d=null,x=xn.updateQueue;if(x!==null&&(d=x.memoCache),d==null){var w=xn.alternate;w!==null&&(w=w.updateQueue,w!==null&&(w=w.memoCache,w!=null&&(d={data:w.data.map(function(N){return N.slice()}),index:0})))}if(d==null&&(d={data:[],index:0}),x===null&&(x=Zp(),xn.updateQueue=x),x.memoCache=d,x=d.data[d.index],x===void 0)for(x=d.data[d.index]=Array(u),w=0;w<u;w++)x[w]=O;return d.index++,x}function Ic(u,d){return typeof d=="function"?d(u):d}function R0(u){var d=Ci();return Uv(d,Os,u)}function Uv(u,d,x){var w=u.queue;if(w===null)throw Error(s(311));w.lastRenderedReducer=x;var N=u.baseQueue,R=w.pending;if(R!==null){if(N!==null){var V=N.next;N.next=R.next,R.next=V}d.baseQueue=N=R,w.pending=null}if(R=u.baseState,N===null)u.memoizedState=R;else{d=N.next;var Q=V=null,gt=null,$t=d,ee=!1;do{var le=$t.lane&-536870913;if(le!==$t.lane?(Kn&le)===le:(_a&le)===le){var Ut=$t.revertLane;if(Ut===0)gt!==null&&(gt=gt.next={lane:0,revertLane:0,gesture:null,action:$t.action,hasEagerState:$t.hasEagerState,eagerState:$t.eagerState,next:null}),le===Ac&&(ee=!0);else if((_a&Ut)===Ut){$t=$t.next,Ut===Ac&&(ee=!0);continue}else le={lane:0,revertLane:$t.revertLane,gesture:null,action:$t.action,hasEagerState:$t.hasEagerState,eagerState:$t.eagerState,next:null},gt===null?(Q=gt=le,V=R):gt=gt.next=le,xn.lanes|=Ut,uo|=Ut;le=$t.action,Wh&&x(R,le),R=$t.hasEagerState?$t.eagerState:x(R,le)}else Ut={lane:le,revertLane:$t.revertLane,gesture:$t.gesture,action:$t.action,hasEagerState:$t.hasEagerState,eagerState:$t.eagerState,next:null},gt===null?(Q=gt=Ut,V=R):gt=gt.next=Ut,xn.lanes|=le,uo|=le;$t=$t.next}while($t!==null&&$t!==d);if(gt===null?V=R:gt.next=Q,!Js(R,u.memoizedState)&&(ti=!0,ee&&(x=cl,x!==null)))throw x;u.memoizedState=R,u.baseState=V,u.baseQueue=gt,w.lastRenderedState=R}return N===null&&(w.lanes=0),[u.memoizedState,w.dispatch]}function D0(u){var d=Ci(),x=d.queue;if(x===null)throw Error(s(311));x.lastRenderedReducer=u;var w=x.dispatch,N=x.pending,R=d.memoizedState;if(N!==null){x.pending=null;var V=N=N.next;do R=u(R,V.action),V=V.next;while(V!==N);Js(R,d.memoizedState)||(ti=!0),d.memoizedState=R,d.baseQueue===null&&(d.baseState=R),x.lastRenderedState=R}return[R,w]}function Bv(u,d,x){var w=xn,N=Ci(),R=Yn;if(R){if(x===void 0)throw Error(s(407));x=x()}else x=d();var V=!Js((Os||N).memoizedState,x);if(V&&(N.memoizedState=x,ti=!0),N=N.queue,Wv(Vv.bind(null,w,N,u),[u]),N.getSnapshot!==d||V||zi!==null&&zi.memoizedState.tag&1){if(w.flags|=2048,nd(9,{destroy:void 0},Pv.bind(null,w,N,x,d),null),ws===null)throw Error(s(349));R||(_a&127)!==0||aw(w,d,x)}return x}function aw(u,d,x){u.flags|=16384,u={getSnapshot:d,value:x},d=xn.updateQueue,d===null?(d=Zp(),xn.updateQueue=d,d.stores=[u]):(x=d.stores,x===null?d.stores=[u]:x.push(u))}function Pv(u,d,x,w){d.value=x,d.getSnapshot=w,Gv(d)&&k0(u)}function Vv(u,d,x){return x(function(){Gv(d)&&k0(u)})}function Gv(u){var d=u.getSnapshot;u=u.value;try{var x=d();return!Js(u,x)}catch{return!0}}function k0(u){var d=Au(u,2);d!==null&&y(d,u,2)}function Jp(u){var d=ca();if(typeof u=="function"){var x=u;if(u=x(),Wh){Ne(!0);try{x()}finally{Ne(!1)}}}return d.memoizedState=d.baseState=u,d.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ic,lastRenderedState:u},d}function ow(u,d,x,w){return u.baseState=x,Uv(u,Os,typeof w=="function"?w:Ic)}function RN(u,d,x,w,N){if(Rc(u))throw Error(s(485));if(u=d.action,u!==null){var R={payload:N,action:u,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(V){R.listeners.push(V)}};P.T!==null?x(!0):R.isTransition=!1,w(R),x=d.pending,x===null?(R.next=d.pending=R,lw(d,R)):(R.next=x.next,d.pending=x.next=R)}}function lw(u,d){var x=d.action,w=d.payload,N=u.state;if(d.isTransition){var R=P.T,V={};P.T=V;try{var Q=x(N,w),gt=P.S;gt!==null&&gt(V,Q),cw(u,d,Q)}catch($t){O0(u,d,$t)}finally{R!==null&&V.types!==null&&(R.types=V.types),P.T=R}}else try{R=x(N,w),cw(u,d,R)}catch($t){O0(u,d,$t)}}function cw(u,d,x){x!==null&&typeof x=="object"&&typeof x.then=="function"?x.then(function(w){Hv(u,d,w)},function(w){return O0(u,d,w)}):Hv(u,d,x)}function Hv(u,d,x){d.status="fulfilled",d.value=x,uw(d),u.state=x,d=u.pending,d!==null&&(x=d.next,x===d?u.pending=null:(x=x.next,d.next=x,lw(u,x)))}function O0(u,d,x){var w=u.pending;if(u.pending=null,w!==null){w=w.next;do d.status="rejected",d.reason=x,uw(d),d=d.next;while(d!==w)}u.action=null}function uw(u){u=u.listeners;for(var d=0;d<u.length;d++)(0,u[d])()}function hw(u,d){return d}function fw(u,d){if(Yn){var x=ws.formState;if(x!==null){t:{var w=xn;if(Yn){if(qs){e:{for(var N=qs,R=dr;N.nodeType!==8;){if(!R){N=null;break e}if(N=Jl(N.nextSibling),N===null){N=null;break e}}R=N.data,N=R==="F!"||R==="F"?N:null}if(N){qs=Jl(N.nextSibling),w=N.data==="F!";break t}}jn(w)}w=!1}w&&(d=x[0])}}return x=ca(),x.memoizedState=x.baseState=d,w={pending:null,lanes:0,dispatch:null,lastRenderedReducer:hw,lastRenderedState:d},x.queue=w,x=_w.bind(null,xn,w),w.dispatch=x,w=Jp(!1),R=tm.bind(null,xn,!1,w.queue),w=ca(),N={state:d,dispatch:null,action:u,pending:null},w.queue=N,x=RN.bind(null,xn,N,R,x),N.dispatch=x,w.memoizedState=u,[d,x,!1]}function dw(u){var d=Ci();return pw(d,Os,u)}function pw(u,d,x){if(d=Uv(u,d,hw)[0],u=R0(Ic)[0],typeof d=="object"&&d!==null&&typeof d.then=="function")try{var w=Qp(d)}catch(V){throw V===Du?ul:V}else w=d;d=Ci();var N=d.queue,R=N.dispatch;return x!==d.memoizedState&&(xn.flags|=2048,nd(9,{destroy:void 0},DN.bind(null,N,x),null)),[w,R,u]}function DN(u,d){u.action=d}function mw(u){var d=Ci(),x=Os;if(x!==null)return pw(d,x,u);Ci(),d=d.memoizedState,x=Ci();var w=x.queue.dispatch;return x.memoizedState=u,[d,w,!1]}function nd(u,d,x,w){return u={tag:u,create:x,deps:w,inst:d,next:null},d=xn.updateQueue,d===null&&(d=Zp(),xn.updateQueue=d),x=d.lastEffect,x===null?d.lastEffect=u.next=u:(w=x.next,x.next=u,u.next=w,d.lastEffect=u),u}function gw(){return Ci().memoizedState}function $0(u,d,x,w){var N=ca();xn.flags|=u,N.memoizedState=nd(1|d,{destroy:void 0},x,w===void 0?null:w)}function L0(u,d,x,w){var N=Ci();w=w===void 0?null:w;var R=N.memoizedState.inst;Os!==null&&w!==null&&kv(w,Os.memoizedState.deps)?N.memoizedState=nd(d,R,x,w):(xn.flags|=u,N.memoizedState=nd(1|d,R,x,w))}function yw(u,d){$0(8390656,8,u,d)}function Wv(u,d){L0(2048,8,u,d)}function xw(u){xn.flags|=4;var d=xn.updateQueue;if(d===null)d=Zp(),xn.updateQueue=d,d.events=[u];else{var x=d.events;x===null?d.events=[u]:x.push(u)}}function vw(u){var d=Ci().memoizedState;return xw({ref:d,nextImpl:u}),function(){if((ts&2)!==0)throw Error(s(440));return d.impl.apply(void 0,arguments)}}function bw(u,d){return L0(4,2,u,d)}function no(u,d){return L0(4,4,u,d)}function qv(u,d){if(typeof d=="function"){u=u();var x=d(u);return function(){typeof x=="function"?x():d(null)}}if(d!=null)return u=u(),d.current=u,function(){d.current=null}}function F0(u,d,x){x=x!=null?x.concat([u]):null,L0(4,4,qv.bind(null,d,u),x)}function z0(){}function Xv(u,d){var x=Ci();d=d===void 0?null:d;var w=x.memoizedState;return d!==null&&kv(d,w[1])?w[0]:(x.memoizedState=[u,d],u)}function jv(u,d){var x=Ci();d=d===void 0?null:d;var w=x.memoizedState;if(d!==null&&kv(d,w[1]))return w[0];if(w=u(),Wh){Ne(!0);try{u()}finally{Ne(!1)}}return x.memoizedState=[w,d],w}function Kv(u,d,x){return x===void 0||(_a&1073741824)!==0&&(Kn&261930)===0?u.memoizedState=d:(u.memoizedState=x,u=m(),xn.lanes|=u,uo|=u,x)}function Yv(u,d,x,w){return Js(x,d)?x:to.current!==null?(u=Kv(u,x,w),Js(u,d)||(ti=!0),u):(_a&42)===0||(_a&1073741824)!==0&&(Kn&261930)===0?(ti=!0,u.memoizedState=x):(u=m(),xn.lanes|=u,uo|=u,d)}function Zv(u,d,x,w,N){var R=W.p;W.p=R!==0&&8>R?R:8;var V=P.T,Q={};P.T=Q,tm(u,!1,d,x);try{var gt=N(),$t=P.S;if($t!==null&&$t(Q,gt),gt!==null&&typeof gt=="object"&&typeof gt.then=="function"){var ee=Tv(gt,w);sd(u,d,ee,ha(u))}else sd(u,d,w,ha(u))}catch(le){sd(u,d,{then:function(){},status:"rejected",reason:le},ha())}finally{W.p=R,V!==null&&Q.types!==null&&(V.types=Q.types),P.T=V}}function kN(){}function Qv(u,d,x,w){if(u.tag!==5)throw Error(s(476));var N=Sw(u).queue;Zv(u,N,d,j,x===null?kN:function(){return Jv(u),x(w)})}function Sw(u){var d=u.memoizedState;if(d!==null)return d;d={memoizedState:j,baseState:j,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ic,lastRenderedState:j},next:null};var x={};return d.next={memoizedState:x,baseState:x,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ic,lastRenderedState:x},next:null},u.memoizedState=d,u=u.alternate,u!==null&&(u.memoizedState=d),d}function Jv(u){var d=Sw(u);d.next===null&&(d=u.alternate.memoizedState),sd(u,d.next.queue,{},ha())}function tb(){return pr(db)}function Nr(){return Ci().memoizedState}function eb(){return Ci().memoizedState}function ON(u){for(var d=u.return;d!==null;){switch(d.tag){case 24:case 3:var x=ha();u=Hl(x);var w=Nc(d,u,x);w!==null&&(y(w,d,x),Lu(w,d,x)),d={cache:Sv()},u.payload=d;return}d=d.return}}function $N(u,d,x){var w=ha();x={lane:w,revertLane:0,gesture:null,action:x,hasEagerState:!1,eagerState:null,next:null},Rc(u)?qh(d,x):(x=Kf(u,d,x,w),x!==null&&(y(x,u,w),wa(x,d,w)))}function _w(u,d,x){var w=ha();sd(u,d,x,w)}function sd(u,d,x,w){var N={lane:w,revertLane:0,gesture:null,action:x,hasEagerState:!1,eagerState:null,next:null};if(Rc(u))qh(d,N);else{var R=u.alternate;if(u.lanes===0&&(R===null||R.lanes===0)&&(R=d.lastRenderedReducer,R!==null))try{var V=d.lastRenderedState,Q=R(V,x);if(N.hasEagerState=!0,N.eagerState=Q,Js(Q,V))return Up(u,d,N,0),ws===null&&Cu(),!1}catch{}finally{}if(x=Kf(u,d,N,w),x!==null)return y(x,u,w),wa(x,d,w),!0}return!1}function tm(u,d,x,w){if(w={lane:2,revertLane:UN(),gesture:null,action:w,hasEagerState:!1,eagerState:null,next:null},Rc(u)){if(d)throw Error(s(479))}else d=Kf(u,x,w,2),d!==null&&y(d,u,2)}function Rc(u){var d=u.alternate;return u===xn||d!==null&&d===xn}function qh(u,d){ql=N0=!0;var x=u.pending;x===null?d.next=d:(d.next=x.next,x.next=d),u.pending=d}function wa(u,d,x){if((x&4194048)!==0){var w=d.lanes;w&=u.pendingLanes,x|=w,d.lanes=x,_h(u,x)}}var em={readContext:pr,use:I0,useCallback:gi,useContext:gi,useEffect:gi,useImperativeHandle:gi,useLayoutEffect:gi,useInsertionEffect:gi,useMemo:gi,useReducer:gi,useRef:gi,useState:gi,useDebugValue:gi,useDeferredValue:gi,useTransition:gi,useSyncExternalStore:gi,useId:gi,useHostTransitionStatus:gi,useFormState:gi,useActionState:gi,useOptimistic:gi,useMemoCache:gi,useCacheRefresh:gi};em.useEffectEvent=gi;var ww={readContext:pr,use:I0,useCallback:function(u,d){return ca().memoizedState=[u,d===void 0?null:d],u},useContext:pr,useEffect:yw,useImperativeHandle:function(u,d,x){x=x!=null?x.concat([u]):null,$0(4194308,4,qv.bind(null,d,u),x)},useLayoutEffect:function(u,d){return $0(4194308,4,u,d)},useInsertionEffect:function(u,d){$0(4,2,u,d)},useMemo:function(u,d){var x=ca();d=d===void 0?null:d;var w=u();if(Wh){Ne(!0);try{u()}finally{Ne(!1)}}return x.memoizedState=[w,d],w},useReducer:function(u,d,x){var w=ca();if(x!==void 0){var N=x(d);if(Wh){Ne(!0);try{x(d)}finally{Ne(!1)}}}else N=d;return w.memoizedState=w.baseState=N,u={pending:null,lanes:0,dispatch:null,lastRenderedReducer:u,lastRenderedState:N},w.queue=u,u=u.dispatch=$N.bind(null,xn,u),[w.memoizedState,u]},useRef:function(u){var d=ca();return u={current:u},d.memoizedState=u},useState:function(u){u=Jp(u);var d=u.queue,x=_w.bind(null,xn,d);return d.dispatch=x,[u.memoizedState,x]},useDebugValue:z0,useDeferredValue:function(u,d){var x=ca();return Kv(x,u,d)},useTransition:function(){var u=Jp(!1);return u=Zv.bind(null,xn,u.queue,!0,!1),ca().memoizedState=u,[!1,u]},useSyncExternalStore:function(u,d,x){var w=xn,N=ca();if(Yn){if(x===void 0)throw Error(s(407));x=x()}else{if(x=d(),ws===null)throw Error(s(349));(Kn&127)!==0||aw(w,d,x)}N.memoizedState=x;var R={value:x,getSnapshot:d};return N.queue=R,yw(Vv.bind(null,w,R,u),[u]),w.flags|=2048,nd(9,{destroy:void 0},Pv.bind(null,w,R,x,d),null),x},useId:function(){var u=ca(),d=ws.identifierPrefix;if(Yn){var x=Vl,w=Pl;x=(w&~(1<<32-ut(w)-1)).toString(32)+x,d="_"+d+"R_"+x,x=M0++,0<x&&(d+="H"+x.toString(32)),d+="_"}else x=MN++,d="_"+d+"r_"+x.toString(32)+"_";return u.memoizedState=d},useHostTransitionStatus:tb,useFormState:fw,useActionState:fw,useOptimistic:function(u){var d=ca();d.memoizedState=d.baseState=u;var x={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return d.queue=x,d=tm.bind(null,xn,!0,x),x.dispatch=d,[u,d]},useMemoCache:zv,useCacheRefresh:function(){return ca().memoizedState=ON.bind(null,xn)},useEffectEvent:function(u){var d=ca(),x={impl:u};return d.memoizedState=x,function(){if((ts&2)!==0)throw Error(s(440));return x.impl.apply(void 0,arguments)}}},id={readContext:pr,use:I0,useCallback:Xv,useContext:pr,useEffect:Wv,useImperativeHandle:F0,useInsertionEffect:bw,useLayoutEffect:no,useMemo:jv,useReducer:R0,useRef:gw,useState:function(){return R0(Ic)},useDebugValue:z0,useDeferredValue:function(u,d){var x=Ci();return Yv(x,Os.memoizedState,u,d)},useTransition:function(){var u=R0(Ic)[0],d=Ci().memoizedState;return[typeof u=="boolean"?u:Qp(u),d]},useSyncExternalStore:Bv,useId:Nr,useHostTransitionStatus:tb,useFormState:dw,useActionState:dw,useOptimistic:function(u,d){var x=Ci();return ow(x,Os,u,d)},useMemoCache:zv,useCacheRefresh:eb};id.useEffectEvent=vw;var nm={readContext:pr,use:I0,useCallback:Xv,useContext:pr,useEffect:Wv,useImperativeHandle:F0,useInsertionEffect:bw,useLayoutEffect:no,useMemo:jv,useReducer:D0,useRef:gw,useState:function(){return D0(Ic)},useDebugValue:z0,useDeferredValue:function(u,d){var x=Ci();return Os===null?Kv(x,u,d):Yv(x,Os.memoizedState,u,d)},useTransition:function(){var u=D0(Ic)[0],d=Ci().memoizedState;return[typeof u=="boolean"?u:Qp(u),d]},useSyncExternalStore:Bv,useId:Nr,useHostTransitionStatus:tb,useFormState:mw,useActionState:mw,useOptimistic:function(u,d){var x=Ci();return Os!==null?ow(x,Os,u,d):(x.baseState=u,[u,x.queue.dispatch])},useMemoCache:zv,useCacheRefresh:eb};nm.useEffectEvent=vw;function rd(u,d,x,w){d=u.memoizedState,x=x(w,d),x=x==null?d:f({},d,x),u.memoizedState=x,u.lanes===0&&(u.updateQueue.baseState=x)}var sm={enqueueSetState:function(u,d,x){u=u._reactInternals;var w=ha(),N=Hl(w);N.payload=d,x!=null&&(N.callback=x),d=Nc(u,N,w),d!==null&&(y(d,u,w),Lu(d,u,w))},enqueueReplaceState:function(u,d,x){u=u._reactInternals;var w=ha(),N=Hl(w);N.tag=1,N.payload=d,x!=null&&(N.callback=x),d=Nc(u,N,w),d!==null&&(y(d,u,w),Lu(d,u,w))},enqueueForceUpdate:function(u,d){u=u._reactInternals;var x=ha(),w=Hl(x);w.tag=2,d!=null&&(w.callback=d),d=Nc(u,w,x),d!==null&&(y(d,u,x),Lu(d,u,x))}};function Tw(u,d,x,w,N,R,V){return u=u.stateNode,typeof u.shouldComponentUpdate=="function"?u.shouldComponentUpdate(w,R,V):d.prototype&&d.prototype.isPureReactComponent?!Gf(x,w)||!Gf(N,R):!0}function Ew(u,d,x,w){u=d.state,typeof d.componentWillReceiveProps=="function"&&d.componentWillReceiveProps(x,w),typeof d.UNSAFE_componentWillReceiveProps=="function"&&d.UNSAFE_componentWillReceiveProps(x,w),d.state!==u&&sm.enqueueReplaceState(d,d.state,null)}function Mr(u,d){var x=d;if("ref"in d){x={};for(var w in d)w!=="ref"&&(x[w]=d[w])}if(u=u.defaultProps){x===d&&(x=f({},x));for(var N in u)x[N]===void 0&&(x[N]=u[N])}return x}function nb(u){Eu(u)}function Cw(u){console.error(u)}function U0(u){Eu(u)}function B0(u,d){try{var x=u.onUncaughtError;x(d.value,{componentStack:d.stack})}catch(w){setTimeout(function(){throw w})}}function Aw(u,d,x){try{var w=u.onCaughtError;w(x.value,{componentStack:x.stack,errorBoundary:d.tag===1?d.stateNode:null})}catch(N){setTimeout(function(){throw N})}}function sb(u,d,x){return x=Hl(x),x.tag=3,x.payload={element:null},x.callback=function(){B0(u,d)},x}function ad(u){return u=Hl(u),u.tag=3,u}function Ta(u,d,x,w){var N=x.type.getDerivedStateFromError;if(typeof N=="function"){var R=w.value;u.payload=function(){return N(R)},u.callback=function(){Aw(d,x,w)}}var V=x.stateNode;V!==null&&typeof V.componentDidCatch=="function"&&(u.callback=function(){Aw(d,x,w),typeof N!="function"&&(Ql===null?Ql=new Set([this]):Ql.add(this));var Q=w.stack;this.componentDidCatch(w.value,{componentStack:Q!==null?Q:""})})}function so(u,d,x,w,N){if(x.flags|=32768,w!==null&&typeof w=="object"&&typeof w.then=="function"){if(d=x.alternate,d!==null&&Iu(d,x,N,!0),x=Qi.current,x!==null){switch(x.tag){case 31:case 13:return Oo===null?En():x.alternate===null&&Ts===0&&(Ts=3),x.flags&=-257,x.flags|=65536,x.lanes=N,w===qp?x.flags|=16384:(d=x.updateQueue,d===null?x.updateQueue=new Set([w]):d.add(w),LN(u,w,N)),!1;case 22:return x.flags|=65536,w===qp?x.flags|=16384:(d=x.updateQueue,d===null?(d={transitions:null,markerInstances:null,retryQueue:new Set([w])},x.updateQueue=d):(x=d.retryQueue,x===null?d.retryQueue=new Set([w]):x.add(w)),LN(u,w,N)),!1}throw Error(s(435,x.tag))}return LN(u,w,N),En(),!1}if(Yn)return d=Qi.current,d!==null?((d.flags&65536)===0&&(d.flags|=256),d.flags|=65536,d.lanes=N,w!==b0&&(u=Error(s(422),{cause:w}),Gp(ba(u,x)))):(w!==b0&&(d=Error(s(423),{cause:w}),Gp(ba(d,x))),u=u.current.alternate,u.flags|=65536,N&=-N,u.lanes|=N,w=ba(w,x),N=sb(u.stateNode,w,N),C0(u,N),Ts!==4&&(Ts=2)),!1;var R=Error(s(520),{cause:w});if(R=ba(R,x),ml===null?ml=[R]:ml.push(R),Ts!==4&&(Ts=2),d===null)return!0;w=ba(w,x),x=d;do{switch(x.tag){case 3:return x.flags|=65536,u=N&-N,x.lanes|=u,u=sb(x.stateNode,w,u),C0(x,u),!1;case 1:if(d=x.type,R=x.stateNode,(x.flags&128)===0&&(typeof d.getDerivedStateFromError=="function"||R!==null&&typeof R.componentDidCatch=="function"&&(Ql===null||!Ql.has(R))))return x.flags|=65536,N&=-N,x.lanes|=N,N=ad(N),Ta(N,u,x,w),C0(x,N),!1}x=x.return}while(x!==null);return!1}var P0=Error(s(461)),ti=!1;function yi(u,d,x,w){d.child=u===null?nw(d,null,x,w):Gh(d,u.child,x,w)}function im(u,d,x,w,N){x=x.render;var R=d.ref;if("ref"in w){var V={};for(var Q in w)Q!=="ref"&&(V[Q]=w[Q])}else V=w;return Bh(d),w=Ov(u,d,x,V,R,N),Q=$v(),u!==null&&!ti?(Lv(u,d,N),dl(u,d,N)):(Yn&&Q&&v0(d),d.flags|=1,yi(u,d,w,N),d.child)}function rm(u,d,x,w,N){if(u===null){var R=x.type;return typeof R=="function"&&!oa(R)&&R.defaultProps===void 0&&x.compare===null?(d.tag=15,d.type=R,io(u,d,R,w,N)):(u=Bp(x.type,null,w,d,d.mode,N),u.ref=d.ref,u.return=d,d.child=u)}if(R=u.child,!Uu(u,N)){var V=R.memoizedProps;if(x=x.compare,x=x!==null?x:Gf,x(V,w)&&u.ref===d.ref)return dl(u,d,N)}return d.flags|=1,u=Ul(R,w),u.ref=d.ref,u.return=d,d.child=u}function io(u,d,x,w,N){if(u!==null){var R=u.memoizedProps;if(Gf(R,w)&&u.ref===d.ref)if(ti=!1,d.pendingProps=w=R,Uu(u,N))(u.flags&131072)!==0&&(ti=!0);else return d.lanes=u.lanes,dl(u,d,N)}return od(u,d,x,w,N)}function ro(u,d,x,w){var N=w.children,R=u!==null?u.memoizedState:null;if(u===null&&d.stateNode===null&&(d.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),w.mode==="hidden"){if((d.flags&128)!==0){if(R=R!==null?R.baseLanes|x:x,u!==null){for(w=d.child=u.child,N=0;w!==null;)N=N|w.lanes|w.childLanes,w=w.sibling;w=N&~R}else w=0,d.child=null;return jl(u,d,R,x,w)}if((x&536870912)!==0)d.memoizedState={baseLanes:0,cachePool:null},u!==null&&td(d,R!==null?R.cachePool:null),R!==null?Iv(d,R):Rv(),sw(d);else return w=d.lanes=536870912,jl(u,d,R!==null?R.baseLanes|x:x,x,w)}else R!==null?(td(d,R.cachePool),Iv(d,R),Mc(),d.memoizedState=null):(u!==null&&td(d,null),Rv(),Mc());return yi(u,d,N,x),d.child}function hl(u,d){return u!==null&&u.tag===22||d.stateNode!==null||(d.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),d.sibling}function jl(u,d,x,w,N){var R=Gl();return R=R===null?null:{parent:rn._currentValue,pool:R},d.memoizedState={baseLanes:x,cachePool:R},u!==null&&td(d,null),Rv(),sw(d),u!==null&&Iu(u,d,w,!0),d.childLanes=N,null}function $o(u,d){return d=ld({mode:d.mode,children:d.children},u.mode),d.ref=u.ref,u.child=d,d.return=u,d}function mr(u,d,x){return Gh(d,u.child,null,x),u=$o(d,d.pendingProps),u.flags|=2,eo(d),d.memoizedState=null,u}function am(u,d,x){var w=d.pendingProps,N=(d.flags&128)!==0;if(d.flags&=-129,u===null){if(Yn){if(w.mode==="hidden")return u=$o(d,w),d.lanes=536870912,hl(null,u);if(Dv(d),(u=qs)?(u=lL(u,dr),u=u!==null&&u.data==="&"?u:null,u!==null&&(d.memoizedState={dehydrated:u,treeContext:Bl!==null?{id:Pl,overflow:Vl}:null,retryLane:536870912,hydrationErrors:null},x=Y_(u),x.return=d,d.child=x,fr=d,qs=null)):u=null,u===null)throw jn(d);return d.lanes=536870912,null}return $o(d,w)}var R=u.memoizedState;if(R!==null){var V=R.dehydrated;if(Dv(d),N)if(d.flags&256)d.flags&=-257,d=mr(u,d,x);else if(d.memoizedState!==null)d.child=u.child,d.flags|=128,d=null;else throw Error(s(558));else if(ti||Iu(u,d,x,!1),N=(x&u.childLanes)!==0,ti||N){if(w=ws,w!==null&&(V=du(w,x),V!==0&&V!==R.retryLane))throw R.retryLane=V,Au(u,V),y(w,u,V),P0;En(),d=mr(u,d,x)}else u=R.treeContext,qs=Jl(V.nextSibling),fr=d,Yn=!0,wc=null,dr=!1,u!==null&&Vp(d,u),d=$o(d,w),d.flags|=4096;return d}return u=Ul(u.child,{mode:w.mode,children:w.children}),u.ref=d.ref,d.child=u,u.return=d,u}function fl(u,d){var x=d.ref;if(x===null)u!==null&&u.ref!==null&&(d.flags|=4194816);else{if(typeof x!="function"&&typeof x!="object")throw Error(s(284));(u===null||u.ref!==x)&&(d.flags|=4194816)}}function od(u,d,x,w,N){return Bh(d),x=Ov(u,d,x,w,void 0,N),w=$v(),u!==null&&!ti?(Lv(u,d,N),dl(u,d,N)):(Yn&&w&&v0(d),d.flags|=1,yi(u,d,x,N),d.child)}function Hr(u,d,x,w,N,R){return Bh(d),d.updateQueue=null,x=rw(d,w,x,N),iw(u),w=$v(),u!==null&&!ti?(Lv(u,d,R),dl(u,d,R)):(Yn&&w&&v0(d),d.flags|=1,yi(u,d,x,R),d.child)}function Ir(u,d,x,w,N){if(Bh(d),d.stateNode===null){var R=Nu,V=x.contextType;typeof V=="object"&&V!==null&&(R=pr(V)),R=new x(w,R),d.memoizedState=R.state!==null&&R.state!==void 0?R.state:null,R.updater=sm,d.stateNode=R,R._reactInternals=d,R=d.stateNode,R.props=w,R.state=d.memoizedState,R.refs={},Av(d),V=x.contextType,R.context=typeof V=="object"&&V!==null?pr(V):Nu,R.state=d.memoizedState,V=x.getDerivedStateFromProps,typeof V=="function"&&(rd(d,x,V,w),R.state=d.memoizedState),typeof x.getDerivedStateFromProps=="function"||typeof R.getSnapshotBeforeUpdate=="function"||typeof R.UNSAFE_componentWillMount!="function"&&typeof R.componentWillMount!="function"||(V=R.state,typeof R.componentWillMount=="function"&&R.componentWillMount(),typeof R.UNSAFE_componentWillMount=="function"&&R.UNSAFE_componentWillMount(),V!==R.state&&sm.enqueueReplaceState(R,R.state,null),Hh(d,w,R,N),Kp(),R.state=d.memoizedState),typeof R.componentDidMount=="function"&&(d.flags|=4194308),w=!0}else if(u===null){R=d.stateNode;var Q=d.memoizedProps,gt=Mr(x,Q);R.props=gt;var $t=R.context,ee=x.contextType;V=Nu,typeof ee=="object"&&ee!==null&&(V=pr(ee));var le=x.getDerivedStateFromProps;ee=typeof le=="function"||typeof R.getSnapshotBeforeUpdate=="function",Q=d.pendingProps!==Q,ee||typeof R.UNSAFE_componentWillReceiveProps!="function"&&typeof R.componentWillReceiveProps!="function"||(Q||$t!==V)&&Ew(d,R,w,V),$u=!1;var Ut=d.memoizedState;R.state=Ut,Hh(d,w,R,N),Kp(),$t=d.memoizedState,Q||Ut!==$t||$u?(typeof le=="function"&&(rd(d,x,le,w),$t=d.memoizedState),(gt=$u||Tw(d,x,gt,w,Ut,$t,V))?(ee||typeof R.UNSAFE_componentWillMount!="function"&&typeof R.componentWillMount!="function"||(typeof R.componentWillMount=="function"&&R.componentWillMount(),typeof R.UNSAFE_componentWillMount=="function"&&R.UNSAFE_componentWillMount()),typeof R.componentDidMount=="function"&&(d.flags|=4194308)):(typeof R.componentDidMount=="function"&&(d.flags|=4194308),d.memoizedProps=w,d.memoizedState=$t),R.props=w,R.state=$t,R.context=V,w=gt):(typeof R.componentDidMount=="function"&&(d.flags|=4194308),w=!1)}else{R=d.stateNode,Nv(u,d),V=d.memoizedProps,ee=Mr(x,V),R.props=ee,le=d.pendingProps,Ut=R.context,$t=x.contextType,gt=Nu,typeof $t=="object"&&$t!==null&&(gt=pr($t)),Q=x.getDerivedStateFromProps,($t=typeof Q=="function"||typeof R.getSnapshotBeforeUpdate=="function")||typeof R.UNSAFE_componentWillReceiveProps!="function"&&typeof R.componentWillReceiveProps!="function"||(V!==le||Ut!==gt)&&Ew(d,R,w,gt),$u=!1,Ut=d.memoizedState,R.state=Ut,Hh(d,w,R,N),Kp();var jt=d.memoizedState;V!==le||Ut!==jt||$u||u!==null&&u.dependencies!==null&&Qf(u.dependencies)?(typeof Q=="function"&&(rd(d,x,Q,w),jt=d.memoizedState),(ee=$u||Tw(d,x,ee,w,Ut,jt,gt)||u!==null&&u.dependencies!==null&&Qf(u.dependencies))?($t||typeof R.UNSAFE_componentWillUpdate!="function"&&typeof R.componentWillUpdate!="function"||(typeof R.componentWillUpdate=="function"&&R.componentWillUpdate(w,jt,gt),typeof R.UNSAFE_componentWillUpdate=="function"&&R.UNSAFE_componentWillUpdate(w,jt,gt)),typeof R.componentDidUpdate=="function"&&(d.flags|=4),typeof R.getSnapshotBeforeUpdate=="function"&&(d.flags|=1024)):(typeof R.componentDidUpdate!="function"||V===u.memoizedProps&&Ut===u.memoizedState||(d.flags|=4),typeof R.getSnapshotBeforeUpdate!="function"||V===u.memoizedProps&&Ut===u.memoizedState||(d.flags|=1024),d.memoizedProps=w,d.memoizedState=jt),R.props=w,R.state=jt,R.context=gt,w=ee):(typeof R.componentDidUpdate!="function"||V===u.memoizedProps&&Ut===u.memoizedState||(d.flags|=4),typeof R.getSnapshotBeforeUpdate!="function"||V===u.memoizedProps&&Ut===u.memoizedState||(d.flags|=1024),w=!1)}return R=w,fl(u,d),w=(d.flags&128)!==0,R||w?(R=d.stateNode,x=w&&typeof x.getDerivedStateFromError!="function"?null:R.render(),d.flags|=1,u!==null&&w?(d.child=Gh(d,u.child,null,N),d.child=Gh(d,null,x,N)):yi(u,d,x,N),d.memoizedState=R.state,u=d.child):u=dl(u,d,N),u}function is(u,d,x,w){return Uh(),d.flags|=256,yi(u,d,x,w),d.child}var ao={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Lo(u){return{baseLanes:u,cachePool:w0()}}function om(u,d,x){return u=u!==null?u.childLanes&~x:0,d&&(u|=es),u}function oo(u,d,x){var w=d.pendingProps,N=!1,R=(d.flags&128)!==0,V;if((V=R)||(V=u!==null&&u.memoizedState===null?!1:(mi.current&2)!==0),V&&(N=!0,d.flags&=-129),V=(d.flags&32)!==0,d.flags&=-33,u===null){if(Yn){if(N?Fu(d):Mc(),(u=qs)?(u=lL(u,dr),u=u!==null&&u.data!=="&"?u:null,u!==null&&(d.memoizedState={dehydrated:u,treeContext:Bl!==null?{id:Pl,overflow:Vl}:null,retryLane:536870912,hydrationErrors:null},x=Y_(u),x.return=d,d.child=x,fr=d,qs=null)):u=null,u===null)throw jn(d);return QN(u)?d.lanes=32:d.lanes=536870912,null}var Q=w.children;return w=w.fallback,N?(Mc(),N=d.mode,Q=ld({mode:"hidden",children:Q},N),w=Sc(w,N,x,null),Q.return=d,w.return=d,Q.sibling=w,d.child=Q,w=d.child,w.memoizedState=Lo(x),w.childLanes=om(u,V,x),d.memoizedState=ao,hl(null,w)):(Fu(d),zu(d,Q))}var gt=u.memoizedState;if(gt!==null&&(Q=gt.dehydrated,Q!==null)){if(R)d.flags&256?(Fu(d),d.flags&=-257,d=cd(u,d,x)):d.memoizedState!==null?(Mc(),d.child=u.child,d.flags|=128,d=null):(Mc(),Q=w.fallback,N=d.mode,w=ld({mode:"visible",children:w.children},N),Q=Sc(Q,N,x,null),Q.flags|=2,w.return=d,Q.return=d,w.sibling=Q,d.child=w,Gh(d,u.child,null,x),w=d.child,w.memoizedState=Lo(x),w.childLanes=om(u,V,x),d.memoizedState=ao,d=hl(null,w));else if(Fu(d),QN(Q)){if(V=Q.nextSibling&&Q.nextSibling.dataset,V)var $t=V.dgst;V=$t,w=Error(s(419)),w.stack="",w.digest=V,Gp({value:w,source:null,stack:null}),d=cd(u,d,x)}else if(ti||Iu(u,d,x,!1),V=(x&u.childLanes)!==0,ti||V){if(V=ws,V!==null&&(w=du(V,x),w!==0&&w!==gt.retryLane))throw gt.retryLane=w,Au(u,w),y(V,u,w),P0;ZN(Q)||En(),d=cd(u,d,x)}else ZN(Q)?(d.flags|=192,d.child=u.child,d=null):(u=gt.treeContext,qs=Jl(Q.nextSibling),fr=d,Yn=!0,wc=null,dr=!1,u!==null&&Vp(d,u),d=zu(d,w.children),d.flags|=4096);return d}return N?(Mc(),Q=w.fallback,N=d.mode,gt=u.child,$t=gt.sibling,w=Ul(gt,{mode:"hidden",children:w.children}),w.subtreeFlags=gt.subtreeFlags&65011712,$t!==null?Q=Ul($t,Q):(Q=Sc(Q,N,x,null),Q.flags|=2),Q.return=d,w.return=d,w.sibling=Q,d.child=w,hl(null,w),w=d.child,Q=u.child.memoizedState,Q===null?Q=Lo(x):(N=Q.cachePool,N!==null?(gt=rn._currentValue,N=N.parent!==gt?{parent:gt,pool:gt}:N):N=w0(),Q={baseLanes:Q.baseLanes|x,cachePool:N}),w.memoizedState=Q,w.childLanes=om(u,V,x),d.memoizedState=ao,hl(u.child,w)):(Fu(d),x=u.child,u=x.sibling,x=Ul(x,{mode:"visible",children:w.children}),x.return=d,x.sibling=null,u!==null&&(V=d.deletions,V===null?(d.deletions=[u],d.flags|=16):V.push(u)),d.child=x,d.memoizedState=null,x)}function zu(u,d){return d=ld({mode:"visible",children:d},u.mode),d.return=u,u.child=d}function ld(u,d){return u=aa(22,u,null,d),u.lanes=0,u}function cd(u,d,x){return Gh(d,u.child,null,x),u=zu(d,d.pendingProps.children),u.flags|=2,d.memoizedState=null,u}function Xh(u,d,x){u.lanes|=d;var w=u.alternate;w!==null&&(w.lanes|=d),Cc(u.return,d,x)}function lm(u,d,x,w,N,R){var V=u.memoizedState;V===null?u.memoizedState={isBackwards:d,rendering:null,renderingStartTime:0,last:w,tail:x,tailMode:N,treeForkCount:R}:(V.isBackwards=d,V.rendering=null,V.renderingStartTime=0,V.last=w,V.tail=x,V.tailMode=N,V.treeForkCount=R)}function cm(u,d,x){var w=d.pendingProps,N=w.revealOrder,R=w.tail;w=w.children;var V=mi.current,Q=(V&2)!==0;if(Q?(V=V&1|2,d.flags|=128):V&=1,ct(mi,V),yi(u,d,w,x),w=Yn?Zf:0,!Q&&u!==null&&(u.flags&128)!==0)t:for(u=d.child;u!==null;){if(u.tag===13)u.memoizedState!==null&&Xh(u,x,d);else if(u.tag===19)Xh(u,x,d);else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===d)break t;for(;u.sibling===null;){if(u.return===null||u.return===d)break t;u=u.return}u.sibling.return=u.return,u=u.sibling}switch(N){case"forwards":for(x=d.child,N=null;x!==null;)u=x.alternate,u!==null&&A0(u)===null&&(N=x),x=x.sibling;x=N,x===null?(N=d.child,d.child=null):(N=x.sibling,x.sibling=null),lm(d,!1,N,x,R,w);break;case"backwards":case"unstable_legacy-backwards":for(x=null,N=d.child,d.child=null;N!==null;){if(u=N.alternate,u!==null&&A0(u)===null){d.child=N;break}u=N.sibling,N.sibling=x,x=N,N=u}lm(d,!0,x,null,R,w);break;case"together":lm(d,!1,null,null,void 0,w);break;default:d.memoizedState=null}return d.child}function dl(u,d,x){if(u!==null&&(d.dependencies=u.dependencies),uo|=d.lanes,(x&d.childLanes)===0)if(u!==null){if(Iu(u,d,x,!1),(x&d.childLanes)===0)return null}else return null;if(u!==null&&d.child!==u.child)throw Error(s(153));if(d.child!==null){for(u=d.child,x=Ul(u,u.pendingProps),d.child=x,x.return=d;u.sibling!==null;)u=u.sibling,x=x.sibling=Ul(u,u.pendingProps),x.return=d;x.sibling=null}return d.child}function Uu(u,d){return(u.lanes&d)!==0?!0:(u=u.dependencies,!!(u!==null&&Qf(u)))}function um(u,d,x){switch(d.tag){case 3:qt(d,d.stateNode.containerInfo),Ec(d,rn,u.memoizedState.cache),Uh();break;case 27:case 5:se(d);break;case 4:qt(d,d.stateNode.containerInfo);break;case 10:Ec(d,d.type,d.memoizedProps.value);break;case 31:if(d.memoizedState!==null)return d.flags|=128,Dv(d),null;break;case 13:var w=d.memoizedState;if(w!==null)return w.dehydrated!==null?(Fu(d),d.flags|=128,null):(x&d.child.childLanes)!==0?oo(u,d,x):(Fu(d),u=dl(u,d,x),u!==null?u.sibling:null);Fu(d);break;case 19:var N=(u.flags&128)!==0;if(w=(x&d.childLanes)!==0,w||(Iu(u,d,x,!1),w=(x&d.childLanes)!==0),N){if(w)return cm(u,d,x);d.flags|=128}if(N=d.memoizedState,N!==null&&(N.rendering=null,N.tail=null,N.lastEffect=null),ct(mi,mi.current),w)break;return null;case 22:return d.lanes=0,ro(u,d,x,d.pendingProps);case 24:Ec(d,rn,u.memoizedState.cache)}return dl(u,d,x)}function V0(u,d,x){if(u!==null)if(u.memoizedProps!==d.pendingProps)ti=!0;else{if(!Uu(u,x)&&(d.flags&128)===0)return ti=!1,um(u,d,x);ti=(u.flags&131072)!==0}else ti=!1,Yn&&(d.flags&1048576)!==0&&gv(d,Zf,d.index);switch(d.lanes=0,d.tag){case 16:t:{var w=d.pendingProps;if(u=Vh(d.elementType),d.type=u,typeof u=="function")oa(u)?(w=Mr(u,w),d.tag=1,d=Ir(null,d,u,w,x)):(d.tag=0,d=od(null,d,u,w,x));else{if(u!=null){var N=u.$$typeof;if(N===A){d.tag=11,d=im(null,d,u,w,x);break t}else if(N===F){d.tag=14,d=rm(null,d,u,w,x);break t}}throw d=K(u)||u,Error(s(306,d,""))}}return d;case 0:return od(u,d,d.type,d.pendingProps,x);case 1:return w=d.type,N=Mr(w,d.pendingProps),Ir(u,d,w,N,x);case 3:t:{if(qt(d,d.stateNode.containerInfo),u===null)throw Error(s(387));w=d.pendingProps;var R=d.memoizedState;N=R.element,Nv(u,d),Hh(d,w,null,x);var V=d.memoizedState;if(w=V.cache,Ec(d,rn,w),w!==R.cache&&_0(d,[rn],x,!0),Kp(),w=V.element,R.isDehydrated)if(R={element:w,isDehydrated:!1,cache:V.cache},d.updateQueue.baseState=R,d.memoizedState=R,d.flags&256){d=is(u,d,w,x);break t}else if(w!==N){N=ba(Error(s(424)),d),Gp(N),d=is(u,d,w,x);break t}else{switch(u=d.stateNode.containerInfo,u.nodeType){case 9:u=u.body;break;default:u=u.nodeName==="HTML"?u.ownerDocument.body:u}for(qs=Jl(u.firstChild),fr=d,Yn=!0,wc=null,dr=!0,x=nw(d,null,w,x),d.child=x;x;)x.flags=x.flags&-3|4096,x=x.sibling}else{if(Uh(),w===N){d=dl(u,d,x);break t}yi(u,d,w,x)}d=d.child}return d;case 26:return fl(u,d),u===null?(x=pL(d.type,null,d.pendingProps,null))?d.memoizedState=x:Yn||(x=d.type,u=d.pendingProps,w=$w(ft.current).createElement(x),w[$n]=d,w[Zi]=u,fa(w,x,u),Z(w),d.stateNode=w):d.memoizedState=pL(d.type,u.memoizedProps,d.pendingProps,u.memoizedState),null;case 27:return se(d),u===null&&Yn&&(w=d.stateNode=hL(d.type,d.pendingProps,ft.current),fr=d,dr=!0,N=qs,gd(d.type)?(JN=N,qs=Jl(w.firstChild)):qs=N),yi(u,d,d.pendingProps.children,x),fl(u,d),u===null&&(d.flags|=4194304),d.child;case 5:return u===null&&Yn&&((N=w=qs)&&(w=dj(w,d.type,d.pendingProps,dr),w!==null?(d.stateNode=w,fr=d,qs=Jl(w.firstChild),dr=!1,N=!0):N=!1),N||jn(d)),se(d),N=d.type,R=d.pendingProps,V=u!==null?u.memoizedProps:null,w=R.children,jN(N,R)?w=null:V!==null&&jN(N,V)&&(d.flags|=32),d.memoizedState!==null&&(N=Ov(u,d,IN,null,null,x),db._currentValue=N),fl(u,d),yi(u,d,w,x),d.child;case 6:return u===null&&Yn&&((u=x=qs)&&(x=pj(x,d.pendingProps,dr),x!==null?(d.stateNode=x,fr=d,qs=null,u=!0):u=!1),u||jn(d)),null;case 13:return oo(u,d,x);case 4:return qt(d,d.stateNode.containerInfo),w=d.pendingProps,u===null?d.child=Gh(d,null,w,x):yi(u,d,w,x),d.child;case 11:return im(u,d,d.type,d.pendingProps,x);case 7:return yi(u,d,d.pendingProps,x),d.child;case 8:return yi(u,d,d.pendingProps.children,x),d.child;case 12:return yi(u,d,d.pendingProps.children,x),d.child;case 10:return w=d.pendingProps,Ec(d,d.type,w.value),yi(u,d,w.children,x),d.child;case 9:return N=d.type._context,w=d.pendingProps.children,Bh(d),N=pr(N),w=w(N),d.flags|=1,yi(u,d,w,x),d.child;case 14:return rm(u,d,d.type,d.pendingProps,x);case 15:return io(u,d,d.type,d.pendingProps,x);case 19:return cm(u,d,x);case 31:return am(u,d,x);case 22:return ro(u,d,x,d.pendingProps);case 24:return Bh(d),w=pr(rn),u===null?(N=Gl(),N===null&&(N=ws,R=Sv(),N.pooledCache=R,R.refCount++,R!==null&&(N.pooledCacheLanes|=x),N=R),d.memoizedState={parent:w,cache:N},Av(d),Ec(d,rn,N)):((u.lanes&x)!==0&&(Nv(u,d),Hh(d,null,null,x),Kp()),N=u.memoizedState,R=d.memoizedState,N.parent!==w?(N={parent:w,cache:w},d.memoizedState=N,d.lanes===0&&(d.memoizedState=d.updateQueue.baseState=N),Ec(d,rn,w)):(w=R.cache,Ec(d,rn,w),w!==N.cache&&_0(d,[rn],x,!0))),yi(u,d,d.pendingProps.children,x),d.child;case 29:throw d.pendingProps}throw Error(s(156,d.tag))}function Ea(u){u.flags|=4}function Bu(u,d,x,w,N){if((d=(u.mode&32)!==0)&&(d=!1),d){if(u.flags|=16777216,(N&335544128)===N)if(u.stateNode.complete)u.flags|=8192;else if(Te())u.flags|=8192;else throw dn=qp,Wp}else u.flags&=-16777217}function Dc(u,d){if(d.type!=="stylesheet"||(d.state.loading&4)!==0)u.flags&=-16777217;else if(u.flags|=16777216,!vL(d))if(Te())u.flags|=8192;else throw dn=qp,Wp}function ud(u,d){d!==null&&(u.flags|=4),u.flags&16384&&(d=u.tag!==22?zn():536870912,u.lanes|=d,ho|=d)}function hm(u,d){if(!Yn)switch(u.tailMode){case"hidden":d=u.tail;for(var x=null;d!==null;)d.alternate!==null&&(x=d),d=d.sibling;x===null?u.tail=null:x.sibling=null;break;case"collapsed":x=u.tail;for(var w=null;x!==null;)x.alternate!==null&&(w=x),x=x.sibling;w===null?d||u.tail===null?u.tail=null:u.tail.sibling=null:w.sibling=null}}function Rs(u){var d=u.alternate!==null&&u.alternate.child===u.child,x=0,w=0;if(d)for(var N=u.child;N!==null;)x|=N.lanes|N.childLanes,w|=N.subtreeFlags&65011712,w|=N.flags&65011712,N.return=u,N=N.sibling;else for(N=u.child;N!==null;)x|=N.lanes|N.childLanes,w|=N.subtreeFlags,w|=N.flags,N.return=u,N=N.sibling;return u.subtreeFlags|=w,u.childLanes=x,d}function ib(u,d,x){var w=d.pendingProps;switch(Mu(d),d.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Rs(d),null;case 1:return Rs(d),null;case 3:return x=d.stateNode,w=null,u!==null&&(w=u.memoizedState.cache),d.memoizedState.cache!==w&&(d.flags|=2048),ko(rn),Qt(),x.pendingContext&&(x.context=x.pendingContext,x.pendingContext=null),(u===null||u.child===null)&&(zh(d)?Ea(d):u===null||u.memoizedState.isDehydrated&&(d.flags&256)===0||(d.flags|=1024,yv())),Rs(d),null;case 26:var N=d.type,R=d.memoizedState;return u===null?(Ea(d),R!==null?(Rs(d),Dc(d,R)):(Rs(d),Bu(d,N,null,w,x))):R?R!==u.memoizedState?(Ea(d),Rs(d),Dc(d,R)):(Rs(d),d.flags&=-16777217):(u=u.memoizedProps,u!==w&&Ea(d),Rs(d),Bu(d,N,u,w,x)),null;case 27:if(Ee(d),x=ft.current,N=d.type,u!==null&&d.stateNode!=null)u.memoizedProps!==w&&Ea(d);else{if(!w){if(d.stateNode===null)throw Error(s(166));return Rs(d),null}u=yt.current,zh(d)?S0(d):(u=hL(N,w,x),d.stateNode=u,Ea(d))}return Rs(d),null;case 5:if(Ee(d),N=d.type,u!==null&&d.stateNode!=null)u.memoizedProps!==w&&Ea(d);else{if(!w){if(d.stateNode===null)throw Error(s(166));return Rs(d),null}if(R=yt.current,zh(d))S0(d);else{var V=$w(ft.current);switch(R){case 1:R=V.createElementNS("http://www.w3.org/2000/svg",N);break;case 2:R=V.createElementNS("http://www.w3.org/1998/Math/MathML",N);break;default:switch(N){case"svg":R=V.createElementNS("http://www.w3.org/2000/svg",N);break;case"math":R=V.createElementNS("http://www.w3.org/1998/Math/MathML",N);break;case"script":R=V.createElement("div"),R.innerHTML="<script><\/script>",R=R.removeChild(R.firstChild);break;case"select":R=typeof w.is=="string"?V.createElement("select",{is:w.is}):V.createElement("select"),w.multiple?R.multiple=!0:w.size&&(R.size=w.size);break;default:R=typeof w.is=="string"?V.createElement(N,{is:w.is}):V.createElement(N)}}R[$n]=d,R[Zi]=w;t:for(V=d.child;V!==null;){if(V.tag===5||V.tag===6)R.appendChild(V.stateNode);else if(V.tag!==4&&V.tag!==27&&V.child!==null){V.child.return=V,V=V.child;continue}if(V===d)break t;for(;V.sibling===null;){if(V.return===null||V.return===d)break t;V=V.return}V.sibling.return=V.return,V=V.sibling}d.stateNode=R;t:switch(fa(R,N,w),N){case"button":case"input":case"select":case"textarea":w=!!w.autoFocus;break t;case"img":w=!0;break t;default:w=!1}w&&Ea(d)}}return Rs(d),Bu(d,d.type,u===null?null:u.memoizedProps,d.pendingProps,x),null;case 6:if(u&&d.stateNode!=null)u.memoizedProps!==w&&Ea(d);else{if(typeof w!="string"&&d.stateNode===null)throw Error(s(166));if(u=ft.current,zh(d)){if(u=d.stateNode,x=d.memoizedProps,w=null,N=fr,N!==null)switch(N.tag){case 27:case 5:w=N.memoizedProps}u[$n]=d,u=!!(u.nodeValue===x||w!==null&&w.suppressHydrationWarning===!0||tL(u.nodeValue,x)),u||jn(d,!0)}else u=$w(u).createTextNode(w),u[$n]=d,d.stateNode=u}return Rs(d),null;case 31:if(x=d.memoizedState,u===null||u.memoizedState!==null){if(w=zh(d),x!==null){if(u===null){if(!w)throw Error(s(318));if(u=d.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(557));u[$n]=d}else Uh(),(d.flags&128)===0&&(d.memoizedState=null),d.flags|=4;Rs(d),u=!1}else x=yv(),u!==null&&u.memoizedState!==null&&(u.memoizedState.hydrationErrors=x),u=!0;if(!u)return d.flags&256?(eo(d),d):(eo(d),null);if((d.flags&128)!==0)throw Error(s(558))}return Rs(d),null;case 13:if(w=d.memoizedState,u===null||u.memoizedState!==null&&u.memoizedState.dehydrated!==null){if(N=zh(d),w!==null&&w.dehydrated!==null){if(u===null){if(!N)throw Error(s(318));if(N=d.memoizedState,N=N!==null?N.dehydrated:null,!N)throw Error(s(317));N[$n]=d}else Uh(),(d.flags&128)===0&&(d.memoizedState=null),d.flags|=4;Rs(d),N=!1}else N=yv(),u!==null&&u.memoizedState!==null&&(u.memoizedState.hydrationErrors=N),N=!0;if(!N)return d.flags&256?(eo(d),d):(eo(d),null)}return eo(d),(d.flags&128)!==0?(d.lanes=x,d):(x=w!==null,u=u!==null&&u.memoizedState!==null,x&&(w=d.child,N=null,w.alternate!==null&&w.alternate.memoizedState!==null&&w.alternate.memoizedState.cachePool!==null&&(N=w.alternate.memoizedState.cachePool.pool),R=null,w.memoizedState!==null&&w.memoizedState.cachePool!==null&&(R=w.memoizedState.cachePool.pool),R!==N&&(w.flags|=2048)),x!==u&&x&&(d.child.flags|=8192),ud(d,d.updateQueue),Rs(d),null);case 4:return Qt(),u===null&&GN(d.stateNode.containerInfo),Rs(d),null;case 10:return ko(d.type),Rs(d),null;case 19:if(it(mi),w=d.memoizedState,w===null)return Rs(d),null;if(N=(d.flags&128)!==0,R=w.rendering,R===null)if(N)hm(w,!1);else{if(Ts!==0||u!==null&&(u.flags&128)!==0)for(u=d.child;u!==null;){if(R=A0(u),R!==null){for(d.flags|=128,hm(w,!1),u=R.updateQueue,d.updateQueue=u,ud(d,u),d.subtreeFlags=0,u=x,x=d.child;x!==null;)Pr(x,u),x=x.sibling;return ct(mi,mi.current&1|2),Yn&&_c(d,w.treeForkCount),d.child}u=u.sibling}w.tail!==null&&G()>fo&&(d.flags|=128,N=!0,hm(w,!1),d.lanes=4194304)}else{if(!N)if(u=A0(R),u!==null){if(d.flags|=128,N=!0,u=u.updateQueue,d.updateQueue=u,ud(d,u),hm(w,!0),w.tail===null&&w.tailMode==="hidden"&&!R.alternate&&!Yn)return Rs(d),null}else 2*G()-w.renderingStartTime>fo&&x!==536870912&&(d.flags|=128,N=!0,hm(w,!1),d.lanes=4194304);w.isBackwards?(R.sibling=d.child,d.child=R):(u=w.last,u!==null?u.sibling=R:d.child=R,w.last=R)}return w.tail!==null?(u=w.tail,w.rendering=u,w.tail=u.sibling,w.renderingStartTime=G(),u.sibling=null,x=mi.current,ct(mi,N?x&1|2:x&1),Yn&&_c(d,w.treeForkCount),u):(Rs(d),null);case 22:case 23:return eo(d),Gr(),w=d.memoizedState!==null,u!==null?u.memoizedState!==null!==w&&(d.flags|=8192):w&&(d.flags|=8192),w?(x&536870912)!==0&&(d.flags&128)===0&&(Rs(d),d.subtreeFlags&6&&(d.flags|=8192)):Rs(d),x=d.updateQueue,x!==null&&ud(d,x.retryQueue),x=null,u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(x=u.memoizedState.cachePool.pool),w=null,d.memoizedState!==null&&d.memoizedState.cachePool!==null&&(w=d.memoizedState.cachePool.pool),w!==x&&(d.flags|=2048),u!==null&&it(Ru),null;case 24:return x=null,u!==null&&(x=u.memoizedState.cache),d.memoizedState.cache!==x&&(d.flags|=2048),ko(rn),Rs(d),null;case 25:return null;case 30:return null}throw Error(s(156,d.tag))}function G0(u,d){switch(Mu(d),d.tag){case 1:return u=d.flags,u&65536?(d.flags=u&-65537|128,d):null;case 3:return ko(rn),Qt(),u=d.flags,(u&65536)!==0&&(u&128)===0?(d.flags=u&-65537|128,d):null;case 26:case 27:case 5:return Ee(d),null;case 31:if(d.memoizedState!==null){if(eo(d),d.alternate===null)throw Error(s(340));Uh()}return u=d.flags,u&65536?(d.flags=u&-65537|128,d):null;case 13:if(eo(d),u=d.memoizedState,u!==null&&u.dehydrated!==null){if(d.alternate===null)throw Error(s(340));Uh()}return u=d.flags,u&65536?(d.flags=u&-65537|128,d):null;case 19:return it(mi),null;case 4:return Qt(),null;case 10:return ko(d.type),null;case 22:case 23:return eo(d),Gr(),u!==null&&it(Ru),u=d.flags,u&65536?(d.flags=u&-65537|128,d):null;case 24:return ko(rn),null;case 25:return null;default:return null}}function jh(u,d){switch(Mu(d),d.tag){case 3:ko(rn),Qt();break;case 26:case 27:case 5:Ee(d);break;case 4:Qt();break;case 31:d.memoizedState!==null&&eo(d);break;case 13:eo(d);break;case 19:it(mi);break;case 10:ko(d.type);break;case 22:case 23:eo(d),Gr(),u!==null&&it(Ru);break;case 24:ko(rn)}}function Kl(u,d){try{var x=d.updateQueue,w=x!==null?x.lastEffect:null;if(w!==null){var N=w.next;x=N;do{if((x.tag&u)===u){w=void 0;var R=x.create,V=x.inst;w=R(),V.destroy=w}x=x.next}while(x!==N)}}catch(Q){Ps(d,d.return,Q)}}function Fo(u,d,x){try{var w=d.updateQueue,N=w!==null?w.lastEffect:null;if(N!==null){var R=N.next;w=R;do{if((w.tag&u)===u){var V=w.inst,Q=V.destroy;if(Q!==void 0){V.destroy=void 0,N=d;var gt=x,$t=Q;try{$t()}catch(ee){Ps(N,gt,ee)}}}w=w.next}while(w!==R)}}catch(ee){Ps(d,d.return,ee)}}function Pu(u){var d=u.updateQueue;if(d!==null){var x=u.stateNode;try{Ar(d,x)}catch(w){Ps(u,u.return,w)}}}function rb(u,d,x){x.props=Mr(u.type,u.memoizedProps),x.state=u.memoizedState;try{x.componentWillUnmount()}catch(w){Ps(u,d,w)}}function Yl(u,d){try{var x=u.ref;if(x!==null){switch(u.tag){case 26:case 27:case 5:var w=u.stateNode;break;case 30:w=u.stateNode;break;default:w=u.stateNode}typeof x=="function"?u.refCleanup=x(w):x.current=w}}catch(N){Ps(u,d,N)}}function lo(u,d){var x=u.ref,w=u.refCleanup;if(x!==null)if(typeof w=="function")try{w()}catch(N){Ps(u,d,N)}finally{u.refCleanup=null,u=u.alternate,u!=null&&(u.refCleanup=null)}else if(typeof x=="function")try{x(null)}catch(N){Ps(u,d,N)}else x.current=null}function co(u){var d=u.type,x=u.memoizedProps,w=u.stateNode;try{t:switch(d){case"button":case"input":case"select":case"textarea":x.autoFocus&&w.focus();break t;case"img":x.src?w.src=x.src:x.srcSet&&(w.srcset=x.srcSet)}}catch(N){Ps(u,u.return,N)}}function zo(u,d,x){try{var w=u.stateNode;oj(w,u.type,x,d),w[Zi]=d}catch(N){Ps(u,u.return,N)}}function Ui(u){return u.tag===5||u.tag===3||u.tag===26||u.tag===27&&gd(u.type)||u.tag===4}function Zl(u){t:for(;;){for(;u.sibling===null;){if(u.return===null||Ui(u.return))return null;u=u.return}for(u.sibling.return=u.return,u=u.sibling;u.tag!==5&&u.tag!==6&&u.tag!==18;){if(u.tag===27&&gd(u.type)||u.flags&2||u.child===null||u.tag===4)continue t;u.child.return=u,u=u.child}if(!(u.flags&2))return u.stateNode}}function Dn(u,d,x){var w=u.tag;if(w===5||w===6)u=u.stateNode,d?(x.nodeType===9?x.body:x.nodeName==="HTML"?x.ownerDocument.body:x).insertBefore(u,d):(d=x.nodeType===9?x.body:x.nodeName==="HTML"?x.ownerDocument.body:x,d.appendChild(u),x=x._reactRootContainer,x!=null||d.onclick!==null||(d.onclick=Ll));else if(w!==4&&(w===27&&gd(u.type)&&(x=u.stateNode,d=null),u=u.child,u!==null))for(Dn(u,d,x),u=u.sibling;u!==null;)Dn(u,d,x),u=u.sibling}function xs(u,d,x){var w=u.tag;if(w===5||w===6)u=u.stateNode,d?x.insertBefore(u,d):x.appendChild(u);else if(w!==4&&(w===27&&gd(u.type)&&(x=u.stateNode),u=u.child,u!==null))for(xs(u,d,x),u=u.sibling;u!==null;)xs(u,d,x),u=u.sibling}function Ai(u){var d=u.stateNode,x=u.memoizedProps;try{for(var w=u.type,N=d.attributes;N.length;)d.removeAttributeNode(N[0]);fa(d,w,x),d[$n]=u,d[Zi]=x}catch(R){Ps(u,u.return,R)}}var Uo=!1,ei=!1,kc=!1,fm=typeof WeakSet=="function"?WeakSet:Set,xi=null;function hd(u,d){if(u=u.containerInfo,qN=Vw,u=h0(u),Hf(u)){if("selectionStart"in u)var x={start:u.selectionStart,end:u.selectionEnd};else t:{x=(x=u.ownerDocument)&&x.defaultView||window;var w=x.getSelection&&x.getSelection();if(w&&w.rangeCount!==0){x=w.anchorNode;var N=w.anchorOffset,R=w.focusNode;w=w.focusOffset;try{x.nodeType,R.nodeType}catch{x=null;break t}var V=0,Q=-1,gt=-1,$t=0,ee=0,le=u,Ut=null;e:for(;;){for(var jt;le!==x||N!==0&&le.nodeType!==3||(Q=V+N),le!==R||w!==0&&le.nodeType!==3||(gt=V+w),le.nodeType===3&&(V+=le.nodeValue.length),(jt=le.firstChild)!==null;)Ut=le,le=jt;for(;;){if(le===u)break e;if(Ut===x&&++$t===N&&(Q=V),Ut===R&&++ee===w&&(gt=V),(jt=le.nextSibling)!==null)break;le=Ut,Ut=le.parentNode}le=jt}x=Q===-1||gt===-1?null:{start:Q,end:gt}}else x=null}x=x||{start:0,end:0}}else x=null;for(XN={focusedElem:u,selectionRange:x},Vw=!1,xi=d;xi!==null;)if(d=xi,u=d.child,(d.subtreeFlags&1028)!==0&&u!==null)u.return=d,xi=u;else for(;xi!==null;){switch(d=xi,R=d.alternate,u=d.flags,d.tag){case 0:if((u&4)!==0&&(u=d.updateQueue,u=u!==null?u.events:null,u!==null))for(x=0;x<u.length;x++)N=u[x],N.ref.impl=N.nextImpl;break;case 11:case 15:break;case 1:if((u&1024)!==0&&R!==null){u=void 0,x=d,N=R.memoizedProps,R=R.memoizedState,w=x.stateNode;try{var Ye=Mr(x.type,N);u=w.getSnapshotBeforeUpdate(Ye,R),w.__reactInternalSnapshotBeforeUpdate=u}catch(gn){Ps(x,x.return,gn)}}break;case 3:if((u&1024)!==0){if(u=d.stateNode.containerInfo,x=u.nodeType,x===9)YN(u);else if(x===1)switch(u.nodeName){case"HEAD":case"HTML":case"BODY":YN(u);break;default:u.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((u&1024)!==0)throw Error(s(163))}if(u=d.sibling,u!==null){u.return=d.return,xi=u;break}xi=d.return}}function Nw(u,d,x){var w=x.flags;switch(x.tag){case 0:case 11:case 15:Oc(u,x),w&4&&Kl(5,x);break;case 1:if(Oc(u,x),w&4)if(u=x.stateNode,d===null)try{u.componentDidMount()}catch(V){Ps(x,x.return,V)}else{var N=Mr(x.type,d.memoizedProps);d=d.memoizedState;try{u.componentDidUpdate(N,d,u.__reactInternalSnapshotBeforeUpdate)}catch(V){Ps(x,x.return,V)}}w&64&&Pu(x),w&512&&Yl(x,x.return);break;case 3:if(Oc(u,x),w&64&&(u=x.updateQueue,u!==null)){if(d=null,x.child!==null)switch(x.child.tag){case 27:case 5:d=x.child.stateNode;break;case 1:d=x.child.stateNode}try{Ar(u,d)}catch(V){Ps(x,x.return,V)}}break;case 27:d===null&&w&4&&Ai(x);case 26:case 5:Oc(u,x),d===null&&w&4&&co(x),w&512&&Yl(x,x.return);break;case 12:Oc(u,x);break;case 31:Oc(u,x),w&4&&W0(u,x);break;case 13:Oc(u,x),w&4&&ab(u,x),w&64&&(u=x.memoizedState,u!==null&&(u=u.dehydrated,u!==null&&(x=KX.bind(null,x),mj(u,x))));break;case 22:if(w=x.memoizedState!==null||Uo,!w){d=d!==null&&d.memoizedState!==null||ei,N=Uo;var R=ei;Uo=w,(ei=d)&&!R?_s(u,x,(x.subtreeFlags&8772)!==0):Oc(u,x),Uo=N,ei=R}break;case 30:break;default:Oc(u,x)}}function H0(u){var d=u.alternate;d!==null&&(u.alternate=null,H0(d)),u.child=null,u.deletions=null,u.sibling=null,u.tag===5&&(d=u.stateNode,d!==null&&Ah(d)),u.stateNode=null,u.return=null,u.dependencies=null,u.memoizedProps=null,u.memoizedState=null,u.pendingProps=null,u.stateNode=null,u.updateQueue=null}var rs=null,Bi=!1;function Wr(u,d,x){for(x=x.child;x!==null;)Vu(u,d,x),x=x.sibling}function Vu(u,d,x){if(de&&typeof de.onCommitFiberUnmount=="function")try{de.onCommitFiberUnmount(ae,x)}catch{}switch(x.tag){case 26:ei||lo(x,d),Wr(u,d,x),x.memoizedState?x.memoizedState.count--:x.stateNode&&(x=x.stateNode,x.parentNode.removeChild(x));break;case 27:ei||lo(x,d);var w=rs,N=Bi;gd(x.type)&&(rs=x.stateNode,Bi=!1),Wr(u,d,x),ub(x.stateNode),rs=w,Bi=N;break;case 5:ei||lo(x,d);case 6:if(w=rs,N=Bi,rs=null,Wr(u,d,x),rs=w,Bi=N,rs!==null)if(Bi)try{(rs.nodeType===9?rs.body:rs.nodeName==="HTML"?rs.ownerDocument.body:rs).removeChild(x.stateNode)}catch(R){Ps(x,d,R)}else try{rs.removeChild(x.stateNode)}catch(R){Ps(x,d,R)}break;case 18:rs!==null&&(Bi?(u=rs,aL(u.nodeType===9?u.body:u.nodeName==="HTML"?u.ownerDocument.body:u,x.stateNode),ny(u)):aL(rs,x.stateNode));break;case 4:w=rs,N=Bi,rs=x.stateNode.containerInfo,Bi=!0,Wr(u,d,x),rs=w,Bi=N;break;case 0:case 11:case 14:case 15:Fo(2,x,d),ei||Fo(4,x,d),Wr(u,d,x);break;case 1:ei||(lo(x,d),w=x.stateNode,typeof w.componentWillUnmount=="function"&&rb(x,d,w)),Wr(u,d,x);break;case 21:Wr(u,d,x);break;case 22:ei=(w=ei)||x.memoizedState!==null,Wr(u,d,x),ei=w;break;default:Wr(u,d,x)}}function W0(u,d){if(d.memoizedState===null&&(u=d.alternate,u!==null&&(u=u.memoizedState,u!==null))){u=u.dehydrated;try{ny(u)}catch(x){Ps(d,d.return,x)}}}function ab(u,d){if(d.memoizedState===null&&(u=d.alternate,u!==null&&(u=u.memoizedState,u!==null&&(u=u.dehydrated,u!==null))))try{ny(u)}catch(x){Ps(d,d.return,x)}}function Mw(u){switch(u.tag){case 31:case 13:case 19:var d=u.stateNode;return d===null&&(d=u.stateNode=new fm),d;case 22:return u=u.stateNode,d=u._retryCache,d===null&&(d=u._retryCache=new fm),d;default:throw Error(s(435,u.tag))}}function Ni(u,d){var x=Mw(u);d.forEach(function(w){if(!x.has(w)){x.add(w);var N=YX.bind(null,u,w);w.then(N,N)}})}function qr(u,d){var x=d.deletions;if(x!==null)for(var w=0;w<x.length;w++){var N=x[w],R=u,V=d,Q=V;t:for(;Q!==null;){switch(Q.tag){case 27:if(gd(Q.type)){rs=Q.stateNode,Bi=!1;break t}break;case 5:rs=Q.stateNode,Bi=!1;break t;case 3:case 4:rs=Q.stateNode.containerInfo,Bi=!0;break t}Q=Q.return}if(rs===null)throw Error(s(160));Vu(R,V,N),rs=null,Bi=!1,R=N.alternate,R!==null&&(R.return=null),N.return=null}if(d.subtreeFlags&13886)for(d=d.child;d!==null;)Gu(d,u),d=d.sibling}var Ca=null;function Gu(u,d){var x=u.alternate,w=u.flags;switch(u.tag){case 0:case 11:case 14:case 15:qr(d,u),vi(u),w&4&&(Fo(3,u,u.return),Kl(3,u),Fo(5,u,u.return));break;case 1:qr(d,u),vi(u),w&512&&(ei||x===null||lo(x,x.return)),w&64&&Uo&&(u=u.updateQueue,u!==null&&(w=u.callbacks,w!==null&&(x=u.shared.hiddenCallbacks,u.shared.hiddenCallbacks=x===null?w:x.concat(w))));break;case 26:var N=Ca;if(qr(d,u),vi(u),w&512&&(ei||x===null||lo(x,x.return)),w&4){var R=x!==null?x.memoizedState:null;if(w=u.memoizedState,x===null)if(w===null)if(u.stateNode===null){t:{w=u.type,x=u.memoizedProps,N=N.ownerDocument||N;e:switch(w){case"title":R=N.getElementsByTagName("title")[0],(!R||R[yc]||R[$n]||R.namespaceURI==="http://www.w3.org/2000/svg"||R.hasAttribute("itemprop"))&&(R=N.createElement(w),N.head.insertBefore(R,N.querySelector("head > title"))),fa(R,w,x),R[$n]=u,Z(R),w=R;break t;case"link":var V=yL("link","href",N).get(w+(x.href||""));if(V){for(var Q=0;Q<V.length;Q++)if(R=V[Q],R.getAttribute("href")===(x.href==null||x.href===""?null:x.href)&&R.getAttribute("rel")===(x.rel==null?null:x.rel)&&R.getAttribute("title")===(x.title==null?null:x.title)&&R.getAttribute("crossorigin")===(x.crossOrigin==null?null:x.crossOrigin)){V.splice(Q,1);break e}}R=N.createElement(w),fa(R,w,x),N.head.appendChild(R);break;case"meta":if(V=yL("meta","content",N).get(w+(x.content||""))){for(Q=0;Q<V.length;Q++)if(R=V[Q],R.getAttribute("content")===(x.content==null?null:""+x.content)&&R.getAttribute("name")===(x.name==null?null:x.name)&&R.getAttribute("property")===(x.property==null?null:x.property)&&R.getAttribute("http-equiv")===(x.httpEquiv==null?null:x.httpEquiv)&&R.getAttribute("charset")===(x.charSet==null?null:x.charSet)){V.splice(Q,1);break e}}R=N.createElement(w),fa(R,w,x),N.head.appendChild(R);break;default:throw Error(s(468,w))}R[$n]=u,Z(R),w=R}u.stateNode=w}else xL(N,u.type,u.stateNode);else u.stateNode=gL(N,w,u.memoizedProps);else R!==w?(R===null?x.stateNode!==null&&(x=x.stateNode,x.parentNode.removeChild(x)):R.count--,w===null?xL(N,u.type,u.stateNode):gL(N,w,u.memoizedProps)):w===null&&u.stateNode!==null&&zo(u,u.memoizedProps,x.memoizedProps)}break;case 27:qr(d,u),vi(u),w&512&&(ei||x===null||lo(x,x.return)),x!==null&&w&4&&zo(u,u.memoizedProps,x.memoizedProps);break;case 5:if(qr(d,u),vi(u),w&512&&(ei||x===null||lo(x,x.return)),u.flags&32){N=u.stateNode;try{$i(N,"")}catch(Ye){Ps(u,u.return,Ye)}}w&4&&u.stateNode!=null&&(N=u.memoizedProps,zo(u,N,x!==null?x.memoizedProps:N)),w&1024&&(kc=!0);break;case 6:if(qr(d,u),vi(u),w&4){if(u.stateNode===null)throw Error(s(162));w=u.memoizedProps,x=u.stateNode;try{x.nodeValue=w}catch(Ye){Ps(u,u.return,Ye)}}break;case 3:if(zw=null,N=Ca,Ca=Lw(d.containerInfo),qr(d,u),Ca=N,vi(u),w&4&&x!==null&&x.memoizedState.isDehydrated)try{ny(d.containerInfo)}catch(Ye){Ps(u,u.return,Ye)}kc&&(kc=!1,Iw(u));break;case 4:w=Ca,Ca=Lw(u.stateNode.containerInfo),qr(d,u),vi(u),Ca=w;break;case 12:qr(d,u),vi(u);break;case 31:qr(d,u),vi(u),w&4&&(w=u.updateQueue,w!==null&&(u.updateQueue=null,Ni(u,w)));break;case 13:qr(d,u),vi(u),u.child.flags&8192&&u.memoizedState!==null!=(x!==null&&x.memoizedState!==null)&&(Fc=G()),w&4&&(w=u.updateQueue,w!==null&&(u.updateQueue=null,Ni(u,w)));break;case 22:N=u.memoizedState!==null;var gt=x!==null&&x.memoizedState!==null,$t=Uo,ee=ei;if(Uo=$t||N,ei=ee||gt,qr(d,u),ei=ee,Uo=$t,vi(u),w&8192)t:for(d=u.stateNode,d._visibility=N?d._visibility&-2:d._visibility|1,N&&(x===null||gt||Uo||ei||Kh(u)),x=null,d=u;;){if(d.tag===5||d.tag===26){if(x===null){gt=x=d;try{if(R=gt.stateNode,N)V=R.style,typeof V.setProperty=="function"?V.setProperty("display","none","important"):V.display="none";else{Q=gt.stateNode;var le=gt.memoizedProps.style,Ut=le!=null&&le.hasOwnProperty("display")?le.display:null;Q.style.display=Ut==null||typeof Ut=="boolean"?"":(""+Ut).trim()}}catch(Ye){Ps(gt,gt.return,Ye)}}}else if(d.tag===6){if(x===null){gt=d;try{gt.stateNode.nodeValue=N?"":gt.memoizedProps}catch(Ye){Ps(gt,gt.return,Ye)}}}else if(d.tag===18){if(x===null){gt=d;try{var jt=gt.stateNode;N?oL(jt,!0):oL(gt.stateNode,!1)}catch(Ye){Ps(gt,gt.return,Ye)}}}else if((d.tag!==22&&d.tag!==23||d.memoizedState===null||d===u)&&d.child!==null){d.child.return=d,d=d.child;continue}if(d===u)break t;for(;d.sibling===null;){if(d.return===null||d.return===u)break t;x===d&&(x=null),d=d.return}x===d&&(x=null),d.sibling.return=d.return,d=d.sibling}w&4&&(w=u.updateQueue,w!==null&&(x=w.retryQueue,x!==null&&(w.retryQueue=null,Ni(u,x))));break;case 19:qr(d,u),vi(u),w&4&&(w=u.updateQueue,w!==null&&(u.updateQueue=null,Ni(u,w)));break;case 30:break;case 21:break;default:qr(d,u),vi(u)}}function vi(u){var d=u.flags;if(d&2){try{for(var x,w=u.return;w!==null;){if(Ui(w)){x=w;break}w=w.return}if(x==null)throw Error(s(160));switch(x.tag){case 27:var N=x.stateNode,R=Zl(u);xs(u,R,N);break;case 5:var V=x.stateNode;x.flags&32&&($i(V,""),x.flags&=-33);var Q=Zl(u);xs(u,Q,V);break;case 3:case 4:var gt=x.stateNode.containerInfo,$t=Zl(u);Dn(u,$t,gt);break;default:throw Error(s(161))}}catch(ee){Ps(u,u.return,ee)}u.flags&=-3}d&4096&&(u.flags&=-4097)}function Iw(u){if(u.subtreeFlags&1024)for(u=u.child;u!==null;){var d=u;Iw(d),d.tag===5&&d.flags&1024&&d.stateNode.reset(),u=u.sibling}}function Oc(u,d){if(d.subtreeFlags&8772)for(d=d.child;d!==null;)Nw(u,d.alternate,d),d=d.sibling}function Kh(u){for(u=u.child;u!==null;){var d=u;switch(d.tag){case 0:case 11:case 14:case 15:Fo(4,d,d.return),Kh(d);break;case 1:lo(d,d.return);var x=d.stateNode;typeof x.componentWillUnmount=="function"&&rb(d,d.return,x),Kh(d);break;case 27:ub(d.stateNode);case 26:case 5:lo(d,d.return),Kh(d);break;case 22:d.memoizedState===null&&Kh(d);break;case 30:Kh(d);break;default:Kh(d)}u=u.sibling}}function _s(u,d,x){for(x=x&&(d.subtreeFlags&8772)!==0,d=d.child;d!==null;){var w=d.alternate,N=u,R=d,V=R.flags;switch(R.tag){case 0:case 11:case 15:_s(N,R,x),Kl(4,R);break;case 1:if(_s(N,R,x),w=R,N=w.stateNode,typeof N.componentDidMount=="function")try{N.componentDidMount()}catch($t){Ps(w,w.return,$t)}if(w=R,N=w.updateQueue,N!==null){var Q=w.stateNode;try{var gt=N.shared.hiddenCallbacks;if(gt!==null)for(N.shared.hiddenCallbacks=null,N=0;N<gt.length;N++)Wl(gt[N],Q)}catch($t){Ps(w,w.return,$t)}}x&&V&64&&Pu(R),Yl(R,R.return);break;case 27:Ai(R);case 26:case 5:_s(N,R,x),x&&w===null&&V&4&&co(R),Yl(R,R.return);break;case 12:_s(N,R,x);break;case 31:_s(N,R,x),x&&V&4&&W0(N,R);break;case 13:_s(N,R,x),x&&V&4&&ab(N,R);break;case 22:R.memoizedState===null&&_s(N,R,x),Yl(R,R.return);break;case 30:break;default:_s(N,R,x)}d=d.sibling}}function q0(u,d){var x=null;u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(x=u.memoizedState.cachePool.pool),u=null,d.memoizedState!==null&&d.memoizedState.cachePool!==null&&(u=d.memoizedState.cachePool.pool),u!==x&&(u!=null&&u.refCount++,x!=null&&Cr(x))}function $c(u,d){u=null,d.alternate!==null&&(u=d.alternate.memoizedState.cache),d=d.memoizedState.cache,d!==u&&(d.refCount++,u!=null&&Cr(u))}function Ji(u,d,x,w){if(d.subtreeFlags&10256)for(d=d.child;d!==null;)ci(u,d,x,w),d=d.sibling}function ci(u,d,x,w){var N=d.flags;switch(d.tag){case 0:case 11:case 15:Ji(u,d,x,w),N&2048&&Kl(9,d);break;case 1:Ji(u,d,x,w);break;case 3:Ji(u,d,x,w),N&2048&&(u=null,d.alternate!==null&&(u=d.alternate.memoizedState.cache),d=d.memoizedState.cache,d!==u&&(d.refCount++,u!=null&&Cr(u)));break;case 12:if(N&2048){Ji(u,d,x,w),u=d.stateNode;try{var R=d.memoizedProps,V=R.id,Q=R.onPostCommit;typeof Q=="function"&&Q(V,d.alternate===null?"mount":"update",u.passiveEffectDuration,-0)}catch(gt){Ps(d,d.return,gt)}}else Ji(u,d,x,w);break;case 31:Ji(u,d,x,w);break;case 13:Ji(u,d,x,w);break;case 23:break;case 22:R=d.stateNode,V=d.alternate,d.memoizedState!==null?R._visibility&2?Ji(u,d,x,w):fd(u,d):R._visibility&2?Ji(u,d,x,w):(R._visibility|=2,Hu(u,d,x,w,(d.subtreeFlags&10256)!==0||!1)),N&2048&&q0(V,d);break;case 24:Ji(u,d,x,w),N&2048&&$c(d.alternate,d);break;default:Ji(u,d,x,w)}}function Hu(u,d,x,w,N){for(N=N&&((d.subtreeFlags&10256)!==0||!1),d=d.child;d!==null;){var R=u,V=d,Q=x,gt=w,$t=V.flags;switch(V.tag){case 0:case 11:case 15:Hu(R,V,Q,gt,N),Kl(8,V);break;case 23:break;case 22:var ee=V.stateNode;V.memoizedState!==null?ee._visibility&2?Hu(R,V,Q,gt,N):fd(R,V):(ee._visibility|=2,Hu(R,V,Q,gt,N)),N&&$t&2048&&q0(V.alternate,V);break;case 24:Hu(R,V,Q,gt,N),N&&$t&2048&&$c(V.alternate,V);break;default:Hu(R,V,Q,gt,N)}d=d.sibling}}function fd(u,d){if(d.subtreeFlags&10256)for(d=d.child;d!==null;){var x=u,w=d,N=w.flags;switch(w.tag){case 22:fd(x,w),N&2048&&q0(w.alternate,w);break;case 24:fd(x,w),N&2048&&$c(w.alternate,w);break;default:fd(x,w)}d=d.sibling}}var bi=8192;function Yh(u,d,x){if(u.subtreeFlags&bi)for(u=u.child;u!==null;)Mi(u,d,x),u=u.sibling}function Mi(u,d,x){switch(u.tag){case 26:Yh(u,d,x),u.flags&bi&&u.memoizedState!==null&&Aj(x,Ca,u.memoizedState,u.memoizedProps);break;case 5:Yh(u,d,x);break;case 3:case 4:var w=Ca;Ca=Lw(u.stateNode.containerInfo),Yh(u,d,x),Ca=w;break;case 22:u.memoizedState===null&&(w=u.alternate,w!==null&&w.memoizedState!==null?(w=bi,bi=16777216,Yh(u,d,x),bi=w):Yh(u,d,x));break;default:Yh(u,d,x)}}function Aa(u){var d=u.alternate;if(d!==null&&(u=d.child,u!==null)){d.child=null;do d=u.sibling,u.sibling=null,u=d;while(u!==null)}}function ua(u){var d=u.deletions;if((u.flags&16)!==0){if(d!==null)for(var x=0;x<d.length;x++){var w=d[x];xi=w,dm(w,u)}Aa(u)}if(u.subtreeFlags&10256)for(u=u.child;u!==null;)Zh(u),u=u.sibling}function Zh(u){switch(u.tag){case 0:case 11:case 15:ua(u),u.flags&2048&&Fo(9,u,u.return);break;case 3:ua(u);break;case 12:ua(u);break;case 22:var d=u.stateNode;u.memoizedState!==null&&d._visibility&2&&(u.return===null||u.return.tag!==13)?(d._visibility&=-3,X0(u)):ua(u);break;default:ua(u)}}function X0(u){var d=u.deletions;if((u.flags&16)!==0){if(d!==null)for(var x=0;x<d.length;x++){var w=d[x];xi=w,dm(w,u)}Aa(u)}for(u=u.child;u!==null;){switch(d=u,d.tag){case 0:case 11:case 15:Fo(8,d,d.return),X0(d);break;case 22:x=d.stateNode,x._visibility&2&&(x._visibility&=-3,X0(d));break;default:X0(d)}u=u.sibling}}function dm(u,d){for(;xi!==null;){var x=xi;switch(x.tag){case 0:case 11:case 15:Fo(8,x,d);break;case 23:case 22:if(x.memoizedState!==null&&x.memoizedState.cachePool!==null){var w=x.memoizedState.cachePool.pool;w!=null&&w.refCount++}break;case 24:Cr(x.memoizedState.cache)}if(w=x.child,w!==null)w.return=x,xi=w;else t:for(x=u;xi!==null;){w=xi;var N=w.sibling,R=w.return;if(H0(w),w===x){xi=null;break t}if(N!==null){N.return=R,xi=N;break t}xi=R}}}var j0={getCacheForType:function(u){var d=pr(rn),x=d.data.get(u);return x===void 0&&(x=u(),d.data.set(u,x)),x},cacheSignal:function(){return pr(rn).controller.signal}},K0=typeof WeakMap=="function"?WeakMap:Map,ts=0,ws=null,kn=null,Kn=0,an=0,Gn=null,Cn=!1,Un=!1,$s=!1,Ii=0,Ts=0,uo=0,Lc=0,pl=0,es=0,ho=0,ml=null,Xr=null,Na=!1,Fc=0,dd=0,fo=1/0,pd=null,Ql=null,ui=0,gl=null,po=null,Bo=0,zc=0,Qh=null,Y0=null,Jh=0,tf=null;function ha(){return(ts&2)!==0&&Kn!==0?Kn&-Kn:P.T!==null?UN():Ro()}function m(){if(es===0)if((Kn&536870912)===0||Yn){var u=fe;fe<<=1,(fe&3932160)===0&&(fe=262144),es=u}else es=536870912;return u=Qi.current,u!==null&&(u.flags|=32),es}function y(u,d,x){(u===ws&&(an===2||an===9)||u.cancelPendingCommit!==null)&&(It(u,0),U(u,Kn,es,!1)),li(u,x),((ts&2)===0||u!==ws)&&(u===ws&&((ts&2)===0&&(Lc|=x),Ts===4&&U(u,Kn,es,!1)),Wu(u))}function E(u,d,x){if((ts&6)!==0)throw Error(s(327));var w=!x&&(d&127)===0&&(d&u.expiredLanes)===0||ve(u,d),N=w?ef(u,d):Ma(u,d,!0),R=w;do{if(N===0){Un&&!w&&U(u,d,0,!1);break}else{if(x=u.current.alternate,R&&!$(x)){N=Ma(u,d,!1),R=!1;continue}if(N===2){if(R=d,u.errorRecoveryDisabledLanes&R)var V=0;else V=u.pendingLanes&-536870913,V=V!==0?V:V&536870912?536870912:0;if(V!==0){d=V;t:{var Q=u;N=ml;var gt=Q.current.memoizedState.isDehydrated;if(gt&&(It(Q,V).flags|=256),V=Ma(Q,V,!1),V!==2){if($s&&!gt){Q.errorRecoveryDisabledLanes|=R,Lc|=R,N=4;break t}R=Xr,Xr=N,R!==null&&(Xr===null?Xr=R:Xr.push.apply(Xr,R))}N=V}if(R=!1,N!==2)continue}}if(N===1){It(u,0),U(u,d,0,!0);break}t:{switch(w=u,R=N,R){case 0:case 1:throw Error(s(345));case 4:if((d&4194048)!==d)break;case 6:U(w,d,es,!Cn);break t;case 2:Xr=null;break;case 3:case 5:break;default:throw Error(s(329))}if((d&62914560)===d&&(N=Fc+300-G(),10<N)){if(U(w,d,es,!Cn),ie(w,0,!0)!==0)break t;Bo=d,w.timeoutHandle=iL(M.bind(null,w,x,Xr,pd,Na,d,es,Lc,ho,Cn,R,"Throttled",-0,0),N);break t}M(w,x,Xr,pd,Na,d,es,Lc,ho,Cn,R,null,-0,0)}}break}while(!0);Wu(u)}function M(u,d,x,w,N,R,V,Q,gt,$t,ee,le,Ut,jt){if(u.timeoutHandle=-1,le=d.subtreeFlags,le&8192||(le&16785408)===16785408){le={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Ll},Mi(d,R,le);var Ye=(R&62914560)===R?Fc-G():(R&4194048)===R?dd-G():0;if(Ye=Nj(le,Ye),Ye!==null){Bo=R,u.cancelPendingCommit=Ye(vn.bind(null,u,d,R,x,w,N,V,Q,gt,ee,le,null,Ut,jt)),U(u,R,V,!$t);return}}vn(u,d,R,x,w,N,V,Q,gt)}function $(u){for(var d=u;;){var x=d.tag;if((x===0||x===11||x===15)&&d.flags&16384&&(x=d.updateQueue,x!==null&&(x=x.stores,x!==null)))for(var w=0;w<x.length;w++){var N=x[w],R=N.getSnapshot;N=N.value;try{if(!Js(R(),N))return!1}catch{return!1}}if(x=d.child,d.subtreeFlags&16384&&x!==null)x.return=d,d=x;else{if(d===u)break;for(;d.sibling===null;){if(d.return===null||d.return===u)return!0;d=d.return}d.sibling.return=d.return,d=d.sibling}}return!0}function U(u,d,x,w){d&=~pl,d&=~Lc,u.suspendedLanes|=d,u.pingedLanes&=~d,w&&(u.warmLanes|=d),w=u.expirationTimes;for(var N=d;0<N;){var R=31-ut(N),V=1<<R;w[R]=-1,N&=~V}x!==0&&Ep(u,x,d)}function tt(){return(ts&6)===0?(ob(0),!1):!0}function mt(){if(kn!==null){if(an===0)var u=kn.return;else u=kn,Vr=Tc=null,Fv(u),ku=null,Ou=0,u=kn;for(;u!==null;)jh(u.alternate,u),u=u.return;kn=null}}function It(u,d){var x=u.timeoutHandle;x!==-1&&(u.timeoutHandle=-1,uj(x)),x=u.cancelPendingCommit,x!==null&&(u.cancelPendingCommit=null,x()),Bo=0,mt(),ws=u,kn=x=Ul(u.current,null),Kn=d,an=0,Gn=null,Cn=!1,Un=ve(u,d),$s=!1,ho=es=pl=Lc=uo=Ts=0,Xr=ml=null,Na=!1,(d&8)!==0&&(d|=d&32);var w=u.entangledLanes;if(w!==0)for(u=u.entanglements,w&=d;0<w;){var N=31-ut(w),R=1<<N;d|=u[N],w&=~R}return Ii=d,Cu(),x}function ne(u,d){xn=null,P.H=em,d===Du||d===ul?(d=T0(),an=3):d===Wp?(d=T0(),an=4):an=d===P0?8:d!==null&&typeof d=="object"&&typeof d.then=="function"?6:1,Gn=d,kn===null&&(Ts=1,B0(u,ba(d,u.current)))}function Te(){var u=Qi.current;return u===null?!0:(Kn&4194048)===Kn?Oo===null:(Kn&62914560)===Kn||(Kn&536870912)!==0?u===Oo:!1}function $e(){var u=P.H;return P.H=em,u===null?em:u}function Ve(){var u=P.A;return P.A=j0,u}function En(){Ts=4,Cn||(Kn&4194048)!==Kn&&Qi.current!==null||(Un=!0),(uo&134217727)===0&&(Lc&134217727)===0||ws===null||U(ws,Kn,es,!1)}function Ma(u,d,x){var w=ts;ts|=2;var N=$e(),R=Ve();(ws!==u||Kn!==d)&&(pd=null,It(u,d)),d=!1;var V=Ts;t:do try{if(an!==0&&kn!==null){var Q=kn,gt=Gn;switch(an){case 8:mt(),V=6;break t;case 3:case 2:case 9:case 6:Qi.current===null&&(d=!0);var $t=an;if(an=0,Gn=null,xe(u,Q,gt,$t),x&&Un){V=0;break t}break;default:$t=an,an=0,Gn=null,xe(u,Q,gt,$t)}}pm(),V=Ts;break}catch(ee){ne(u,ee)}while(!0);return d&&u.shellSuspendCounter++,Vr=Tc=null,ts=w,P.H=N,P.A=R,kn===null&&(ws=null,Kn=0,Cu()),V}function pm(){for(;kn!==null;)Nt(kn)}function ef(u,d){var x=ts;ts|=2;var w=$e(),N=Ve();ws!==u||Kn!==d?(pd=null,fo=G()+500,It(u,d)):Un=ve(u,d);t:do try{if(an!==0&&kn!==null){d=kn;var R=Gn;e:switch(an){case 1:an=0,Gn=null,xe(u,d,R,1);break;case 2:case 9:if(ew(R)){an=0,Gn=null,Wt(d);break}d=function(){an!==2&&an!==9||ws!==u||(an=7),Wu(u)},R.then(d,d);break t;case 3:an=7;break t;case 4:an=5;break t;case 7:ew(R)?(an=0,Gn=null,Wt(d)):(an=0,Gn=null,xe(u,d,R,7));break;case 5:var V=null;switch(kn.tag){case 26:V=kn.memoizedState;case 5:case 27:var Q=kn;if(V?vL(V):Q.stateNode.complete){an=0,Gn=null;var gt=Q.sibling;if(gt!==null)kn=gt;else{var $t=Q.return;$t!==null?(kn=$t,sn($t)):kn=null}break e}}an=0,Gn=null,xe(u,d,R,5);break;case 6:an=0,Gn=null,xe(u,d,R,6);break;case 8:mt(),Ts=6;break t;default:throw Error(s(462))}}zt();break}catch(ee){ne(u,ee)}while(!0);return Vr=Tc=null,P.H=w,P.A=N,ts=x,kn!==null?0:(ws=null,Kn=0,Cu(),Ts)}function zt(){for(;kn!==null&&!pe();)Nt(kn)}function Nt(u){var d=V0(u.alternate,u,Ii);u.memoizedProps=u.pendingProps,d===null?sn(u):kn=d}function Wt(u){var d=u,x=d.alternate;switch(d.tag){case 15:case 0:d=Hr(x,d,d.pendingProps,d.type,void 0,Kn);break;case 11:d=Hr(x,d,d.pendingProps,d.type.render,d.ref,Kn);break;case 5:Fv(d);default:jh(x,d),d=kn=Pr(d,Ii),d=V0(x,d,Ii)}u.memoizedProps=u.pendingProps,d===null?sn(u):kn=d}function xe(u,d,x,w){Vr=Tc=null,Fv(d),ku=null,Ou=0;var N=d.return;try{if(so(u,N,d,x,Kn)){Ts=1,B0(u,ba(x,u.current)),kn=null;return}}catch(R){if(N!==null)throw kn=N,R;Ts=1,B0(u,ba(x,u.current)),kn=null;return}d.flags&32768?(Yn||w===1?u=!0:Un||(Kn&536870912)!==0?u=!1:(Cn=u=!0,(w===2||w===9||w===3||w===6)&&(w=Qi.current,w!==null&&w.tag===13&&(w.flags|=16384))),Xs(d,u)):sn(d)}function sn(u){var d=u;do{if((d.flags&32768)!==0){Xs(d,Cn);return}u=d.return;var x=ib(d.alternate,d,Ii);if(x!==null){kn=x;return}if(d=d.sibling,d!==null){kn=d;return}kn=d=u}while(d!==null);Ts===0&&(Ts=5)}function Xs(u,d){do{var x=G0(u.alternate,u);if(x!==null){x.flags&=32767,kn=x;return}if(x=u.return,x!==null&&(x.flags|=32768,x.subtreeFlags=0,x.deletions=null),!d&&(u=u.sibling,u!==null)){kn=u;return}kn=u=x}while(u!==null);Ts=6,kn=null}function vn(u,d,x,w,N,R,V,Q,gt){u.cancelPendingCommit=null;do Z0();while(ui!==0);if((ts&6)!==0)throw Error(s(327));if(d!==null){if(d===u.current)throw Error(s(177));if(R=d.lanes|d.childLanes,R|=g0,wr(u,x,R,V,Q,gt),u===ws&&(kn=ws=null,Kn=0),po=d,gl=u,Bo=x,zc=R,Qh=N,Y0=w,(d.subtreeFlags&10256)!==0||(d.flags&10256)!==0?(u.callbackNode=null,u.callbackPriority=0,ZX(Pt,function(){return P$(),null})):(u.callbackNode=null,u.callbackPriority=0),w=(d.flags&13878)!==0,(d.subtreeFlags&13878)!==0||w){w=P.T,P.T=null,N=W.p,W.p=2,V=ts,ts|=4;try{hd(u,d,x)}finally{ts=V,W.p=N,P.T=w}}ui=1,as(),tr(),os()}}function as(){if(ui===1){ui=0;var u=gl,d=po,x=(d.flags&13878)!==0;if((d.subtreeFlags&13878)!==0||x){x=P.T,P.T=null;var w=W.p;W.p=2;var N=ts;ts|=4;try{Gu(d,u);var R=XN,V=h0(u.containerInfo),Q=R.focusedElem,gt=R.selectionRange;if(V!==Q&&Q&&Q.ownerDocument&&u0(Q.ownerDocument.documentElement,Q)){if(gt!==null&&Hf(Q)){var $t=gt.start,ee=gt.end;if(ee===void 0&&(ee=$t),"selectionStart"in Q)Q.selectionStart=$t,Q.selectionEnd=Math.min(ee,Q.value.length);else{var le=Q.ownerDocument||document,Ut=le&&le.defaultView||window;if(Ut.getSelection){var jt=Ut.getSelection(),Ye=Q.textContent.length,gn=Math.min(gt.start,Ye),Ks=gt.end===void 0?gn:Math.min(gt.end,Ye);!jt.extend&&gn>Ks&&(V=Ks,Ks=gn,gn=V);var Mt=fv(Q,gn),St=fv(Q,Ks);if(Mt&&St&&(jt.rangeCount!==1||jt.anchorNode!==Mt.node||jt.anchorOffset!==Mt.offset||jt.focusNode!==St.node||jt.focusOffset!==St.offset)){var Ot=le.createRange();Ot.setStart(Mt.node,Mt.offset),jt.removeAllRanges(),gn>Ks?(jt.addRange(Ot),jt.extend(St.node,St.offset)):(Ot.setEnd(St.node,St.offset),jt.addRange(Ot))}}}}for(le=[],jt=Q;jt=jt.parentNode;)jt.nodeType===1&&le.push({element:jt,left:jt.scrollLeft,top:jt.scrollTop});for(typeof Q.focus=="function"&&Q.focus(),Q=0;Q<le.length;Q++){var re=le[Q];re.element.scrollLeft=re.left,re.element.scrollTop=re.top}}Vw=!!qN,XN=qN=null}finally{ts=N,W.p=w,P.T=x}}u.current=d,ui=2}}function tr(){if(ui===2){ui=0;var u=gl,d=po,x=(d.flags&8772)!==0;if((d.subtreeFlags&8772)!==0||x){x=P.T,P.T=null;var w=W.p;W.p=2;var N=ts;ts|=4;try{Nw(u,d.alternate,d)}finally{ts=N,W.p=w,P.T=x}}ui=3}}function os(){if(ui===4||ui===3){ui=0,nt();var u=gl,d=po,x=Bo,w=Y0;(d.subtreeFlags&10256)!==0||(d.flags&10256)!==0?ui=5:(ui=0,po=gl=null,Uc(u,u.pendingLanes));var N=u.pendingLanes;if(N===0&&(Ql=null),wh(x),d=d.stateNode,de&&typeof de.onCommitFiberRoot=="function")try{de.onCommitFiberRoot(ae,d,void 0,(d.current.flags&128)===128)}catch{}if(w!==null){d=P.T,N=W.p,W.p=2,P.T=null;try{for(var R=u.onRecoverableError,V=0;V<w.length;V++){var Q=w[V];R(Q.value,{componentStack:Q.stack})}}finally{P.T=d,W.p=N}}(Bo&3)!==0&&Z0(),Wu(u),N=u.pendingLanes,(x&261930)!==0&&(N&42)!==0?u===tf?Jh++:(Jh=0,tf=u):Jh=0,ob(0)}}function Uc(u,d){(u.pooledCacheLanes&=d)===0&&(d=u.pooledCache,d!=null&&(u.pooledCache=null,Cr(d)))}function Z0(){return as(),tr(),os(),P$()}function P$(){if(ui!==5)return!1;var u=gl,d=zc;zc=0;var x=wh(Bo),w=P.T,N=W.p;try{W.p=32>x?32:x,P.T=null,x=Qh,Qh=null;var R=gl,V=Bo;if(ui=0,po=gl=null,Bo=0,(ts&6)!==0)throw Error(s(331));var Q=ts;if(ts|=4,Zh(R.current),ci(R,R.current,V,x),ts=Q,ob(0,!1),de&&typeof de.onPostCommitFiberRoot=="function")try{de.onPostCommitFiberRoot(ae,R)}catch{}return!0}finally{W.p=N,P.T=w,Uc(u,d)}}function V$(u,d,x){d=ba(x,d),d=sb(u.stateNode,d,2),u=Nc(u,d,2),u!==null&&(li(u,2),Wu(u))}function Ps(u,d,x){if(u.tag===3)V$(u,u,x);else for(;d!==null;){if(d.tag===3){V$(d,u,x);break}else if(d.tag===1){var w=d.stateNode;if(typeof d.type.getDerivedStateFromError=="function"||typeof w.componentDidCatch=="function"&&(Ql===null||!Ql.has(w))){u=ba(x,u),x=ad(2),w=Nc(d,x,2),w!==null&&(Ta(x,w,d,u),li(w,2),Wu(w));break}}d=d.return}}function LN(u,d,x){var w=u.pingCache;if(w===null){w=u.pingCache=new K0;var N=new Set;w.set(d,N)}else N=w.get(d),N===void 0&&(N=new Set,w.set(d,N));N.has(x)||($s=!0,N.add(x),u=jX.bind(null,u,d,x),d.then(u,u))}function jX(u,d,x){var w=u.pingCache;w!==null&&w.delete(d),u.pingedLanes|=u.suspendedLanes&x,u.warmLanes&=~x,ws===u&&(Kn&x)===x&&(Ts===4||Ts===3&&(Kn&62914560)===Kn&&300>G()-Fc?(ts&2)===0&&It(u,0):pl|=x,ho===Kn&&(ho=0)),Wu(u)}function G$(u,d){d===0&&(d=zn()),u=Au(u,d),u!==null&&(li(u,d),Wu(u))}function KX(u){var d=u.memoizedState,x=0;d!==null&&(x=d.retryLane),G$(u,x)}function YX(u,d){var x=0;switch(u.tag){case 31:case 13:var w=u.stateNode,N=u.memoizedState;N!==null&&(x=N.retryLane);break;case 19:w=u.stateNode;break;case 22:w=u.stateNode._retryCache;break;default:throw Error(s(314))}w!==null&&w.delete(d),G$(u,x)}function ZX(u,d){return he(u,d)}var Rw=null,Q0=null,FN=!1,Dw=!1,zN=!1,md=0;function Wu(u){u!==Q0&&u.next===null&&(Q0===null?Rw=Q0=u:Q0=Q0.next=u),Dw=!0,FN||(FN=!0,JX())}function ob(u,d){if(!zN&&Dw){zN=!0;do for(var x=!1,w=Rw;w!==null;){if(u!==0){var N=w.pendingLanes;if(N===0)var R=0;else{var V=w.suspendedLanes,Q=w.pingedLanes;R=(1<<31-ut(42|u)+1)-1,R&=N&~(V&~Q),R=R&201326741?R&201326741|1:R?R|2:0}R!==0&&(x=!0,X$(w,R))}else R=Kn,R=ie(w,w===ws?R:0,w.cancelPendingCommit!==null||w.timeoutHandle!==-1),(R&3)===0||ve(w,R)||(x=!0,X$(w,R));w=w.next}while(x);zN=!1}}function QX(){H$()}function H$(){Dw=FN=!1;var u=0;md!==0&&cj()&&(u=md);for(var d=G(),x=null,w=Rw;w!==null;){var N=w.next,R=W$(w,d);R===0?(w.next=null,x===null?Rw=N:x.next=N,N===null&&(Q0=x)):(x=w,(u!==0||(R&3)!==0)&&(Dw=!0)),w=N}ui!==0&&ui!==5||ob(u),md!==0&&(md=0)}function W$(u,d){for(var x=u.suspendedLanes,w=u.pingedLanes,N=u.expirationTimes,R=u.pendingLanes&-62914561;0<R;){var V=31-ut(R),Q=1<<V,gt=N[V];gt===-1?((Q&x)===0||(Q&w)!==0)&&(N[V]=Je(Q,d)):gt<=d&&(u.expiredLanes|=Q),R&=~Q}if(d=ws,x=Kn,x=ie(u,u===d?x:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),w=u.callbackNode,x===0||u===d&&(an===2||an===9)||u.cancelPendingCommit!==null)return w!==null&&w!==null&&Pe(w),u.callbackNode=null,u.callbackPriority=0;if((x&3)===0||ve(u,x)){if(d=x&-x,d===u.callbackPriority)return d;switch(w!==null&&Pe(w),wh(x)){case 2:case 8:x=te;break;case 32:x=Pt;break;case 268435456:x=we;break;default:x=Pt}return w=q$.bind(null,u),x=he(x,w),u.callbackPriority=d,u.callbackNode=x,d}return w!==null&&w!==null&&Pe(w),u.callbackPriority=2,u.callbackNode=null,2}function q$(u,d){if(ui!==0&&ui!==5)return u.callbackNode=null,u.callbackPriority=0,null;var x=u.callbackNode;if(Z0()&&u.callbackNode!==x)return null;var w=Kn;return w=ie(u,u===ws?w:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),w===0?null:(E(u,w,d),W$(u,G()),u.callbackNode!=null&&u.callbackNode===x?q$.bind(null,u):null)}function X$(u,d){if(Z0())return null;E(u,d,!0)}function JX(){hj(function(){(ts&6)!==0?he(Vt,QX):H$()})}function UN(){if(md===0){var u=Ac;u===0&&(u=ye,ye<<=1,(ye&261888)===0&&(ye=256)),md=u}return md}function j$(u){return u==null||typeof u=="symbol"||typeof u=="boolean"?null:typeof u=="function"?u:Cp(""+u)}function K$(u,d){var x=d.ownerDocument.createElement("input");return x.name=d.name,x.value=d.value,u.id&&x.setAttribute("form",u.id),d.parentNode.insertBefore(x,d),u=new FormData(u),x.parentNode.removeChild(x),u}function tj(u,d,x,w,N){if(d==="submit"&&x&&x.stateNode===N){var R=j$((N[Zi]||null).action),V=w.submitter;V&&(d=(d=V[Zi]||null)?j$(d.formAction):V.getAttribute("formAction"),d!==null&&(R=d,V=null));var Q=new Ip("action","action",null,w,N);u.push({event:Q,listeners:[{instance:null,listener:function(){if(w.defaultPrevented){if(md!==0){var gt=V?K$(N,V):new FormData(N);Qv(x,{pending:!0,data:gt,method:N.method,action:R},null,gt)}}else typeof R=="function"&&(Q.preventDefault(),gt=V?K$(N,V):new FormData(N),Qv(x,{pending:!0,data:gt,method:N.method,action:R},R,gt))},currentTarget:N}]})}}for(var BN=0;BN<m0.length;BN++){var PN=m0[BN],ej=PN.toLowerCase(),nj=PN[0].toUpperCase()+PN.slice(1);Br(ej,"on"+nj)}Br(va,"onAnimationEnd"),Br(dv,"onAnimationIteration"),Br(zl,"onAnimationStart"),Br("dblclick","onDoubleClick"),Br("focusin","onFocus"),Br("focusout","onBlur"),Br(jf,"onTransitionRun"),Br(Tu,"onTransitionStart"),Br(pv,"onTransitionCancel"),Br(p0,"onTransitionEnd"),Dt("onMouseEnter",["mouseout","mouseover"]),Dt("onMouseLeave",["mouseout","mouseover"]),Dt("onPointerEnter",["pointerout","pointerover"]),Dt("onPointerLeave",["pointerout","pointerover"]),Ft("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Ft("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Ft("onBeforeInput",["compositionend","keypress","textInput","paste"]),Ft("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Ft("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Ft("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lb="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),sj=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(lb));function Y$(u,d){d=(d&4)!==0;for(var x=0;x<u.length;x++){var w=u[x],N=w.event;w=w.listeners;t:{var R=void 0;if(d)for(var V=w.length-1;0<=V;V--){var Q=w[V],gt=Q.instance,$t=Q.currentTarget;if(Q=Q.listener,gt!==R&&N.isPropagationStopped())break t;R=Q,N.currentTarget=$t;try{R(N)}catch(ee){Eu(ee)}N.currentTarget=null,R=gt}else for(V=0;V<w.length;V++){if(Q=w[V],gt=Q.instance,$t=Q.currentTarget,Q=Q.listener,gt!==R&&N.isPropagationStopped())break t;R=Q,N.currentTarget=$t;try{R(N)}catch(ee){Eu(ee)}N.currentTarget=null,R=gt}}}}function Zn(u,d){var x=d[Th];x===void 0&&(x=d[Th]=new Set);var w=u+"__bubble";x.has(w)||(Z$(d,u,2,!1),x.add(w))}function VN(u,d,x){var w=0;d&&(w|=4),Z$(x,u,w,d)}var kw="_reactListening"+Math.random().toString(36).slice(2);function GN(u){if(!u[kw]){u[kw]=!0,Et.forEach(function(x){x!=="selectionchange"&&(sj.has(x)||VN(x,!1,u),VN(x,!0,u))});var d=u.nodeType===9?u:u.ownerDocument;d===null||d[kw]||(d[kw]=!0,VN("selectionchange",!1,d))}}function Z$(u,d,x,w){switch(CL(d)){case 2:var N=Rj;break;case 8:N=Dj;break;default:N=iM}x=N.bind(null,d,x,u),N=void 0,!t0||d!=="touchstart"&&d!=="touchmove"&&d!=="wheel"||(N=!0),w?N!==void 0?u.addEventListener(d,x,{capture:!0,passive:N}):u.addEventListener(d,x,!0):N!==void 0?u.addEventListener(d,x,{passive:N}):u.addEventListener(d,x,!1)}function HN(u,d,x,w,N){var R=w;if((d&1)===0&&(d&2)===0&&w!==null)t:for(;;){if(w===null)return;var V=w.tag;if(V===3||V===4){var Q=w.stateNode.containerInfo;if(Q===N)break;if(V===4)for(V=w.return;V!==null;){var gt=V.tag;if((gt===3||gt===4)&&V.stateNode.containerInfo===N)return;V=V.return}for(;Q!==null;){if(V=Ei(Q),V===null)return;if(gt=V.tag,gt===5||gt===6||gt===26||gt===27){w=R=V;continue t}Q=Q.parentNode}}w=w.return}Kx(function(){var $t=R,ee=Qg(x),le=[];t:{var Ut=bc.get(u);if(Ut!==void 0){var jt=Ip,Ye=u;switch(u){case"keypress":if(Rh(x)===0)break t;case"keydown":case"keyup":jt=nv;break;case"focusin":Ye="focus",jt=r0;break;case"focusout":Ye="blur",jt=r0;break;case"beforeblur":case"afterblur":jt=r0;break;case"click":if(x.button===2)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":jt=D_;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":jt=k_;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":jt=xc;break;case va:case dv:case zl:jt=L_;break;case p0:jt=NN;break;case"scroll":case"scrollend":jt=s0;break;case"wheel":jt=xu;break;case"copy":case"cut":case"paste":jt=Zx;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":jt=a0;break;case"toggle":case"beforetoggle":jt=iv}var gn=(d&4)!==0,Ks=!gn&&(u==="scroll"||u==="scrollend"),Mt=gn?Ut!==null?Ut+"Capture":null:Ut;gn=[];for(var St=$t,Ot;St!==null;){var re=St;if(Ot=re.stateNode,re=re.tag,re!==5&&re!==26&&re!==27||Ot===null||Mt===null||(re=Ih(St,Mt),re!=null&&gn.push(cb(St,re,Ot))),Ks)break;St=St.return}0<gn.length&&(Ut=new jt(Ut,Ye,null,x,ee),le.push({event:Ut,listeners:gn}))}}if((d&7)===0){t:{if(Ut=u==="mouseover"||u==="pointerover",jt=u==="mouseout"||u==="pointerout",Ut&&x!==Ap&&(Ye=x.relatedTarget||x.fromElement)&&(Ei(Ye)||Ye[Ka]))break t;if((jt||Ut)&&(Ut=ee.window===ee?ee:(Ut=ee.ownerDocument)?Ut.defaultView||Ut.parentWindow:window,jt?(Ye=x.relatedTarget||x.toElement,jt=$t,Ye=Ye?Ei(Ye):null,Ye!==null&&(Ks=r(Ye),gn=Ye.tag,Ye!==Ks||gn!==5&&gn!==27&&gn!==6)&&(Ye=null)):(jt=null,Ye=$t),jt!==Ye)){if(gn=D_,re="onMouseLeave",Mt="onMouseEnter",St="mouse",(u==="pointerout"||u==="pointerover")&&(gn=a0,re="onPointerLeave",Mt="onPointerEnter",St="pointer"),Ks=jt==null?Ut:il(jt),Ot=Ye==null?Ut:il(Ye),Ut=new gn(re,St+"leave",jt,x,ee),Ut.target=Ks,Ut.relatedTarget=Ot,re=null,Ei(ee)===$t&&(gn=new gn(Mt,St+"enter",Ye,x,ee),gn.target=Ot,gn.relatedTarget=Ks,re=gn),Ks=re,jt&&Ye)e:{for(gn=ij,Mt=jt,St=Ye,Ot=0,re=Mt;re;re=gn(re))Ot++;re=0;for(var hn=St;hn;hn=gn(hn))re++;for(;0<Ot-re;)Mt=gn(Mt),Ot--;for(;0<re-Ot;)St=gn(St),re--;for(;Ot--;){if(Mt===St||St!==null&&Mt===St.alternate){gn=Mt;break e}Mt=gn(Mt),St=gn(St)}gn=null}else gn=null;jt!==null&&Q$(le,Ut,jt,gn,!1),Ye!==null&&Ks!==null&&Q$(le,Ks,Ye,gn,!0)}}t:{if(Ut=$t?il($t):window,jt=Ut.nodeName&&Ut.nodeName.toLowerCase(),jt==="select"||jt==="input"&&Ut.type==="file")var Es=cv;else if(ov(Ut))if(Lp)Es=X_;else{Es=Su;var en=Fp}else jt=Ut.nodeName,!jt||jt.toLowerCase()!=="input"||Ut.type!=="checkbox"&&Ut.type!=="radio"?$t&&Ya($t.elementType)&&(Es=cv):Es=q_;if(Es&&(Es=Es(u,$t))){c0(le,Es,x,ee);break t}en&&en(u,Ut,$t),u==="focusout"&&$t&&Ut.type==="number"&&$t.memoizedProps.value!=null&&ur(Ut,"number",Ut.value)}switch(en=$t?il($t):window,u){case"focusin":(ov(en)||en.contentEditable==="true")&&(Wf=en,f0=$t,qf=null);break;case"focusout":qf=f0=Wf=null;break;case"mousedown":Qa=!0;break;case"contextmenu":case"mouseup":case"dragend":Qa=!1,d0(le,x,ee);break;case"selectionchange":if(j_)break;case"keydown":case"keyup":d0(le,x,ee)}var Bn;if(Dh)t:{switch(u){case"compositionstart":var ns="onCompositionStart";break t;case"compositionend":ns="onCompositionEnd";break t;case"compositionupdate":ns="onCompositionUpdate";break t}ns=void 0}else bu?o0(u,x)&&(ns="onCompositionEnd"):u==="keydown"&&x.keyCode===229&&(ns="onCompositionStart");ns&&(Er&&x.locale!=="ko"&&(bu||ns!=="onCompositionStart"?ns==="onCompositionEnd"&&bu&&(Bn=n0()):(mu=ee,e0="value"in mu?mu.value:mu.textContent,bu=!0)),en=Ow($t,ns),0<en.length&&(ns=new Qx(ns,u,null,x,ee),le.push({event:ns,listeners:en}),Bn?ns.data=Bn:(Bn=Uf(x),Bn!==null&&(ns.data=Bn)))),(Bn=kh?l0(u,x):G_(u,x))&&(ns=Ow($t,"onBeforeInput"),0<ns.length&&(en=new Qx("onBeforeInput","beforeinput",null,x,ee),le.push({event:en,listeners:ns}),en.data=Bn)),tj(le,u,$t,x,ee)}Y$(le,d)})}function cb(u,d,x){return{instance:u,listener:d,currentTarget:x}}function Ow(u,d){for(var x=d+"Capture",w=[];u!==null;){var N=u,R=N.stateNode;if(N=N.tag,N!==5&&N!==26&&N!==27||R===null||(N=Ih(u,x),N!=null&&w.unshift(cb(u,N,R)),N=Ih(u,d),N!=null&&w.push(cb(u,N,R))),u.tag===3)return w;u=u.return}return[]}function ij(u){if(u===null)return null;do u=u.return;while(u&&u.tag!==5&&u.tag!==27);return u||null}function Q$(u,d,x,w,N){for(var R=d._reactName,V=[];x!==null&&x!==w;){var Q=x,gt=Q.alternate,$t=Q.stateNode;if(Q=Q.tag,gt!==null&&gt===w)break;Q!==5&&Q!==26&&Q!==27||$t===null||(gt=$t,N?($t=Ih(x,R),$t!=null&&V.unshift(cb(x,$t,gt))):N||($t=Ih(x,R),$t!=null&&V.push(cb(x,$t,gt)))),x=x.return}V.length!==0&&u.push({event:d,listeners:V})}var rj=/\r\n?/g,aj=/\u0000|\uFFFD/g;function J$(u){return(typeof u=="string"?u:""+u).replace(rj,`
`).replace(aj,"")}function tL(u,d){return d=J$(d),J$(u)===d}function js(u,d,x,w,N,R){switch(x){case"children":typeof w=="string"?d==="body"||d==="textarea"&&w===""||$i(u,w):(typeof w=="number"||typeof w=="bigint")&&d!=="body"&&$i(u,""+w);break;case"className":cn(u,"class",w);break;case"tabIndex":cn(u,"tabindex",w);break;case"dir":case"role":case"viewBox":case"width":case"height":cn(u,x,w);break;case"style":Nh(u,w,R);break;case"data":if(d!=="object"){cn(u,"data",w);break}case"src":case"href":if(w===""&&(d!=="a"||x!=="href")){u.removeAttribute(x);break}if(w==null||typeof w=="function"||typeof w=="symbol"||typeof w=="boolean"){u.removeAttribute(x);break}w=Cp(""+w),u.setAttribute(x,w);break;case"action":case"formAction":if(typeof w=="function"){u.setAttribute(x,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof R=="function"&&(x==="formAction"?(d!=="input"&&js(u,d,"name",N.name,N,null),js(u,d,"formEncType",N.formEncType,N,null),js(u,d,"formMethod",N.formMethod,N,null),js(u,d,"formTarget",N.formTarget,N,null)):(js(u,d,"encType",N.encType,N,null),js(u,d,"method",N.method,N,null),js(u,d,"target",N.target,N,null)));if(w==null||typeof w=="symbol"||typeof w=="boolean"){u.removeAttribute(x);break}w=Cp(""+w),u.setAttribute(x,w);break;case"onClick":w!=null&&(u.onclick=Ll);break;case"onScroll":w!=null&&Zn("scroll",u);break;case"onScrollEnd":w!=null&&Zn("scrollend",u);break;case"dangerouslySetInnerHTML":if(w!=null){if(typeof w!="object"||!("__html"in w))throw Error(s(61));if(x=w.__html,x!=null){if(N.children!=null)throw Error(s(60));u.innerHTML=x}}break;case"multiple":u.multiple=w&&typeof w!="function"&&typeof w!="symbol";break;case"muted":u.muted=w&&typeof w!="function"&&typeof w!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(w==null||typeof w=="function"||typeof w=="boolean"||typeof w=="symbol"){u.removeAttribute("xlink:href");break}x=Cp(""+w),u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",x);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":w!=null&&typeof w!="function"&&typeof w!="symbol"?u.setAttribute(x,""+w):u.removeAttribute(x);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":w&&typeof w!="function"&&typeof w!="symbol"?u.setAttribute(x,""):u.removeAttribute(x);break;case"capture":case"download":w===!0?u.setAttribute(x,""):w!==!1&&w!=null&&typeof w!="function"&&typeof w!="symbol"?u.setAttribute(x,w):u.removeAttribute(x);break;case"cols":case"rows":case"size":case"span":w!=null&&typeof w!="function"&&typeof w!="symbol"&&!isNaN(w)&&1<=w?u.setAttribute(x,w):u.removeAttribute(x);break;case"rowSpan":case"start":w==null||typeof w=="function"||typeof w=="symbol"||isNaN(w)?u.removeAttribute(x):u.setAttribute(x,w);break;case"popover":Zn("beforetoggle",u),Zn("toggle",u),Ke(u,"popover",w);break;case"xlinkActuate":Xe(u,"http://www.w3.org/1999/xlink","xlink:actuate",w);break;case"xlinkArcrole":Xe(u,"http://www.w3.org/1999/xlink","xlink:arcrole",w);break;case"xlinkRole":Xe(u,"http://www.w3.org/1999/xlink","xlink:role",w);break;case"xlinkShow":Xe(u,"http://www.w3.org/1999/xlink","xlink:show",w);break;case"xlinkTitle":Xe(u,"http://www.w3.org/1999/xlink","xlink:title",w);break;case"xlinkType":Xe(u,"http://www.w3.org/1999/xlink","xlink:type",w);break;case"xmlBase":Xe(u,"http://www.w3.org/XML/1998/namespace","xml:base",w);break;case"xmlLang":Xe(u,"http://www.w3.org/XML/1998/namespace","xml:lang",w);break;case"xmlSpace":Xe(u,"http://www.w3.org/XML/1998/namespace","xml:space",w);break;case"is":Ke(u,"is",w);break;case"innerText":case"textContent":break;default:(!(2<x.length)||x[0]!=="o"&&x[0]!=="O"||x[1]!=="n"&&x[1]!=="N")&&(x=I_.get(x)||x,Ke(u,x,w))}}function WN(u,d,x,w,N,R){switch(x){case"style":Nh(u,w,R);break;case"dangerouslySetInnerHTML":if(w!=null){if(typeof w!="object"||!("__html"in w))throw Error(s(61));if(x=w.__html,x!=null){if(N.children!=null)throw Error(s(60));u.innerHTML=x}}break;case"children":typeof w=="string"?$i(u,w):(typeof w=="number"||typeof w=="bigint")&&$i(u,""+w);break;case"onScroll":w!=null&&Zn("scroll",u);break;case"onScrollEnd":w!=null&&Zn("scrollend",u);break;case"onClick":w!=null&&(u.onclick=Ll);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Gt.hasOwnProperty(x))t:{if(x[0]==="o"&&x[1]==="n"&&(N=x.endsWith("Capture"),d=x.slice(2,N?x.length-7:void 0),R=u[Zi]||null,R=R!=null?R[x]:null,typeof R=="function"&&u.removeEventListener(d,R,N),typeof w=="function")){typeof R!="function"&&R!==null&&(x in u?u[x]=null:u.hasAttribute(x)&&u.removeAttribute(x)),u.addEventListener(d,w,N);break t}x in u?u[x]=w:w===!0?u.setAttribute(x,""):Ke(u,x,w)}}}function fa(u,d,x){switch(d){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Zn("error",u),Zn("load",u);var w=!1,N=!1,R;for(R in x)if(x.hasOwnProperty(R)){var V=x[R];if(V!=null)switch(R){case"src":w=!0;break;case"srcSet":N=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,d));default:js(u,d,R,V,x,null)}}N&&js(u,d,"srcSet",x.srcSet,x,null),w&&js(u,d,"src",x.src,x,null);return;case"input":Zn("invalid",u);var Q=R=V=N=null,gt=null,$t=null;for(w in x)if(x.hasOwnProperty(w)){var ee=x[w];if(ee!=null)switch(w){case"name":N=ee;break;case"type":V=ee;break;case"checked":gt=ee;break;case"defaultChecked":$t=ee;break;case"value":R=ee;break;case"defaultValue":Q=ee;break;case"children":case"dangerouslySetInnerHTML":if(ee!=null)throw Error(s(137,d));break;default:js(u,d,w,ee,x,null)}}$l(u,R,Q,gt,$t,V,N,!1);return;case"select":Zn("invalid",u),w=V=R=null;for(N in x)if(x.hasOwnProperty(N)&&(Q=x[N],Q!=null))switch(N){case"value":R=Q;break;case"defaultValue":V=Q;break;case"multiple":w=Q;default:js(u,d,N,Q,x,null)}d=R,x=V,u.multiple=!!w,d!=null?Do(u,!!w,d,!1):x!=null&&Do(u,!!w,x,!0);return;case"textarea":Zn("invalid",u),R=N=w=null;for(V in x)if(x.hasOwnProperty(V)&&(Q=x[V],Q!=null))switch(V){case"value":w=Q;break;case"defaultValue":N=Q;break;case"children":R=Q;break;case"dangerouslySetInnerHTML":if(Q!=null)throw Error(s(91));break;default:js(u,d,V,Q,x,null)}pi(u,w,N,R);return;case"option":for(gt in x)if(x.hasOwnProperty(gt)&&(w=x[gt],w!=null))switch(gt){case"selected":u.selected=w&&typeof w!="function"&&typeof w!="symbol";break;default:js(u,d,gt,w,x,null)}return;case"dialog":Zn("beforetoggle",u),Zn("toggle",u),Zn("cancel",u),Zn("close",u);break;case"iframe":case"object":Zn("load",u);break;case"video":case"audio":for(w=0;w<lb.length;w++)Zn(lb[w],u);break;case"image":Zn("error",u),Zn("load",u);break;case"details":Zn("toggle",u);break;case"embed":case"source":case"link":Zn("error",u),Zn("load",u);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for($t in x)if(x.hasOwnProperty($t)&&(w=x[$t],w!=null))switch($t){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,d));default:js(u,d,$t,w,x,null)}return;default:if(Ya(d)){for(ee in x)x.hasOwnProperty(ee)&&(w=x[ee],w!==void 0&&WN(u,d,ee,w,x,void 0));return}}for(Q in x)x.hasOwnProperty(Q)&&(w=x[Q],w!=null&&js(u,d,Q,w,x,null))}function oj(u,d,x,w){switch(d){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var N=null,R=null,V=null,Q=null,gt=null,$t=null,ee=null;for(jt in x){var le=x[jt];if(x.hasOwnProperty(jt)&&le!=null)switch(jt){case"checked":break;case"value":break;case"defaultValue":gt=le;default:w.hasOwnProperty(jt)||js(u,d,jt,null,w,le)}}for(var Ut in w){var jt=w[Ut];if(le=x[Ut],w.hasOwnProperty(Ut)&&(jt!=null||le!=null))switch(Ut){case"type":R=jt;break;case"name":N=jt;break;case"checked":$t=jt;break;case"defaultChecked":ee=jt;break;case"value":V=jt;break;case"defaultValue":Q=jt;break;case"children":case"dangerouslySetInnerHTML":if(jt!=null)throw Error(s(137,d));break;default:jt!==le&&js(u,d,Ut,jt,w,le)}}cr(u,V,Q,gt,$t,ee,R,N);return;case"select":jt=V=Q=Ut=null;for(R in x)if(gt=x[R],x.hasOwnProperty(R)&&gt!=null)switch(R){case"value":break;case"multiple":jt=gt;default:w.hasOwnProperty(R)||js(u,d,R,null,w,gt)}for(N in w)if(R=w[N],gt=x[N],w.hasOwnProperty(N)&&(R!=null||gt!=null))switch(N){case"value":Ut=R;break;case"defaultValue":Q=R;break;case"multiple":V=R;default:R!==gt&&js(u,d,N,R,w,gt)}d=Q,x=V,w=jt,Ut!=null?Do(u,!!x,Ut,!1):!!w!=!!x&&(d!=null?Do(u,!!x,d,!0):Do(u,!!x,x?[]:"",!1));return;case"textarea":jt=Ut=null;for(Q in x)if(N=x[Q],x.hasOwnProperty(Q)&&N!=null&&!w.hasOwnProperty(Q))switch(Q){case"value":break;case"children":break;default:js(u,d,Q,null,w,N)}for(V in w)if(N=w[V],R=x[V],w.hasOwnProperty(V)&&(N!=null||R!=null))switch(V){case"value":Ut=N;break;case"defaultValue":jt=N;break;case"children":break;case"dangerouslySetInnerHTML":if(N!=null)throw Error(s(91));break;default:N!==R&&js(u,d,V,N,w,R)}Ss(u,Ut,jt);return;case"option":for(var Ye in x)if(Ut=x[Ye],x.hasOwnProperty(Ye)&&Ut!=null&&!w.hasOwnProperty(Ye))switch(Ye){case"selected":u.selected=!1;break;default:js(u,d,Ye,null,w,Ut)}for(gt in w)if(Ut=w[gt],jt=x[gt],w.hasOwnProperty(gt)&&Ut!==jt&&(Ut!=null||jt!=null))switch(gt){case"selected":u.selected=Ut&&typeof Ut!="function"&&typeof Ut!="symbol";break;default:js(u,d,gt,Ut,w,jt)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var gn in x)Ut=x[gn],x.hasOwnProperty(gn)&&Ut!=null&&!w.hasOwnProperty(gn)&&js(u,d,gn,null,w,Ut);for($t in w)if(Ut=w[$t],jt=x[$t],w.hasOwnProperty($t)&&Ut!==jt&&(Ut!=null||jt!=null))switch($t){case"children":case"dangerouslySetInnerHTML":if(Ut!=null)throw Error(s(137,d));break;default:js(u,d,$t,Ut,w,jt)}return;default:if(Ya(d)){for(var Ks in x)Ut=x[Ks],x.hasOwnProperty(Ks)&&Ut!==void 0&&!w.hasOwnProperty(Ks)&&WN(u,d,Ks,void 0,w,Ut);for(ee in w)Ut=w[ee],jt=x[ee],!w.hasOwnProperty(ee)||Ut===jt||Ut===void 0&&jt===void 0||WN(u,d,ee,Ut,w,jt);return}}for(var Mt in x)Ut=x[Mt],x.hasOwnProperty(Mt)&&Ut!=null&&!w.hasOwnProperty(Mt)&&js(u,d,Mt,null,w,Ut);for(le in w)Ut=w[le],jt=x[le],!w.hasOwnProperty(le)||Ut===jt||Ut==null&&jt==null||js(u,d,le,Ut,w,jt)}function eL(u){switch(u){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function lj(){if(typeof performance.getEntriesByType=="function"){for(var u=0,d=0,x=performance.getEntriesByType("resource"),w=0;w<x.length;w++){var N=x[w],R=N.transferSize,V=N.initiatorType,Q=N.duration;if(R&&Q&&eL(V)){for(V=0,Q=N.responseEnd,w+=1;w<x.length;w++){var gt=x[w],$t=gt.startTime;if($t>Q)break;var ee=gt.transferSize,le=gt.initiatorType;ee&&eL(le)&&(gt=gt.responseEnd,V+=ee*(gt<Q?1:(Q-$t)/(gt-$t)))}if(--w,d+=8*(R+V)/(N.duration/1e3),u++,10<u)break}}if(0<u)return d/u/1e6}return navigator.connection&&(u=navigator.connection.downlink,typeof u=="number")?u:5}var qN=null,XN=null;function $w(u){return u.nodeType===9?u:u.ownerDocument}function nL(u){switch(u){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function sL(u,d){if(u===0)switch(d){case"svg":return 1;case"math":return 2;default:return 0}return u===1&&d==="foreignObject"?0:u}function jN(u,d){return u==="textarea"||u==="noscript"||typeof d.children=="string"||typeof d.children=="number"||typeof d.children=="bigint"||typeof d.dangerouslySetInnerHTML=="object"&&d.dangerouslySetInnerHTML!==null&&d.dangerouslySetInnerHTML.__html!=null}var KN=null;function cj(){var u=window.event;return u&&u.type==="popstate"?u===KN?!1:(KN=u,!0):(KN=null,!1)}var iL=typeof setTimeout=="function"?setTimeout:void 0,uj=typeof clearTimeout=="function"?clearTimeout:void 0,rL=typeof Promise=="function"?Promise:void 0,hj=typeof queueMicrotask=="function"?queueMicrotask:typeof rL<"u"?function(u){return rL.resolve(null).then(u).catch(fj)}:iL;function fj(u){setTimeout(function(){throw u})}function gd(u){return u==="head"}function aL(u,d){var x=d,w=0;do{var N=x.nextSibling;if(u.removeChild(x),N&&N.nodeType===8)if(x=N.data,x==="/$"||x==="/&"){if(w===0){u.removeChild(N),ny(d);return}w--}else if(x==="$"||x==="$?"||x==="$~"||x==="$!"||x==="&")w++;else if(x==="html")ub(u.ownerDocument.documentElement);else if(x==="head"){x=u.ownerDocument.head,ub(x);for(var R=x.firstChild;R;){var V=R.nextSibling,Q=R.nodeName;R[yc]||Q==="SCRIPT"||Q==="STYLE"||Q==="LINK"&&R.rel.toLowerCase()==="stylesheet"||x.removeChild(R),R=V}}else x==="body"&&ub(u.ownerDocument.body);x=N}while(x);ny(d)}function oL(u,d){var x=u;u=0;do{var w=x.nextSibling;if(x.nodeType===1?d?(x._stashedDisplay=x.style.display,x.style.display="none"):(x.style.display=x._stashedDisplay||"",x.getAttribute("style")===""&&x.removeAttribute("style")):x.nodeType===3&&(d?(x._stashedText=x.nodeValue,x.nodeValue=""):x.nodeValue=x._stashedText||""),w&&w.nodeType===8)if(x=w.data,x==="/$"){if(u===0)break;u--}else x!=="$"&&x!=="$?"&&x!=="$~"&&x!=="$!"||u++;x=w}while(x)}function YN(u){var d=u.firstChild;for(d&&d.nodeType===10&&(d=d.nextSibling);d;){var x=d;switch(d=d.nextSibling,x.nodeName){case"HTML":case"HEAD":case"BODY":YN(x),Ah(x);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(x.rel.toLowerCase()==="stylesheet")continue}u.removeChild(x)}}function dj(u,d,x,w){for(;u.nodeType===1;){var N=x;if(u.nodeName.toLowerCase()!==d.toLowerCase()){if(!w&&(u.nodeName!=="INPUT"||u.type!=="hidden"))break}else if(w){if(!u[yc])switch(d){case"meta":if(!u.hasAttribute("itemprop"))break;return u;case"link":if(R=u.getAttribute("rel"),R==="stylesheet"&&u.hasAttribute("data-precedence"))break;if(R!==N.rel||u.getAttribute("href")!==(N.href==null||N.href===""?null:N.href)||u.getAttribute("crossorigin")!==(N.crossOrigin==null?null:N.crossOrigin)||u.getAttribute("title")!==(N.title==null?null:N.title))break;return u;case"style":if(u.hasAttribute("data-precedence"))break;return u;case"script":if(R=u.getAttribute("src"),(R!==(N.src==null?null:N.src)||u.getAttribute("type")!==(N.type==null?null:N.type)||u.getAttribute("crossorigin")!==(N.crossOrigin==null?null:N.crossOrigin))&&R&&u.hasAttribute("async")&&!u.hasAttribute("itemprop"))break;return u;default:return u}}else if(d==="input"&&u.type==="hidden"){var R=N.name==null?null:""+N.name;if(N.type==="hidden"&&u.getAttribute("name")===R)return u}else return u;if(u=Jl(u.nextSibling),u===null)break}return null}function pj(u,d,x){if(d==="")return null;for(;u.nodeType!==3;)if((u.nodeType!==1||u.nodeName!=="INPUT"||u.type!=="hidden")&&!x||(u=Jl(u.nextSibling),u===null))return null;return u}function lL(u,d){for(;u.nodeType!==8;)if((u.nodeType!==1||u.nodeName!=="INPUT"||u.type!=="hidden")&&!d||(u=Jl(u.nextSibling),u===null))return null;return u}function ZN(u){return u.data==="$?"||u.data==="$~"}function QN(u){return u.data==="$!"||u.data==="$?"&&u.ownerDocument.readyState!=="loading"}function mj(u,d){var x=u.ownerDocument;if(u.data==="$~")u._reactRetry=d;else if(u.data!=="$?"||x.readyState!=="loading")d();else{var w=function(){d(),x.removeEventListener("DOMContentLoaded",w)};x.addEventListener("DOMContentLoaded",w),u._reactRetry=w}}function Jl(u){for(;u!=null;u=u.nextSibling){var d=u.nodeType;if(d===1||d===3)break;if(d===8){if(d=u.data,d==="$"||d==="$!"||d==="$?"||d==="$~"||d==="&"||d==="F!"||d==="F")break;if(d==="/$"||d==="/&")return null}}return u}var JN=null;function cL(u){u=u.nextSibling;for(var d=0;u;){if(u.nodeType===8){var x=u.data;if(x==="/$"||x==="/&"){if(d===0)return Jl(u.nextSibling);d--}else x!=="$"&&x!=="$!"&&x!=="$?"&&x!=="$~"&&x!=="&"||d++}u=u.nextSibling}return null}function uL(u){u=u.previousSibling;for(var d=0;u;){if(u.nodeType===8){var x=u.data;if(x==="$"||x==="$!"||x==="$?"||x==="$~"||x==="&"){if(d===0)return u;d--}else x!=="/$"&&x!=="/&"||d++}u=u.previousSibling}return null}function hL(u,d,x){switch(d=$w(x),u){case"html":if(u=d.documentElement,!u)throw Error(s(452));return u;case"head":if(u=d.head,!u)throw Error(s(453));return u;case"body":if(u=d.body,!u)throw Error(s(454));return u;default:throw Error(s(451))}}function ub(u){for(var d=u.attributes;d.length;)u.removeAttributeNode(d[0]);Ah(u)}var tc=new Map,fL=new Set;function Lw(u){return typeof u.getRootNode=="function"?u.getRootNode():u.nodeType===9?u:u.ownerDocument}var nf=W.d;W.d={f:gj,r:yj,D:xj,C:vj,L:bj,m:Sj,X:wj,S:_j,M:Tj};function gj(){var u=nf.f(),d=tt();return u||d}function yj(u){var d=Us(u);d!==null&&d.tag===5&&d.type==="form"?Jv(d):nf.r(u)}var J0=typeof document>"u"?null:document;function dL(u,d,x){var w=J0;if(w&&typeof d=="string"&&d){var N=wn(d);N='link[rel="'+u+'"][href="'+N+'"]',typeof x=="string"&&(N+='[crossorigin="'+x+'"]'),fL.has(N)||(fL.add(N),u={rel:u,crossOrigin:x,href:d},w.querySelector(N)===null&&(d=w.createElement("link"),fa(d,"link",u),Z(d),w.head.appendChild(d)))}}function xj(u){nf.D(u),dL("dns-prefetch",u,null)}function vj(u,d){nf.C(u,d),dL("preconnect",u,d)}function bj(u,d,x){nf.L(u,d,x);var w=J0;if(w&&u&&d){var N='link[rel="preload"][as="'+wn(d)+'"]';d==="image"&&x&&x.imageSrcSet?(N+='[imagesrcset="'+wn(x.imageSrcSet)+'"]',typeof x.imageSizes=="string"&&(N+='[imagesizes="'+wn(x.imageSizes)+'"]')):N+='[href="'+wn(u)+'"]';var R=N;switch(d){case"style":R=ty(u);break;case"script":R=ey(u)}tc.has(R)||(u=f({rel:"preload",href:d==="image"&&x&&x.imageSrcSet?void 0:u,as:d},x),tc.set(R,u),w.querySelector(N)!==null||d==="style"&&w.querySelector(hb(R))||d==="script"&&w.querySelector(fb(R))||(d=w.createElement("link"),fa(d,"link",u),Z(d),w.head.appendChild(d)))}}function Sj(u,d){nf.m(u,d);var x=J0;if(x&&u){var w=d&&typeof d.as=="string"?d.as:"script",N='link[rel="modulepreload"][as="'+wn(w)+'"][href="'+wn(u)+'"]',R=N;switch(w){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":R=ey(u)}if(!tc.has(R)&&(u=f({rel:"modulepreload",href:u},d),tc.set(R,u),x.querySelector(N)===null)){switch(w){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(x.querySelector(fb(R)))return}w=x.createElement("link"),fa(w,"link",u),Z(w),x.head.appendChild(w)}}}function _j(u,d,x){nf.S(u,d,x);var w=J0;if(w&&u){var N=rl(w).hoistableStyles,R=ty(u);d=d||"default";var V=N.get(R);if(!V){var Q={loading:0,preload:null};if(V=w.querySelector(hb(R)))Q.loading=5;else{u=f({rel:"stylesheet",href:u,"data-precedence":d},x),(x=tc.get(R))&&tM(u,x);var gt=V=w.createElement("link");Z(gt),fa(gt,"link",u),gt._p=new Promise(function($t,ee){gt.onload=$t,gt.onerror=ee}),gt.addEventListener("load",function(){Q.loading|=1}),gt.addEventListener("error",function(){Q.loading|=2}),Q.loading|=4,Fw(V,d,w)}V={type:"stylesheet",instance:V,count:1,state:Q},N.set(R,V)}}}function wj(u,d){nf.X(u,d);var x=J0;if(x&&u){var w=rl(x).hoistableScripts,N=ey(u),R=w.get(N);R||(R=x.querySelector(fb(N)),R||(u=f({src:u,async:!0},d),(d=tc.get(N))&&eM(u,d),R=x.createElement("script"),Z(R),fa(R,"link",u),x.head.appendChild(R)),R={type:"script",instance:R,count:1,state:null},w.set(N,R))}}function Tj(u,d){nf.M(u,d);var x=J0;if(x&&u){var w=rl(x).hoistableScripts,N=ey(u),R=w.get(N);R||(R=x.querySelector(fb(N)),R||(u=f({src:u,async:!0,type:"module"},d),(d=tc.get(N))&&eM(u,d),R=x.createElement("script"),Z(R),fa(R,"link",u),x.head.appendChild(R)),R={type:"script",instance:R,count:1,state:null},w.set(N,R))}}function pL(u,d,x,w){var N=(N=ft.current)?Lw(N):null;if(!N)throw Error(s(446));switch(u){case"meta":case"title":return null;case"style":return typeof x.precedence=="string"&&typeof x.href=="string"?(d=ty(x.href),x=rl(N).hoistableStyles,w=x.get(d),w||(w={type:"style",instance:null,count:0,state:null},x.set(d,w)),w):{type:"void",instance:null,count:0,state:null};case"link":if(x.rel==="stylesheet"&&typeof x.href=="string"&&typeof x.precedence=="string"){u=ty(x.href);var R=rl(N).hoistableStyles,V=R.get(u);if(V||(N=N.ownerDocument||N,V={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},R.set(u,V),(R=N.querySelector(hb(u)))&&!R._p&&(V.instance=R,V.state.loading=5),tc.has(u)||(x={rel:"preload",as:"style",href:x.href,crossOrigin:x.crossOrigin,integrity:x.integrity,media:x.media,hrefLang:x.hrefLang,referrerPolicy:x.referrerPolicy},tc.set(u,x),R||Ej(N,u,x,V.state))),d&&w===null)throw Error(s(528,""));return V}if(d&&w!==null)throw Error(s(529,""));return null;case"script":return d=x.async,x=x.src,typeof x=="string"&&d&&typeof d!="function"&&typeof d!="symbol"?(d=ey(x),x=rl(N).hoistableScripts,w=x.get(d),w||(w={type:"script",instance:null,count:0,state:null},x.set(d,w)),w):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,u))}}function ty(u){return'href="'+wn(u)+'"'}function hb(u){return'link[rel="stylesheet"]['+u+"]"}function mL(u){return f({},u,{"data-precedence":u.precedence,precedence:null})}function Ej(u,d,x,w){u.querySelector('link[rel="preload"][as="style"]['+d+"]")?w.loading=1:(d=u.createElement("link"),w.preload=d,d.addEventListener("load",function(){return w.loading|=1}),d.addEventListener("error",function(){return w.loading|=2}),fa(d,"link",x),Z(d),u.head.appendChild(d))}function ey(u){return'[src="'+wn(u)+'"]'}function fb(u){return"script[async]"+u}function gL(u,d,x){if(d.count++,d.instance===null)switch(d.type){case"style":var w=u.querySelector('style[data-href~="'+wn(x.href)+'"]');if(w)return d.instance=w,Z(w),w;var N=f({},x,{"data-href":x.href,"data-precedence":x.precedence,href:null,precedence:null});return w=(u.ownerDocument||u).createElement("style"),Z(w),fa(w,"style",N),Fw(w,x.precedence,u),d.instance=w;case"stylesheet":N=ty(x.href);var R=u.querySelector(hb(N));if(R)return d.state.loading|=4,d.instance=R,Z(R),R;w=mL(x),(N=tc.get(N))&&tM(w,N),R=(u.ownerDocument||u).createElement("link"),Z(R);var V=R;return V._p=new Promise(function(Q,gt){V.onload=Q,V.onerror=gt}),fa(R,"link",w),d.state.loading|=4,Fw(R,x.precedence,u),d.instance=R;case"script":return R=ey(x.src),(N=u.querySelector(fb(R)))?(d.instance=N,Z(N),N):(w=x,(N=tc.get(R))&&(w=f({},x),eM(w,N)),u=u.ownerDocument||u,N=u.createElement("script"),Z(N),fa(N,"link",w),u.head.appendChild(N),d.instance=N);case"void":return null;default:throw Error(s(443,d.type))}else d.type==="stylesheet"&&(d.state.loading&4)===0&&(w=d.instance,d.state.loading|=4,Fw(w,x.precedence,u));return d.instance}function Fw(u,d,x){for(var w=x.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),N=w.length?w[w.length-1]:null,R=N,V=0;V<w.length;V++){var Q=w[V];if(Q.dataset.precedence===d)R=Q;else if(R!==N)break}R?R.parentNode.insertBefore(u,R.nextSibling):(d=x.nodeType===9?x.head:x,d.insertBefore(u,d.firstChild))}function tM(u,d){u.crossOrigin==null&&(u.crossOrigin=d.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=d.referrerPolicy),u.title==null&&(u.title=d.title)}function eM(u,d){u.crossOrigin==null&&(u.crossOrigin=d.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=d.referrerPolicy),u.integrity==null&&(u.integrity=d.integrity)}var zw=null;function yL(u,d,x){if(zw===null){var w=new Map,N=zw=new Map;N.set(x,w)}else N=zw,w=N.get(x),w||(w=new Map,N.set(x,w));if(w.has(u))return w;for(w.set(u,null),x=x.getElementsByTagName(u),N=0;N<x.length;N++){var R=x[N];if(!(R[yc]||R[$n]||u==="link"&&R.getAttribute("rel")==="stylesheet")&&R.namespaceURI!=="http://www.w3.org/2000/svg"){var V=R.getAttribute(d)||"";V=u+V;var Q=w.get(V);Q?Q.push(R):w.set(V,[R])}}return w}function xL(u,d,x){u=u.ownerDocument||u,u.head.insertBefore(x,d==="title"?u.querySelector("head > title"):null)}function Cj(u,d,x){if(x===1||d.itemProp!=null)return!1;switch(u){case"meta":case"title":return!0;case"style":if(typeof d.precedence!="string"||typeof d.href!="string"||d.href==="")break;return!0;case"link":if(typeof d.rel!="string"||typeof d.href!="string"||d.href===""||d.onLoad||d.onError)break;switch(d.rel){case"stylesheet":return u=d.disabled,typeof d.precedence=="string"&&u==null;default:return!0}case"script":if(d.async&&typeof d.async!="function"&&typeof d.async!="symbol"&&!d.onLoad&&!d.onError&&d.src&&typeof d.src=="string")return!0}return!1}function vL(u){return!(u.type==="stylesheet"&&(u.state.loading&3)===0)}function Aj(u,d,x,w){if(x.type==="stylesheet"&&(typeof w.media!="string"||matchMedia(w.media).matches!==!1)&&(x.state.loading&4)===0){if(x.instance===null){var N=ty(w.href),R=d.querySelector(hb(N));if(R){d=R._p,d!==null&&typeof d=="object"&&typeof d.then=="function"&&(u.count++,u=Uw.bind(u),d.then(u,u)),x.state.loading|=4,x.instance=R,Z(R);return}R=d.ownerDocument||d,w=mL(w),(N=tc.get(N))&&tM(w,N),R=R.createElement("link"),Z(R);var V=R;V._p=new Promise(function(Q,gt){V.onload=Q,V.onerror=gt}),fa(R,"link",w),x.instance=R}u.stylesheets===null&&(u.stylesheets=new Map),u.stylesheets.set(x,d),(d=x.state.preload)&&(x.state.loading&3)===0&&(u.count++,x=Uw.bind(u),d.addEventListener("load",x),d.addEventListener("error",x))}}var nM=0;function Nj(u,d){return u.stylesheets&&u.count===0&&Pw(u,u.stylesheets),0<u.count||0<u.imgCount?function(x){var w=setTimeout(function(){if(u.stylesheets&&Pw(u,u.stylesheets),u.unsuspend){var R=u.unsuspend;u.unsuspend=null,R()}},6e4+d);0<u.imgBytes&&nM===0&&(nM=62500*lj());var N=setTimeout(function(){if(u.waitingForImages=!1,u.count===0&&(u.stylesheets&&Pw(u,u.stylesheets),u.unsuspend)){var R=u.unsuspend;u.unsuspend=null,R()}},(u.imgBytes>nM?50:800)+d);return u.unsuspend=x,function(){u.unsuspend=null,clearTimeout(w),clearTimeout(N)}}:null}function Uw(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)Pw(this,this.stylesheets);else if(this.unsuspend){var u=this.unsuspend;this.unsuspend=null,u()}}}var Bw=null;function Pw(u,d){u.stylesheets=null,u.unsuspend!==null&&(u.count++,Bw=new Map,d.forEach(Mj,u),Bw=null,Uw.call(u))}function Mj(u,d){if(!(d.state.loading&4)){var x=Bw.get(u);if(x)var w=x.get(null);else{x=new Map,Bw.set(u,x);for(var N=u.querySelectorAll("link[data-precedence],style[data-precedence]"),R=0;R<N.length;R++){var V=N[R];(V.nodeName==="LINK"||V.getAttribute("media")!=="not all")&&(x.set(V.dataset.precedence,V),w=V)}w&&x.set(null,w)}N=d.instance,V=N.getAttribute("data-precedence"),R=x.get(V)||w,R===w&&x.set(null,N),x.set(V,N),this.count++,w=Uw.bind(this),N.addEventListener("load",w),N.addEventListener("error",w),R?R.parentNode.insertBefore(N,R.nextSibling):(u=u.nodeType===9?u.head:u,u.insertBefore(N,u.firstChild)),d.state.loading|=4}}var db={$$typeof:C,Provider:null,Consumer:null,_currentValue:j,_currentValue2:j,_threadCount:0};function Ij(u,d,x,w,N,R,V,Q,gt){this.tag=1,this.containerInfo=u,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Mn(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Mn(0),this.hiddenUpdates=Mn(null),this.identifierPrefix=w,this.onUncaughtError=N,this.onCaughtError=R,this.onRecoverableError=V,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=gt,this.incompleteTransitions=new Map}function bL(u,d,x,w,N,R,V,Q,gt,$t,ee,le){return u=new Ij(u,d,x,V,gt,$t,ee,le,Q),d=1,R===!0&&(d|=24),R=aa(3,null,null,d),u.current=R,R.stateNode=u,d=Sv(),d.refCount++,u.pooledCache=d,d.refCount++,R.memoizedState={element:w,isDehydrated:x,cache:d},Av(R),u}function SL(u){return u?(u=Nu,u):Nu}function _L(u,d,x,w,N,R){N=SL(N),w.context===null?w.context=N:w.pendingContext=N,w=Hl(d),w.payload={element:x},R=R===void 0?null:R,R!==null&&(w.callback=R),x=Nc(u,w,d),x!==null&&(y(x,u,d),Lu(x,u,d))}function wL(u,d){if(u=u.memoizedState,u!==null&&u.dehydrated!==null){var x=u.retryLane;u.retryLane=x!==0&&x<d?x:d}}function sM(u,d){wL(u,d),(u=u.alternate)&&wL(u,d)}function TL(u){if(u.tag===13||u.tag===31){var d=Au(u,67108864);d!==null&&y(d,u,67108864),sM(u,67108864)}}function EL(u){if(u.tag===13||u.tag===31){var d=ha();d=Io(d);var x=Au(u,d);x!==null&&y(x,u,d),sM(u,d)}}var Vw=!0;function Rj(u,d,x,w){var N=P.T;P.T=null;var R=W.p;try{W.p=2,iM(u,d,x,w)}finally{W.p=R,P.T=N}}function Dj(u,d,x,w){var N=P.T;P.T=null;var R=W.p;try{W.p=8,iM(u,d,x,w)}finally{W.p=R,P.T=N}}function iM(u,d,x,w){if(Vw){var N=rM(w);if(N===null)HN(u,d,w,Gw,x),AL(u,w);else if(Oj(N,u,d,x,w))w.stopPropagation();else if(AL(u,w),d&4&&-1<kj.indexOf(u)){for(;N!==null;){var R=Us(N);if(R!==null)switch(R.tag){case 3:if(R=R.stateNode,R.current.memoizedState.isDehydrated){var V=ue(R.pendingLanes);if(V!==0){var Q=R;for(Q.pendingLanes|=2,Q.entangledLanes|=2;V;){var gt=1<<31-ut(V);Q.entanglements[1]|=gt,V&=~gt}Wu(R),(ts&6)===0&&(fo=G()+500,ob(0))}}break;case 31:case 13:Q=Au(R,2),Q!==null&&y(Q,R,2),tt(),sM(R,2)}if(R=rM(w),R===null&&HN(u,d,w,Gw,x),R===N)break;N=R}N!==null&&w.stopPropagation()}else HN(u,d,w,null,x)}}function rM(u){return u=Qg(u),aM(u)}var Gw=null;function aM(u){if(Gw=null,u=Ei(u),u!==null){var d=r(u);if(d===null)u=null;else{var x=d.tag;if(x===13){if(u=a(d),u!==null)return u;u=null}else if(x===31){if(u=o(d),u!==null)return u;u=null}else if(x===3){if(d.stateNode.current.memoizedState.isDehydrated)return d.tag===3?d.stateNode.containerInfo:null;u=null}else d!==u&&(u=null)}}return Gw=u,null}function CL(u){switch(u){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(vt()){case Vt:return 2;case te:return 8;case Pt:case Ue:return 32;case we:return 268435456;default:return 32}default:return 32}}var oM=!1,yd=null,xd=null,vd=null,pb=new Map,mb=new Map,bd=[],kj="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function AL(u,d){switch(u){case"focusin":case"focusout":yd=null;break;case"dragenter":case"dragleave":xd=null;break;case"mouseover":case"mouseout":vd=null;break;case"pointerover":case"pointerout":pb.delete(d.pointerId);break;case"gotpointercapture":case"lostpointercapture":mb.delete(d.pointerId)}}function gb(u,d,x,w,N,R){return u===null||u.nativeEvent!==R?(u={blockedOn:d,domEventName:x,eventSystemFlags:w,nativeEvent:R,targetContainers:[N]},d!==null&&(d=Us(d),d!==null&&TL(d)),u):(u.eventSystemFlags|=w,d=u.targetContainers,N!==null&&d.indexOf(N)===-1&&d.push(N),u)}function Oj(u,d,x,w,N){switch(d){case"focusin":return yd=gb(yd,u,d,x,w,N),!0;case"dragenter":return xd=gb(xd,u,d,x,w,N),!0;case"mouseover":return vd=gb(vd,u,d,x,w,N),!0;case"pointerover":var R=N.pointerId;return pb.set(R,gb(pb.get(R)||null,u,d,x,w,N)),!0;case"gotpointercapture":return R=N.pointerId,mb.set(R,gb(mb.get(R)||null,u,d,x,w,N)),!0}return!1}function NL(u){var d=Ei(u.target);if(d!==null){var x=r(d);if(x!==null){if(d=x.tag,d===13){if(d=a(x),d!==null){u.blockedOn=d,lr(u.priority,function(){EL(x)});return}}else if(d===31){if(d=o(x),d!==null){u.blockedOn=d,lr(u.priority,function(){EL(x)});return}}else if(d===3&&x.stateNode.current.memoizedState.isDehydrated){u.blockedOn=x.tag===3?x.stateNode.containerInfo:null;return}}}u.blockedOn=null}function Hw(u){if(u.blockedOn!==null)return!1;for(var d=u.targetContainers;0<d.length;){var x=rM(u.nativeEvent);if(x===null){x=u.nativeEvent;var w=new x.constructor(x.type,x);Ap=w,x.target.dispatchEvent(w),Ap=null}else return d=Us(x),d!==null&&TL(d),u.blockedOn=x,!1;d.shift()}return!0}function ML(u,d,x){Hw(u)&&x.delete(d)}function $j(){oM=!1,yd!==null&&Hw(yd)&&(yd=null),xd!==null&&Hw(xd)&&(xd=null),vd!==null&&Hw(vd)&&(vd=null),pb.forEach(ML),mb.forEach(ML)}function Ww(u,d){u.blockedOn===d&&(u.blockedOn=null,oM||(oM=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,$j)))}var qw=null;function IL(u){qw!==u&&(qw=u,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){qw===u&&(qw=null);for(var d=0;d<u.length;d+=3){var x=u[d],w=u[d+1],N=u[d+2];if(typeof w!="function"){if(aM(w||x)===null)continue;break}var R=Us(x);R!==null&&(u.splice(d,3),d-=3,Qv(R,{pending:!0,data:N,method:x.method,action:w},w,N))}}))}function ny(u){function d(gt){return Ww(gt,u)}yd!==null&&Ww(yd,u),xd!==null&&Ww(xd,u),vd!==null&&Ww(vd,u),pb.forEach(d),mb.forEach(d);for(var x=0;x<bd.length;x++){var w=bd[x];w.blockedOn===u&&(w.blockedOn=null)}for(;0<bd.length&&(x=bd[0],x.blockedOn===null);)NL(x),x.blockedOn===null&&bd.shift();if(x=(u.ownerDocument||u).$$reactFormReplay,x!=null)for(w=0;w<x.length;w+=3){var N=x[w],R=x[w+1],V=N[Zi]||null;if(typeof R=="function")V||IL(x);else if(V){var Q=null;if(R&&R.hasAttribute("formAction")){if(N=R,V=R[Zi]||null)Q=V.formAction;else if(aM(N)!==null)continue}else Q=V.action;typeof Q=="function"?x[w+1]=Q:(x.splice(w,3),w-=3),IL(x)}}}function RL(){function u(R){R.canIntercept&&R.info==="react-transition"&&R.intercept({handler:function(){return new Promise(function(V){return N=V})},focusReset:"manual",scroll:"manual"})}function d(){N!==null&&(N(),N=null),w||setTimeout(x,20)}function x(){if(!w&&!navigation.transition){var R=navigation.currentEntry;R&&R.url!=null&&navigation.navigate(R.url,{state:R.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var w=!1,N=null;return navigation.addEventListener("navigate",u),navigation.addEventListener("navigatesuccess",d),navigation.addEventListener("navigateerror",d),setTimeout(x,100),function(){w=!0,navigation.removeEventListener("navigate",u),navigation.removeEventListener("navigatesuccess",d),navigation.removeEventListener("navigateerror",d),N!==null&&(N(),N=null)}}}function lM(u){this._internalRoot=u}Xw.prototype.render=lM.prototype.render=function(u){var d=this._internalRoot;if(d===null)throw Error(s(409));var x=d.current,w=ha();_L(x,w,u,d,null,null)},Xw.prototype.unmount=lM.prototype.unmount=function(){var u=this._internalRoot;if(u!==null){this._internalRoot=null;var d=u.containerInfo;_L(u.current,2,null,u,null,null),tt(),d[Ka]=null}};function Xw(u){this._internalRoot=u}Xw.prototype.unstable_scheduleHydration=function(u){if(u){var d=Ro();u={blockedOn:null,target:u,priority:d};for(var x=0;x<bd.length&&d!==0&&d<bd[x].priority;x++);bd.splice(x,0,u),x===0&&NL(u)}};var DL=t.version;if(DL!=="19.2.3")throw Error(s(527,DL,"19.2.3"));W.findDOMNode=function(u){var d=u._reactInternals;if(d===void 0)throw typeof u.render=="function"?Error(s(188)):(u=Object.keys(u).join(","),Error(s(268,u)));return u=c(d),u=u!==null?h(u):null,u=u===null?null:u.stateNode,u};var Lj={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:P,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var jw=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!jw.isDisabled&&jw.supportsFiber)try{ae=jw.inject(Lj),de=jw}catch{}}return xb.createRoot=function(u,d){if(!i(u))throw Error(s(299));var x=!1,w="",N=nb,R=Cw,V=U0;return d!=null&&(d.unstable_strictMode===!0&&(x=!0),d.identifierPrefix!==void 0&&(w=d.identifierPrefix),d.onUncaughtError!==void 0&&(N=d.onUncaughtError),d.onCaughtError!==void 0&&(R=d.onCaughtError),d.onRecoverableError!==void 0&&(V=d.onRecoverableError)),d=bL(u,1,!1,null,null,x,w,null,N,R,V,RL),u[Ka]=d.current,GN(u),new lM(d)},xb.hydrateRoot=function(u,d,x){if(!i(u))throw Error(s(299));var w=!1,N="",R=nb,V=Cw,Q=U0,gt=null;return x!=null&&(x.unstable_strictMode===!0&&(w=!0),x.identifierPrefix!==void 0&&(N=x.identifierPrefix),x.onUncaughtError!==void 0&&(R=x.onUncaughtError),x.onCaughtError!==void 0&&(V=x.onCaughtError),x.onRecoverableError!==void 0&&(Q=x.onRecoverableError),x.formState!==void 0&&(gt=x.formState)),d=bL(u,1,!0,d,x??null,w,N,gt,R,V,Q,RL),d.context=SL(null),x=d.current,w=ha(),w=Io(w),N=Hl(w),N.callback=null,Nc(x,N,w),x=w,d.current.lanes=x,li(d,x),Wu(d),u[Ka]=d.current,GN(u),new Xw(d)},xb.version="19.2.3",xb}var VL;function jj(){if(VL)return hM.exports;VL=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),hM.exports=Xj(),hM.exports}var Kj=jj();const Yj=_x(Kj);var mM={exports:{}},sf={};/**
 * @license React
 * react-reconciler-constants.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var GL;function Zj(){return GL||(GL=1,sf.ConcurrentRoot=1,sf.ContinuousEventPriority=8,sf.DefaultEventPriority=32,sf.DiscreteEventPriority=2,sf.IdleEventPriority=268435456,sf.LegacyRoot=0,sf.NoEventPriority=0),sf}var HL;function Qj(){return HL||(HL=1,mM.exports=Zj()),mM.exports}var sE=Qj();/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const kg="182",Dm={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},km={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},bP=0,YI=1,SP=2,Jj=3,_P=0,Py=1,Zb=2,Vm=3,dh=0,kr=1,Fa=2,da=0,Zm=1,Zy=2,ZI=3,QI=4,wP=5,Dd=100,TP=101,EP=102,CP=103,AP=104,NP=200,MP=201,IP=202,RP=203,wE=204,TE=205,DP=206,kP=207,OP=208,$P=209,LP=210,FP=211,zP=212,UP=213,BP=214,EE=0,h1=1,CE=2,ig=3,AE=4,NE=5,ME=6,IE=7,tS=0,PP=1,VP=2,Tl=0,$D=1,LD=2,FD=3,aC=4,zD=5,UD=6,BD=7,JI="attached",GP="detached",oC=300,ph=301,Xd=302,f1=303,d1=304,wx=306,p1=1e3,Yo=1001,m1=1002,hi=1003,PD=1004,t9=1004,zy=1005,e9=1005,Hs=1006,Qb=1007,n9=1007,th=1008,s9=1008,Gi=1009,VD=1010,GD=1011,Qy=1012,lC=1013,Nl=1014,Ua=1015,ru=1016,cC=1017,uC=1018,rg=1020,HD=35902,WD=35899,qD=1021,XD=1022,Ba=1023,mh=1026,vf=1027,hC=1028,eS=1029,ag=1030,fC=1031,i9=1032,dC=1033,Jb=33776,t1=33777,e1=33778,n1=33779,RE=35840,DE=35841,kE=35842,OE=35843,$E=36196,LE=37492,FE=37496,zE=37488,UE=37489,BE=37490,PE=37491,VE=37808,GE=37809,HE=37810,WE=37811,qE=37812,XE=37813,jE=37814,KE=37815,YE=37816,ZE=37817,QE=37818,JE=37819,t2=37820,e2=37821,n2=36492,s2=36494,i2=36495,r2=36283,a2=36284,o2=36285,l2=36286,HP=2200,WP=2201,qP=2202,g1=2300,c2=2301,iE=2302,Gm=2400,Hm=2401,y1=2402,pC=2500,jD=2501,r9=0,a9=1,o9=2,op=3200,l9=3201,c9=3202,u9=3203,lp=0,XP=1,Yc="",Ms="srgb",gh="srgb-linear",x1="linear",Ls="srgb",h9="",f9="rg",d9="ga",p9=0,Om=7680,m9=7681,g9=7682,y9=7683,x9=34055,v9=34056,b9=5386,S9=512,_9=513,w9=514,T9=515,E9=516,C9=517,A9=518,tR=519,jP=512,KP=513,YP=514,mC=515,ZP=516,QP=517,gC=518,JP=519,v1=35044,N9=35048,M9=35040,I9=35045,R9=35049,D9=35041,k9=35046,O9=35050,$9=35042,L9="100",eR="300 es",Sl=2e3,Jy=2001,F9={COMPUTE:"compute",RENDER:"render"},z9={PERSPECTIVE:"perspective",LINEAR:"linear",FLAT:"flat"},U9={NORMAL:"normal",CENTROID:"centroid",SAMPLE:"sample",FIRST:"first",EITHER:"either"};function t4(n){for(let t=n.length-1;t>=0;--t)if(n[t]>=65535)return!0;return!1}const B9={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Uy(n,t){return new B9[n](t)}function e4(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function b1(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function n4(){const n=b1("canvas");return n.style.display="block",n}const WL={};let jd=null;function P9(n){jd=n}function V9(){return jd}function S1(...n){const t="THREE."+n.shift();jd?jd("log",t,...n):console.log(t,...n)}function Oe(...n){const t="THREE."+n.shift();jd?jd("warn",t,...n):console.warn(t,...n)}function on(...n){const t="THREE."+n.shift();jd?jd("error",t,...n):console.error(t,...n)}function tx(...n){const t=n.join(" ");t in WL||(WL[t]=!0,Oe(...n))}function G9(n,t,e){return new Promise(function(s,i){function r(){switch(n.clientWaitSync(t,n.SYNC_FLUSH_COMMANDS_BIT,0)){case n.WAIT_FAILED:i();break;case n.TIMEOUT_EXPIRED:setTimeout(r,e);break;default:s()}}setTimeout(r,e)})}let Rl=class{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[t]===void 0&&(s[t]=[]),s[t].indexOf(e)===-1&&s[t].push(e)}hasEventListener(t,e){const s=this._listeners;return s===void 0?!1:s[t]!==void 0&&s[t].indexOf(e)!==-1}removeEventListener(t,e){const s=this._listeners;if(s===void 0)return;const i=s[t];if(i!==void 0){const r=i.indexOf(e);r!==-1&&i.splice(r,1)}}dispatchEvent(t){const e=this._listeners;if(e===void 0)return;const s=e[t.type];if(s!==void 0){t.target=this;const i=s.slice(0);for(let r=0,a=i.length;r<a;r++)i[r].call(this,t);t.target=null}}};const Ra=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let qL=1234567;const Qm=Math.PI/180,ex=180/Math.PI;function El(){const n=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(Ra[n&255]+Ra[n>>8&255]+Ra[n>>16&255]+Ra[n>>24&255]+"-"+Ra[t&255]+Ra[t>>8&255]+"-"+Ra[t>>16&15|64]+Ra[t>>24&255]+"-"+Ra[e&63|128]+Ra[e>>8&255]+"-"+Ra[e>>16&255]+Ra[e>>24&255]+Ra[s&255]+Ra[s>>8&255]+Ra[s>>16&255]+Ra[s>>24&255]).toLowerCase()}function Sn(n,t,e){return Math.max(t,Math.min(e,n))}function KD(n,t){return(n%t+t)%t}function H9(n,t,e,s,i){return s+(n-t)*(i-s)/(e-t)}function W9(n,t,e){return n!==t?(e-n)/(t-n):0}function s1(n,t,e){return(1-e)*n+e*t}function q9(n,t,e,s){return s1(n,t,1-Math.exp(-e*s))}function X9(n,t=1){return t-Math.abs(KD(n,t*2)-t)}function j9(n,t,e){return n<=t?0:n>=e?1:(n=(n-t)/(e-t),n*n*(3-2*n))}function K9(n,t,e){return n<=t?0:n>=e?1:(n=(n-t)/(e-t),n*n*n*(n*(n*6-15)+10))}function Y9(n,t){return n+Math.floor(Math.random()*(t-n+1))}function Z9(n,t){return n+Math.random()*(t-n)}function Q9(n){return n*(.5-Math.random())}function J9(n){n!==void 0&&(qL=n);let t=qL+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}function t7(n){return n*Qm}function e7(n){return n*ex}function n7(n){return(n&n-1)===0&&n!==0}function s7(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function i7(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function r7(n,t,e,s,i){const r=Math.cos,a=Math.sin,o=r(e/2),l=a(e/2),c=r((t+s)/2),h=a((t+s)/2),f=r((t-s)/2),p=a((t-s)/2),g=r((s-t)/2),v=a((s-t)/2);switch(i){case"XYX":n.set(o*h,l*f,l*p,o*c);break;case"YZY":n.set(l*p,o*h,l*f,o*c);break;case"ZXZ":n.set(l*f,l*p,o*h,o*c);break;case"XZX":n.set(o*h,l*v,l*g,o*c);break;case"YXY":n.set(l*g,o*h,l*v,o*c);break;case"ZYZ":n.set(l*v,l*g,o*h,o*c);break;default:Oe("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function bo(n,t){switch(t.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function Ln(n,t){switch(t.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}const s4={DEG2RAD:Qm,RAD2DEG:ex,generateUUID:El,clamp:Sn,euclideanModulo:KD,mapLinear:H9,inverseLerp:W9,lerp:s1,damp:q9,pingpong:X9,smoothstep:j9,smootherstep:K9,randInt:Y9,randFloat:Z9,randFloatSpread:Q9,seededRandom:J9,degToRad:t7,radToDeg:e7,isPowerOfTwo:n7,ceilPowerOfTwo:s7,floorPowerOfTwo:i7,setQuaternionFromProperEuler:r7,normalize:Ln,denormalize:bo};class Yt{constructor(t=0,e=0){Yt.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,s=this.y,i=t.elements;return this.x=i[0]*e+i[3]*s+i[6],this.y=i[1]*e+i[4]*s+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Sn(this.x,t.x,e.x),this.y=Sn(this.y,t.y,e.y),this}clampScalar(t,e){return this.x=Sn(this.x,t,e),this.y=Sn(this.y,t,e),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Sn(s,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const s=this.dot(t)/e;return Math.acos(Sn(s,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y;return e*e+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const s=Math.cos(e),i=Math.sin(e),r=this.x-t.x,a=this.y-t.y;return this.x=r*s-a*i+t.x,this.y=r*i+a*s+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Va{constructor(t=0,e=0,s=0,i=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=s,this._w=i}static slerpFlat(t,e,s,i,r,a,o){let l=s[i+0],c=s[i+1],h=s[i+2],f=s[i+3],p=r[a+0],g=r[a+1],v=r[a+2],_=r[a+3];if(o<=0){t[e+0]=l,t[e+1]=c,t[e+2]=h,t[e+3]=f;return}if(o>=1){t[e+0]=p,t[e+1]=g,t[e+2]=v,t[e+3]=_;return}if(f!==_||l!==p||c!==g||h!==v){let S=l*p+c*g+h*v+f*_;S<0&&(p=-p,g=-g,v=-v,_=-_,S=-S);let b=1-o;if(S<.9995){const T=Math.acos(S),C=Math.sin(T);b=Math.sin(b*T)/C,o=Math.sin(o*T)/C,l=l*b+p*o,c=c*b+g*o,h=h*b+v*o,f=f*b+_*o}else{l=l*b+p*o,c=c*b+g*o,h=h*b+v*o,f=f*b+_*o;const T=1/Math.sqrt(l*l+c*c+h*h+f*f);l*=T,c*=T,h*=T,f*=T}}t[e]=l,t[e+1]=c,t[e+2]=h,t[e+3]=f}static multiplyQuaternionsFlat(t,e,s,i,r,a){const o=s[i],l=s[i+1],c=s[i+2],h=s[i+3],f=r[a],p=r[a+1],g=r[a+2],v=r[a+3];return t[e]=o*v+h*f+l*g-c*p,t[e+1]=l*v+h*p+c*f-o*g,t[e+2]=c*v+h*g+o*p-l*f,t[e+3]=h*v-o*f-l*p-c*g,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,s,i){return this._x=t,this._y=e,this._z=s,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const s=t._x,i=t._y,r=t._z,a=t._order,o=Math.cos,l=Math.sin,c=o(s/2),h=o(i/2),f=o(r/2),p=l(s/2),g=l(i/2),v=l(r/2);switch(a){case"XYZ":this._x=p*h*f+c*g*v,this._y=c*g*f-p*h*v,this._z=c*h*v+p*g*f,this._w=c*h*f-p*g*v;break;case"YXZ":this._x=p*h*f+c*g*v,this._y=c*g*f-p*h*v,this._z=c*h*v-p*g*f,this._w=c*h*f+p*g*v;break;case"ZXY":this._x=p*h*f-c*g*v,this._y=c*g*f+p*h*v,this._z=c*h*v+p*g*f,this._w=c*h*f-p*g*v;break;case"ZYX":this._x=p*h*f-c*g*v,this._y=c*g*f+p*h*v,this._z=c*h*v-p*g*f,this._w=c*h*f+p*g*v;break;case"YZX":this._x=p*h*f+c*g*v,this._y=c*g*f+p*h*v,this._z=c*h*v-p*g*f,this._w=c*h*f-p*g*v;break;case"XZY":this._x=p*h*f-c*g*v,this._y=c*g*f-p*h*v,this._z=c*h*v+p*g*f,this._w=c*h*f+p*g*v;break;default:Oe("Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const s=e/2,i=Math.sin(s);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,s=e[0],i=e[4],r=e[8],a=e[1],o=e[5],l=e[9],c=e[2],h=e[6],f=e[10],p=s+o+f;if(p>0){const g=.5/Math.sqrt(p+1);this._w=.25/g,this._x=(h-l)*g,this._y=(r-c)*g,this._z=(a-i)*g}else if(s>o&&s>f){const g=2*Math.sqrt(1+s-o-f);this._w=(h-l)/g,this._x=.25*g,this._y=(i+a)/g,this._z=(r+c)/g}else if(o>f){const g=2*Math.sqrt(1+o-s-f);this._w=(r-c)/g,this._x=(i+a)/g,this._y=.25*g,this._z=(l+h)/g}else{const g=2*Math.sqrt(1+f-s-o);this._w=(a-i)/g,this._x=(r+c)/g,this._y=(l+h)/g,this._z=.25*g}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let s=t.dot(e)+1;return s<1e-8?(s=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=s):(this._x=0,this._y=-t.z,this._z=t.y,this._w=s)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=s),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Sn(this.dot(t),-1,1)))}rotateTowards(t,e){const s=this.angleTo(t);if(s===0)return this;const i=Math.min(1,e/s);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const s=t._x,i=t._y,r=t._z,a=t._w,o=e._x,l=e._y,c=e._z,h=e._w;return this._x=s*h+a*o+i*c-r*l,this._y=i*h+a*l+r*o-s*c,this._z=r*h+a*c+s*l-i*o,this._w=a*h-s*o-i*l-r*c,this._onChangeCallback(),this}slerp(t,e){if(e<=0)return this;if(e>=1)return this.copy(t);let s=t._x,i=t._y,r=t._z,a=t._w,o=this.dot(t);o<0&&(s=-s,i=-i,r=-r,a=-a,o=-o);let l=1-e;if(o<.9995){const c=Math.acos(o),h=Math.sin(c);l=Math.sin(l*c)/h,e=Math.sin(e*c)/h,this._x=this._x*l+s*e,this._y=this._y*l+i*e,this._z=this._z*l+r*e,this._w=this._w*l+a*e,this._onChangeCallback()}else this._x=this._x*l+s*e,this._y=this._y*l+i*e,this._z=this._z*l+r*e,this._w=this._w*l+a*e,this.normalize();return this}slerpQuaternions(t,e,s){return this.copy(t).slerp(e,s)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),s=Math.random(),i=Math.sqrt(1-s),r=Math.sqrt(s);return this.set(i*Math.sin(t),i*Math.cos(t),r*Math.sin(e),r*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class at{constructor(t=0,e=0,s=0){at.prototype.isVector3=!0,this.x=t,this.y=e,this.z=s}set(t,e,s){return s===void 0&&(s=this.z),this.x=t,this.y=e,this.z=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(XL.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(XL.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,s=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*s+r[6]*i,this.y=r[1]*e+r[4]*s+r[7]*i,this.z=r[2]*e+r[5]*s+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,s=this.y,i=this.z,r=t.elements,a=1/(r[3]*e+r[7]*s+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*s+r[8]*i+r[12])*a,this.y=(r[1]*e+r[5]*s+r[9]*i+r[13])*a,this.z=(r[2]*e+r[6]*s+r[10]*i+r[14])*a,this}applyQuaternion(t){const e=this.x,s=this.y,i=this.z,r=t.x,a=t.y,o=t.z,l=t.w,c=2*(a*i-o*s),h=2*(o*e-r*i),f=2*(r*s-a*e);return this.x=e+l*c+a*f-o*h,this.y=s+l*h+o*c-r*f,this.z=i+l*f+r*h-a*c,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,s=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*s+r[8]*i,this.y=r[1]*e+r[5]*s+r[9]*i,this.z=r[2]*e+r[6]*s+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Sn(this.x,t.x,e.x),this.y=Sn(this.y,t.y,e.y),this.z=Sn(this.z,t.z,e.z),this}clampScalar(t,e){return this.x=Sn(this.x,t,e),this.y=Sn(this.y,t,e),this.z=Sn(this.z,t,e),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Sn(s,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this.z=t.z+(e.z-t.z)*s,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const s=t.x,i=t.y,r=t.z,a=e.x,o=e.y,l=e.z;return this.x=i*l-r*o,this.y=r*a-s*l,this.z=s*o-i*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const s=t.dot(this)/e;return this.copy(t).multiplyScalar(s)}projectOnPlane(t){return gM.copy(this).projectOnVector(t),this.sub(gM)}reflect(t){return this.sub(gM.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const s=this.dot(t)/e;return Math.acos(Sn(s,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y,i=this.z-t.z;return e*e+s*s+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,s){const i=Math.sin(e)*t;return this.x=i*Math.sin(s),this.y=Math.cos(e)*t,this.z=i*Math.cos(s),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,s){return this.x=t*Math.sin(e),this.y=s,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),s=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=s,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=Math.random()*2-1,s=Math.sqrt(1-e*e);return this.x=s*Math.cos(t),this.y=e,this.z=s*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const gM=new at,XL=new Va;class On{constructor(t,e,s,i,r,a,o,l,c){On.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,e,s,i,r,a,o,l,c)}set(t,e,s,i,r,a,o,l,c){const h=this.elements;return h[0]=t,h[1]=i,h[2]=o,h[3]=e,h[4]=r,h[5]=l,h[6]=s,h[7]=a,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],this}extractBasis(t,e,s){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,r=this.elements,a=s[0],o=s[3],l=s[6],c=s[1],h=s[4],f=s[7],p=s[2],g=s[5],v=s[8],_=i[0],S=i[3],b=i[6],T=i[1],C=i[4],A=i[7],I=i[2],D=i[5],F=i[8];return r[0]=a*_+o*T+l*I,r[3]=a*S+o*C+l*D,r[6]=a*b+o*A+l*F,r[1]=c*_+h*T+f*I,r[4]=c*S+h*C+f*D,r[7]=c*b+h*A+f*F,r[2]=p*_+g*T+v*I,r[5]=p*S+g*C+v*D,r[8]=p*b+g*A+v*F,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[1],i=t[2],r=t[3],a=t[4],o=t[5],l=t[6],c=t[7],h=t[8];return e*a*h-e*o*c-s*r*h+s*o*l+i*r*c-i*a*l}invert(){const t=this.elements,e=t[0],s=t[1],i=t[2],r=t[3],a=t[4],o=t[5],l=t[6],c=t[7],h=t[8],f=h*a-o*c,p=o*l-h*r,g=c*r-a*l,v=e*f+s*p+i*g;if(v===0)return this.set(0,0,0,0,0,0,0,0,0);const _=1/v;return t[0]=f*_,t[1]=(i*c-h*s)*_,t[2]=(o*s-i*a)*_,t[3]=p*_,t[4]=(h*e-i*l)*_,t[5]=(i*r-o*e)*_,t[6]=g*_,t[7]=(s*l-c*e)*_,t[8]=(a*e-s*r)*_,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,s,i,r,a,o){const l=Math.cos(r),c=Math.sin(r);return this.set(s*l,s*c,-s*(l*a+c*o)+a+t,-i*c,i*l,-i*(-c*a+l*o)+o+e,0,0,1),this}scale(t,e){return this.premultiply(yM.makeScale(t,e)),this}rotate(t){return this.premultiply(yM.makeRotation(-t)),this}translate(t,e){return this.premultiply(yM.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,s,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,s=t.elements;for(let i=0;i<9;i++)if(e[i]!==s[i])return!1;return!0}fromArray(t,e=0){for(let s=0;s<9;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const yM=new On,jL=new On().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),KL=new On().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function a7(){const n={enabled:!0,workingColorSpace:gh,spaces:{},convert:function(i,r,a){return this.enabled===!1||r===a||!r||!a||(this.spaces[r].transfer===Ls&&(i.r=Sf(i.r),i.g=Sf(i.g),i.b=Sf(i.b)),this.spaces[r].primaries!==this.spaces[a].primaries&&(i.applyMatrix3(this.spaces[r].toXYZ),i.applyMatrix3(this.spaces[a].fromXYZ)),this.spaces[a].transfer===Ls&&(i.r=Vy(i.r),i.g=Vy(i.g),i.b=Vy(i.b))),i},workingToColorSpace:function(i,r){return this.convert(i,this.workingColorSpace,r)},colorSpaceToWorking:function(i,r){return this.convert(i,r,this.workingColorSpace)},getPrimaries:function(i){return this.spaces[i].primaries},getTransfer:function(i){return i===Yc?x1:this.spaces[i].transfer},getToneMappingMode:function(i){return this.spaces[i].outputColorSpaceConfig.toneMappingMode||"standard"},getLuminanceCoefficients:function(i,r=this.workingColorSpace){return i.fromArray(this.spaces[r].luminanceCoefficients)},define:function(i){Object.assign(this.spaces,i)},_getMatrix:function(i,r,a){return i.copy(this.spaces[r].toXYZ).multiply(this.spaces[a].fromXYZ)},_getDrawingBufferColorSpace:function(i){return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(i=this.workingColorSpace){return this.spaces[i].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(i,r){return tx("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),n.workingToColorSpace(i,r)},toWorkingColorSpace:function(i,r){return tx("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),n.colorSpaceToWorking(i,r)}},t=[.64,.33,.3,.6,.15,.06],e=[.2126,.7152,.0722],s=[.3127,.329];return n.define({[gh]:{primaries:t,whitePoint:s,transfer:x1,toXYZ:jL,fromXYZ:KL,luminanceCoefficients:e,workingColorSpaceConfig:{unpackColorSpace:Ms},outputColorSpaceConfig:{drawingBufferColorSpace:Ms}},[Ms]:{primaries:t,whitePoint:s,transfer:Ls,toXYZ:jL,fromXYZ:KL,luminanceCoefficients:e,outputColorSpaceConfig:{drawingBufferColorSpace:Ms}}}),n}const ss=a7();function Sf(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function Vy(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let sy;class i4{static getDataURL(t,e="image/png"){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let s;if(t instanceof HTMLCanvasElement)s=t;else{sy===void 0&&(sy=b1("canvas")),sy.width=t.width,sy.height=t.height;const i=sy.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),s=sy}return s.toDataURL(e)}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=b1("canvas");e.width=t.width,e.height=t.height;const s=e.getContext("2d");s.drawImage(t,0,0,t.width,t.height);const i=s.getImageData(0,0,t.width,t.height),r=i.data;for(let a=0;a<r.length;a++)r[a]=Sf(r[a]/255)*255;return s.putImageData(i,0,0),e}else if(t.data){const e=t.data.slice(0);for(let s=0;s<e.length;s++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[s]=Math.floor(Sf(e[s]/255)*255):e[s]=Sf(e[s]);return{data:e,width:t.width,height:t.height}}else return Oe("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let o7=0;class Od{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:o7++}),this.uuid=El(),this.data=t,this.dataReady=!0,this.version=0}getSize(t){const e=this.data;return typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement?t.set(e.videoWidth,e.videoHeight,0):typeof VideoFrame<"u"&&e instanceof VideoFrame?t.set(e.displayHeight,e.displayWidth,0):e!==null?t.set(e.width,e.height,e.depth||0):t.set(0,0,0),t}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const s={uuid:this.uuid,url:""},i=this.data;if(i!==null){let r;if(Array.isArray(i)){r=[];for(let a=0,o=i.length;a<o;a++)i[a].isDataTexture?r.push(xM(i[a].image)):r.push(xM(i[a]))}else r=xM(i);s.url=r}return e||(t.images[this.uuid]=s),s}}function xM(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?i4.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(Oe("Texture: Unable to serialize Texture."),{})}let l7=0;const vM=new at;class wi extends Rl{constructor(t=wi.DEFAULT_IMAGE,e=wi.DEFAULT_MAPPING,s=Yo,i=Yo,r=Hs,a=th,o=Ba,l=Gi,c=wi.DEFAULT_ANISOTROPY,h=Yc){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:l7++}),this.uuid=El(),this.name="",this.source=new Od(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=s,this.wrapT=i,this.magFilter=r,this.minFilter=a,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=l,this.offset=new Yt(0,0),this.repeat=new Yt(1,1),this.center=new Yt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new On,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=h,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(t&&t.depth&&t.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(vM).x}get height(){return this.source.getSize(vM).y}get depth(){return this.source.getSize(vM).z}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.renderTarget=t.renderTarget,this.isRenderTargetTexture=t.isRenderTargetTexture,this.isArrayTexture=t.isArrayTexture,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}setValues(t){for(const e in t){const s=t[e];if(s===void 0){Oe(`Texture.setValues(): parameter '${e}' has value of undefined.`);continue}const i=this[e];if(i===void 0){Oe(`Texture.setValues(): property '${e}' does not exist.`);continue}i&&s&&i.isVector2&&s.isVector2||i&&s&&i.isVector3&&s.isVector3||i&&s&&i.isMatrix3&&s.isMatrix3?i.copy(s):this[e]=s}}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const s={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),e||(t.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==oC)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case p1:t.x=t.x-Math.floor(t.x);break;case Yo:t.x=t.x<0?0:1;break;case m1:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case p1:t.y=t.y-Math.floor(t.y);break;case Yo:t.y=t.y<0?0:1;break;case m1:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){t===!0&&this.pmremVersion++}}wi.DEFAULT_IMAGE=null;wi.DEFAULT_MAPPING=oC;wi.DEFAULT_ANISOTROPY=1;class Gs{constructor(t=0,e=0,s=0,i=1){Gs.prototype.isVector4=!0,this.x=t,this.y=e,this.z=s,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,s,i){return this.x=t,this.y=e,this.z=s,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,s=this.y,i=this.z,r=this.w,a=t.elements;return this.x=a[0]*e+a[4]*s+a[8]*i+a[12]*r,this.y=a[1]*e+a[5]*s+a[9]*i+a[13]*r,this.z=a[2]*e+a[6]*s+a[10]*i+a[14]*r,this.w=a[3]*e+a[7]*s+a[11]*i+a[15]*r,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,s,i,r;const l=t.elements,c=l[0],h=l[4],f=l[8],p=l[1],g=l[5],v=l[9],_=l[2],S=l[6],b=l[10];if(Math.abs(h-p)<.01&&Math.abs(f-_)<.01&&Math.abs(v-S)<.01){if(Math.abs(h+p)<.1&&Math.abs(f+_)<.1&&Math.abs(v+S)<.1&&Math.abs(c+g+b-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const C=(c+1)/2,A=(g+1)/2,I=(b+1)/2,D=(h+p)/4,F=(f+_)/4,z=(v+S)/4;return C>A&&C>I?C<.01?(s=0,i=.707106781,r=.707106781):(s=Math.sqrt(C),i=D/s,r=F/s):A>I?A<.01?(s=.707106781,i=0,r=.707106781):(i=Math.sqrt(A),s=D/i,r=z/i):I<.01?(s=.707106781,i=.707106781,r=0):(r=Math.sqrt(I),s=F/r,i=z/r),this.set(s,i,r,e),this}let T=Math.sqrt((S-v)*(S-v)+(f-_)*(f-_)+(p-h)*(p-h));return Math.abs(T)<.001&&(T=1),this.x=(S-v)/T,this.y=(f-_)/T,this.z=(p-h)/T,this.w=Math.acos((c+g+b-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Sn(this.x,t.x,e.x),this.y=Sn(this.y,t.y,e.y),this.z=Sn(this.z,t.z,e.z),this.w=Sn(this.w,t.w,e.w),this}clampScalar(t,e){return this.x=Sn(this.x,t,e),this.y=Sn(this.y,t,e),this.z=Sn(this.z,t,e),this.w=Sn(this.w,t,e),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Sn(s,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this.z=t.z+(e.z-t.z)*s,this.w=t.w+(e.w-t.w)*s,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class YD extends Rl{constructor(t=1,e=1,s={}){super(),s=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:Hs,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},s),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=s.depth,this.scissor=new Gs(0,0,t,e),this.scissorTest=!1,this.viewport=new Gs(0,0,t,e);const i={width:t,height:e,depth:s.depth},r=new wi(i);this.textures=[];const a=s.count;for(let o=0;o<a;o++)this.textures[o]=r.clone(),this.textures[o].isRenderTargetTexture=!0,this.textures[o].renderTarget=this;this._setTextureOptions(s),this.depthBuffer=s.depthBuffer,this.stencilBuffer=s.stencilBuffer,this.resolveDepthBuffer=s.resolveDepthBuffer,this.resolveStencilBuffer=s.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=s.depthTexture,this.samples=s.samples,this.multiview=s.multiview}_setTextureOptions(t={}){const e={minFilter:Hs,generateMipmaps:!1,flipY:!1,internalFormat:null};t.mapping!==void 0&&(e.mapping=t.mapping),t.wrapS!==void 0&&(e.wrapS=t.wrapS),t.wrapT!==void 0&&(e.wrapT=t.wrapT),t.wrapR!==void 0&&(e.wrapR=t.wrapR),t.magFilter!==void 0&&(e.magFilter=t.magFilter),t.minFilter!==void 0&&(e.minFilter=t.minFilter),t.format!==void 0&&(e.format=t.format),t.type!==void 0&&(e.type=t.type),t.anisotropy!==void 0&&(e.anisotropy=t.anisotropy),t.colorSpace!==void 0&&(e.colorSpace=t.colorSpace),t.flipY!==void 0&&(e.flipY=t.flipY),t.generateMipmaps!==void 0&&(e.generateMipmaps=t.generateMipmaps),t.internalFormat!==void 0&&(e.internalFormat=t.internalFormat);for(let s=0;s<this.textures.length;s++)this.textures[s].setValues(e)}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}set depthTexture(t){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),t!==null&&(t.renderTarget=this),this._depthTexture=t}get depthTexture(){return this._depthTexture}setSize(t,e,s=1){if(this.width!==t||this.height!==e||this.depth!==s){this.width=t,this.height=e,this.depth=s;for(let i=0,r=this.textures.length;i<r;i++)this.textures[i].image.width=t,this.textures[i].image.height=e,this.textures[i].image.depth=s,this.textures[i].isData3DTexture!==!0&&(this.textures[i].isArrayTexture=this.textures[i].image.depth>1);this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let e=0,s=t.textures.length;e<s;e++){this.textures[e]=t.textures[e].clone(),this.textures[e].isRenderTargetTexture=!0,this.textures[e].renderTarget=this;const i=Object.assign({},t.textures[e].image);this.textures[e].source=new Od(i)}return this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class ki extends YD{constructor(t=1,e=1,s={}){super(t,e,s),this.isWebGLRenderTarget=!0}}class yC extends wi{constructor(t=null,e=1,s=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:s,depth:i},this.magFilter=hi,this.minFilter=hi,this.wrapR=Yo,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class c7 extends ki{constructor(t=1,e=1,s=1,i={}){super(t,e,i),this.isWebGLArrayRenderTarget=!0,this.depth=s,this.texture=new yC(null,t,e,s),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class xC extends wi{constructor(t=null,e=1,s=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:s,depth:i},this.magFilter=hi,this.minFilter=hi,this.wrapR=Yo,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class u7 extends ki{constructor(t=1,e=1,s=1,i={}){super(t,e,i),this.isWebGL3DRenderTarget=!0,this.depth=s,this.texture=new xC(null,t,e,s),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class Ga{constructor(t=new at(1/0,1/0,1/0),e=new at(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e+=3)this.expandByPoint(Bc.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,s=t.count;e<s;e++)this.expandByPoint(Bc.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const s=Bc.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(s),this.max.copy(t).add(s),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const s=t.geometry;if(s!==void 0){const r=s.getAttribute("position");if(e===!0&&r!==void 0&&t.isInstancedMesh!==!0)for(let a=0,o=r.count;a<o;a++)t.isMesh===!0?t.getVertexPosition(a,Bc):Bc.fromBufferAttribute(r,a),Bc.applyMatrix4(t.matrixWorld),this.expandByPoint(Bc);else t.boundingBox!==void 0?(t.boundingBox===null&&t.computeBoundingBox(),Kw.copy(t.boundingBox)):(s.boundingBox===null&&s.computeBoundingBox(),Kw.copy(s.boundingBox)),Kw.applyMatrix4(t.matrixWorld),this.union(Kw)}const i=t.children;for(let r=0,a=i.length;r<a;r++)this.expandByObject(i[r],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,Bc),Bc.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,s;return t.normal.x>0?(e=t.normal.x*this.min.x,s=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,s=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,s+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,s+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,s+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,s+=t.normal.z*this.min.z),e<=-t.constant&&s>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(vb),Yw.subVectors(this.max,vb),iy.subVectors(t.a,vb),ry.subVectors(t.b,vb),ay.subVectors(t.c,vb),_d.subVectors(ry,iy),wd.subVectors(ay,ry),mm.subVectors(iy,ay);let e=[0,-_d.z,_d.y,0,-wd.z,wd.y,0,-mm.z,mm.y,_d.z,0,-_d.x,wd.z,0,-wd.x,mm.z,0,-mm.x,-_d.y,_d.x,0,-wd.y,wd.x,0,-mm.y,mm.x,0];return!bM(e,iy,ry,ay,Yw)||(e=[1,0,0,0,1,0,0,0,1],!bM(e,iy,ry,ay,Yw))?!1:(Zw.crossVectors(_d,wd),e=[Zw.x,Zw.y,Zw.z],bM(e,iy,ry,ay,Yw))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,Bc).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize(Bc).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(rf[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),rf[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),rf[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),rf[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),rf[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),rf[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),rf[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),rf[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(rf),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(t){return this.min.fromArray(t.min),this.max.fromArray(t.max),this}}const rf=[new at,new at,new at,new at,new at,new at,new at,new at],Bc=new at,Kw=new Ga,iy=new at,ry=new at,ay=new at,_d=new at,wd=new at,mm=new at,vb=new at,Yw=new at,Zw=new at,gm=new at;function bM(n,t,e,s,i){for(let r=0,a=n.length-3;r<=a;r+=3){gm.fromArray(n,r);const o=i.x*Math.abs(gm.x)+i.y*Math.abs(gm.y)+i.z*Math.abs(gm.z),l=t.dot(gm),c=e.dot(gm),h=s.dot(gm);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>o)return!1}return!0}const h7=new Ga,bb=new at,SM=new at;class pa{constructor(t=new at,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const s=this.center;e!==void 0?s.copy(e):h7.setFromPoints(t).getCenter(s);let i=0;for(let r=0,a=t.length;r<a;r++)i=Math.max(i,s.distanceToSquared(t[r]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const s=this.center.distanceToSquared(t);return e.copy(t),s>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;bb.subVectors(t,this.center);const e=bb.lengthSq();if(e>this.radius*this.radius){const s=Math.sqrt(e),i=(s-this.radius)*.5;this.center.addScaledVector(bb,i/s),this.radius+=i}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(SM.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(bb.copy(t.center).add(SM)),this.expandByPoint(bb.copy(t.center).sub(SM))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(t){return this.radius=t.radius,this.center.fromArray(t.center),this}}const af=new at,_M=new at,Qw=new at,Td=new at,wM=new at,Jw=new at,TM=new at;class Og{constructor(t=new at,e=new at(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,af)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const s=e.dot(this.direction);return s<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,s)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=af.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(af.copy(this.origin).addScaledVector(this.direction,e),af.distanceToSquared(t))}distanceSqToSegment(t,e,s,i){_M.copy(t).add(e).multiplyScalar(.5),Qw.copy(e).sub(t).normalize(),Td.copy(this.origin).sub(_M);const r=t.distanceTo(e)*.5,a=-this.direction.dot(Qw),o=Td.dot(this.direction),l=-Td.dot(Qw),c=Td.lengthSq(),h=Math.abs(1-a*a);let f,p,g,v;if(h>0)if(f=a*l-o,p=a*o-l,v=r*h,f>=0)if(p>=-v)if(p<=v){const _=1/h;f*=_,p*=_,g=f*(f+a*p+2*o)+p*(a*f+p+2*l)+c}else p=r,f=Math.max(0,-(a*p+o)),g=-f*f+p*(p+2*l)+c;else p=-r,f=Math.max(0,-(a*p+o)),g=-f*f+p*(p+2*l)+c;else p<=-v?(f=Math.max(0,-(-a*r+o)),p=f>0?-r:Math.min(Math.max(-r,-l),r),g=-f*f+p*(p+2*l)+c):p<=v?(f=0,p=Math.min(Math.max(-r,-l),r),g=p*(p+2*l)+c):(f=Math.max(0,-(a*r+o)),p=f>0?r:Math.min(Math.max(-r,-l),r),g=-f*f+p*(p+2*l)+c);else p=a>0?-r:r,f=Math.max(0,-(a*p+o)),g=-f*f+p*(p+2*l)+c;return s&&s.copy(this.origin).addScaledVector(this.direction,f),i&&i.copy(_M).addScaledVector(Qw,p),g}intersectSphere(t,e){af.subVectors(t.center,this.origin);const s=af.dot(this.direction),i=af.dot(af)-s*s,r=t.radius*t.radius;if(i>r)return null;const a=Math.sqrt(r-i),o=s-a,l=s+a;return l<0?null:o<0?this.at(l,e):this.at(o,e)}intersectsSphere(t){return t.radius<0?!1:this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(t.normal)+t.constant)/e;return s>=0?s:null}intersectPlane(t,e){const s=this.distanceToPlane(t);return s===null?null:this.at(s,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let s,i,r,a,o,l;const c=1/this.direction.x,h=1/this.direction.y,f=1/this.direction.z,p=this.origin;return c>=0?(s=(t.min.x-p.x)*c,i=(t.max.x-p.x)*c):(s=(t.max.x-p.x)*c,i=(t.min.x-p.x)*c),h>=0?(r=(t.min.y-p.y)*h,a=(t.max.y-p.y)*h):(r=(t.max.y-p.y)*h,a=(t.min.y-p.y)*h),s>a||r>i||((r>s||isNaN(s))&&(s=r),(a<i||isNaN(i))&&(i=a),f>=0?(o=(t.min.z-p.z)*f,l=(t.max.z-p.z)*f):(o=(t.max.z-p.z)*f,l=(t.min.z-p.z)*f),s>l||o>i)||((o>s||s!==s)&&(s=o),(l<i||i!==i)&&(i=l),i<0)?null:this.at(s>=0?s:i,e)}intersectsBox(t){return this.intersectBox(t,af)!==null}intersectTriangle(t,e,s,i,r){wM.subVectors(e,t),Jw.subVectors(s,t),TM.crossVectors(wM,Jw);let a=this.direction.dot(TM),o;if(a>0){if(i)return null;o=1}else if(a<0)o=-1,a=-a;else return null;Td.subVectors(this.origin,t);const l=o*this.direction.dot(Jw.crossVectors(Td,Jw));if(l<0)return null;const c=o*this.direction.dot(wM.cross(Td));if(c<0||l+c>a)return null;const h=-o*Td.dot(TM);return h<0?null:this.at(h/a,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Tn{constructor(t,e,s,i,r,a,o,l,c,h,f,p,g,v,_,S){Tn.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,e,s,i,r,a,o,l,c,h,f,p,g,v,_,S)}set(t,e,s,i,r,a,o,l,c,h,f,p,g,v,_,S){const b=this.elements;return b[0]=t,b[4]=e,b[8]=s,b[12]=i,b[1]=r,b[5]=a,b[9]=o,b[13]=l,b[2]=c,b[6]=h,b[10]=f,b[14]=p,b[3]=g,b[7]=v,b[11]=_,b[15]=S,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Tn().fromArray(this.elements)}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],e[9]=s[9],e[10]=s[10],e[11]=s[11],e[12]=s[12],e[13]=s[13],e[14]=s[14],e[15]=s[15],this}copyPosition(t){const e=this.elements,s=t.elements;return e[12]=s[12],e[13]=s[13],e[14]=s[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,s){return this.determinant()===0?(t.set(1,0,0),e.set(0,1,0),s.set(0,0,1),this):(t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this)}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,0,t.y,e.y,s.y,0,t.z,e.z,s.z,0,0,0,0,1),this}extractRotation(t){if(t.determinant()===0)return this.identity();const e=this.elements,s=t.elements,i=1/oy.setFromMatrixColumn(t,0).length(),r=1/oy.setFromMatrixColumn(t,1).length(),a=1/oy.setFromMatrixColumn(t,2).length();return e[0]=s[0]*i,e[1]=s[1]*i,e[2]=s[2]*i,e[3]=0,e[4]=s[4]*r,e[5]=s[5]*r,e[6]=s[6]*r,e[7]=0,e[8]=s[8]*a,e[9]=s[9]*a,e[10]=s[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,s=t.x,i=t.y,r=t.z,a=Math.cos(s),o=Math.sin(s),l=Math.cos(i),c=Math.sin(i),h=Math.cos(r),f=Math.sin(r);if(t.order==="XYZ"){const p=a*h,g=a*f,v=o*h,_=o*f;e[0]=l*h,e[4]=-l*f,e[8]=c,e[1]=g+v*c,e[5]=p-_*c,e[9]=-o*l,e[2]=_-p*c,e[6]=v+g*c,e[10]=a*l}else if(t.order==="YXZ"){const p=l*h,g=l*f,v=c*h,_=c*f;e[0]=p+_*o,e[4]=v*o-g,e[8]=a*c,e[1]=a*f,e[5]=a*h,e[9]=-o,e[2]=g*o-v,e[6]=_+p*o,e[10]=a*l}else if(t.order==="ZXY"){const p=l*h,g=l*f,v=c*h,_=c*f;e[0]=p-_*o,e[4]=-a*f,e[8]=v+g*o,e[1]=g+v*o,e[5]=a*h,e[9]=_-p*o,e[2]=-a*c,e[6]=o,e[10]=a*l}else if(t.order==="ZYX"){const p=a*h,g=a*f,v=o*h,_=o*f;e[0]=l*h,e[4]=v*c-g,e[8]=p*c+_,e[1]=l*f,e[5]=_*c+p,e[9]=g*c-v,e[2]=-c,e[6]=o*l,e[10]=a*l}else if(t.order==="YZX"){const p=a*l,g=a*c,v=o*l,_=o*c;e[0]=l*h,e[4]=_-p*f,e[8]=v*f+g,e[1]=f,e[5]=a*h,e[9]=-o*h,e[2]=-c*h,e[6]=g*f+v,e[10]=p-_*f}else if(t.order==="XZY"){const p=a*l,g=a*c,v=o*l,_=o*c;e[0]=l*h,e[4]=-f,e[8]=c*h,e[1]=p*f+_,e[5]=a*h,e[9]=g*f-v,e[2]=v*f-g,e[6]=o*h,e[10]=_*f+p}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(f7,t,d7)}lookAt(t,e,s){const i=this.elements;return yl.subVectors(t,e),yl.lengthSq()===0&&(yl.z=1),yl.normalize(),Ed.crossVectors(s,yl),Ed.lengthSq()===0&&(Math.abs(s.z)===1?yl.x+=1e-4:yl.z+=1e-4,yl.normalize(),Ed.crossVectors(s,yl)),Ed.normalize(),tT.crossVectors(yl,Ed),i[0]=Ed.x,i[4]=tT.x,i[8]=yl.x,i[1]=Ed.y,i[5]=tT.y,i[9]=yl.y,i[2]=Ed.z,i[6]=tT.z,i[10]=yl.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,r=this.elements,a=s[0],o=s[4],l=s[8],c=s[12],h=s[1],f=s[5],p=s[9],g=s[13],v=s[2],_=s[6],S=s[10],b=s[14],T=s[3],C=s[7],A=s[11],I=s[15],D=i[0],F=i[4],z=i[8],k=i[12],O=i[1],L=i[5],H=i[9],q=i[13],K=i[2],Y=i[6],P=i[10],W=i[14],j=i[3],st=i[7],ot=i[11],X=i[15];return r[0]=a*D+o*O+l*K+c*j,r[4]=a*F+o*L+l*Y+c*st,r[8]=a*z+o*H+l*P+c*ot,r[12]=a*k+o*q+l*W+c*X,r[1]=h*D+f*O+p*K+g*j,r[5]=h*F+f*L+p*Y+g*st,r[9]=h*z+f*H+p*P+g*ot,r[13]=h*k+f*q+p*W+g*X,r[2]=v*D+_*O+S*K+b*j,r[6]=v*F+_*L+S*Y+b*st,r[10]=v*z+_*H+S*P+b*ot,r[14]=v*k+_*q+S*W+b*X,r[3]=T*D+C*O+A*K+I*j,r[7]=T*F+C*L+A*Y+I*st,r[11]=T*z+C*H+A*P+I*ot,r[15]=T*k+C*q+A*W+I*X,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[4],i=t[8],r=t[12],a=t[1],o=t[5],l=t[9],c=t[13],h=t[2],f=t[6],p=t[10],g=t[14],v=t[3],_=t[7],S=t[11],b=t[15],T=l*g-c*p,C=o*g-c*f,A=o*p-l*f,I=a*g-c*h,D=a*p-l*h,F=a*f-o*h;return e*(_*T-S*C+b*A)-s*(v*T-S*I+b*D)+i*(v*C-_*I+b*F)-r*(v*A-_*D+S*F)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,s){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=s),this}invert(){const t=this.elements,e=t[0],s=t[1],i=t[2],r=t[3],a=t[4],o=t[5],l=t[6],c=t[7],h=t[8],f=t[9],p=t[10],g=t[11],v=t[12],_=t[13],S=t[14],b=t[15],T=f*S*c-_*p*c+_*l*g-o*S*g-f*l*b+o*p*b,C=v*p*c-h*S*c-v*l*g+a*S*g+h*l*b-a*p*b,A=h*_*c-v*f*c+v*o*g-a*_*g-h*o*b+a*f*b,I=v*f*l-h*_*l-v*o*p+a*_*p+h*o*S-a*f*S,D=e*T+s*C+i*A+r*I;if(D===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const F=1/D;return t[0]=T*F,t[1]=(_*p*r-f*S*r-_*i*g+s*S*g+f*i*b-s*p*b)*F,t[2]=(o*S*r-_*l*r+_*i*c-s*S*c-o*i*b+s*l*b)*F,t[3]=(f*l*r-o*p*r-f*i*c+s*p*c+o*i*g-s*l*g)*F,t[4]=C*F,t[5]=(h*S*r-v*p*r+v*i*g-e*S*g-h*i*b+e*p*b)*F,t[6]=(v*l*r-a*S*r-v*i*c+e*S*c+a*i*b-e*l*b)*F,t[7]=(a*p*r-h*l*r+h*i*c-e*p*c-a*i*g+e*l*g)*F,t[8]=A*F,t[9]=(v*f*r-h*_*r-v*s*g+e*_*g+h*s*b-e*f*b)*F,t[10]=(a*_*r-v*o*r+v*s*c-e*_*c-a*s*b+e*o*b)*F,t[11]=(h*o*r-a*f*r-h*s*c+e*f*c+a*s*g-e*o*g)*F,t[12]=I*F,t[13]=(h*_*i-v*f*i+v*s*p-e*_*p-h*s*S+e*f*S)*F,t[14]=(v*o*i-a*_*i-v*s*l+e*_*l+a*s*S-e*o*S)*F,t[15]=(a*f*i-h*o*i+h*s*l-e*f*l-a*s*p+e*o*p)*F,this}scale(t){const e=this.elements,s=t.x,i=t.y,r=t.z;return e[0]*=s,e[4]*=i,e[8]*=r,e[1]*=s,e[5]*=i,e[9]*=r,e[2]*=s,e[6]*=i,e[10]*=r,e[3]*=s,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],s=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,s,i))}makeTranslation(t,e,s){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,s,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),s=Math.sin(t);return this.set(1,0,0,0,0,e,-s,0,0,s,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,0,s,0,0,1,0,0,-s,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,0,s,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const s=Math.cos(e),i=Math.sin(e),r=1-s,a=t.x,o=t.y,l=t.z,c=r*a,h=r*o;return this.set(c*a+s,c*o-i*l,c*l+i*o,0,c*o+i*l,h*o+s,h*l-i*a,0,c*l-i*o,h*l+i*a,r*l*l+s,0,0,0,0,1),this}makeScale(t,e,s){return this.set(t,0,0,0,0,e,0,0,0,0,s,0,0,0,0,1),this}makeShear(t,e,s,i,r,a){return this.set(1,s,r,0,t,1,a,0,e,i,1,0,0,0,0,1),this}compose(t,e,s){const i=this.elements,r=e._x,a=e._y,o=e._z,l=e._w,c=r+r,h=a+a,f=o+o,p=r*c,g=r*h,v=r*f,_=a*h,S=a*f,b=o*f,T=l*c,C=l*h,A=l*f,I=s.x,D=s.y,F=s.z;return i[0]=(1-(_+b))*I,i[1]=(g+A)*I,i[2]=(v-C)*I,i[3]=0,i[4]=(g-A)*D,i[5]=(1-(p+b))*D,i[6]=(S+T)*D,i[7]=0,i[8]=(v+C)*F,i[9]=(S-T)*F,i[10]=(1-(p+_))*F,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,s){const i=this.elements;if(t.x=i[12],t.y=i[13],t.z=i[14],this.determinant()===0)return s.set(1,1,1),e.identity(),this;let r=oy.set(i[0],i[1],i[2]).length();const a=oy.set(i[4],i[5],i[6]).length(),o=oy.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),Pc.copy(this);const c=1/r,h=1/a,f=1/o;return Pc.elements[0]*=c,Pc.elements[1]*=c,Pc.elements[2]*=c,Pc.elements[4]*=h,Pc.elements[5]*=h,Pc.elements[6]*=h,Pc.elements[8]*=f,Pc.elements[9]*=f,Pc.elements[10]*=f,e.setFromRotationMatrix(Pc),s.x=r,s.y=a,s.z=o,this}makePerspective(t,e,s,i,r,a,o=Sl,l=!1){const c=this.elements,h=2*r/(e-t),f=2*r/(s-i),p=(e+t)/(e-t),g=(s+i)/(s-i);let v,_;if(l)v=r/(a-r),_=a*r/(a-r);else if(o===Sl)v=-(a+r)/(a-r),_=-2*a*r/(a-r);else if(o===Jy)v=-a/(a-r),_=-a*r/(a-r);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);return c[0]=h,c[4]=0,c[8]=p,c[12]=0,c[1]=0,c[5]=f,c[9]=g,c[13]=0,c[2]=0,c[6]=0,c[10]=v,c[14]=_,c[3]=0,c[7]=0,c[11]=-1,c[15]=0,this}makeOrthographic(t,e,s,i,r,a,o=Sl,l=!1){const c=this.elements,h=2/(e-t),f=2/(s-i),p=-(e+t)/(e-t),g=-(s+i)/(s-i);let v,_;if(l)v=1/(a-r),_=a/(a-r);else if(o===Sl)v=-2/(a-r),_=-(a+r)/(a-r);else if(o===Jy)v=-1/(a-r),_=-r/(a-r);else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);return c[0]=h,c[4]=0,c[8]=0,c[12]=p,c[1]=0,c[5]=f,c[9]=0,c[13]=g,c[2]=0,c[6]=0,c[10]=v,c[14]=_,c[3]=0,c[7]=0,c[11]=0,c[15]=1,this}equals(t){const e=this.elements,s=t.elements;for(let i=0;i<16;i++)if(e[i]!==s[i])return!1;return!0}fromArray(t,e=0){for(let s=0;s<16;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t[e+9]=s[9],t[e+10]=s[10],t[e+11]=s[11],t[e+12]=s[12],t[e+13]=s[13],t[e+14]=s[14],t[e+15]=s[15],t}}const oy=new at,Pc=new Tn,f7=new at(0,0,0),d7=new at(1,1,1),Ed=new at,tT=new at,yl=new at,YL=new Tn,ZL=new Va;class Ml{constructor(t=0,e=0,s=0,i=Ml.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=s,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,s,i=this._order){return this._x=t,this._y=e,this._z=s,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,s=!0){const i=t.elements,r=i[0],a=i[4],o=i[8],l=i[1],c=i[5],h=i[9],f=i[2],p=i[6],g=i[10];switch(e){case"XYZ":this._y=Math.asin(Sn(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-h,g),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(p,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Sn(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(o,g),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-f,r),this._z=0);break;case"ZXY":this._x=Math.asin(Sn(p,-1,1)),Math.abs(p)<.9999999?(this._y=Math.atan2(-f,g),this._z=Math.atan2(-a,c)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-Sn(f,-1,1)),Math.abs(f)<.9999999?(this._x=Math.atan2(p,g),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-a,c));break;case"YZX":this._z=Math.asin(Sn(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-f,r)):(this._x=0,this._y=Math.atan2(o,g));break;case"XZY":this._z=Math.asin(-Sn(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(p,c),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-h,g),this._y=0);break;default:Oe("Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,s===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,s){return YL.makeRotationFromQuaternion(t),this.setFromRotationMatrix(YL,e,s)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return ZL.setFromEuler(this),this.setFromQuaternion(ZL,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Ml.DEFAULT_ORDER="XYZ";class nx{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let p7=0;const QL=new at,ly=new Va,of=new Tn,eT=new at,Sb=new at,m7=new at,g7=new Va,JL=new at(1,0,0),tF=new at(0,1,0),eF=new at(0,0,1),nF={type:"added"},y7={type:"removed"},cy={type:"childadded",child:null},EM={type:"childremoved",child:null};class ps extends Rl{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:p7++}),this.uuid=El(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=ps.DEFAULT_UP.clone();const t=new at,e=new Ml,s=new Va,i=new at(1,1,1);function r(){s.setFromEuler(e,!1)}function a(){e.setFromQuaternion(s,void 0,!1)}e._onChange(r),s._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Tn},normalMatrix:{value:new On}}),this.matrix=new Tn,this.matrixWorld=new Tn,this.matrixAutoUpdate=ps.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=ps.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new nx,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return ly.setFromAxisAngle(t,e),this.quaternion.multiply(ly),this}rotateOnWorldAxis(t,e){return ly.setFromAxisAngle(t,e),this.quaternion.premultiply(ly),this}rotateX(t){return this.rotateOnAxis(JL,t)}rotateY(t){return this.rotateOnAxis(tF,t)}rotateZ(t){return this.rotateOnAxis(eF,t)}translateOnAxis(t,e){return QL.copy(t).applyQuaternion(this.quaternion),this.position.add(QL.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(JL,t)}translateY(t){return this.translateOnAxis(tF,t)}translateZ(t){return this.translateOnAxis(eF,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(of.copy(this.matrixWorld).invert())}lookAt(t,e,s){t.isVector3?eT.copy(t):eT.set(t,e,s);const i=this.parent;this.updateWorldMatrix(!0,!1),Sb.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?of.lookAt(Sb,eT,this.up):of.lookAt(eT,Sb,this.up),this.quaternion.setFromRotationMatrix(of),i&&(of.extractRotation(i.matrixWorld),ly.setFromRotationMatrix(of),this.quaternion.premultiply(ly.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(on("Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(nF),cy.child=t,this.dispatchEvent(cy),cy.child=null):on("Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(y7),EM.child=t,this.dispatchEvent(EM),EM.child=null),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),of.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),of.multiply(t.parent.matrixWorld)),t.applyMatrix4(of),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(nF),cy.child=t,this.dispatchEvent(cy),cy.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let s=0,i=this.children.length;s<i;s++){const a=this.children[s].getObjectByProperty(t,e);if(a!==void 0)return a}}getObjectsByProperty(t,e,s=[]){this[t]===e&&s.push(this);const i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].getObjectsByProperty(t,e,s);return s}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Sb,t,m7),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Sb,g7,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let s=0,i=e.length;s<i;s++)e[s].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let s=0,i=e.length;s<i;s++)e[s].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let s=0,i=e.length;s<i;s++)e[s].updateMatrixWorld(t)}updateWorldMatrix(t,e){const s=this.parent;if(t===!0&&s!==null&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),e===!0){const i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",s={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.geometryInfo=this._geometryInfo.map(o=>({...o,boundingBox:o.boundingBox?o.boundingBox.toJSON():void 0,boundingSphere:o.boundingSphere?o.boundingSphere.toJSON():void 0})),i.instanceInfo=this._instanceInfo.map(o=>({...o})),i.availableInstanceIds=this._availableInstanceIds.slice(),i.availableGeometryIds=this._availableGeometryIds.slice(),i.nextIndexStart=this._nextIndexStart,i.nextVertexStart=this._nextVertexStart,i.geometryCount=this._geometryCount,i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.matricesTexture=this._matricesTexture.toJSON(t),i.indirectTexture=this._indirectTexture.toJSON(t),this._colorsTexture!==null&&(i.colorsTexture=this._colorsTexture.toJSON(t)),this.boundingSphere!==null&&(i.boundingSphere=this.boundingSphere.toJSON()),this.boundingBox!==null&&(i.boundingBox=this.boundingBox.toJSON()));function r(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(t)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let c=0,h=l.length;c<h;c++){const f=l[c];r(t.shapes,f)}else r(t.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,c=this.material.length;l<c;l++)o.push(r(t.materials,this.material[l]));i.material=o}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];i.animations.push(r(t.animations,l))}}if(e){const o=a(t.geometries),l=a(t.materials),c=a(t.textures),h=a(t.images),f=a(t.shapes),p=a(t.skeletons),g=a(t.animations),v=a(t.nodes);o.length>0&&(s.geometries=o),l.length>0&&(s.materials=l),c.length>0&&(s.textures=c),h.length>0&&(s.images=h),f.length>0&&(s.shapes=f),p.length>0&&(s.skeletons=p),g.length>0&&(s.animations=g),v.length>0&&(s.nodes=v)}return s.object=i,s;function a(o){const l=[];for(const c in o){const h=o[c];delete h.metadata,l.push(h)}return l}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let s=0;s<t.children.length;s++){const i=t.children[s];this.add(i.clone())}return this}}ps.DEFAULT_UP=new at(0,1,0);ps.DEFAULT_MATRIX_AUTO_UPDATE=!0;ps.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Vc=new at,lf=new at,CM=new at,cf=new at,uy=new at,hy=new at,sF=new at,AM=new at,NM=new at,MM=new at,IM=new Gs,RM=new Gs,DM=new Gs;class jo{constructor(t=new at,e=new at,s=new at){this.a=t,this.b=e,this.c=s}static getNormal(t,e,s,i){i.subVectors(s,e),Vc.subVectors(t,e),i.cross(Vc);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,s,i,r){Vc.subVectors(i,e),lf.subVectors(s,e),CM.subVectors(t,e);const a=Vc.dot(Vc),o=Vc.dot(lf),l=Vc.dot(CM),c=lf.dot(lf),h=lf.dot(CM),f=a*c-o*o;if(f===0)return r.set(0,0,0),null;const p=1/f,g=(c*l-o*h)*p,v=(a*h-o*l)*p;return r.set(1-g-v,v,g)}static containsPoint(t,e,s,i){return this.getBarycoord(t,e,s,i,cf)===null?!1:cf.x>=0&&cf.y>=0&&cf.x+cf.y<=1}static getInterpolation(t,e,s,i,r,a,o,l){return this.getBarycoord(t,e,s,i,cf)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(r,cf.x),l.addScaledVector(a,cf.y),l.addScaledVector(o,cf.z),l)}static getInterpolatedAttribute(t,e,s,i,r,a){return IM.setScalar(0),RM.setScalar(0),DM.setScalar(0),IM.fromBufferAttribute(t,e),RM.fromBufferAttribute(t,s),DM.fromBufferAttribute(t,i),a.setScalar(0),a.addScaledVector(IM,r.x),a.addScaledVector(RM,r.y),a.addScaledVector(DM,r.z),a}static isFrontFacing(t,e,s,i){return Vc.subVectors(s,e),lf.subVectors(t,e),Vc.cross(lf).dot(i)<0}set(t,e,s){return this.a.copy(t),this.b.copy(e),this.c.copy(s),this}setFromPointsAndIndices(t,e,s,i){return this.a.copy(t[e]),this.b.copy(t[s]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,s,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,s),this.c.fromBufferAttribute(t,i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Vc.subVectors(this.c,this.b),lf.subVectors(this.a,this.b),Vc.cross(lf).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return jo.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return jo.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,s,i,r){return jo.getInterpolation(t,this.a,this.b,this.c,e,s,i,r)}containsPoint(t){return jo.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return jo.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const s=this.a,i=this.b,r=this.c;let a,o;uy.subVectors(i,s),hy.subVectors(r,s),AM.subVectors(t,s);const l=uy.dot(AM),c=hy.dot(AM);if(l<=0&&c<=0)return e.copy(s);NM.subVectors(t,i);const h=uy.dot(NM),f=hy.dot(NM);if(h>=0&&f<=h)return e.copy(i);const p=l*f-h*c;if(p<=0&&l>=0&&h<=0)return a=l/(l-h),e.copy(s).addScaledVector(uy,a);MM.subVectors(t,r);const g=uy.dot(MM),v=hy.dot(MM);if(v>=0&&g<=v)return e.copy(r);const _=g*c-l*v;if(_<=0&&c>=0&&v<=0)return o=c/(c-v),e.copy(s).addScaledVector(hy,o);const S=h*v-g*f;if(S<=0&&f-h>=0&&g-v>=0)return sF.subVectors(r,i),o=(f-h)/(f-h+(g-v)),e.copy(i).addScaledVector(sF,o);const b=1/(S+_+p);return a=_*b,o=p*b,e.copy(s).addScaledVector(uy,a).addScaledVector(hy,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const r4={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Cd={h:0,s:0,l:0},nT={h:0,s:0,l:0};function kM(n,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?n+(t-n)*6*e:e<1/2?t:e<2/3?n+(t-n)*6*(2/3-e):n}class ke{constructor(t,e,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,s)}set(t,e,s){if(e===void 0&&s===void 0){const i=t;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(t,e,s);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=Ms){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,ss.colorSpaceToWorking(this,e),this}setRGB(t,e,s,i=ss.workingColorSpace){return this.r=t,this.g=e,this.b=s,ss.colorSpaceToWorking(this,i),this}setHSL(t,e,s,i=ss.workingColorSpace){if(t=KD(t,1),e=Sn(e,0,1),s=Sn(s,0,1),e===0)this.r=this.g=this.b=s;else{const r=s<=.5?s*(1+e):s+e-s*e,a=2*s-r;this.r=kM(a,r,t+1/3),this.g=kM(a,r,t),this.b=kM(a,r,t-1/3)}return ss.colorSpaceToWorking(this,i),this}setStyle(t,e=Ms){function s(r){r!==void 0&&parseFloat(r)<1&&Oe("Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(t)){let r;const a=i[1],o=i[2];switch(a){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return s(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,e);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return s(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,e);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return s(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,e);break;default:Oe("Color: Unknown color model "+t)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const r=i[1],a=r.length;if(a===3)return this.setRGB(parseInt(r.charAt(0),16)/15,parseInt(r.charAt(1),16)/15,parseInt(r.charAt(2),16)/15,e);if(a===6)return this.setHex(parseInt(r,16),e);Oe("Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=Ms){const s=r4[t.toLowerCase()];return s!==void 0?this.setHex(s,e):Oe("Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Sf(t.r),this.g=Sf(t.g),this.b=Sf(t.b),this}copyLinearToSRGB(t){return this.r=Vy(t.r),this.g=Vy(t.g),this.b=Vy(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=Ms){return ss.workingToColorSpace(Da.copy(this),t),Math.round(Sn(Da.r*255,0,255))*65536+Math.round(Sn(Da.g*255,0,255))*256+Math.round(Sn(Da.b*255,0,255))}getHexString(t=Ms){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=ss.workingColorSpace){ss.workingToColorSpace(Da.copy(this),e);const s=Da.r,i=Da.g,r=Da.b,a=Math.max(s,i,r),o=Math.min(s,i,r);let l,c;const h=(o+a)/2;if(o===a)l=0,c=0;else{const f=a-o;switch(c=h<=.5?f/(a+o):f/(2-a-o),a){case s:l=(i-r)/f+(i<r?6:0);break;case i:l=(r-s)/f+2;break;case r:l=(s-i)/f+4;break}l/=6}return t.h=l,t.s=c,t.l=h,t}getRGB(t,e=ss.workingColorSpace){return ss.workingToColorSpace(Da.copy(this),e),t.r=Da.r,t.g=Da.g,t.b=Da.b,t}getStyle(t=Ms){ss.workingToColorSpace(Da.copy(this),t);const e=Da.r,s=Da.g,i=Da.b;return t!==Ms?`color(${t} ${e.toFixed(3)} ${s.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(s*255)},${Math.round(i*255)})`}offsetHSL(t,e,s){return this.getHSL(Cd),this.setHSL(Cd.h+t,Cd.s+e,Cd.l+s)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,s){return this.r=t.r+(e.r-t.r)*s,this.g=t.g+(e.g-t.g)*s,this.b=t.b+(e.b-t.b)*s,this}lerpHSL(t,e){this.getHSL(Cd),t.getHSL(nT);const s=s1(Cd.h,nT.h,e),i=s1(Cd.s,nT.s,e),r=s1(Cd.l,nT.l,e);return this.setHSL(s,i,r),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,s=this.g,i=this.b,r=t.elements;return this.r=r[0]*e+r[3]*s+r[6]*i,this.g=r[1]*e+r[4]*s+r[7]*i,this.b=r[2]*e+r[5]*s+r[8]*i,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Da=new ke;ke.NAMES=r4;let x7=0;class Jr extends Rl{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:x7++}),this.uuid=El(),this.name="",this.type="Material",this.blending=Zm,this.side=dh,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=wE,this.blendDst=TE,this.blendEquation=Dd,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new ke(0,0,0),this.blendAlpha=0,this.depthFunc=ig,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=tR,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Om,this.stencilZFail=Om,this.stencilZPass=Om,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const s=t[e];if(s===void 0){Oe(`Material: parameter '${e}' has value of undefined.`);continue}const i=this[e];if(i===void 0){Oe(`Material: '${e}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(s):i&&i.isVector3&&s&&s.isVector3?i.copy(s):this[e]=s}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const s={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.sheenColorMap&&this.sheenColorMap.isTexture&&(s.sheenColorMap=this.sheenColorMap.toJSON(t).uuid),this.sheenRoughnessMap&&this.sheenRoughnessMap.isTexture&&(s.sheenRoughnessMap=this.sheenRoughnessMap.toJSON(t).uuid),this.dispersion!==void 0&&(s.dispersion=this.dispersion),this.iridescence!==void 0&&(s.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(s.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.anisotropy!==void 0&&(s.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(s.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(s.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(t).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(t).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(t).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(t).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(t).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapRotation!==void 0&&(s.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==Zm&&(s.blending=this.blending),this.side!==dh&&(s.side=this.side),this.vertexColors===!0&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.transparent===!0&&(s.transparent=!0),this.blendSrc!==wE&&(s.blendSrc=this.blendSrc),this.blendDst!==TE&&(s.blendDst=this.blendDst),this.blendEquation!==Dd&&(s.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(s.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(s.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(s.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(s.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(s.blendAlpha=this.blendAlpha),this.depthFunc!==ig&&(s.depthFunc=this.depthFunc),this.depthTest===!1&&(s.depthTest=this.depthTest),this.depthWrite===!1&&(s.depthWrite=this.depthWrite),this.colorWrite===!1&&(s.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(s.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==tR&&(s.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(s.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(s.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Om&&(s.stencilFail=this.stencilFail),this.stencilZFail!==Om&&(s.stencilZFail=this.stencilZFail),this.stencilZPass!==Om&&(s.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(s.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaHash===!0&&(s.alphaHash=!0),this.alphaToCoverage===!0&&(s.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=!0),this.forceSinglePass===!0&&(s.forceSinglePass=!0),this.allowOverride===!1&&(s.allowOverride=!1),this.wireframe===!0&&(s.wireframe=!0),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=!0),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),this.fog===!1&&(s.fog=!1),Object.keys(this.userData).length>0&&(s.userData=this.userData);function i(r){const a=[];for(const o in r){const l=r[o];delete l.metadata,a.push(l)}return a}if(e){const r=i(t.textures),a=i(t.images);r.length>0&&(s.textures=r),a.length>0&&(s.images=a)}return s}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let s=null;if(e!==null){const i=e.length;s=new Array(i);for(let r=0;r!==i;++r)s[r]=e[r].clone()}return this.clippingPlanes=s,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.allowOverride=t.allowOverride,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}class cp extends Jr{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new ke(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ml,this.combine=tS,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const gf=v7();function v7(){const n=new ArrayBuffer(4),t=new Float32Array(n),e=new Uint32Array(n),s=new Uint32Array(512),i=new Uint32Array(512);for(let l=0;l<256;++l){const c=l-127;c<-27?(s[l]=0,s[l|256]=32768,i[l]=24,i[l|256]=24):c<-14?(s[l]=1024>>-c-14,s[l|256]=1024>>-c-14|32768,i[l]=-c-1,i[l|256]=-c-1):c<=15?(s[l]=c+15<<10,s[l|256]=c+15<<10|32768,i[l]=13,i[l|256]=13):c<128?(s[l]=31744,s[l|256]=64512,i[l]=24,i[l|256]=24):(s[l]=31744,s[l|256]=64512,i[l]=13,i[l|256]=13)}const r=new Uint32Array(2048),a=new Uint32Array(64),o=new Uint32Array(64);for(let l=1;l<1024;++l){let c=l<<13,h=0;for(;(c&8388608)===0;)c<<=1,h-=8388608;c&=-8388609,h+=947912704,r[l]=c|h}for(let l=1024;l<2048;++l)r[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)a[l]=l<<23;a[31]=1199570944,a[32]=2147483648;for(let l=33;l<63;++l)a[l]=2147483648+(l-32<<23);a[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(o[l]=1024);return{floatView:t,uint32View:e,baseTable:s,shiftTable:i,mantissaTable:r,exponentTable:a,offsetTable:o}}function Ho(n){Math.abs(n)>65504&&Oe("DataUtils.toHalfFloat(): Value out of range."),n=Sn(n,-65504,65504),gf.floatView[0]=n;const t=gf.uint32View[0],e=t>>23&511;return gf.baseTable[e]+((t&8388607)>>gf.shiftTable[e])}function Bb(n){const t=n>>10;return gf.uint32View[0]=gf.mantissaTable[gf.offsetTable[t]+(n&1023)]+gf.exponentTable[t],gf.floatView[0]}class b7{static toHalfFloat(t){return Ho(t)}static fromHalfFloat(t){return Bb(t)}}const gr=new at,sT=new Yt;let S7=0;class Fs{constructor(t,e,s=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:S7++}),this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=s,this.usage=v1,this.updateRanges=[],this.gpuType=Ua,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,s){t*=this.itemSize,s*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[s+i];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,s=this.count;e<s;e++)sT.fromBufferAttribute(this,e),sT.applyMatrix3(t),this.setXY(e,sT.x,sT.y);else if(this.itemSize===3)for(let e=0,s=this.count;e<s;e++)gr.fromBufferAttribute(this,e),gr.applyMatrix3(t),this.setXYZ(e,gr.x,gr.y,gr.z);return this}applyMatrix4(t){for(let e=0,s=this.count;e<s;e++)gr.fromBufferAttribute(this,e),gr.applyMatrix4(t),this.setXYZ(e,gr.x,gr.y,gr.z);return this}applyNormalMatrix(t){for(let e=0,s=this.count;e<s;e++)gr.fromBufferAttribute(this,e),gr.applyNormalMatrix(t),this.setXYZ(e,gr.x,gr.y,gr.z);return this}transformDirection(t){for(let e=0,s=this.count;e<s;e++)gr.fromBufferAttribute(this,e),gr.transformDirection(t),this.setXYZ(e,gr.x,gr.y,gr.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let s=this.array[t*this.itemSize+e];return this.normalized&&(s=bo(s,this.array)),s}setComponent(t,e,s){return this.normalized&&(s=Ln(s,this.array)),this.array[t*this.itemSize+e]=s,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=bo(e,this.array)),e}setX(t,e){return this.normalized&&(e=Ln(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=bo(e,this.array)),e}setY(t,e){return this.normalized&&(e=Ln(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=bo(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Ln(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=bo(e,this.array)),e}setW(t,e){return this.normalized&&(e=Ln(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,s){return t*=this.itemSize,this.normalized&&(e=Ln(e,this.array),s=Ln(s,this.array)),this.array[t+0]=e,this.array[t+1]=s,this}setXYZ(t,e,s,i){return t*=this.itemSize,this.normalized&&(e=Ln(e,this.array),s=Ln(s,this.array),i=Ln(i,this.array)),this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=i,this}setXYZW(t,e,s,i,r){return t*=this.itemSize,this.normalized&&(e=Ln(e,this.array),s=Ln(s,this.array),i=Ln(i,this.array),r=Ln(r,this.array)),this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==v1&&(t.usage=this.usage),t}}class _7 extends Fs{constructor(t,e,s){super(new Int8Array(t),e,s)}}class w7 extends Fs{constructor(t,e,s){super(new Uint8Array(t),e,s)}}class T7 extends Fs{constructor(t,e,s){super(new Uint8ClampedArray(t),e,s)}}class E7 extends Fs{constructor(t,e,s){super(new Int16Array(t),e,s)}}class ZD extends Fs{constructor(t,e,s){super(new Uint16Array(t),e,s)}}class C7 extends Fs{constructor(t,e,s){super(new Int32Array(t),e,s)}}class QD extends Fs{constructor(t,e,s){super(new Uint32Array(t),e,s)}}class A7 extends Fs{constructor(t,e,s){super(new Uint16Array(t),e,s),this.isFloat16BufferAttribute=!0}getX(t){let e=Bb(this.array[t*this.itemSize]);return this.normalized&&(e=bo(e,this.array)),e}setX(t,e){return this.normalized&&(e=Ln(e,this.array)),this.array[t*this.itemSize]=Ho(e),this}getY(t){let e=Bb(this.array[t*this.itemSize+1]);return this.normalized&&(e=bo(e,this.array)),e}setY(t,e){return this.normalized&&(e=Ln(e,this.array)),this.array[t*this.itemSize+1]=Ho(e),this}getZ(t){let e=Bb(this.array[t*this.itemSize+2]);return this.normalized&&(e=bo(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Ln(e,this.array)),this.array[t*this.itemSize+2]=Ho(e),this}getW(t){let e=Bb(this.array[t*this.itemSize+3]);return this.normalized&&(e=bo(e,this.array)),e}setW(t,e){return this.normalized&&(e=Ln(e,this.array)),this.array[t*this.itemSize+3]=Ho(e),this}setXY(t,e,s){return t*=this.itemSize,this.normalized&&(e=Ln(e,this.array),s=Ln(s,this.array)),this.array[t+0]=Ho(e),this.array[t+1]=Ho(s),this}setXYZ(t,e,s,i){return t*=this.itemSize,this.normalized&&(e=Ln(e,this.array),s=Ln(s,this.array),i=Ln(i,this.array)),this.array[t+0]=Ho(e),this.array[t+1]=Ho(s),this.array[t+2]=Ho(i),this}setXYZW(t,e,s,i,r){return t*=this.itemSize,this.normalized&&(e=Ln(e,this.array),s=Ln(s,this.array),i=Ln(i,this.array),r=Ln(r,this.array)),this.array[t+0]=Ho(e),this.array[t+1]=Ho(s),this.array[t+2]=Ho(i),this.array[t+3]=Ho(r),this}}class je extends Fs{constructor(t,e,s){super(new Float32Array(t),e,s)}}let N7=0;const ec=new Tn,OM=new ps,fy=new at,xl=new Ga,_b=new Ga,jr=new at;class Nn extends Rl{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:N7++}),this.uuid=El(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.indirectOffset=0,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(t4(t)?QD:ZD)(t,1):this.index=t,this}setIndirect(t,e=0){return this.indirect=t,this.indirectOffset=e,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,s=0){this.groups.push({start:t,count:e,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const r=new On().getNormalMatrix(t);s.applyNormalMatrix(r),s.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return ec.makeRotationFromQuaternion(t),this.applyMatrix4(ec),this}rotateX(t){return ec.makeRotationX(t),this.applyMatrix4(ec),this}rotateY(t){return ec.makeRotationY(t),this.applyMatrix4(ec),this}rotateZ(t){return ec.makeRotationZ(t),this.applyMatrix4(ec),this}translate(t,e,s){return ec.makeTranslation(t,e,s),this.applyMatrix4(ec),this}scale(t,e,s){return ec.makeScale(t,e,s),this.applyMatrix4(ec),this}lookAt(t){return OM.lookAt(t),OM.updateMatrix(),this.applyMatrix4(OM.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(fy).negate(),this.translate(fy.x,fy.y,fy.z),this}setFromPoints(t){const e=this.getAttribute("position");if(e===void 0){const s=[];for(let i=0,r=t.length;i<r;i++){const a=t[i];s.push(a.x,a.y,a.z||0)}this.setAttribute("position",new je(s,3))}else{const s=Math.min(t.length,e.count);for(let i=0;i<s;i++){const r=t[i];e.setXYZ(i,r.x,r.y,r.z||0)}t.length>e.count&&Oe("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ga);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){on("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new at(-1/0,-1/0,-1/0),new at(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let s=0,i=e.length;s<i;s++){const r=e[s];xl.setFromBufferAttribute(r),this.morphTargetsRelative?(jr.addVectors(this.boundingBox.min,xl.min),this.boundingBox.expandByPoint(jr),jr.addVectors(this.boundingBox.max,xl.max),this.boundingBox.expandByPoint(jr)):(this.boundingBox.expandByPoint(xl.min),this.boundingBox.expandByPoint(xl.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&on('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new pa);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){on("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new at,1/0);return}if(t){const s=this.boundingSphere.center;if(xl.setFromBufferAttribute(t),e)for(let r=0,a=e.length;r<a;r++){const o=e[r];_b.setFromBufferAttribute(o),this.morphTargetsRelative?(jr.addVectors(xl.min,_b.min),xl.expandByPoint(jr),jr.addVectors(xl.max,_b.max),xl.expandByPoint(jr)):(xl.expandByPoint(_b.min),xl.expandByPoint(_b.max))}xl.getCenter(s);let i=0;for(let r=0,a=t.count;r<a;r++)jr.fromBufferAttribute(t,r),i=Math.max(i,s.distanceToSquared(jr));if(e)for(let r=0,a=e.length;r<a;r++){const o=e[r],l=this.morphTargetsRelative;for(let c=0,h=o.count;c<h;c++)jr.fromBufferAttribute(o,c),l&&(fy.fromBufferAttribute(t,c),jr.add(fy)),i=Math.max(i,s.distanceToSquared(jr))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&on('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){on("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=e.position,i=e.normal,r=e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Fs(new Float32Array(4*s.count),4));const a=this.getAttribute("tangent"),o=[],l=[];for(let z=0;z<s.count;z++)o[z]=new at,l[z]=new at;const c=new at,h=new at,f=new at,p=new Yt,g=new Yt,v=new Yt,_=new at,S=new at;function b(z,k,O){c.fromBufferAttribute(s,z),h.fromBufferAttribute(s,k),f.fromBufferAttribute(s,O),p.fromBufferAttribute(r,z),g.fromBufferAttribute(r,k),v.fromBufferAttribute(r,O),h.sub(c),f.sub(c),g.sub(p),v.sub(p);const L=1/(g.x*v.y-v.x*g.y);isFinite(L)&&(_.copy(h).multiplyScalar(v.y).addScaledVector(f,-g.y).multiplyScalar(L),S.copy(f).multiplyScalar(g.x).addScaledVector(h,-v.x).multiplyScalar(L),o[z].add(_),o[k].add(_),o[O].add(_),l[z].add(S),l[k].add(S),l[O].add(S))}let T=this.groups;T.length===0&&(T=[{start:0,count:t.count}]);for(let z=0,k=T.length;z<k;++z){const O=T[z],L=O.start,H=O.count;for(let q=L,K=L+H;q<K;q+=3)b(t.getX(q+0),t.getX(q+1),t.getX(q+2))}const C=new at,A=new at,I=new at,D=new at;function F(z){I.fromBufferAttribute(i,z),D.copy(I);const k=o[z];C.copy(k),C.sub(I.multiplyScalar(I.dot(k))).normalize(),A.crossVectors(D,k);const L=A.dot(l[z])<0?-1:1;a.setXYZW(z,C.x,C.y,C.z,L)}for(let z=0,k=T.length;z<k;++z){const O=T[z],L=O.start,H=O.count;for(let q=L,K=L+H;q<K;q+=3)F(t.getX(q+0)),F(t.getX(q+1)),F(t.getX(q+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new Fs(new Float32Array(e.count*3),3),this.setAttribute("normal",s);else for(let p=0,g=s.count;p<g;p++)s.setXYZ(p,0,0,0);const i=new at,r=new at,a=new at,o=new at,l=new at,c=new at,h=new at,f=new at;if(t)for(let p=0,g=t.count;p<g;p+=3){const v=t.getX(p+0),_=t.getX(p+1),S=t.getX(p+2);i.fromBufferAttribute(e,v),r.fromBufferAttribute(e,_),a.fromBufferAttribute(e,S),h.subVectors(a,r),f.subVectors(i,r),h.cross(f),o.fromBufferAttribute(s,v),l.fromBufferAttribute(s,_),c.fromBufferAttribute(s,S),o.add(h),l.add(h),c.add(h),s.setXYZ(v,o.x,o.y,o.z),s.setXYZ(_,l.x,l.y,l.z),s.setXYZ(S,c.x,c.y,c.z)}else for(let p=0,g=e.count;p<g;p+=3)i.fromBufferAttribute(e,p+0),r.fromBufferAttribute(e,p+1),a.fromBufferAttribute(e,p+2),h.subVectors(a,r),f.subVectors(i,r),h.cross(f),s.setXYZ(p+0,h.x,h.y,h.z),s.setXYZ(p+1,h.x,h.y,h.z),s.setXYZ(p+2,h.x,h.y,h.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,s=t.count;e<s;e++)jr.fromBufferAttribute(t,e),jr.normalize(),t.setXYZ(e,jr.x,jr.y,jr.z)}toNonIndexed(){function t(o,l){const c=o.array,h=o.itemSize,f=o.normalized,p=new c.constructor(l.length*h);let g=0,v=0;for(let _=0,S=l.length;_<S;_++){o.isInterleavedBufferAttribute?g=l[_]*o.data.stride+o.offset:g=l[_]*h;for(let b=0;b<h;b++)p[v++]=c[g++]}return new Fs(p,h,f)}if(this.index===null)return Oe("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Nn,s=this.index.array,i=this.attributes;for(const o in i){const l=i[o],c=t(l,s);e.setAttribute(o,c)}const r=this.morphAttributes;for(const o in r){const l=[],c=r[o];for(let h=0,f=c.length;h<f;h++){const p=c[h],g=t(p,s);l.push(g)}e.morphAttributes[o]=l}e.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,l=a.length;o<l;o++){const c=a[o];e.addGroup(c.start,c.count,c.materialIndex)}return e}toJSON(){const t={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(t[c]=l[c]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const s=this.attributes;for(const l in s){const c=s[l];t.data.attributes[l]=c.toJSON(t.data)}const i={};let r=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],h=[];for(let f=0,p=c.length;f<p;f++){const g=c[f];h.push(g.toJSON(t.data))}h.length>0&&(i[l]=h,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(t.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(t.data.boundingSphere=o.toJSON()),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const s=t.index;s!==null&&this.setIndex(s.clone());const i=t.attributes;for(const c in i){const h=i[c];this.setAttribute(c,h.clone(e))}const r=t.morphAttributes;for(const c in r){const h=[],f=r[c];for(let p=0,g=f.length;p<g;p++)h.push(f[p].clone(e));this.morphAttributes[c]=h}this.morphTargetsRelative=t.morphTargetsRelative;const a=t.groups;for(let c=0,h=a.length;c<h;c++){const f=a[c];this.addGroup(f.start,f.count,f.materialIndex)}const o=t.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=t.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const iF=new Tn,ym=new Og,iT=new pa,rF=new at,rT=new at,aT=new at,oT=new at,$M=new at,lT=new at,aF=new at,cT=new at;class rr extends ps{constructor(t=new Nn,e=new cp){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,s=Object.keys(e);if(s.length>0){const i=e[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}getVertexPosition(t,e){const s=this.geometry,i=s.attributes.position,r=s.morphAttributes.position,a=s.morphTargetsRelative;e.fromBufferAttribute(i,t);const o=this.morphTargetInfluences;if(r&&o){lT.set(0,0,0);for(let l=0,c=r.length;l<c;l++){const h=o[l],f=r[l];h!==0&&($M.fromBufferAttribute(f,t),a?lT.addScaledVector($M,h):lT.addScaledVector($M.sub(e),h))}e.add(lT)}return e}raycast(t,e){const s=this.geometry,i=this.material,r=this.matrixWorld;i!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),iT.copy(s.boundingSphere),iT.applyMatrix4(r),ym.copy(t.ray).recast(t.near),!(iT.containsPoint(ym.origin)===!1&&(ym.intersectSphere(iT,rF)===null||ym.origin.distanceToSquared(rF)>(t.far-t.near)**2))&&(iF.copy(r).invert(),ym.copy(t.ray).applyMatrix4(iF),!(s.boundingBox!==null&&ym.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(t,e,ym)))}_computeIntersections(t,e,s){let i;const r=this.geometry,a=this.material,o=r.index,l=r.attributes.position,c=r.attributes.uv,h=r.attributes.uv1,f=r.attributes.normal,p=r.groups,g=r.drawRange;if(o!==null)if(Array.isArray(a))for(let v=0,_=p.length;v<_;v++){const S=p[v],b=a[S.materialIndex],T=Math.max(S.start,g.start),C=Math.min(o.count,Math.min(S.start+S.count,g.start+g.count));for(let A=T,I=C;A<I;A+=3){const D=o.getX(A),F=o.getX(A+1),z=o.getX(A+2);i=uT(this,b,t,s,c,h,f,D,F,z),i&&(i.faceIndex=Math.floor(A/3),i.face.materialIndex=S.materialIndex,e.push(i))}}else{const v=Math.max(0,g.start),_=Math.min(o.count,g.start+g.count);for(let S=v,b=_;S<b;S+=3){const T=o.getX(S),C=o.getX(S+1),A=o.getX(S+2);i=uT(this,a,t,s,c,h,f,T,C,A),i&&(i.faceIndex=Math.floor(S/3),e.push(i))}}else if(l!==void 0)if(Array.isArray(a))for(let v=0,_=p.length;v<_;v++){const S=p[v],b=a[S.materialIndex],T=Math.max(S.start,g.start),C=Math.min(l.count,Math.min(S.start+S.count,g.start+g.count));for(let A=T,I=C;A<I;A+=3){const D=A,F=A+1,z=A+2;i=uT(this,b,t,s,c,h,f,D,F,z),i&&(i.faceIndex=Math.floor(A/3),i.face.materialIndex=S.materialIndex,e.push(i))}}else{const v=Math.max(0,g.start),_=Math.min(l.count,g.start+g.count);for(let S=v,b=_;S<b;S+=3){const T=S,C=S+1,A=S+2;i=uT(this,a,t,s,c,h,f,T,C,A),i&&(i.faceIndex=Math.floor(S/3),e.push(i))}}}}function M7(n,t,e,s,i,r,a,o){let l;if(t.side===kr?l=s.intersectTriangle(a,r,i,!0,o):l=s.intersectTriangle(i,r,a,t.side===dh,o),l===null)return null;cT.copy(o),cT.applyMatrix4(n.matrixWorld);const c=e.ray.origin.distanceTo(cT);return c<e.near||c>e.far?null:{distance:c,point:cT.clone(),object:n}}function uT(n,t,e,s,i,r,a,o,l,c){n.getVertexPosition(o,rT),n.getVertexPosition(l,aT),n.getVertexPosition(c,oT);const h=M7(n,t,e,s,rT,aT,oT,aF);if(h){const f=new at;jo.getBarycoord(aF,rT,aT,oT,f),i&&(h.uv=jo.getInterpolatedAttribute(i,o,l,c,f,new Yt)),r&&(h.uv1=jo.getInterpolatedAttribute(r,o,l,c,f,new Yt)),a&&(h.normal=jo.getInterpolatedAttribute(a,o,l,c,f,new at),h.normal.dot(s.direction)>0&&h.normal.multiplyScalar(-1));const p={a:o,b:l,c,normal:new at,materialIndex:0};jo.getNormal(rT,aT,oT,p.normal),h.face=p,h.barycoord=f}return h}class $g extends Nn{constructor(t=1,e=1,s=1,i=1,r=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:s,widthSegments:i,heightSegments:r,depthSegments:a};const o=this;i=Math.floor(i),r=Math.floor(r),a=Math.floor(a);const l=[],c=[],h=[],f=[];let p=0,g=0;v("z","y","x",-1,-1,s,e,t,a,r,0),v("z","y","x",1,-1,s,e,-t,a,r,1),v("x","z","y",1,1,t,s,e,i,a,2),v("x","z","y",1,-1,t,s,-e,i,a,3),v("x","y","z",1,-1,t,e,s,i,r,4),v("x","y","z",-1,-1,t,e,-s,i,r,5),this.setIndex(l),this.setAttribute("position",new je(c,3)),this.setAttribute("normal",new je(h,3)),this.setAttribute("uv",new je(f,2));function v(_,S,b,T,C,A,I,D,F,z,k){const O=A/F,L=I/z,H=A/2,q=I/2,K=D/2,Y=F+1,P=z+1;let W=0,j=0;const st=new at;for(let ot=0;ot<P;ot++){const X=ot*L-q;for(let it=0;it<Y;it++){const ct=it*O-H;st[_]=ct*T,st[S]=X*C,st[b]=K,c.push(st.x,st.y,st.z),st[_]=0,st[S]=0,st[b]=D>0?1:-1,h.push(st.x,st.y,st.z),f.push(it/F),f.push(1-ot/z),W+=1}}for(let ot=0;ot<z;ot++)for(let X=0;X<F;X++){const it=p+X+Y*ot,ct=p+X+Y*(ot+1),yt=p+(X+1)+Y*(ot+1),Rt=p+(X+1)+Y*ot;l.push(it,ct,Rt),l.push(ct,yt,Rt),j+=6}o.addGroup(g,j,k),g+=j,p+=W}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new $g(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function sx(n){const t={};for(const e in n){t[e]={};for(const s in n[e]){const i=n[e][s];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(Oe("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),t[e][s]=null):t[e][s]=i.clone():Array.isArray(i)?t[e][s]=i.slice():t[e][s]=i}}return t}function go(n){const t={};for(let e=0;e<n.length;e++){const s=sx(n[e]);for(const i in s)t[i]=s[i]}return t}function I7(n){const t=[];for(let e=0;e<n.length;e++)t.push(n[e].clone());return t}function a4(n){const t=n.getRenderTarget();return t===null?n.outputColorSpace:t.isXRRenderTarget===!0?t.texture.colorSpace:ss.workingColorSpace}const o4={clone:sx,merge:go};var R7=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,D7=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ar extends Jr{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=R7,this.fragmentShader=D7,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=sx(t.uniforms),this.uniformsGroups=I7(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this.defaultAttributeValues=Object.assign({},t.defaultAttributeValues),this.index0AttributeName=t.index0AttributeName,this.uniformsNeedUpdate=t.uniformsNeedUpdate,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?e.uniforms[i]={type:"t",value:a.toJSON(t).uuid}:a&&a.isColor?e.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?e.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?e.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?e.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?e.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?e.uniforms[i]={type:"m4",value:a.toArray()}:e.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const s={};for(const i in this.extensions)this.extensions[i]===!0&&(s[i]=!0);return Object.keys(s).length>0&&(e.extensions=s),e}}class vC extends ps{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Tn,this.projectionMatrix=new Tn,this.projectionMatrixInverse=new Tn,this.coordinateSystem=Sl,this._reversedDepth=!1}get reversedDepth(){return this._reversedDepth}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Ad=new at,oF=new Yt,lF=new Yt;class Vi extends vC{constructor(t=50,e=1,s=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=s,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=ex*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(Qm*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return ex*2*Math.atan(Math.tan(Qm*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,s){Ad.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(Ad.x,Ad.y).multiplyScalar(-t/Ad.z),Ad.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),s.set(Ad.x,Ad.y).multiplyScalar(-t/Ad.z)}getViewSize(t,e){return this.getViewBounds(t,oF,lF),e.subVectors(lF,oF)}setViewOffset(t,e,s,i,r,a){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=s,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(Qm*.5*this.fov)/this.zoom,s=2*e,i=this.aspect*s,r=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const l=a.fullWidth,c=a.fullHeight;r+=a.offsetX*i/l,e-=a.offsetY*s/c,i*=a.width/l,s*=a.height/c}const o=this.filmOffset;o!==0&&(r+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-s,t,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const dy=-90,py=1;class l4 extends ps{constructor(t,e,s){super(),this.type="CubeCamera",this.renderTarget=s,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Vi(dy,py,t,e);i.layers=this.layers,this.add(i);const r=new Vi(dy,py,t,e);r.layers=this.layers,this.add(r);const a=new Vi(dy,py,t,e);a.layers=this.layers,this.add(a);const o=new Vi(dy,py,t,e);o.layers=this.layers,this.add(o);const l=new Vi(dy,py,t,e);l.layers=this.layers,this.add(l);const c=new Vi(dy,py,t,e);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[s,i,r,a,o,l]=e;for(const c of e)this.remove(c);if(t===Sl)s.up.set(0,1,0),s.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),r.up.set(0,0,-1),r.lookAt(0,1,0),a.up.set(0,0,1),a.lookAt(0,-1,0),o.up.set(0,1,0),o.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(t===Jy)s.up.set(0,-1,0),s.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),r.up.set(0,0,1),r.lookAt(0,1,0),a.up.set(0,0,-1),a.lookAt(0,-1,0),o.up.set(0,-1,0),o.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);for(const c of e)this.add(c),c.updateMatrixWorld()}update(t,e){this.parent===null&&this.updateMatrixWorld();const{renderTarget:s,activeMipmapLevel:i}=this;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[r,a,o,l,c,h]=this.children,f=t.getRenderTarget(),p=t.getActiveCubeFace(),g=t.getActiveMipmapLevel(),v=t.xr.enabled;t.xr.enabled=!1;const _=s.texture.generateMipmaps;s.texture.generateMipmaps=!1,t.setRenderTarget(s,0,i),t.render(e,r),t.setRenderTarget(s,1,i),t.render(e,a),t.setRenderTarget(s,2,i),t.render(e,o),t.setRenderTarget(s,3,i),t.render(e,l),t.setRenderTarget(s,4,i),t.render(e,c),s.texture.generateMipmaps=_,t.setRenderTarget(s,5,i),t.render(e,h),t.setRenderTarget(f,p,g),t.xr.enabled=v,s.texture.needsPMREMUpdate=!0}}class nS extends wi{constructor(t=[],e=ph,s,i,r,a,o,l,c,h){super(t,e,s,i,r,a,o,l,c,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class JD extends ki{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const s={width:t,height:t,depth:1},i=[s,s,s,s,s,s];this.texture=new nS(i),this._setTextureOptions(e),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const s={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new $g(5,5,5),r=new ar({name:"CubemapFromEquirect",uniforms:sx(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,side:kr,blending:da});r.uniforms.tEquirect.value=e;const a=new rr(i,r),o=e.minFilter;return e.minFilter===th&&(e.minFilter=Hs),new l4(1,10,this).update(t,a),e.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(t,e=!0,s=!0,i=!0){const r=t.getRenderTarget();for(let a=0;a<6;a++)t.setRenderTarget(this,a),t.clear(e,s,i);t.setRenderTarget(r)}}class By extends ps{constructor(){super(),this.isGroup=!0,this.type="Group"}}const k7={type:"move"};class rE{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new By,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new By,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new at,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new at),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new By,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new at,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new at),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this._hand;if(e)for(const s of t.hand.values())this._getHandJoint(e,s)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,s){let i=null,r=null,a=null;const o=this._targetRay,l=this._grip,c=this._hand;if(t&&e.session.visibilityState!=="visible-blurred"){if(c&&t.hand){a=!0;for(const _ of t.hand.values()){const S=e.getJointPose(_,s),b=this._getHandJoint(c,_);S!==null&&(b.matrix.fromArray(S.transform.matrix),b.matrix.decompose(b.position,b.rotation,b.scale),b.matrixWorldNeedsUpdate=!0,b.jointRadius=S.radius),b.visible=S!==null}const h=c.joints["index-finger-tip"],f=c.joints["thumb-tip"],p=h.position.distanceTo(f.position),g=.02,v=.005;c.inputState.pinching&&p>g+v?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!c.inputState.pinching&&p<=g-v&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else l!==null&&t.gripSpace&&(r=e.getPose(t.gripSpace,s),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));o!==null&&(i=e.getPose(t.targetRaySpace,s),i===null&&r!==null&&(i=r),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(k7)))}return o!==null&&(o.visible=i!==null),l!==null&&(l.visible=r!==null),c!==null&&(c.visible=a!==null),this}_getHandJoint(t,e){if(t.joints[e.jointName]===void 0){const s=new By;s.matrixAutoUpdate=!1,s.visible=!1,t.joints[e.jointName]=s,t.add(s)}return t.joints[e.jointName]}}class bC{constructor(t,e=25e-5){this.isFogExp2=!0,this.name="",this.color=new ke(t),this.density=e}clone(){return new bC(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class SC{constructor(t,e=1,s=1e3){this.isFog=!0,this.name="",this.color=new ke(t),this.near=e,this.far=s}clone(){return new SC(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class _1 extends ps{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Ml,this.environmentIntensity=1,this.environmentRotation=new Ml,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}}class _C{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=v1,this.updateRanges=[],this.version=0,this.uuid=El()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,s){t*=this.stride,s*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[s+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=El()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(e,this.stride);return s.setUsage(this.usage),s}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=El()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const mo=new at;class og{constructor(t,e,s,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=s,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,s=this.data.count;e<s;e++)mo.fromBufferAttribute(this,e),mo.applyMatrix4(t),this.setXYZ(e,mo.x,mo.y,mo.z);return this}applyNormalMatrix(t){for(let e=0,s=this.count;e<s;e++)mo.fromBufferAttribute(this,e),mo.applyNormalMatrix(t),this.setXYZ(e,mo.x,mo.y,mo.z);return this}transformDirection(t){for(let e=0,s=this.count;e<s;e++)mo.fromBufferAttribute(this,e),mo.transformDirection(t),this.setXYZ(e,mo.x,mo.y,mo.z);return this}getComponent(t,e){let s=this.array[t*this.data.stride+this.offset+e];return this.normalized&&(s=bo(s,this.array)),s}setComponent(t,e,s){return this.normalized&&(s=Ln(s,this.array)),this.data.array[t*this.data.stride+this.offset+e]=s,this}setX(t,e){return this.normalized&&(e=Ln(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=Ln(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=Ln(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=Ln(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=bo(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=bo(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=bo(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=bo(e,this.array)),e}setXY(t,e,s){return t=t*this.data.stride+this.offset,this.normalized&&(e=Ln(e,this.array),s=Ln(s,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=s,this}setXYZ(t,e,s,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=Ln(e,this.array),s=Ln(s,this.array),i=Ln(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=s,this.data.array[t+2]=i,this}setXYZW(t,e,s,i,r){return t=t*this.data.stride+this.offset,this.normalized&&(e=Ln(e,this.array),s=Ln(s,this.array),i=Ln(i,this.array),r=Ln(r,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=s,this.data.array[t+2]=i,this.data.array[t+3]=r,this}clone(t){if(t===void 0){S1("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let s=0;s<this.count;s++){const i=s*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[i+r])}return new Fs(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new og(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){S1("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let s=0;s<this.count;s++){const i=s*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class t3 extends Jr{constructor(t){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new ke(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}let my;const wb=new at,gy=new at,yy=new at,xy=new Yt,Tb=new Yt,c4=new Tn,hT=new at,Eb=new at,fT=new at,cF=new Yt,LM=new Yt,uF=new Yt;class u4 extends ps{constructor(t=new t3){if(super(),this.isSprite=!0,this.type="Sprite",my===void 0){my=new Nn;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),s=new _C(e,5);my.setIndex([0,1,2,0,2,3]),my.setAttribute("position",new og(s,3,0,!1)),my.setAttribute("uv",new og(s,2,3,!1))}this.geometry=my,this.material=t,this.center=new Yt(.5,.5),this.count=1}raycast(t,e){t.camera===null&&on('Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),gy.setFromMatrixScale(this.matrixWorld),c4.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),yy.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&gy.multiplyScalar(-yy.z);const s=this.material.rotation;let i,r;s!==0&&(r=Math.cos(s),i=Math.sin(s));const a=this.center;dT(hT.set(-.5,-.5,0),yy,a,gy,i,r),dT(Eb.set(.5,-.5,0),yy,a,gy,i,r),dT(fT.set(.5,.5,0),yy,a,gy,i,r),cF.set(0,0),LM.set(1,0),uF.set(1,1);let o=t.ray.intersectTriangle(hT,Eb,fT,!1,wb);if(o===null&&(dT(Eb.set(-.5,.5,0),yy,a,gy,i,r),LM.set(0,1),o=t.ray.intersectTriangle(hT,fT,Eb,!1,wb),o===null))return;const l=t.ray.origin.distanceTo(wb);l<t.near||l>t.far||e.push({distance:l,point:wb.clone(),uv:jo.getInterpolation(wb,hT,Eb,fT,cF,LM,uF,new Yt),face:null,object:this})}copy(t,e){return super.copy(t,e),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}function dT(n,t,e,s,i,r){xy.subVectors(n,e).addScalar(.5).multiply(s),i!==void 0?(Tb.x=r*xy.x-i*xy.y,Tb.y=i*xy.x+r*xy.y):Tb.copy(xy),n.copy(t),n.x+=Tb.x,n.y+=Tb.y,n.applyMatrix4(c4)}const pT=new at,hF=new at;class h4 extends ps{constructor(){super(),this.isLOD=!0,this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let s=0,i=e.length;s<i;s++){const r=e[s];this.addLevel(r.object.clone(),r.distance,r.hysteresis)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0,s=0){e=Math.abs(e);const i=this.levels;let r;for(r=0;r<i.length&&!(e<i[r].distance);r++);return i.splice(r,0,{distance:e,hysteresis:s,object:t}),this.add(t),this}removeLevel(t){const e=this.levels;for(let s=0;s<e.length;s++)if(e[s].distance===t){const i=e.splice(s,1);return this.remove(i[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const e=this.levels;if(e.length>0){let s,i;for(s=1,i=e.length;s<i;s++){let r=e[s].distance;if(e[s].object.visible&&(r-=r*e[s].hysteresis),t<r)break}return e[s-1].object}return null}raycast(t,e){if(this.levels.length>0){pT.setFromMatrixPosition(this.matrixWorld);const i=t.ray.origin.distanceTo(pT);this.getObjectForDistance(i).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){pT.setFromMatrixPosition(t.matrixWorld),hF.setFromMatrixPosition(this.matrixWorld);const s=pT.distanceTo(hF)/t.zoom;e[0].object.visible=!0;let i,r;for(i=1,r=e.length;i<r;i++){let a=e[i].distance;if(e[i].object.visible&&(a-=a*e[i].hysteresis),s>=a)e[i-1].object.visible=!1,e[i].object.visible=!0;else break}for(this._currentLevel=i-1;i<r;i++)e[i].object.visible=!1}}toJSON(t){const e=super.toJSON(t);this.autoUpdate===!1&&(e.object.autoUpdate=!1),e.object.levels=[];const s=this.levels;for(let i=0,r=s.length;i<r;i++){const a=s[i];e.object.levels.push({object:a.object.uuid,distance:a.distance,hysteresis:a.hysteresis})}return e}}const fF=new at,dF=new Gs,pF=new Gs,O7=new at,mF=new Tn,mT=new at,FM=new pa,gF=new Tn,zM=new Og;class f4 extends rr{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=JI,this.bindMatrix=new Tn,this.bindMatrixInverse=new Tn,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const t=this.geometry;this.boundingBox===null&&(this.boundingBox=new Ga),this.boundingBox.makeEmpty();const e=t.getAttribute("position");for(let s=0;s<e.count;s++)this.getVertexPosition(s,mT),this.boundingBox.expandByPoint(mT)}computeBoundingSphere(){const t=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new pa),this.boundingSphere.makeEmpty();const e=t.getAttribute("position");for(let s=0;s<e.count;s++)this.getVertexPosition(s,mT),this.boundingSphere.expandByPoint(mT)}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,t.boundingBox!==null&&(this.boundingBox=t.boundingBox.clone()),t.boundingSphere!==null&&(this.boundingSphere=t.boundingSphere.clone()),this}raycast(t,e){const s=this.material,i=this.matrixWorld;s!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),FM.copy(this.boundingSphere),FM.applyMatrix4(i),t.ray.intersectsSphere(FM)!==!1&&(gF.copy(i).invert(),zM.copy(t.ray).applyMatrix4(gF),!(this.boundingBox!==null&&zM.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(t,e,zM)))}getVertexPosition(t,e){return super.getVertexPosition(t,e),this.applyBoneTransform(t,e),e}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new Gs,e=this.geometry.attributes.skinWeight;for(let s=0,i=e.count;s<i;s++){t.fromBufferAttribute(e,s);const r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(s,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode===JI?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===GP?this.bindMatrixInverse.copy(this.bindMatrix).invert():Oe("SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(t,e){const s=this.skeleton,i=this.geometry;dF.fromBufferAttribute(i.attributes.skinIndex,t),pF.fromBufferAttribute(i.attributes.skinWeight,t),fF.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let r=0;r<4;r++){const a=pF.getComponent(r);if(a!==0){const o=dF.getComponent(r);mF.multiplyMatrices(s.bones[o].matrixWorld,s.boneInverses[o]),e.addScaledVector(O7.copy(fF).applyMatrix4(mF),a)}}return e.applyMatrix4(this.bindMatrixInverse)}}class e3 extends ps{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Jc extends wi{constructor(t=null,e=1,s=1,i,r,a,o,l,c=hi,h=hi,f,p){super(null,a,o,l,c,h,i,r,f,p),this.isDataTexture=!0,this.image={data:t,width:e,height:s},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const yF=new Tn,$7=new Tn;class wC{constructor(t=[],e=[]){this.uuid=El(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.previousBoneMatrices=null,this.boneTexture=null,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(t.length*16),e.length===0)this.calculateInverses();else if(t.length!==e.length){Oe("Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let s=0,i=this.bones.length;s<i;s++)this.boneInverses.push(new Tn)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const s=new Tn;this.bones[t]&&s.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(s)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const s=this.bones[t];s&&s.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const s=this.bones[t];s&&(s.parent&&s.parent.isBone?(s.matrix.copy(s.parent.matrixWorld).invert(),s.matrix.multiply(s.matrixWorld)):s.matrix.copy(s.matrixWorld),s.matrix.decompose(s.position,s.quaternion,s.scale))}}update(){const t=this.bones,e=this.boneInverses,s=this.boneMatrices,i=this.boneTexture;for(let r=0,a=t.length;r<a;r++){const o=t[r]?t[r].matrixWorld:$7;yF.multiplyMatrices(o,e[r]),yF.toArray(s,r*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new wC(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(this.bones.length*4);t=Math.ceil(t/4)*4,t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const s=new Jc(e,t,t,Ba,Ua);return s.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=s,this}getBoneByName(t){for(let e=0,s=this.bones.length;e<s;e++){const i=this.bones[e];if(i.name===t)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let s=0,i=t.bones.length;s<i;s++){const r=t.bones[s];let a=e[r];a===void 0&&(Oe("Skeleton: No bone found with UUID:",r),a=new e3),this.bones.push(a),this.boneInverses.push(new Tn().fromArray(t.boneInverses[s]))}return this.init(),this}toJSON(){const t={metadata:{version:4.7,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,s=this.boneInverses;for(let i=0,r=e.length;i<r;i++){const a=e[i];t.bones.push(a.uuid);const o=s[i];t.boneInverses.push(o.toArray())}return t}}class ix extends Fs{constructor(t,e,s,i=1){super(t,e,s),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const vy=new Tn,xF=new Tn,gT=[],vF=new Ga,L7=new Tn,Cb=new rr,Ab=new pa;class d4 extends rr{constructor(t,e,s){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new ix(new Float32Array(s*16),16),this.instanceColor=null,this.morphTexture=null,this.count=s,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<s;i++)this.setMatrixAt(i,L7)}computeBoundingBox(){const t=this.geometry,e=this.count;this.boundingBox===null&&(this.boundingBox=new Ga),t.boundingBox===null&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let s=0;s<e;s++)this.getMatrixAt(s,vy),vF.copy(t.boundingBox).applyMatrix4(vy),this.boundingBox.union(vF)}computeBoundingSphere(){const t=this.geometry,e=this.count;this.boundingSphere===null&&(this.boundingSphere=new pa),t.boundingSphere===null&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let s=0;s<e;s++)this.getMatrixAt(s,vy),Ab.copy(t.boundingSphere).applyMatrix4(vy),this.boundingSphere.union(Ab)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),t.morphTexture!==null&&(this.morphTexture=t.morphTexture.clone()),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,t.boundingBox!==null&&(this.boundingBox=t.boundingBox.clone()),t.boundingSphere!==null&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}getMorphAt(t,e){const s=e.morphTargetInfluences,i=this.morphTexture.source.data.data,r=s.length+1,a=t*r+1;for(let o=0;o<s.length;o++)s[o]=i[a+o]}raycast(t,e){const s=this.matrixWorld,i=this.count;if(Cb.geometry=this.geometry,Cb.material=this.material,Cb.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Ab.copy(this.boundingSphere),Ab.applyMatrix4(s),t.ray.intersectsSphere(Ab)!==!1))for(let r=0;r<i;r++){this.getMatrixAt(r,vy),xF.multiplyMatrices(s,vy),Cb.matrixWorld=xF,Cb.raycast(t,gT);for(let a=0,o=gT.length;a<o;a++){const l=gT[a];l.instanceId=r,l.object=this,e.push(l)}gT.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new ix(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}setMorphAt(t,e){const s=e.morphTargetInfluences,i=s.length+1;this.morphTexture===null&&(this.morphTexture=new Jc(new Float32Array(i*this.count),i,this.count,hC,Ua));const r=this.morphTexture.source.data.data;let a=0;for(let c=0;c<s.length;c++)a+=s[c];const o=this.geometry.morphTargetsRelative?1:1-a,l=i*t;r[l]=o,r.set(s,l+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null)}}const UM=new at,F7=new at,z7=new On;class hf{constructor(t=new at(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,s,i){return this.normal.set(t,e,s),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,s){const i=UM.subVectors(s,e).cross(F7.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const s=t.delta(UM),i=this.normal.dot(s);if(i===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(t.start).addScaledVector(s,r)}intersectsLine(t){const e=this.distanceToPoint(t.start),s=this.distanceToPoint(t.end);return e<0&&s>0||s<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const s=e||z7.getNormalMatrix(t),i=this.coplanarPoint(UM).applyMatrix4(t),r=this.normal.applyMatrix3(s).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const xm=new pa,U7=new Yt(.5,.5),yT=new at;class Tx{constructor(t=new hf,e=new hf,s=new hf,i=new hf,r=new hf,a=new hf){this.planes=[t,e,s,i,r,a]}set(t,e,s,i,r,a){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(s),o[3].copy(i),o[4].copy(r),o[5].copy(a),this}copy(t){const e=this.planes;for(let s=0;s<6;s++)e[s].copy(t.planes[s]);return this}setFromProjectionMatrix(t,e=Sl,s=!1){const i=this.planes,r=t.elements,a=r[0],o=r[1],l=r[2],c=r[3],h=r[4],f=r[5],p=r[6],g=r[7],v=r[8],_=r[9],S=r[10],b=r[11],T=r[12],C=r[13],A=r[14],I=r[15];if(i[0].setComponents(c-a,g-h,b-v,I-T).normalize(),i[1].setComponents(c+a,g+h,b+v,I+T).normalize(),i[2].setComponents(c+o,g+f,b+_,I+C).normalize(),i[3].setComponents(c-o,g-f,b-_,I-C).normalize(),s)i[4].setComponents(l,p,S,A).normalize(),i[5].setComponents(c-l,g-p,b-S,I-A).normalize();else if(i[4].setComponents(c-l,g-p,b-S,I-A).normalize(),e===Sl)i[5].setComponents(c+l,g+p,b+S,I+A).normalize();else if(e===Jy)i[5].setComponents(l,p,S,A).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);return this}intersectsObject(t){if(t.boundingSphere!==void 0)t.boundingSphere===null&&t.computeBoundingSphere(),xm.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;e.boundingSphere===null&&e.computeBoundingSphere(),xm.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(xm)}intersectsSprite(t){xm.center.set(0,0,0);const e=U7.distanceTo(t.center);return xm.radius=.7071067811865476+e,xm.applyMatrix4(t.matrixWorld),this.intersectsSphere(xm)}intersectsSphere(t){const e=this.planes,s=t.center,i=-t.radius;for(let r=0;r<6;r++)if(e[r].distanceToPoint(s)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let s=0;s<6;s++){const i=e[s];if(yT.x=i.normal.x>0?t.max.x:t.min.x,yT.y=i.normal.y>0?t.max.y:t.min.y,yT.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(yT)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let s=0;s<6;s++)if(e[s].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}const qu=new Tn,Xu=new Tx;class TC{constructor(){this.coordinateSystem=Sl}intersectsObject(t,e){if(!e.isArrayCamera||e.cameras.length===0)return!1;for(let s=0;s<e.cameras.length;s++){const i=e.cameras[s];if(qu.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Xu.setFromProjectionMatrix(qu,i.coordinateSystem,i.reversedDepth),Xu.intersectsObject(t))return!0}return!1}intersectsSprite(t,e){if(!e||!e.cameras||e.cameras.length===0)return!1;for(let s=0;s<e.cameras.length;s++){const i=e.cameras[s];if(qu.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Xu.setFromProjectionMatrix(qu,i.coordinateSystem,i.reversedDepth),Xu.intersectsSprite(t))return!0}return!1}intersectsSphere(t,e){if(!e||!e.cameras||e.cameras.length===0)return!1;for(let s=0;s<e.cameras.length;s++){const i=e.cameras[s];if(qu.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Xu.setFromProjectionMatrix(qu,i.coordinateSystem,i.reversedDepth),Xu.intersectsSphere(t))return!0}return!1}intersectsBox(t,e){if(!e||!e.cameras||e.cameras.length===0)return!1;for(let s=0;s<e.cameras.length;s++){const i=e.cameras[s];if(qu.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Xu.setFromProjectionMatrix(qu,i.coordinateSystem,i.reversedDepth),Xu.intersectsBox(t))return!0}return!1}containsPoint(t,e){if(!e||!e.cameras||e.cameras.length===0)return!1;for(let s=0;s<e.cameras.length;s++){const i=e.cameras[s];if(qu.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Xu.setFromProjectionMatrix(qu,i.coordinateSystem,i.reversedDepth),Xu.containsPoint(t))return!0}return!1}clone(){return new TC}}function BM(n,t){return n-t}function B7(n,t){return n.z-t.z}function P7(n,t){return t.z-n.z}class V7{constructor(){this.index=0,this.pool=[],this.list=[]}push(t,e,s,i){const r=this.pool,a=this.list;this.index>=r.length&&r.push({start:-1,count:-1,z:-1,index:-1});const o=r[this.index];a.push(o),this.index++,o.start=t,o.count=e,o.z=s,o.index=i}reset(){this.list.length=0,this.index=0}}const Po=new Tn,G7=new ke(1,1,1),bF=new Tx,H7=new TC,xT=new Ga,vm=new pa,Nb=new at,SF=new at,W7=new at,PM=new V7,ka=new rr,vT=[];function q7(n,t,e=0){const s=t.itemSize;if(n.isInterleavedBufferAttribute||n.array.constructor!==t.array.constructor){const i=n.count;for(let r=0;r<i;r++)for(let a=0;a<s;a++)t.setComponent(r+e,a,n.getComponent(r,a))}else t.array.set(n.array,e*s);t.needsUpdate=!0}function bm(n,t){if(n.constructor!==t.constructor){const e=Math.min(n.length,t.length);for(let s=0;s<e;s++)t[s]=n[s]}else{const e=Math.min(n.length,t.length);t.set(new n.constructor(n.buffer,0,e))}}class p4 extends rr{constructor(t,e,s=e*2,i){super(new Nn,i),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=t,this._maxVertexCount=e,this._maxIndexCount=s,this._multiDrawCounts=new Int32Array(t),this._multiDrawStarts=new Int32Array(t),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}_initMatricesTexture(){let t=Math.sqrt(this._maxInstanceCount*4);t=Math.ceil(t/4)*4,t=Math.max(t,4);const e=new Float32Array(t*t*4),s=new Jc(e,t,t,Ba,Ua);this._matricesTexture=s}_initIndirectTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=new Uint32Array(t*t),s=new Jc(e,t,t,eS,Nl);this._indirectTexture=s}_initColorsTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=new Float32Array(t*t*4).fill(1),s=new Jc(e,t,t,Ba,Ua);s.colorSpace=ss.workingColorSpace,this._colorsTexture=s}_initializeGeometry(t){const e=this.geometry,s=this._maxVertexCount,i=this._maxIndexCount;if(this._geometryInitialized===!1){for(const r in t.attributes){const a=t.getAttribute(r),{array:o,itemSize:l,normalized:c}=a,h=new o.constructor(s*l),f=new Fs(h,l,c);e.setAttribute(r,f)}if(t.getIndex()!==null){const r=s>65535?new Uint32Array(i):new Uint16Array(i);e.setIndex(new Fs(r,1))}this._geometryInitialized=!0}}_validateGeometry(t){const e=this.geometry;if(!!t.getIndex()!=!!e.getIndex())throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const s in e.attributes){if(!t.hasAttribute(s))throw new Error(`THREE.BatchedMesh: Added geometry missing "${s}". All geometries must have consistent attributes.`);const i=t.getAttribute(s),r=e.getAttribute(s);if(i.itemSize!==r.itemSize||i.normalized!==r.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(t){const e=this._instanceInfo;if(t<0||t>=e.length||e[t].active===!1)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${t}. Instance is either out of range or has been deleted.`)}validateGeometryId(t){const e=this._geometryInfo;if(t<0||t>=e.length||e[t].active===!1)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${t}. Geometry is either out of range or has been deleted.`)}setCustomSort(t){return this.customSort=t,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ga);const t=this.boundingBox,e=this._instanceInfo;t.makeEmpty();for(let s=0,i=e.length;s<i;s++){if(e[s].active===!1)continue;const r=e[s].geometryIndex;this.getMatrixAt(s,Po),this.getBoundingBoxAt(r,xT).applyMatrix4(Po),t.union(xT)}}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new pa);const t=this.boundingSphere,e=this._instanceInfo;t.makeEmpty();for(let s=0,i=e.length;s<i;s++){if(e[s].active===!1)continue;const r=e[s].geometryIndex;this.getMatrixAt(s,Po),this.getBoundingSphereAt(r,vm).applyMatrix4(Po),t.union(vm)}}addInstance(t){if(this._instanceInfo.length>=this.maxInstanceCount&&this._availableInstanceIds.length===0)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const s={visible:!0,active:!0,geometryIndex:t};let i=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(BM),i=this._availableInstanceIds.shift(),this._instanceInfo[i]=s):(i=this._instanceInfo.length,this._instanceInfo.push(s));const r=this._matricesTexture;Po.identity().toArray(r.image.data,i*16),r.needsUpdate=!0;const a=this._colorsTexture;return a&&(G7.toArray(a.image.data,i*4),a.needsUpdate=!0),this._visibilityChanged=!0,i}addGeometry(t,e=-1,s=-1){this._initializeGeometry(t),this._validateGeometry(t);const i={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},r=this._geometryInfo;i.vertexStart=this._nextVertexStart,i.reservedVertexCount=e===-1?t.getAttribute("position").count:e;const a=t.getIndex();if(a!==null&&(i.indexStart=this._nextIndexStart,i.reservedIndexCount=s===-1?a.count:s),i.indexStart!==-1&&i.indexStart+i.reservedIndexCount>this._maxIndexCount||i.vertexStart+i.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let l;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(BM),l=this._availableGeometryIds.shift(),r[l]=i):(l=this._geometryCount,this._geometryCount++,r.push(i)),this.setGeometryAt(l,t),this._nextIndexStart=i.indexStart+i.reservedIndexCount,this._nextVertexStart=i.vertexStart+i.reservedVertexCount,l}setGeometryAt(t,e){if(t>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(e);const s=this.geometry,i=s.getIndex()!==null,r=s.getIndex(),a=e.getIndex(),o=this._geometryInfo[t];if(i&&a.count>o.reservedIndexCount||e.attributes.position.count>o.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const l=o.vertexStart,c=o.reservedVertexCount;o.vertexCount=e.getAttribute("position").count;for(const h in s.attributes){const f=e.getAttribute(h),p=s.getAttribute(h);q7(f,p,l);const g=f.itemSize;for(let v=f.count,_=c;v<_;v++){const S=l+v;for(let b=0;b<g;b++)p.setComponent(S,b,0)}p.needsUpdate=!0,p.addUpdateRange(l*g,c*g)}if(i){const h=o.indexStart,f=o.reservedIndexCount;o.indexCount=e.getIndex().count;for(let p=0;p<a.count;p++)r.setX(h+p,l+a.getX(p));for(let p=a.count,g=f;p<g;p++)r.setX(h+p,l);r.needsUpdate=!0,r.addUpdateRange(h,o.reservedIndexCount)}return o.start=i?o.indexStart:o.vertexStart,o.count=i?o.indexCount:o.vertexCount,o.boundingBox=null,e.boundingBox!==null&&(o.boundingBox=e.boundingBox.clone()),o.boundingSphere=null,e.boundingSphere!==null&&(o.boundingSphere=e.boundingSphere.clone()),this._visibilityChanged=!0,t}deleteGeometry(t){const e=this._geometryInfo;if(t>=e.length||e[t].active===!1)return this;const s=this._instanceInfo;for(let i=0,r=s.length;i<r;i++)s[i].active&&s[i].geometryIndex===t&&this.deleteInstance(i);return e[t].active=!1,this._availableGeometryIds.push(t),this._visibilityChanged=!0,this}deleteInstance(t){return this.validateInstanceId(t),this._instanceInfo[t].active=!1,this._availableInstanceIds.push(t),this._visibilityChanged=!0,this}optimize(){let t=0,e=0;const s=this._geometryInfo,i=s.map((a,o)=>o).sort((a,o)=>s[a].vertexStart-s[o].vertexStart),r=this.geometry;for(let a=0,o=s.length;a<o;a++){const l=i[a],c=s[l];if(c.active!==!1){if(r.index!==null){if(c.indexStart!==e){const{indexStart:h,vertexStart:f,reservedIndexCount:p}=c,g=r.index,v=g.array,_=t-f;for(let S=h;S<h+p;S++)v[S]=v[S]+_;g.array.copyWithin(e,h,h+p),g.addUpdateRange(e,p),g.needsUpdate=!0,c.indexStart=e}e+=c.reservedIndexCount}if(c.vertexStart!==t){const{vertexStart:h,reservedVertexCount:f}=c,p=r.attributes;for(const g in p){const v=p[g],{array:_,itemSize:S}=v;_.copyWithin(t*S,h*S,(h+f)*S),v.addUpdateRange(t*S,f*S),v.needsUpdate=!0}c.vertexStart=t}t+=c.reservedVertexCount,c.start=r.index?c.indexStart:c.vertexStart,this._nextIndexStart=r.index?c.indexStart+c.reservedIndexCount:0,this._nextVertexStart=c.vertexStart+c.reservedVertexCount}}return this._visibilityChanged=!0,this}getBoundingBoxAt(t,e){if(t>=this._geometryCount)return null;const s=this.geometry,i=this._geometryInfo[t];if(i.boundingBox===null){const r=new Ga,a=s.index,o=s.attributes.position;for(let l=i.start,c=i.start+i.count;l<c;l++){let h=l;a&&(h=a.getX(h)),r.expandByPoint(Nb.fromBufferAttribute(o,h))}i.boundingBox=r}return e.copy(i.boundingBox),e}getBoundingSphereAt(t,e){if(t>=this._geometryCount)return null;const s=this.geometry,i=this._geometryInfo[t];if(i.boundingSphere===null){const r=new pa;this.getBoundingBoxAt(t,xT),xT.getCenter(r.center);const a=s.index,o=s.attributes.position;let l=0;for(let c=i.start,h=i.start+i.count;c<h;c++){let f=c;a&&(f=a.getX(f)),Nb.fromBufferAttribute(o,f),l=Math.max(l,r.center.distanceToSquared(Nb))}r.radius=Math.sqrt(l),i.boundingSphere=r}return e.copy(i.boundingSphere),e}setMatrixAt(t,e){this.validateInstanceId(t);const s=this._matricesTexture,i=this._matricesTexture.image.data;return e.toArray(i,t*16),s.needsUpdate=!0,this}getMatrixAt(t,e){return this.validateInstanceId(t),e.fromArray(this._matricesTexture.image.data,t*16)}setColorAt(t,e){return this.validateInstanceId(t),this._colorsTexture===null&&this._initColorsTexture(),e.toArray(this._colorsTexture.image.data,t*4),this._colorsTexture.needsUpdate=!0,this}getColorAt(t,e){return this.validateInstanceId(t),e.fromArray(this._colorsTexture.image.data,t*4)}setVisibleAt(t,e){return this.validateInstanceId(t),this._instanceInfo[t].visible===e?this:(this._instanceInfo[t].visible=e,this._visibilityChanged=!0,this)}getVisibleAt(t){return this.validateInstanceId(t),this._instanceInfo[t].visible}setGeometryIdAt(t,e){return this.validateInstanceId(t),this.validateGeometryId(e),this._instanceInfo[t].geometryIndex=e,this}getGeometryIdAt(t){return this.validateInstanceId(t),this._instanceInfo[t].geometryIndex}getGeometryRangeAt(t,e={}){this.validateGeometryId(t);const s=this._geometryInfo[t];return e.vertexStart=s.vertexStart,e.vertexCount=s.vertexCount,e.reservedVertexCount=s.reservedVertexCount,e.indexStart=s.indexStart,e.indexCount=s.indexCount,e.reservedIndexCount=s.reservedIndexCount,e.start=s.start,e.count=s.count,e}setInstanceCount(t){const e=this._availableInstanceIds,s=this._instanceInfo;for(e.sort(BM);e[e.length-1]===s.length-1;)s.pop(),e.pop();if(t<s.length)throw new Error(`BatchedMesh: Instance ids outside the range ${t} are being used. Cannot shrink instance count.`);const i=new Int32Array(t),r=new Int32Array(t);bm(this._multiDrawCounts,i),bm(this._multiDrawStarts,r),this._multiDrawCounts=i,this._multiDrawStarts=r,this._maxInstanceCount=t;const a=this._indirectTexture,o=this._matricesTexture,l=this._colorsTexture;a.dispose(),this._initIndirectTexture(),bm(a.image.data,this._indirectTexture.image.data),o.dispose(),this._initMatricesTexture(),bm(o.image.data,this._matricesTexture.image.data),l&&(l.dispose(),this._initColorsTexture(),bm(l.image.data,this._colorsTexture.image.data))}setGeometrySize(t,e){const s=[...this._geometryInfo].filter(o=>o.active);if(Math.max(...s.map(o=>o.vertexStart+o.reservedVertexCount))>t)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${e}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...s.map(l=>l.indexStart+l.reservedIndexCount))>e)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${e}. Cannot shrink further.`);const r=this.geometry;r.dispose(),this._maxVertexCount=t,this._maxIndexCount=e,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new Nn,this._initializeGeometry(r));const a=this.geometry;r.index&&bm(r.index.array,a.index.array);for(const o in r.attributes)bm(r.attributes[o].array,a.attributes[o].array)}raycast(t,e){const s=this._instanceInfo,i=this._geometryInfo,r=this.matrixWorld,a=this.geometry;ka.material=this.material,ka.geometry.index=a.index,ka.geometry.attributes=a.attributes,ka.geometry.boundingBox===null&&(ka.geometry.boundingBox=new Ga),ka.geometry.boundingSphere===null&&(ka.geometry.boundingSphere=new pa);for(let o=0,l=s.length;o<l;o++){if(!s[o].visible||!s[o].active)continue;const c=s[o].geometryIndex,h=i[c];ka.geometry.setDrawRange(h.start,h.count),this.getMatrixAt(o,ka.matrixWorld).premultiply(r),this.getBoundingBoxAt(c,ka.geometry.boundingBox),this.getBoundingSphereAt(c,ka.geometry.boundingSphere),ka.raycast(t,vT);for(let f=0,p=vT.length;f<p;f++){const g=vT[f];g.object=this,g.batchId=o,e.push(g)}vT.length=0}ka.material=null,ka.geometry.index=null,ka.geometry.attributes={},ka.geometry.setDrawRange(0,1/0)}copy(t){return super.copy(t),this.geometry=t.geometry.clone(),this.perObjectFrustumCulled=t.perObjectFrustumCulled,this.sortObjects=t.sortObjects,this.boundingBox=t.boundingBox!==null?t.boundingBox.clone():null,this.boundingSphere=t.boundingSphere!==null?t.boundingSphere.clone():null,this._geometryInfo=t._geometryInfo.map(e=>({...e,boundingBox:e.boundingBox!==null?e.boundingBox.clone():null,boundingSphere:e.boundingSphere!==null?e.boundingSphere.clone():null})),this._instanceInfo=t._instanceInfo.map(e=>({...e})),this._availableInstanceIds=t._availableInstanceIds.slice(),this._availableGeometryIds=t._availableGeometryIds.slice(),this._nextIndexStart=t._nextIndexStart,this._nextVertexStart=t._nextVertexStart,this._geometryCount=t._geometryCount,this._maxInstanceCount=t._maxInstanceCount,this._maxVertexCount=t._maxVertexCount,this._maxIndexCount=t._maxIndexCount,this._geometryInitialized=t._geometryInitialized,this._multiDrawCounts=t._multiDrawCounts.slice(),this._multiDrawStarts=t._multiDrawStarts.slice(),this._indirectTexture=t._indirectTexture.clone(),this._indirectTexture.image.data=this._indirectTexture.image.data.slice(),this._matricesTexture=t._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),this._colorsTexture!==null&&(this._colorsTexture=t._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,this._colorsTexture!==null&&(this._colorsTexture.dispose(),this._colorsTexture=null)}onBeforeRender(t,e,s,i,r){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const a=i.getIndex(),o=a===null?1:a.array.BYTES_PER_ELEMENT,l=this._instanceInfo,c=this._multiDrawStarts,h=this._multiDrawCounts,f=this._geometryInfo,p=this.perObjectFrustumCulled,g=this._indirectTexture,v=g.image.data,_=s.isArrayCamera?H7:bF;p&&!s.isArrayCamera&&(Po.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse).multiply(this.matrixWorld),bF.setFromProjectionMatrix(Po,s.coordinateSystem,s.reversedDepth));let S=0;if(this.sortObjects){Po.copy(this.matrixWorld).invert(),Nb.setFromMatrixPosition(s.matrixWorld).applyMatrix4(Po),SF.set(0,0,-1).transformDirection(s.matrixWorld).transformDirection(Po);for(let C=0,A=l.length;C<A;C++)if(l[C].visible&&l[C].active){const I=l[C].geometryIndex;this.getMatrixAt(C,Po),this.getBoundingSphereAt(I,vm).applyMatrix4(Po);let D=!1;if(p&&(D=!_.intersectsSphere(vm,s)),!D){const F=f[I],z=W7.subVectors(vm.center,Nb).dot(SF);PM.push(F.start,F.count,z,C)}}const b=PM.list,T=this.customSort;T===null?b.sort(r.transparent?P7:B7):T.call(this,b,s);for(let C=0,A=b.length;C<A;C++){const I=b[C];c[S]=I.start*o,h[S]=I.count,v[S]=I.index,S++}PM.reset()}else for(let b=0,T=l.length;b<T;b++)if(l[b].visible&&l[b].active){const C=l[b].geometryIndex;let A=!1;if(p&&(this.getMatrixAt(b,Po),this.getBoundingSphereAt(C,vm).applyMatrix4(Po),A=!_.intersectsSphere(vm,s)),!A){const I=f[C];c[S]=I.start*o,h[S]=I.count,v[S]=b,S++}}g.needsUpdate=!0,this._multiDrawCount=S,this._visibilityChanged=!1}onBeforeShadow(t,e,s,i,r,a){this.onBeforeRender(t,null,i,r,a)}}class Ao extends Jr{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new ke(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const u2=new at,h2=new at,_F=new Tn,Mb=new Og,bT=new pa,VM=new at,wF=new at;class Kd extends ps{constructor(t=new Nn,e=new Ao){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,s=[0];for(let i=1,r=e.count;i<r;i++)u2.fromBufferAttribute(e,i-1),h2.fromBufferAttribute(e,i),s[i]=s[i-1],s[i]+=u2.distanceTo(h2);t.setAttribute("lineDistance",new je(s,1))}else Oe("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const s=this.geometry,i=this.matrixWorld,r=t.params.Line.threshold,a=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),bT.copy(s.boundingSphere),bT.applyMatrix4(i),bT.radius+=r,t.ray.intersectsSphere(bT)===!1)return;_F.copy(i).invert(),Mb.copy(t.ray).applyMatrix4(_F);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,c=this.isLineSegments?2:1,h=s.index,p=s.attributes.position;if(h!==null){const g=Math.max(0,a.start),v=Math.min(h.count,a.start+a.count);for(let _=g,S=v-1;_<S;_+=c){const b=h.getX(_),T=h.getX(_+1),C=ST(this,t,Mb,l,b,T,_);C&&e.push(C)}if(this.isLineLoop){const _=h.getX(v-1),S=h.getX(g),b=ST(this,t,Mb,l,_,S,v-1);b&&e.push(b)}}else{const g=Math.max(0,a.start),v=Math.min(p.count,a.start+a.count);for(let _=g,S=v-1;_<S;_+=c){const b=ST(this,t,Mb,l,_,_+1,_);b&&e.push(b)}if(this.isLineLoop){const _=ST(this,t,Mb,l,v-1,g,v-1);_&&e.push(_)}}}updateMorphTargets(){const e=this.geometry.morphAttributes,s=Object.keys(e);if(s.length>0){const i=e[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}}function ST(n,t,e,s,i,r,a){const o=n.geometry.attributes.position;if(u2.fromBufferAttribute(o,i),h2.fromBufferAttribute(o,r),e.distanceSqToSegment(u2,h2,VM,wF)>s)return;VM.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(VM);if(!(c<t.near||c>t.far))return{distance:c,point:wF.clone().applyMatrix4(n.matrixWorld),index:a,face:null,faceIndex:null,barycoord:null,object:n}}const TF=new at,EF=new at;class bh extends Kd{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,s=[];for(let i=0,r=e.count;i<r;i+=2)TF.fromBufferAttribute(e,i),EF.fromBufferAttribute(e,i+1),s[i]=i===0?0:s[i-1],s[i+1]=s[i]+TF.distanceTo(EF);t.setAttribute("lineDistance",new je(s,1))}else Oe("LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class m4 extends Kd{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class n3 extends Jr{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new ke(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const CF=new Tn,nR=new Og,_T=new pa,wT=new at;class g4 extends ps{constructor(t=new Nn,e=new n3){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const s=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold,a=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),_T.copy(s.boundingSphere),_T.applyMatrix4(i),_T.radius+=r,t.ray.intersectsSphere(_T)===!1)return;CF.copy(i).invert(),nR.copy(t.ray).applyMatrix4(CF);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,c=s.index,f=s.attributes.position;if(c!==null){const p=Math.max(0,a.start),g=Math.min(c.count,a.start+a.count);for(let v=p,_=g;v<_;v++){const S=c.getX(v);wT.fromBufferAttribute(f,S),AF(wT,S,l,i,t,e,this)}}else{const p=Math.max(0,a.start),g=Math.min(f.count,a.start+a.count);for(let v=p,_=g;v<_;v++)wT.fromBufferAttribute(f,v),AF(wT,v,l,i,t,e,this)}}updateMorphTargets(){const e=this.geometry.morphAttributes,s=Object.keys(e);if(s.length>0){const i=e[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}}function AF(n,t,e,s,i,r,a){const o=nR.distanceSqToPoint(n);if(o<e){const l=new at;nR.closestPointToPoint(n,l),l.applyMatrix4(s);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;r.push({distance:c,distanceToRay:Math.sqrt(o),point:l,index:t,face:null,faceIndex:null,barycoord:null,object:a})}}class y4 extends wi{constructor(t,e,s,i,r=Hs,a=Hs,o,l,c){super(t,e,s,i,r,a,o,l,c),this.isVideoTexture=!0,this.generateMipmaps=!1,this._requestVideoFrameCallbackId=0;const h=this;function f(){h.needsUpdate=!0,h._requestVideoFrameCallbackId=t.requestVideoFrameCallback(f)}"requestVideoFrameCallback"in t&&(this._requestVideoFrameCallbackId=t.requestVideoFrameCallback(f))}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;"requestVideoFrameCallback"in t===!1&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}dispose(){this._requestVideoFrameCallbackId!==0&&(this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId),this._requestVideoFrameCallbackId=0),super.dispose()}}class X7 extends y4{constructor(t,e,s,i,r,a,o,l){super({},t,e,s,i,r,a,o,l),this.isVideoFrameTexture=!0}update(){}clone(){return new this.constructor().copy(this)}setFrame(t){this.image=t,this.needsUpdate=!0}}class j7 extends wi{constructor(t,e){super({width:t,height:e}),this.isFramebufferTexture=!0,this.magFilter=hi,this.minFilter=hi,this.generateMipmaps=!1,this.needsUpdate=!0}}class EC extends wi{constructor(t,e,s,i,r,a,o,l,c,h,f,p){super(null,a,o,l,c,h,i,r,f,p),this.isCompressedTexture=!0,this.image={width:e,height:s},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}class K7 extends EC{constructor(t,e,s,i,r,a){super(t,e,s,r,a),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=Yo,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class Y7 extends EC{constructor(t,e,s){super(void 0,t[0].width,t[0].height,e,s,ph),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=t}}class x4 extends wi{constructor(t,e,s,i,r,a,o,l,c){super(t,e,s,i,r,a,o,l,c),this.isCanvasTexture=!0,this.needsUpdate=!0}}class lg extends wi{constructor(t,e,s=Nl,i,r,a,o=hi,l=hi,c,h=mh,f=1){if(h!==mh&&h!==vf)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");const p={width:t,height:e,depth:f};super(p,i,r,a,o,l,h,s,c),this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.source=new Od(Object.assign({},t.image)),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return this.compareFunction!==null&&(e.compareFunction=this.compareFunction),e}}class v4 extends lg{constructor(t,e=Nl,s=ph,i,r,a=hi,o=hi,l,c=mh){const h={width:t,height:t,depth:1},f=[h,h,h,h,h,h];super(t,t,e,s,i,r,a,o,l,c),this.image=f,this.isCubeDepthTexture=!0,this.isCubeTexture=!0}get images(){return this.image}set images(t){this.image=t}}class s3 extends wi{constructor(t=null){super(),this.sourceTexture=t,this.isExternalTexture=!0}copy(t){return super.copy(t),this.sourceTexture=t.sourceTexture,this}}class CC extends Nn{constructor(t=1,e=1,s=4,i=8,r=1){super(),this.type="CapsuleGeometry",this.parameters={radius:t,height:e,capSegments:s,radialSegments:i,heightSegments:r},e=Math.max(0,e),s=Math.max(1,Math.floor(s)),i=Math.max(3,Math.floor(i)),r=Math.max(1,Math.floor(r));const a=[],o=[],l=[],c=[],h=e/2,f=Math.PI/2*t,p=e,g=2*f+p,v=s*2+r,_=i+1,S=new at,b=new at;for(let T=0;T<=v;T++){let C=0,A=0,I=0,D=0;if(T<=s){const k=T/s,O=k*Math.PI/2;A=-h-t*Math.cos(O),I=t*Math.sin(O),D=-t*Math.cos(O),C=k*f}else if(T<=s+r){const k=(T-s)/r;A=-h+k*e,I=t,D=0,C=f+k*p}else{const k=(T-s-r)/s,O=k*Math.PI/2;A=h+t*Math.sin(O),I=t*Math.cos(O),D=t*Math.sin(O),C=f+p+k*f}const F=Math.max(0,Math.min(1,C/g));let z=0;T===0?z=.5/i:T===v&&(z=-.5/i);for(let k=0;k<=i;k++){const O=k/i,L=O*Math.PI*2,H=Math.sin(L),q=Math.cos(L);b.x=-I*q,b.y=A,b.z=I*H,o.push(b.x,b.y,b.z),S.set(-I*q,D,I*H),S.normalize(),l.push(S.x,S.y,S.z),c.push(O+z,F)}if(T>0){const k=(T-1)*_;for(let O=0;O<i;O++){const L=k+O,H=k+O+1,q=T*_+O,K=T*_+O+1;a.push(L,H,q),a.push(H,K,q)}}}this.setIndex(a),this.setAttribute("position",new je(o,3)),this.setAttribute("normal",new je(l,3)),this.setAttribute("uv",new je(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new CC(t.radius,t.height,t.capSegments,t.radialSegments,t.heightSegments)}}class AC extends Nn{constructor(t=1,e=32,s=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:s,thetaLength:i},e=Math.max(3,e);const r=[],a=[],o=[],l=[],c=new at,h=new Yt;a.push(0,0,0),o.push(0,0,1),l.push(.5,.5);for(let f=0,p=3;f<=e;f++,p+=3){const g=s+f/e*i;c.x=t*Math.cos(g),c.y=t*Math.sin(g),a.push(c.x,c.y,c.z),o.push(0,0,1),h.x=(a[p]/t+1)/2,h.y=(a[p+1]/t+1)/2,l.push(h.x,h.y)}for(let f=1;f<=e;f++)r.push(f,f+1,0);this.setIndex(r),this.setAttribute("position",new je(a,3)),this.setAttribute("normal",new je(o,3)),this.setAttribute("uv",new je(l,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new AC(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class sS extends Nn{constructor(t=1,e=1,s=1,i=32,r=1,a=!1,o=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:s,radialSegments:i,heightSegments:r,openEnded:a,thetaStart:o,thetaLength:l};const c=this;i=Math.floor(i),r=Math.floor(r);const h=[],f=[],p=[],g=[];let v=0;const _=[],S=s/2;let b=0;T(),a===!1&&(t>0&&C(!0),e>0&&C(!1)),this.setIndex(h),this.setAttribute("position",new je(f,3)),this.setAttribute("normal",new je(p,3)),this.setAttribute("uv",new je(g,2));function T(){const A=new at,I=new at;let D=0;const F=(e-t)/s;for(let z=0;z<=r;z++){const k=[],O=z/r,L=O*(e-t)+t;for(let H=0;H<=i;H++){const q=H/i,K=q*l+o,Y=Math.sin(K),P=Math.cos(K);I.x=L*Y,I.y=-O*s+S,I.z=L*P,f.push(I.x,I.y,I.z),A.set(Y,F,P).normalize(),p.push(A.x,A.y,A.z),g.push(q,1-O),k.push(v++)}_.push(k)}for(let z=0;z<i;z++)for(let k=0;k<r;k++){const O=_[k][z],L=_[k+1][z],H=_[k+1][z+1],q=_[k][z+1];(t>0||k!==0)&&(h.push(O,L,q),D+=3),(e>0||k!==r-1)&&(h.push(L,H,q),D+=3)}c.addGroup(b,D,0),b+=D}function C(A){const I=v,D=new Yt,F=new at;let z=0;const k=A===!0?t:e,O=A===!0?1:-1;for(let H=1;H<=i;H++)f.push(0,S*O,0),p.push(0,O,0),g.push(.5,.5),v++;const L=v;for(let H=0;H<=i;H++){const K=H/i*l+o,Y=Math.cos(K),P=Math.sin(K);F.x=k*P,F.y=S*O,F.z=k*Y,f.push(F.x,F.y,F.z),p.push(0,O,0),D.x=Y*.5+.5,D.y=P*.5*O+.5,g.push(D.x,D.y),v++}for(let H=0;H<i;H++){const q=I+H,K=L+H;A===!0?h.push(K,K+1,q):h.push(K+1,K,q),z+=3}c.addGroup(b,z,A===!0?1:2),b+=z}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new sS(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class iS extends sS{constructor(t=1,e=1,s=32,i=1,r=!1,a=0,o=Math.PI*2){super(0,t,e,s,i,r,a,o),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:s,heightSegments:i,openEnded:r,thetaStart:a,thetaLength:o}}static fromJSON(t){return new iS(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class up extends Nn{constructor(t=[],e=[],s=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:s,detail:i};const r=[],a=[];o(i),c(s),h(),this.setAttribute("position",new je(r,3)),this.setAttribute("normal",new je(r.slice(),3)),this.setAttribute("uv",new je(a,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function o(T){const C=new at,A=new at,I=new at;for(let D=0;D<e.length;D+=3)g(e[D+0],C),g(e[D+1],A),g(e[D+2],I),l(C,A,I,T)}function l(T,C,A,I){const D=I+1,F=[];for(let z=0;z<=D;z++){F[z]=[];const k=T.clone().lerp(A,z/D),O=C.clone().lerp(A,z/D),L=D-z;for(let H=0;H<=L;H++)H===0&&z===D?F[z][H]=k:F[z][H]=k.clone().lerp(O,H/L)}for(let z=0;z<D;z++)for(let k=0;k<2*(D-z)-1;k++){const O=Math.floor(k/2);k%2===0?(p(F[z][O+1]),p(F[z+1][O]),p(F[z][O])):(p(F[z][O+1]),p(F[z+1][O+1]),p(F[z+1][O]))}}function c(T){const C=new at;for(let A=0;A<r.length;A+=3)C.x=r[A+0],C.y=r[A+1],C.z=r[A+2],C.normalize().multiplyScalar(T),r[A+0]=C.x,r[A+1]=C.y,r[A+2]=C.z}function h(){const T=new at;for(let C=0;C<r.length;C+=3){T.x=r[C+0],T.y=r[C+1],T.z=r[C+2];const A=S(T)/2/Math.PI+.5,I=b(T)/Math.PI+.5;a.push(A,1-I)}v(),f()}function f(){for(let T=0;T<a.length;T+=6){const C=a[T+0],A=a[T+2],I=a[T+4],D=Math.max(C,A,I),F=Math.min(C,A,I);D>.9&&F<.1&&(C<.2&&(a[T+0]+=1),A<.2&&(a[T+2]+=1),I<.2&&(a[T+4]+=1))}}function p(T){r.push(T.x,T.y,T.z)}function g(T,C){const A=T*3;C.x=t[A+0],C.y=t[A+1],C.z=t[A+2]}function v(){const T=new at,C=new at,A=new at,I=new at,D=new Yt,F=new Yt,z=new Yt;for(let k=0,O=0;k<r.length;k+=9,O+=6){T.set(r[k+0],r[k+1],r[k+2]),C.set(r[k+3],r[k+4],r[k+5]),A.set(r[k+6],r[k+7],r[k+8]),D.set(a[O+0],a[O+1]),F.set(a[O+2],a[O+3]),z.set(a[O+4],a[O+5]),I.copy(T).add(C).add(A).divideScalar(3);const L=S(I);_(D,O+0,T,L),_(F,O+2,C,L),_(z,O+4,A,L)}}function _(T,C,A,I){I<0&&T.x===1&&(a[C]=T.x-1),A.x===0&&A.z===0&&(a[C]=I/2/Math.PI+.5)}function S(T){return Math.atan2(T.z,-T.x)}function b(T){return Math.atan2(-T.y,Math.sqrt(T.x*T.x+T.z*T.z))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new up(t.vertices,t.indices,t.radius,t.detail)}}class NC extends up{constructor(t=1,e=0){const s=(1+Math.sqrt(5))/2,i=1/s,r=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-s,0,-i,s,0,i,-s,0,i,s,-i,-s,0,-i,s,0,i,-s,0,i,s,0,-s,0,-i,s,0,-i,-s,0,i,s,0,i],a=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(r,a,t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new NC(t.radius,t.detail)}}const TT=new at,ET=new at,GM=new at,CT=new jo;class b4 extends Nn{constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},t!==null){const i=Math.pow(10,4),r=Math.cos(Qm*e),a=t.getIndex(),o=t.getAttribute("position"),l=a?a.count:o.count,c=[0,0,0],h=["a","b","c"],f=new Array(3),p={},g=[];for(let v=0;v<l;v+=3){a?(c[0]=a.getX(v),c[1]=a.getX(v+1),c[2]=a.getX(v+2)):(c[0]=v,c[1]=v+1,c[2]=v+2);const{a:_,b:S,c:b}=CT;if(_.fromBufferAttribute(o,c[0]),S.fromBufferAttribute(o,c[1]),b.fromBufferAttribute(o,c[2]),CT.getNormal(GM),f[0]=`${Math.round(_.x*i)},${Math.round(_.y*i)},${Math.round(_.z*i)}`,f[1]=`${Math.round(S.x*i)},${Math.round(S.y*i)},${Math.round(S.z*i)}`,f[2]=`${Math.round(b.x*i)},${Math.round(b.y*i)},${Math.round(b.z*i)}`,!(f[0]===f[1]||f[1]===f[2]||f[2]===f[0]))for(let T=0;T<3;T++){const C=(T+1)%3,A=f[T],I=f[C],D=CT[h[T]],F=CT[h[C]],z=`${A}_${I}`,k=`${I}_${A}`;k in p&&p[k]?(GM.dot(p[k].normal)<=r&&(g.push(D.x,D.y,D.z),g.push(F.x,F.y,F.z)),p[k]=null):z in p||(p[z]={index0:c[T],index1:c[C],normal:GM.clone()})}}for(const v in p)if(p[v]){const{index0:_,index1:S}=p[v];TT.fromBufferAttribute(o,_),ET.fromBufferAttribute(o,S),g.push(TT.x,TT.y,TT.z),g.push(ET.x,ET.y,ET.z)}this.setAttribute("position",new je(g,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}class cu{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){Oe("Curve: .getPoint() not implemented.")}getPointAt(t,e){const s=this.getUtoTmapping(t);return this.getPoint(s,e)}getPoints(t=5){const e=[];for(let s=0;s<=t;s++)e.push(this.getPoint(s/t));return e}getSpacedPoints(t=5){const e=[];for(let s=0;s<=t;s++)e.push(this.getPointAt(s/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let s,i=this.getPoint(0),r=0;e.push(0);for(let a=1;a<=t;a++)s=this.getPoint(a/t),r+=s.distanceTo(i),e.push(r),i=s;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e=null){const s=this.getLengths();let i=0;const r=s.length;let a;e?a=e:a=t*s[r-1];let o=0,l=r-1,c;for(;o<=l;)if(i=Math.floor(o+(l-o)/2),c=s[i]-a,c<0)o=i+1;else if(c>0)l=i-1;else{l=i;break}if(i=l,s[i]===a)return i/(r-1);const h=s[i],p=s[i+1]-h,g=(a-h)/p;return(i+g)/(r-1)}getTangent(t,e){let i=t-1e-4,r=t+1e-4;i<0&&(i=0),r>1&&(r=1);const a=this.getPoint(i),o=this.getPoint(r),l=e||(a.isVector2?new Yt:new at);return l.copy(o).sub(a).normalize(),l}getTangentAt(t,e){const s=this.getUtoTmapping(t);return this.getTangent(s,e)}computeFrenetFrames(t,e=!1){const s=new at,i=[],r=[],a=[],o=new at,l=new Tn;for(let g=0;g<=t;g++){const v=g/t;i[g]=this.getTangentAt(v,new at)}r[0]=new at,a[0]=new at;let c=Number.MAX_VALUE;const h=Math.abs(i[0].x),f=Math.abs(i[0].y),p=Math.abs(i[0].z);h<=c&&(c=h,s.set(1,0,0)),f<=c&&(c=f,s.set(0,1,0)),p<=c&&s.set(0,0,1),o.crossVectors(i[0],s).normalize(),r[0].crossVectors(i[0],o),a[0].crossVectors(i[0],r[0]);for(let g=1;g<=t;g++){if(r[g]=r[g-1].clone(),a[g]=a[g-1].clone(),o.crossVectors(i[g-1],i[g]),o.length()>Number.EPSILON){o.normalize();const v=Math.acos(Sn(i[g-1].dot(i[g]),-1,1));r[g].applyMatrix4(l.makeRotationAxis(o,v))}a[g].crossVectors(i[g],r[g])}if(e===!0){let g=Math.acos(Sn(r[0].dot(r[t]),-1,1));g/=t,i[0].dot(o.crossVectors(r[0],r[t]))>0&&(g=-g);for(let v=1;v<=t;v++)r[v].applyMatrix4(l.makeRotationAxis(i[v],g*v)),a[v].crossVectors(i[v],r[v])}return{tangents:i,normals:r,binormals:a}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.7,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class MC extends cu{constructor(t=0,e=0,s=1,i=1,r=0,a=Math.PI*2,o=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=s,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=a,this.aClockwise=o,this.aRotation=l}getPoint(t,e=new Yt){const s=e,i=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const a=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(a?r=0:r=i),this.aClockwise===!0&&!a&&(r===i?r=-i:r=r-i);const o=this.aStartAngle+t*r;let l=this.aX+this.xRadius*Math.cos(o),c=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const h=Math.cos(this.aRotation),f=Math.sin(this.aRotation),p=l-this.aX,g=c-this.aY;l=p*h-g*f+this.aX,c=p*f+g*h+this.aY}return s.set(l,c)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}class S4 extends MC{constructor(t,e,s,i,r,a){super(t,e,s,s,i,r,a),this.isArcCurve=!0,this.type="ArcCurve"}}function i3(){let n=0,t=0,e=0,s=0;function i(r,a,o,l){n=r,t=o,e=-3*r+3*a-2*o-l,s=2*r-2*a+o+l}return{initCatmullRom:function(r,a,o,l,c){i(a,o,c*(o-r),c*(l-a))},initNonuniformCatmullRom:function(r,a,o,l,c,h,f){let p=(a-r)/c-(o-r)/(c+h)+(o-a)/h,g=(o-a)/h-(l-a)/(h+f)+(l-o)/f;p*=h,g*=h,i(a,o,p,g)},calc:function(r){const a=r*r,o=a*r;return n+t*r+e*a+s*o}}}const AT=new at,HM=new i3,WM=new i3,qM=new i3;class _4 extends cu{constructor(t=[],e=!1,s="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=s,this.tension=i}getPoint(t,e=new at){const s=e,i=this.points,r=i.length,a=(r-(this.closed?0:1))*t;let o=Math.floor(a),l=a-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/r)+1)*r:l===0&&o===r-1&&(o=r-2,l=1);let c,h;this.closed||o>0?c=i[(o-1)%r]:(AT.subVectors(i[0],i[1]).add(i[0]),c=AT);const f=i[o%r],p=i[(o+1)%r];if(this.closed||o+2<r?h=i[(o+2)%r]:(AT.subVectors(i[r-1],i[r-2]).add(i[r-1]),h=AT),this.curveType==="centripetal"||this.curveType==="chordal"){const g=this.curveType==="chordal"?.5:.25;let v=Math.pow(c.distanceToSquared(f),g),_=Math.pow(f.distanceToSquared(p),g),S=Math.pow(p.distanceToSquared(h),g);_<1e-4&&(_=1),v<1e-4&&(v=_),S<1e-4&&(S=_),HM.initNonuniformCatmullRom(c.x,f.x,p.x,h.x,v,_,S),WM.initNonuniformCatmullRom(c.y,f.y,p.y,h.y,v,_,S),qM.initNonuniformCatmullRom(c.z,f.z,p.z,h.z,v,_,S)}else this.curveType==="catmullrom"&&(HM.initCatmullRom(c.x,f.x,p.x,h.x,this.tension),WM.initCatmullRom(c.y,f.y,p.y,h.y,this.tension),qM.initCatmullRom(c.z,f.z,p.z,h.z,this.tension));return s.set(HM.calc(l),WM.calc(l),qM.calc(l)),s}copy(t){super.copy(t),this.points=[];for(let e=0,s=t.points.length;e<s;e++){const i=t.points[e];this.points.push(i.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,s=this.points.length;e<s;e++){const i=this.points[e];t.points.push(i.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,s=t.points.length;e<s;e++){const i=t.points[e];this.points.push(new at().fromArray(i))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function NF(n,t,e,s,i){const r=(s-t)*.5,a=(i-e)*.5,o=n*n,l=n*o;return(2*e-2*s+r+a)*l+(-3*e+3*s-2*r-a)*o+r*n+e}function Z7(n,t){const e=1-n;return e*e*t}function Q7(n,t){return 2*(1-n)*n*t}function J7(n,t){return n*n*t}function i1(n,t,e,s){return Z7(n,t)+Q7(n,e)+J7(n,s)}function tK(n,t){const e=1-n;return e*e*e*t}function eK(n,t){const e=1-n;return 3*e*e*n*t}function nK(n,t){return 3*(1-n)*n*n*t}function sK(n,t){return n*n*n*t}function r1(n,t,e,s,i){return tK(n,t)+eK(n,e)+nK(n,s)+sK(n,i)}class r3 extends cu{constructor(t=new Yt,e=new Yt,s=new Yt,i=new Yt){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=s,this.v3=i}getPoint(t,e=new Yt){const s=e,i=this.v0,r=this.v1,a=this.v2,o=this.v3;return s.set(r1(t,i.x,r.x,a.x,o.x),r1(t,i.y,r.y,a.y,o.y)),s}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class w4 extends cu{constructor(t=new at,e=new at,s=new at,i=new at){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=s,this.v3=i}getPoint(t,e=new at){const s=e,i=this.v0,r=this.v1,a=this.v2,o=this.v3;return s.set(r1(t,i.x,r.x,a.x,o.x),r1(t,i.y,r.y,a.y,o.y),r1(t,i.z,r.z,a.z,o.z)),s}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class a3 extends cu{constructor(t=new Yt,e=new Yt){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new Yt){const s=e;return t===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(t).add(this.v1)),s}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new Yt){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class T4 extends cu{constructor(t=new at,e=new at){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=e}getPoint(t,e=new at){const s=e;return t===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(t).add(this.v1)),s}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new at){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class o3 extends cu{constructor(t=new Yt,e=new Yt,s=new Yt){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=s}getPoint(t,e=new Yt){const s=e,i=this.v0,r=this.v1,a=this.v2;return s.set(i1(t,i.x,r.x,a.x),i1(t,i.y,r.y,a.y)),s}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class l3 extends cu{constructor(t=new at,e=new at,s=new at){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=s}getPoint(t,e=new at){const s=e,i=this.v0,r=this.v1,a=this.v2;return s.set(i1(t,i.x,r.x,a.x),i1(t,i.y,r.y,a.y),i1(t,i.z,r.z,a.z)),s}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class c3 extends cu{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,e=new Yt){const s=e,i=this.points,r=(i.length-1)*t,a=Math.floor(r),o=r-a,l=i[a===0?a:a-1],c=i[a],h=i[a>i.length-2?i.length-1:a+1],f=i[a>i.length-3?i.length-1:a+2];return s.set(NF(o,l.x,c.x,h.x,f.x),NF(o,l.y,c.y,h.y,f.y)),s}copy(t){super.copy(t),this.points=[];for(let e=0,s=t.points.length;e<s;e++){const i=t.points[e];this.points.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,s=this.points.length;e<s;e++){const i=this.points[e];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,s=t.points.length;e<s;e++){const i=t.points[e];this.points.push(new Yt().fromArray(i))}return this}}var f2=Object.freeze({__proto__:null,ArcCurve:S4,CatmullRomCurve3:_4,CubicBezierCurve:r3,CubicBezierCurve3:w4,EllipseCurve:MC,LineCurve:a3,LineCurve3:T4,QuadraticBezierCurve:o3,QuadraticBezierCurve3:l3,SplineCurve:c3});class E4 extends cu{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);if(!t.equals(e)){const s=t.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new f2[s](e,t))}return this}getPoint(t,e){const s=t*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=s){const a=i[r]-s,o=this.curves[r],l=o.getLength(),c=l===0?0:1-a/l;return o.getPointAt(c,e)}r++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let s=0,i=this.curves.length;s<i;s++)e+=this.curves[s].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let s=0;s<=t;s++)e.push(this.getPoint(s/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let s;for(let i=0,r=this.curves;i<r.length;i++){const a=r[i],o=a.isEllipseCurve?t*2:a.isLineCurve||a.isLineCurve3?1:a.isSplineCurve?t*a.points.length:t,l=a.getPoints(o);for(let c=0;c<l.length;c++){const h=l[c];s&&s.equals(h)||(e.push(h),s=h)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,s=t.curves.length;e<s;e++){const i=t.curves[e];this.curves.push(i.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,s=this.curves.length;e<s;e++){const i=this.curves[e];t.curves.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,s=t.curves.length;e<s;e++){const i=t.curves[e];this.curves.push(new f2[i.type]().fromJSON(i))}return this}}class d2 extends E4{constructor(t){super(),this.type="Path",this.currentPoint=new Yt,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,s=t.length;e<s;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const s=new a3(this.currentPoint.clone(),new Yt(t,e));return this.curves.push(s),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,s,i){const r=new o3(this.currentPoint.clone(),new Yt(t,e),new Yt(s,i));return this.curves.push(r),this.currentPoint.set(s,i),this}bezierCurveTo(t,e,s,i,r,a){const o=new r3(this.currentPoint.clone(),new Yt(t,e),new Yt(s,i),new Yt(r,a));return this.curves.push(o),this.currentPoint.set(r,a),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),s=new c3(e);return this.curves.push(s),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,s,i,r,a){const o=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(t+o,e+l,s,i,r,a),this}absarc(t,e,s,i,r,a){return this.absellipse(t,e,s,s,i,r,a),this}ellipse(t,e,s,i,r,a,o,l){const c=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(t+c,e+h,s,i,r,a,o,l),this}absellipse(t,e,s,i,r,a,o,l){const c=new MC(t,e,s,i,r,a,o,l);if(this.curves.length>0){const f=c.getPoint(0);f.equals(this.currentPoint)||this.lineTo(f.x,f.y)}this.curves.push(c);const h=c.getPoint(1);return this.currentPoint.copy(h),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class Bd extends d2{constructor(t){super(t),this.uuid=El(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let s=0,i=this.holes.length;s<i;s++)e[s]=this.holes[s].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,s=t.holes.length;e<s;e++){const i=t.holes[e];this.holes.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,s=this.holes.length;e<s;e++){const i=this.holes[e];t.holes.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,s=t.holes.length;e<s;e++){const i=t.holes[e];this.holes.push(new d2().fromJSON(i))}return this}}function iK(n,t,e=2){const s=t&&t.length,i=s?t[0]*e:n.length;let r=C4(n,0,i,e,!0);const a=[];if(!r||r.next===r.prev)return a;let o,l,c;if(s&&(r=cK(n,t,r,e)),n.length>80*e){o=n[0],l=n[1];let h=o,f=l;for(let p=e;p<i;p+=e){const g=n[p],v=n[p+1];g<o&&(o=g),v<l&&(l=v),g>h&&(h=g),v>f&&(f=v)}c=Math.max(h-o,f-l),c=c!==0?32767/c:0}return w1(r,a,e,o,l,c,0),a}function C4(n,t,e,s,i){let r;if(i===bK(n,t,e,s)>0)for(let a=t;a<e;a+=s)r=MF(a/s|0,n[a],n[a+1],r);else for(let a=e-s;a>=t;a-=s)r=MF(a/s|0,n[a],n[a+1],r);return r&&rx(r,r.next)&&(E1(r),r=r.next),r}function cg(n,t){if(!n)return n;t||(t=n);let e=n,s;do if(s=!1,!e.steiner&&(rx(e,e.next)||Di(e.prev,e,e.next)===0)){if(E1(e),e=t=e.prev,e===e.next)break;s=!0}else e=e.next;while(s||e!==t);return t}function w1(n,t,e,s,i,r,a){if(!n)return;!a&&r&&pK(n,s,i,r);let o=n;for(;n.prev!==n.next;){const l=n.prev,c=n.next;if(r?aK(n,s,i,r):rK(n)){t.push(l.i,n.i,c.i),E1(n),n=c.next,o=c.next;continue}if(n=c,n===o){a?a===1?(n=oK(cg(n),t),w1(n,t,e,s,i,r,2)):a===2&&lK(n,t,e,s,i,r):w1(cg(n),t,e,s,i,r,1);break}}}function rK(n){const t=n.prev,e=n,s=n.next;if(Di(t,e,s)>=0)return!1;const i=t.x,r=e.x,a=s.x,o=t.y,l=e.y,c=s.y,h=Math.min(i,r,a),f=Math.min(o,l,c),p=Math.max(i,r,a),g=Math.max(o,l,c);let v=s.next;for(;v!==t;){if(v.x>=h&&v.x<=p&&v.y>=f&&v.y<=g&&Pb(i,o,r,l,a,c,v.x,v.y)&&Di(v.prev,v,v.next)>=0)return!1;v=v.next}return!0}function aK(n,t,e,s){const i=n.prev,r=n,a=n.next;if(Di(i,r,a)>=0)return!1;const o=i.x,l=r.x,c=a.x,h=i.y,f=r.y,p=a.y,g=Math.min(o,l,c),v=Math.min(h,f,p),_=Math.max(o,l,c),S=Math.max(h,f,p),b=sR(g,v,t,e,s),T=sR(_,S,t,e,s);let C=n.prevZ,A=n.nextZ;for(;C&&C.z>=b&&A&&A.z<=T;){if(C.x>=g&&C.x<=_&&C.y>=v&&C.y<=S&&C!==i&&C!==a&&Pb(o,h,l,f,c,p,C.x,C.y)&&Di(C.prev,C,C.next)>=0||(C=C.prevZ,A.x>=g&&A.x<=_&&A.y>=v&&A.y<=S&&A!==i&&A!==a&&Pb(o,h,l,f,c,p,A.x,A.y)&&Di(A.prev,A,A.next)>=0))return!1;A=A.nextZ}for(;C&&C.z>=b;){if(C.x>=g&&C.x<=_&&C.y>=v&&C.y<=S&&C!==i&&C!==a&&Pb(o,h,l,f,c,p,C.x,C.y)&&Di(C.prev,C,C.next)>=0)return!1;C=C.prevZ}for(;A&&A.z<=T;){if(A.x>=g&&A.x<=_&&A.y>=v&&A.y<=S&&A!==i&&A!==a&&Pb(o,h,l,f,c,p,A.x,A.y)&&Di(A.prev,A,A.next)>=0)return!1;A=A.nextZ}return!0}function oK(n,t){let e=n;do{const s=e.prev,i=e.next.next;!rx(s,i)&&N4(s,e,e.next,i)&&T1(s,i)&&T1(i,s)&&(t.push(s.i,e.i,i.i),E1(e),E1(e.next),e=n=i),e=e.next}while(e!==n);return cg(e)}function lK(n,t,e,s,i,r){let a=n;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&yK(a,o)){let l=M4(a,o);a=cg(a,a.next),l=cg(l,l.next),w1(a,t,e,s,i,r,0),w1(l,t,e,s,i,r,0);return}o=o.next}a=a.next}while(a!==n)}function cK(n,t,e,s){const i=[];for(let r=0,a=t.length;r<a;r++){const o=t[r]*s,l=r<a-1?t[r+1]*s:n.length,c=C4(n,o,l,s,!1);c===c.next&&(c.steiner=!0),i.push(gK(c))}i.sort(uK);for(let r=0;r<i.length;r++)e=hK(i[r],e);return e}function uK(n,t){let e=n.x-t.x;if(e===0&&(e=n.y-t.y,e===0)){const s=(n.next.y-n.y)/(n.next.x-n.x),i=(t.next.y-t.y)/(t.next.x-t.x);e=s-i}return e}function hK(n,t){const e=fK(n,t);if(!e)return t;const s=M4(e,n);return cg(s,s.next),cg(e,e.next)}function fK(n,t){let e=t;const s=n.x,i=n.y;let r=-1/0,a;if(rx(n,e))return e;do{if(rx(n,e.next))return e.next;if(i<=e.y&&i>=e.next.y&&e.next.y!==e.y){const f=e.x+(i-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(f<=s&&f>r&&(r=f,a=e.x<e.next.x?e:e.next,f===s))return a}e=e.next}while(e!==t);if(!a)return null;const o=a,l=a.x,c=a.y;let h=1/0;e=a;do{if(s>=e.x&&e.x>=l&&s!==e.x&&A4(i<c?s:r,i,l,c,i<c?r:s,i,e.x,e.y)){const f=Math.abs(i-e.y)/(s-e.x);T1(e,n)&&(f<h||f===h&&(e.x>a.x||e.x===a.x&&dK(a,e)))&&(a=e,h=f)}e=e.next}while(e!==o);return a}function dK(n,t){return Di(n.prev,n,t.prev)<0&&Di(t.next,n,n.next)<0}function pK(n,t,e,s){let i=n;do i.z===0&&(i.z=sR(i.x,i.y,t,e,s)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==n);i.prevZ.nextZ=null,i.prevZ=null,mK(i)}function mK(n){let t,e=1;do{let s=n,i;n=null;let r=null;for(t=0;s;){t++;let a=s,o=0;for(let c=0;c<e&&(o++,a=a.nextZ,!!a);c++);let l=e;for(;o>0||l>0&&a;)o!==0&&(l===0||!a||s.z<=a.z)?(i=s,s=s.nextZ,o--):(i=a,a=a.nextZ,l--),r?r.nextZ=i:n=i,i.prevZ=r,r=i;s=a}r.nextZ=null,e*=2}while(t>1);return n}function sR(n,t,e,s,i){return n=(n-e)*i|0,t=(t-s)*i|0,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,n|t<<1}function gK(n){let t=n,e=n;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==n);return e}function A4(n,t,e,s,i,r,a,o){return(i-a)*(t-o)>=(n-a)*(r-o)&&(n-a)*(s-o)>=(e-a)*(t-o)&&(e-a)*(r-o)>=(i-a)*(s-o)}function Pb(n,t,e,s,i,r,a,o){return!(n===a&&t===o)&&A4(n,t,e,s,i,r,a,o)}function yK(n,t){return n.next.i!==t.i&&n.prev.i!==t.i&&!xK(n,t)&&(T1(n,t)&&T1(t,n)&&vK(n,t)&&(Di(n.prev,n,t.prev)||Di(n,t.prev,t))||rx(n,t)&&Di(n.prev,n,n.next)>0&&Di(t.prev,t,t.next)>0)}function Di(n,t,e){return(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y)}function rx(n,t){return n.x===t.x&&n.y===t.y}function N4(n,t,e,s){const i=MT(Di(n,t,e)),r=MT(Di(n,t,s)),a=MT(Di(e,s,n)),o=MT(Di(e,s,t));return!!(i!==r&&a!==o||i===0&&NT(n,e,t)||r===0&&NT(n,s,t)||a===0&&NT(e,n,s)||o===0&&NT(e,t,s))}function NT(n,t,e){return t.x<=Math.max(n.x,e.x)&&t.x>=Math.min(n.x,e.x)&&t.y<=Math.max(n.y,e.y)&&t.y>=Math.min(n.y,e.y)}function MT(n){return n>0?1:n<0?-1:0}function xK(n,t){let e=n;do{if(e.i!==n.i&&e.next.i!==n.i&&e.i!==t.i&&e.next.i!==t.i&&N4(e,e.next,n,t))return!0;e=e.next}while(e!==n);return!1}function T1(n,t){return Di(n.prev,n,n.next)<0?Di(n,t,n.next)>=0&&Di(n,n.prev,t)>=0:Di(n,t,n.prev)<0||Di(n,n.next,t)<0}function vK(n,t){let e=n,s=!1;const i=(n.x+t.x)/2,r=(n.y+t.y)/2;do e.y>r!=e.next.y>r&&e.next.y!==e.y&&i<(e.next.x-e.x)*(r-e.y)/(e.next.y-e.y)+e.x&&(s=!s),e=e.next;while(e!==n);return s}function M4(n,t){const e=iR(n.i,n.x,n.y),s=iR(t.i,t.x,t.y),i=n.next,r=t.prev;return n.next=t,t.prev=n,e.next=i,i.prev=e,s.next=e,e.prev=s,r.next=s,s.prev=r,s}function MF(n,t,e,s){const i=iR(n,t,e);return s?(i.next=s.next,i.prev=s,s.next.prev=i,s.next=i):(i.prev=i,i.next=i),i}function E1(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function iR(n,t,e){return{i:n,x:t,y:e,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function bK(n,t,e,s){let i=0;for(let r=t,a=e-s;r<e;r+=s)i+=(n[a]-n[r])*(n[r+1]+n[a+1]),a=r;return i}class SK{static triangulate(t,e,s=2){return iK(t,e,s)}}class Zc{static area(t){const e=t.length;let s=0;for(let i=e-1,r=0;r<e;i=r++)s+=t[i].x*t[r].y-t[r].x*t[i].y;return s*.5}static isClockWise(t){return Zc.area(t)<0}static triangulateShape(t,e){const s=[],i=[],r=[];IF(t),RF(s,t);let a=t.length;e.forEach(IF);for(let l=0;l<e.length;l++)i.push(a),a+=e[l].length,RF(s,e[l]);const o=SK.triangulate(s,i);for(let l=0;l<o.length;l+=3)r.push(o.slice(l,l+3));return r}}function IF(n){const t=n.length;t>2&&n[t-1].equals(n[0])&&n.pop()}function RF(n,t){for(let e=0;e<t.length;e++)n.push(t[e].x),n.push(t[e].y)}class IC extends Nn{constructor(t=new Bd([new Yt(.5,.5),new Yt(-.5,.5),new Yt(-.5,-.5),new Yt(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const s=this,i=[],r=[];for(let o=0,l=t.length;o<l;o++){const c=t[o];a(c)}this.setAttribute("position",new je(i,3)),this.setAttribute("uv",new je(r,2)),this.computeVertexNormals();function a(o){const l=[],c=e.curveSegments!==void 0?e.curveSegments:12,h=e.steps!==void 0?e.steps:1,f=e.depth!==void 0?e.depth:1;let p=e.bevelEnabled!==void 0?e.bevelEnabled:!0,g=e.bevelThickness!==void 0?e.bevelThickness:.2,v=e.bevelSize!==void 0?e.bevelSize:g-.1,_=e.bevelOffset!==void 0?e.bevelOffset:0,S=e.bevelSegments!==void 0?e.bevelSegments:3;const b=e.extrudePath,T=e.UVGenerator!==void 0?e.UVGenerator:_K;let C,A=!1,I,D,F,z;if(b){C=b.getSpacedPoints(h),A=!0,p=!1;const Ht=b.isCatmullRomCurve3?b.closed:!1;I=b.computeFrenetFrames(h,Ht),D=new at,F=new at,z=new at}p||(S=0,g=0,v=0,_=0);const k=o.extractPoints(c);let O=k.shape;const L=k.holes;if(!Zc.isClockWise(O)){O=O.reverse();for(let Ht=0,Jt=L.length;Ht<Jt;Ht++){const Xt=L[Ht];Zc.isClockWise(Xt)&&(L[Ht]=Xt.reverse())}}function q(Ht){const Xt=10000000000000001e-36;let ce=Ht[0];for(let rt=1;rt<=Ht.length;rt++){const Fe=rt%Ht.length,he=Ht[Fe],Pe=he.x-ce.x,pe=he.y-ce.y,nt=Pe*Pe+pe*pe,G=Math.max(Math.abs(he.x),Math.abs(he.y),Math.abs(ce.x),Math.abs(ce.y)),vt=Xt*G*G;if(nt<=vt){Ht.splice(Fe,1),rt--;continue}ce=he}}q(O),L.forEach(q);const K=L.length,Y=O;for(let Ht=0;Ht<K;Ht++){const Jt=L[Ht];O=O.concat(Jt)}function P(Ht,Jt,Xt){return Jt||on("ExtrudeGeometry: vec does not exist"),Ht.clone().addScaledVector(Jt,Xt)}const W=O.length;function j(Ht,Jt,Xt){let ce,rt,Fe;const he=Ht.x-Jt.x,Pe=Ht.y-Jt.y,pe=Xt.x-Ht.x,nt=Xt.y-Ht.y,G=he*he+Pe*Pe,vt=he*nt-Pe*pe;if(Math.abs(vt)>Number.EPSILON){const Vt=Math.sqrt(G),te=Math.sqrt(pe*pe+nt*nt),Pt=Jt.x-Pe/Vt,Ue=Jt.y+he/Vt,we=Xt.x-nt/te,ze=Xt.y+pe/te,nn=((we-Pt)*nt-(ze-Ue)*pe)/(he*nt-Pe*pe);ce=Pt+he*nn-Ht.x,rt=Ue+Pe*nn-Ht.y;const ae=ce*ce+rt*rt;if(ae<=2)return new Yt(ce,rt);Fe=Math.sqrt(ae/2)}else{let Vt=!1;he>Number.EPSILON?pe>Number.EPSILON&&(Vt=!0):he<-Number.EPSILON?pe<-Number.EPSILON&&(Vt=!0):Math.sign(Pe)===Math.sign(nt)&&(Vt=!0),Vt?(ce=-Pe,rt=he,Fe=Math.sqrt(G)):(ce=he,rt=Pe,Fe=Math.sqrt(G/2))}return new Yt(ce/Fe,rt/Fe)}const st=[];for(let Ht=0,Jt=Y.length,Xt=Jt-1,ce=Ht+1;Ht<Jt;Ht++,Xt++,ce++)Xt===Jt&&(Xt=0),ce===Jt&&(ce=0),st[Ht]=j(Y[Ht],Y[Xt],Y[ce]);const ot=[];let X,it=st.concat();for(let Ht=0,Jt=K;Ht<Jt;Ht++){const Xt=L[Ht];X=[];for(let ce=0,rt=Xt.length,Fe=rt-1,he=ce+1;ce<rt;ce++,Fe++,he++)Fe===rt&&(Fe=0),he===rt&&(he=0),X[ce]=j(Xt[ce],Xt[Fe],Xt[he]);ot.push(X),it=it.concat(X)}let ct;if(S===0)ct=Zc.triangulateShape(Y,L);else{const Ht=[],Jt=[];for(let Xt=0;Xt<S;Xt++){const ce=Xt/S,rt=g*Math.cos(ce*Math.PI/2),Fe=v*Math.sin(ce*Math.PI/2)+_;for(let he=0,Pe=Y.length;he<Pe;he++){const pe=P(Y[he],st[he],Fe);Qt(pe.x,pe.y,-rt),ce===0&&Ht.push(pe)}for(let he=0,Pe=K;he<Pe;he++){const pe=L[he];X=ot[he];const nt=[];for(let G=0,vt=pe.length;G<vt;G++){const Vt=P(pe[G],X[G],Fe);Qt(Vt.x,Vt.y,-rt),ce===0&&nt.push(Vt)}ce===0&&Jt.push(nt)}}ct=Zc.triangulateShape(Ht,Jt)}const yt=ct.length,Rt=v+_;for(let Ht=0;Ht<W;Ht++){const Jt=p?P(O[Ht],it[Ht],Rt):O[Ht];A?(F.copy(I.normals[0]).multiplyScalar(Jt.x),D.copy(I.binormals[0]).multiplyScalar(Jt.y),z.copy(C[0]).add(F).add(D),Qt(z.x,z.y,z.z)):Qt(Jt.x,Jt.y,0)}for(let Ht=1;Ht<=h;Ht++)for(let Jt=0;Jt<W;Jt++){const Xt=p?P(O[Jt],it[Jt],Rt):O[Jt];A?(F.copy(I.normals[Ht]).multiplyScalar(Xt.x),D.copy(I.binormals[Ht]).multiplyScalar(Xt.y),z.copy(C[Ht]).add(F).add(D),Qt(z.x,z.y,z.z)):Qt(Xt.x,Xt.y,f/h*Ht)}for(let Ht=S-1;Ht>=0;Ht--){const Jt=Ht/S,Xt=g*Math.cos(Jt*Math.PI/2),ce=v*Math.sin(Jt*Math.PI/2)+_;for(let rt=0,Fe=Y.length;rt<Fe;rt++){const he=P(Y[rt],st[rt],ce);Qt(he.x,he.y,f+Xt)}for(let rt=0,Fe=L.length;rt<Fe;rt++){const he=L[rt];X=ot[rt];for(let Pe=0,pe=he.length;Pe<pe;Pe++){const nt=P(he[Pe],X[Pe],ce);A?Qt(nt.x,nt.y+C[h-1].y,C[h-1].x+Xt):Qt(nt.x,nt.y,f+Xt)}}}ft(),_t();function ft(){const Ht=i.length/3;if(p){let Jt=0,Xt=W*Jt;for(let ce=0;ce<yt;ce++){const rt=ct[ce];se(rt[2]+Xt,rt[1]+Xt,rt[0]+Xt)}Jt=h+S*2,Xt=W*Jt;for(let ce=0;ce<yt;ce++){const rt=ct[ce];se(rt[0]+Xt,rt[1]+Xt,rt[2]+Xt)}}else{for(let Jt=0;Jt<yt;Jt++){const Xt=ct[Jt];se(Xt[2],Xt[1],Xt[0])}for(let Jt=0;Jt<yt;Jt++){const Xt=ct[Jt];se(Xt[0]+W*h,Xt[1]+W*h,Xt[2]+W*h)}}s.addGroup(Ht,i.length/3-Ht,0)}function _t(){const Ht=i.length/3;let Jt=0;qt(Y,Jt),Jt+=Y.length;for(let Xt=0,ce=L.length;Xt<ce;Xt++){const rt=L[Xt];qt(rt,Jt),Jt+=rt.length}s.addGroup(Ht,i.length/3-Ht,1)}function qt(Ht,Jt){let Xt=Ht.length;for(;--Xt>=0;){const ce=Xt;let rt=Xt-1;rt<0&&(rt=Ht.length-1);for(let Fe=0,he=h+S*2;Fe<he;Fe++){const Pe=W*Fe,pe=W*(Fe+1),nt=Jt+ce+Pe,G=Jt+rt+Pe,vt=Jt+rt+pe,Vt=Jt+ce+pe;Ee(nt,G,vt,Vt)}}}function Qt(Ht,Jt,Xt){l.push(Ht),l.push(Jt),l.push(Xt)}function se(Ht,Jt,Xt){He(Ht),He(Jt),He(Xt);const ce=i.length/3,rt=T.generateTopUV(s,i,ce-3,ce-2,ce-1);Ae(rt[0]),Ae(rt[1]),Ae(rt[2])}function Ee(Ht,Jt,Xt,ce){He(Ht),He(Jt),He(ce),He(Jt),He(Xt),He(ce);const rt=i.length/3,Fe=T.generateSideWallUV(s,i,rt-6,rt-3,rt-2,rt-1);Ae(Fe[0]),Ae(Fe[1]),Ae(Fe[3]),Ae(Fe[1]),Ae(Fe[2]),Ae(Fe[3])}function He(Ht){i.push(l[Ht*3+0]),i.push(l[Ht*3+1]),i.push(l[Ht*3+2])}function Ae(Ht){r.push(Ht.x),r.push(Ht.y)}}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON(),e=this.parameters.shapes,s=this.parameters.options;return wK(e,s,t)}static fromJSON(t,e){const s=[];for(let r=0,a=t.shapes.length;r<a;r++){const o=e[t.shapes[r]];s.push(o)}const i=t.options.extrudePath;return i!==void 0&&(t.options.extrudePath=new f2[i.type]().fromJSON(i)),new IC(s,t.options)}}const _K={generateTopUV:function(n,t,e,s,i){const r=t[e*3],a=t[e*3+1],o=t[s*3],l=t[s*3+1],c=t[i*3],h=t[i*3+1];return[new Yt(r,a),new Yt(o,l),new Yt(c,h)]},generateSideWallUV:function(n,t,e,s,i,r){const a=t[e*3],o=t[e*3+1],l=t[e*3+2],c=t[s*3],h=t[s*3+1],f=t[s*3+2],p=t[i*3],g=t[i*3+1],v=t[i*3+2],_=t[r*3],S=t[r*3+1],b=t[r*3+2];return Math.abs(o-h)<Math.abs(a-c)?[new Yt(a,1-l),new Yt(c,1-f),new Yt(p,1-v),new Yt(_,1-b)]:[new Yt(o,1-l),new Yt(h,1-f),new Yt(g,1-v),new Yt(S,1-b)]}};function wK(n,t,e){if(e.shapes=[],Array.isArray(n))for(let s=0,i=n.length;s<i;s++){const r=n[s];e.shapes.push(r.uuid)}else e.shapes.push(n.uuid);return e.options=Object.assign({},t),t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}class RC extends up{constructor(t=1,e=0){const s=(1+Math.sqrt(5))/2,i=[-1,s,0,1,s,0,-1,-s,0,1,-s,0,0,-1,s,0,1,s,0,-1,-s,0,1,-s,s,0,-1,s,0,1,-s,0,-1,-s,0,1],r=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,r,t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new RC(t.radius,t.detail)}}class DC extends Nn{constructor(t=[new Yt(0,-.5),new Yt(.5,0),new Yt(0,.5)],e=12,s=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:s,phiLength:i},e=Math.floor(e),i=Sn(i,0,Math.PI*2);const r=[],a=[],o=[],l=[],c=[],h=1/e,f=new at,p=new Yt,g=new at,v=new at,_=new at;let S=0,b=0;for(let T=0;T<=t.length-1;T++)switch(T){case 0:S=t[T+1].x-t[T].x,b=t[T+1].y-t[T].y,g.x=b*1,g.y=-S,g.z=b*0,_.copy(g),g.normalize(),l.push(g.x,g.y,g.z);break;case t.length-1:l.push(_.x,_.y,_.z);break;default:S=t[T+1].x-t[T].x,b=t[T+1].y-t[T].y,g.x=b*1,g.y=-S,g.z=b*0,v.copy(g),g.x+=_.x,g.y+=_.y,g.z+=_.z,g.normalize(),l.push(g.x,g.y,g.z),_.copy(v)}for(let T=0;T<=e;T++){const C=s+T*h*i,A=Math.sin(C),I=Math.cos(C);for(let D=0;D<=t.length-1;D++){f.x=t[D].x*A,f.y=t[D].y,f.z=t[D].x*I,a.push(f.x,f.y,f.z),p.x=T/e,p.y=D/(t.length-1),o.push(p.x,p.y);const F=l[3*D+0]*A,z=l[3*D+1],k=l[3*D+0]*I;c.push(F,z,k)}}for(let T=0;T<e;T++)for(let C=0;C<t.length-1;C++){const A=C+T*t.length,I=A,D=A+t.length,F=A+t.length+1,z=A+1;r.push(I,D,z),r.push(F,z,D)}this.setIndex(r),this.setAttribute("position",new je(a,3)),this.setAttribute("uv",new je(o,2)),this.setAttribute("normal",new je(c,3))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new DC(t.points,t.segments,t.phiStart,t.phiLength)}}class rS extends up{constructor(t=1,e=0){const s=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(s,i,t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new rS(t.radius,t.detail)}}class Ex extends Nn{constructor(t=1,e=1,s=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:s,heightSegments:i};const r=t/2,a=e/2,o=Math.floor(s),l=Math.floor(i),c=o+1,h=l+1,f=t/o,p=e/l,g=[],v=[],_=[],S=[];for(let b=0;b<h;b++){const T=b*p-a;for(let C=0;C<c;C++){const A=C*f-r;v.push(A,-T,0),_.push(0,0,1),S.push(C/o),S.push(1-b/l)}}for(let b=0;b<l;b++)for(let T=0;T<o;T++){const C=T+c*b,A=T+c*(b+1),I=T+1+c*(b+1),D=T+1+c*b;g.push(C,A,D),g.push(A,I,D)}this.setIndex(g),this.setAttribute("position",new je(v,3)),this.setAttribute("normal",new je(_,3)),this.setAttribute("uv",new je(S,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Ex(t.width,t.height,t.widthSegments,t.heightSegments)}}class kC extends Nn{constructor(t=.5,e=1,s=32,i=1,r=0,a=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:s,phiSegments:i,thetaStart:r,thetaLength:a},s=Math.max(3,s),i=Math.max(1,i);const o=[],l=[],c=[],h=[];let f=t;const p=(e-t)/i,g=new at,v=new Yt;for(let _=0;_<=i;_++){for(let S=0;S<=s;S++){const b=r+S/s*a;g.x=f*Math.cos(b),g.y=f*Math.sin(b),l.push(g.x,g.y,g.z),c.push(0,0,1),v.x=(g.x/e+1)/2,v.y=(g.y/e+1)/2,h.push(v.x,v.y)}f+=p}for(let _=0;_<i;_++){const S=_*(s+1);for(let b=0;b<s;b++){const T=b+S,C=T,A=T+s+1,I=T+s+2,D=T+1;o.push(C,A,D),o.push(A,I,D)}}this.setIndex(o),this.setAttribute("position",new je(l,3)),this.setAttribute("normal",new je(c,3)),this.setAttribute("uv",new je(h,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new kC(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class OC extends Nn{constructor(t=new Bd([new Yt(0,.5),new Yt(-.5,-.5),new Yt(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const s=[],i=[],r=[],a=[];let o=0,l=0;if(Array.isArray(t)===!1)c(t);else for(let h=0;h<t.length;h++)c(t[h]),this.addGroup(o,l,h),o+=l,l=0;this.setIndex(s),this.setAttribute("position",new je(i,3)),this.setAttribute("normal",new je(r,3)),this.setAttribute("uv",new je(a,2));function c(h){const f=i.length/3,p=h.extractPoints(e);let g=p.shape;const v=p.holes;Zc.isClockWise(g)===!1&&(g=g.reverse());for(let S=0,b=v.length;S<b;S++){const T=v[S];Zc.isClockWise(T)===!0&&(v[S]=T.reverse())}const _=Zc.triangulateShape(g,v);for(let S=0,b=v.length;S<b;S++){const T=v[S];g=g.concat(T)}for(let S=0,b=g.length;S<b;S++){const T=g[S];i.push(T.x,T.y,0),r.push(0,0,1),a.push(T.x,T.y)}for(let S=0,b=_.length;S<b;S++){const T=_[S],C=T[0]+f,A=T[1]+f,I=T[2]+f;s.push(C,A,I),l+=3}}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON(),e=this.parameters.shapes;return TK(e,t)}static fromJSON(t,e){const s=[];for(let i=0,r=t.shapes.length;i<r;i++){const a=e[t.shapes[i]];s.push(a)}return new OC(s,t.curveSegments)}}function TK(n,t){if(t.shapes=[],Array.isArray(n))for(let e=0,s=n.length;e<s;e++){const i=n[e];t.shapes.push(i.uuid)}else t.shapes.push(n.uuid);return t}class aS extends Nn{constructor(t=1,e=32,s=16,i=0,r=Math.PI*2,a=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:s,phiStart:i,phiLength:r,thetaStart:a,thetaLength:o},e=Math.max(3,Math.floor(e)),s=Math.max(2,Math.floor(s));const l=Math.min(a+o,Math.PI);let c=0;const h=[],f=new at,p=new at,g=[],v=[],_=[],S=[];for(let b=0;b<=s;b++){const T=[],C=b/s;let A=0;b===0&&a===0?A=.5/e:b===s&&l===Math.PI&&(A=-.5/e);for(let I=0;I<=e;I++){const D=I/e;f.x=-t*Math.cos(i+D*r)*Math.sin(a+C*o),f.y=t*Math.cos(a+C*o),f.z=t*Math.sin(i+D*r)*Math.sin(a+C*o),v.push(f.x,f.y,f.z),p.copy(f).normalize(),_.push(p.x,p.y,p.z),S.push(D+A,1-C),T.push(c++)}h.push(T)}for(let b=0;b<s;b++)for(let T=0;T<e;T++){const C=h[b][T+1],A=h[b][T],I=h[b+1][T],D=h[b+1][T+1];(b!==0||a>0)&&g.push(C,A,D),(b!==s-1||l<Math.PI)&&g.push(A,I,D)}this.setIndex(g),this.setAttribute("position",new je(v,3)),this.setAttribute("normal",new je(_,3)),this.setAttribute("uv",new je(S,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new aS(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class $C extends up{constructor(t=1,e=0){const s=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(s,i,t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new $C(t.radius,t.detail)}}class LC extends Nn{constructor(t=1,e=.4,s=12,i=48,r=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:s,tubularSegments:i,arc:r},s=Math.floor(s),i=Math.floor(i);const a=[],o=[],l=[],c=[],h=new at,f=new at,p=new at;for(let g=0;g<=s;g++)for(let v=0;v<=i;v++){const _=v/i*r,S=g/s*Math.PI*2;f.x=(t+e*Math.cos(S))*Math.cos(_),f.y=(t+e*Math.cos(S))*Math.sin(_),f.z=e*Math.sin(S),o.push(f.x,f.y,f.z),h.x=t*Math.cos(_),h.y=t*Math.sin(_),p.subVectors(f,h).normalize(),l.push(p.x,p.y,p.z),c.push(v/i),c.push(g/s)}for(let g=1;g<=s;g++)for(let v=1;v<=i;v++){const _=(i+1)*g+v-1,S=(i+1)*(g-1)+v-1,b=(i+1)*(g-1)+v,T=(i+1)*g+v;a.push(_,S,T),a.push(S,b,T)}this.setIndex(a),this.setAttribute("position",new je(o,3)),this.setAttribute("normal",new je(l,3)),this.setAttribute("uv",new je(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new LC(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class FC extends Nn{constructor(t=1,e=.4,s=64,i=8,r=2,a=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:s,radialSegments:i,p:r,q:a},s=Math.floor(s),i=Math.floor(i);const o=[],l=[],c=[],h=[],f=new at,p=new at,g=new at,v=new at,_=new at,S=new at,b=new at;for(let C=0;C<=s;++C){const A=C/s*r*Math.PI*2;T(A,r,a,t,g),T(A+.01,r,a,t,v),S.subVectors(v,g),b.addVectors(v,g),_.crossVectors(S,b),b.crossVectors(_,S),_.normalize(),b.normalize();for(let I=0;I<=i;++I){const D=I/i*Math.PI*2,F=-e*Math.cos(D),z=e*Math.sin(D);f.x=g.x+(F*b.x+z*_.x),f.y=g.y+(F*b.y+z*_.y),f.z=g.z+(F*b.z+z*_.z),l.push(f.x,f.y,f.z),p.subVectors(f,g).normalize(),c.push(p.x,p.y,p.z),h.push(C/s),h.push(I/i)}}for(let C=1;C<=s;C++)for(let A=1;A<=i;A++){const I=(i+1)*(C-1)+(A-1),D=(i+1)*C+(A-1),F=(i+1)*C+A,z=(i+1)*(C-1)+A;o.push(I,D,z),o.push(D,F,z)}this.setIndex(o),this.setAttribute("position",new je(l,3)),this.setAttribute("normal",new je(c,3)),this.setAttribute("uv",new je(h,2));function T(C,A,I,D,F){const z=Math.cos(C),k=Math.sin(C),O=I/A*C,L=Math.cos(O);F.x=D*(2+L)*.5*z,F.y=D*(2+L)*k*.5,F.z=D*Math.sin(O)*.5}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new FC(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class zC extends Nn{constructor(t=new l3(new at(-1,-1,0),new at(-1,1,0),new at(1,1,0)),e=64,s=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:s,radialSegments:i,closed:r};const a=t.computeFrenetFrames(e,r);this.tangents=a.tangents,this.normals=a.normals,this.binormals=a.binormals;const o=new at,l=new at,c=new Yt;let h=new at;const f=[],p=[],g=[],v=[];_(),this.setIndex(v),this.setAttribute("position",new je(f,3)),this.setAttribute("normal",new je(p,3)),this.setAttribute("uv",new je(g,2));function _(){for(let C=0;C<e;C++)S(C);S(r===!1?e:0),T(),b()}function S(C){h=t.getPointAt(C/e,h);const A=a.normals[C],I=a.binormals[C];for(let D=0;D<=i;D++){const F=D/i*Math.PI*2,z=Math.sin(F),k=-Math.cos(F);l.x=k*A.x+z*I.x,l.y=k*A.y+z*I.y,l.z=k*A.z+z*I.z,l.normalize(),p.push(l.x,l.y,l.z),o.x=h.x+s*l.x,o.y=h.y+s*l.y,o.z=h.z+s*l.z,f.push(o.x,o.y,o.z)}}function b(){for(let C=1;C<=e;C++)for(let A=1;A<=i;A++){const I=(i+1)*(C-1)+(A-1),D=(i+1)*C+(A-1),F=(i+1)*C+A,z=(i+1)*(C-1)+A;v.push(I,D,z),v.push(D,F,z)}}function T(){for(let C=0;C<=e;C++)for(let A=0;A<=i;A++)c.x=C/e,c.y=A/i,g.push(c.x,c.y)}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new zC(new f2[t.path.type]().fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class I4 extends Nn{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},t!==null){const e=[],s=new Set,i=new at,r=new at;if(t.index!==null){const a=t.attributes.position,o=t.index;let l=t.groups;l.length===0&&(l=[{start:0,count:o.count,materialIndex:0}]);for(let c=0,h=l.length;c<h;++c){const f=l[c],p=f.start,g=f.count;for(let v=p,_=p+g;v<_;v+=3)for(let S=0;S<3;S++){const b=o.getX(v+S),T=o.getX(v+(S+1)%3);i.fromBufferAttribute(a,b),r.fromBufferAttribute(a,T),DF(i,r,s)===!0&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}}else{const a=t.attributes.position;for(let o=0,l=a.count/3;o<l;o++)for(let c=0;c<3;c++){const h=3*o+c,f=3*o+(c+1)%3;i.fromBufferAttribute(a,h),r.fromBufferAttribute(a,f),DF(i,r,s)===!0&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}this.setAttribute("position",new je(e,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}function DF(n,t,e){const s=`${n.x},${n.y},${n.z}-${t.x},${t.y},${t.z}`,i=`${t.x},${t.y},${t.z}-${n.x},${n.y},${n.z}`;return e.has(s)===!0||e.has(i)===!0?!1:(e.add(s),e.add(i),!0)}var kF=Object.freeze({__proto__:null,BoxGeometry:$g,CapsuleGeometry:CC,CircleGeometry:AC,ConeGeometry:iS,CylinderGeometry:sS,DodecahedronGeometry:NC,EdgesGeometry:b4,ExtrudeGeometry:IC,IcosahedronGeometry:RC,LatheGeometry:DC,OctahedronGeometry:rS,PlaneGeometry:Ex,PolyhedronGeometry:up,RingGeometry:kC,ShapeGeometry:OC,SphereGeometry:aS,TetrahedronGeometry:$C,TorusGeometry:LC,TorusKnotGeometry:FC,TubeGeometry:zC,WireframeGeometry:I4});class R4 extends Jr{constructor(t){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new ke(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}}class u3 extends ar{constructor(t){super(t),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class h3 extends Jr{constructor(t){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new ke(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ke(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=lp,this.normalScale=new Yt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ml,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class D4 extends h3{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Yt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Sn(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new ke(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new ke(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new ke(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get dispersion(){return this._dispersion}set dispersion(t){this._dispersion>0!=t>0&&this.version++,this._dispersion=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.dispersion=t.dispersion,this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class k4 extends Jr{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new ke(16777215),this.specular=new ke(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ke(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=lp,this.normalScale=new Yt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ml,this.combine=tS,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class O4 extends Jr{constructor(t){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new ke(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ke(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=lp,this.normalScale=new Yt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class f3 extends Jr{constructor(t){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=lp,this.normalScale=new Yt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}class $4 extends Jr{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new ke(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ke(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=lp,this.normalScale=new Yt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ml,this.combine=tS,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class d3 extends Jr{constructor(t){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=op,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class p3 extends Jr{constructor(t){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}class L4 extends Jr{constructor(t){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new ke(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=lp,this.normalScale=new Yt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this.fog=t.fog,this}}class F4 extends Ao{constructor(t){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}function Wm(n,t){return!n||n.constructor===t?n:typeof t.BYTES_PER_ELEMENT=="number"?new t(n):Array.prototype.slice.call(n)}function z4(n){function t(i,r){return n[i]-n[r]}const e=n.length,s=new Array(e);for(let i=0;i!==e;++i)s[i]=i;return s.sort(t),s}function rR(n,t,e){const s=n.length,i=new n.constructor(s);for(let r=0,a=0;a!==s;++r){const o=e[r]*t;for(let l=0;l!==t;++l)i[a++]=n[o+l]}return i}function m3(n,t,e,s){let i=1,r=n[0];for(;r!==void 0&&r[s]===void 0;)r=n[i++];if(r===void 0)return;let a=r[s];if(a!==void 0)if(Array.isArray(a))do a=r[s],a!==void 0&&(t.push(r.time),e.push(...a)),r=n[i++];while(r!==void 0);else if(a.toArray!==void 0)do a=r[s],a!==void 0&&(t.push(r.time),a.toArray(e,e.length)),r=n[i++];while(r!==void 0);else do a=r[s],a!==void 0&&(t.push(r.time),e.push(a)),r=n[i++];while(r!==void 0)}function EK(n,t,e,s,i=30){const r=n.clone();r.name=t;const a=[];for(let l=0;l<r.tracks.length;++l){const c=r.tracks[l],h=c.getValueSize(),f=[],p=[];for(let g=0;g<c.times.length;++g){const v=c.times[g]*i;if(!(v<e||v>=s)){f.push(c.times[g]);for(let _=0;_<h;++_)p.push(c.values[g*h+_])}}f.length!==0&&(c.times=Wm(f,c.times.constructor),c.values=Wm(p,c.values.constructor),a.push(c))}r.tracks=a;let o=1/0;for(let l=0;l<r.tracks.length;++l)o>r.tracks[l].times[0]&&(o=r.tracks[l].times[0]);for(let l=0;l<r.tracks.length;++l)r.tracks[l].shift(-1*o);return r.resetDuration(),r}function CK(n,t=0,e=n,s=30){s<=0&&(s=30);const i=e.tracks.length,r=t/s;for(let a=0;a<i;++a){const o=e.tracks[a],l=o.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(b){return b.name===o.name&&b.ValueTypeName===l});if(c===void 0)continue;let h=0;const f=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=f/3);let p=0;const g=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(p=g/3);const v=o.times.length-1;let _;if(r<=o.times[0]){const b=h,T=f-h;_=o.values.slice(b,T)}else if(r>=o.times[v]){const b=v*f+h,T=b+f-h;_=o.values.slice(b,T)}else{const b=o.createInterpolant(),T=h,C=f-h;b.evaluate(r),_=b.resultBuffer.slice(T,C)}l==="quaternion"&&new Va().fromArray(_).normalize().conjugate().toArray(_);const S=c.times.length;for(let b=0;b<S;++b){const T=b*g+p;if(l==="quaternion")Va.multiplyQuaternionsFlat(c.values,T,_,0,c.values,T);else{const C=g-p*2;for(let A=0;A<C;++A)c.values[T+A]-=_[A]}}}return n.blendMode=jD,n}class AK{static convertArray(t,e){return Wm(t,e)}static isTypedArray(t){return e4(t)}static getKeyframeOrder(t){return z4(t)}static sortedArray(t,e,s){return rR(t,e,s)}static flattenJSON(t,e,s,i){m3(t,e,s,i)}static subclip(t,e,s,i,r=30){return EK(t,e,s,i,r)}static makeClipAdditive(t,e=0,s=t,i=30){return CK(t,e,s,i)}}class oS{constructor(t,e,s,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new e.constructor(s),this.sampleValues=e,this.valueSize=s,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let s=this._cachedIndex,i=e[s],r=e[s-1];t:{e:{let a;n:{s:if(!(t<i)){for(let o=s+2;;){if(i===void 0){if(t<r)break s;return s=e.length,this._cachedIndex=s,this.copySampleValue_(s-1)}if(s===o)break;if(r=i,i=e[++s],t<i)break e}a=e.length;break n}if(!(t>=r)){const o=e[1];t<o&&(s=2,r=o);for(let l=s-2;;){if(r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===l)break;if(i=r,r=e[--s-1],t>=r)break e}a=s,s=0;break n}break t}for(;s<a;){const o=s+a>>>1;t<e[o]?a=o:s=o+1}if(i=e[s],r=e[s-1],r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return s=e.length,this._cachedIndex=s,this.copySampleValue_(s-1)}this._cachedIndex=s,this.intervalChanged_(s,r,i)}return this.interpolate_(s,r,t,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,s=this.sampleValues,i=this.valueSize,r=t*i;for(let a=0;a!==i;++a)e[a]=s[r+a];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class U4 extends oS{constructor(t,e,s,i){super(t,e,s,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Gm,endingEnd:Gm}}intervalChanged_(t,e,s){const i=this.parameterPositions;let r=t-2,a=t+1,o=i[r],l=i[a];if(o===void 0)switch(this.getSettings_().endingStart){case Hm:r=t,o=2*e-s;break;case y1:r=i.length-2,o=e+i[r]-i[r+1];break;default:r=t,o=s}if(l===void 0)switch(this.getSettings_().endingEnd){case Hm:a=t,l=2*s-e;break;case y1:a=1,l=s+i[1]-i[0];break;default:a=t-1,l=e}const c=(s-e)*.5,h=this.valueSize;this._weightPrev=c/(e-o),this._weightNext=c/(l-s),this._offsetPrev=r*h,this._offsetNext=a*h}interpolate_(t,e,s,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=t*o,c=l-o,h=this._offsetPrev,f=this._offsetNext,p=this._weightPrev,g=this._weightNext,v=(s-e)/(i-e),_=v*v,S=_*v,b=-p*S+2*p*_-p*v,T=(1+p)*S+(-1.5-2*p)*_+(-.5+p)*v+1,C=(-1-g)*S+(1.5+g)*_+.5*v,A=g*S-g*_;for(let I=0;I!==o;++I)r[I]=b*a[h+I]+T*a[c+I]+C*a[l+I]+A*a[f+I];return r}}class g3 extends oS{constructor(t,e,s,i){super(t,e,s,i)}interpolate_(t,e,s,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=t*o,c=l-o,h=(s-e)/(i-e),f=1-h;for(let p=0;p!==o;++p)r[p]=a[c+p]*f+a[l+p]*h;return r}}class B4 extends oS{constructor(t,e,s,i){super(t,e,s,i)}interpolate_(t){return this.copySampleValue_(t-1)}}class fc{constructor(t,e,s,i){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Wm(e,this.TimeBufferType),this.values=Wm(s,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let s;if(e.toJSON!==this.toJSON)s=e.toJSON(t);else{s={name:t.name,times:Wm(t.times,Array),values:Wm(t.values,Array)};const i=t.getInterpolation();i!==t.DefaultInterpolation&&(s.interpolation=i)}return s.type=t.ValueTypeName,s}InterpolantFactoryMethodDiscrete(t){return new B4(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new g3(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new U4(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case g1:e=this.InterpolantFactoryMethodDiscrete;break;case c2:e=this.InterpolantFactoryMethodLinear;break;case iE:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const s="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(s);return Oe("KeyframeTrack:",s),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return g1;case this.InterpolantFactoryMethodLinear:return c2;case this.InterpolantFactoryMethodSmooth:return iE}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let s=0,i=e.length;s!==i;++s)e[s]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let s=0,i=e.length;s!==i;++s)e[s]*=t}return this}trim(t,e){const s=this.times,i=s.length;let r=0,a=i-1;for(;r!==i&&s[r]<t;)++r;for(;a!==-1&&s[a]>e;)--a;if(++a,r!==0||a!==i){r>=a&&(a=Math.max(a,1),r=a-1);const o=this.getValueSize();this.times=s.slice(r,a),this.values=this.values.slice(r*o,a*o)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(on("KeyframeTrack: Invalid value size in track.",this),t=!1);const s=this.times,i=this.values,r=s.length;r===0&&(on("KeyframeTrack: Track is empty.",this),t=!1);let a=null;for(let o=0;o!==r;o++){const l=s[o];if(typeof l=="number"&&isNaN(l)){on("KeyframeTrack: Time is not a valid number.",this,o,l),t=!1;break}if(a!==null&&a>l){on("KeyframeTrack: Out of order keys.",this,o,l,a),t=!1;break}a=l}if(i!==void 0&&e4(i))for(let o=0,l=i.length;o!==l;++o){const c=i[o];if(isNaN(c)){on("KeyframeTrack: Value is not a valid number.",this,o,c),t=!1;break}}return t}optimize(){const t=this.times.slice(),e=this.values.slice(),s=this.getValueSize(),i=this.getInterpolation()===iE,r=t.length-1;let a=1;for(let o=1;o<r;++o){let l=!1;const c=t[o],h=t[o+1];if(c!==h&&(o!==1||c!==t[0]))if(i)l=!0;else{const f=o*s,p=f-s,g=f+s;for(let v=0;v!==s;++v){const _=e[f+v];if(_!==e[p+v]||_!==e[g+v]){l=!0;break}}}if(l){if(o!==a){t[a]=t[o];const f=o*s,p=a*s;for(let g=0;g!==s;++g)e[p+g]=e[f+g]}++a}}if(r>0){t[a]=t[r];for(let o=r*s,l=a*s,c=0;c!==s;++c)e[l+c]=e[o+c];++a}return a!==t.length?(this.times=t.slice(0,a),this.values=e.slice(0,a*s)):(this.times=t,this.values=e),this}clone(){const t=this.times.slice(),e=this.values.slice(),s=this.constructor,i=new s(this.name,t,e);return i.createInterpolant=this.createInterpolant,i}}fc.prototype.ValueTypeName="";fc.prototype.TimeBufferType=Float32Array;fc.prototype.ValueBufferType=Float32Array;fc.prototype.DefaultInterpolation=c2;class Lg extends fc{constructor(t,e,s){super(t,e,s)}}Lg.prototype.ValueTypeName="bool";Lg.prototype.ValueBufferType=Array;Lg.prototype.DefaultInterpolation=g1;Lg.prototype.InterpolantFactoryMethodLinear=void 0;Lg.prototype.InterpolantFactoryMethodSmooth=void 0;class y3 extends fc{constructor(t,e,s,i){super(t,e,s,i)}}y3.prototype.ValueTypeName="color";class C1 extends fc{constructor(t,e,s,i){super(t,e,s,i)}}C1.prototype.ValueTypeName="number";class P4 extends oS{constructor(t,e,s,i){super(t,e,s,i)}interpolate_(t,e,s,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=(s-e)/(i-e);let c=t*o;for(let h=c+o;c!==h;c+=4)Va.slerpFlat(r,0,a,c-o,a,c,l);return r}}class lS extends fc{constructor(t,e,s,i){super(t,e,s,i)}InterpolantFactoryMethodLinear(t){return new P4(this.times,this.values,this.getValueSize(),t)}}lS.prototype.ValueTypeName="quaternion";lS.prototype.InterpolantFactoryMethodSmooth=void 0;class Fg extends fc{constructor(t,e,s){super(t,e,s)}}Fg.prototype.ValueTypeName="string";Fg.prototype.ValueBufferType=Array;Fg.prototype.DefaultInterpolation=g1;Fg.prototype.InterpolantFactoryMethodLinear=void 0;Fg.prototype.InterpolantFactoryMethodSmooth=void 0;class A1 extends fc{constructor(t,e,s,i){super(t,e,s,i)}}A1.prototype.ValueTypeName="vector";class N1{constructor(t="",e=-1,s=[],i=pC){this.name=t,this.tracks=s,this.duration=e,this.blendMode=i,this.uuid=El(),this.userData={},this.duration<0&&this.resetDuration()}static parse(t){const e=[],s=t.tracks,i=1/(t.fps||1);for(let a=0,o=s.length;a!==o;++a)e.push(MK(s[a]).scale(i));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r.userData=JSON.parse(t.userData||"{}"),r}static toJSON(t){const e=[],s=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode,userData:JSON.stringify(t.userData)};for(let r=0,a=s.length;r!==a;++r)e.push(fc.toJSON(s[r]));return i}static CreateFromMorphTargetSequence(t,e,s,i){const r=e.length,a=[];for(let o=0;o<r;o++){let l=[],c=[];l.push((o+r-1)%r,o,(o+1)%r),c.push(0,1,0);const h=z4(l);l=rR(l,1,h),c=rR(c,1,h),!i&&l[0]===0&&(l.push(r),c.push(c[0])),a.push(new C1(".morphTargetInfluences["+e[o].name+"]",l,c).scale(1/s))}return new this(t,-1,a)}static findByName(t,e){let s=t;if(!Array.isArray(t)){const i=t;s=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<s.length;i++)if(s[i].name===e)return s[i];return null}static CreateClipsFromMorphTargetSequences(t,e,s){const i={},r=/^([\w-]*?)([\d]+)$/;for(let o=0,l=t.length;o<l;o++){const c=t[o],h=c.name.match(r);if(h&&h.length>1){const f=h[1];let p=i[f];p||(i[f]=p=[]),p.push(c)}}const a=[];for(const o in i)a.push(this.CreateFromMorphTargetSequence(o,i[o],e,s));return a}static parseAnimation(t,e){if(Oe("AnimationClip: parseAnimation() is deprecated and will be removed with r185"),!t)return on("AnimationClip: No animation in JSONLoader data."),null;const s=function(f,p,g,v,_){if(g.length!==0){const S=[],b=[];m3(g,S,b,v),S.length!==0&&_.push(new f(p,S,b))}},i=[],r=t.name||"default",a=t.fps||30,o=t.blendMode;let l=t.length||-1;const c=t.hierarchy||[];for(let f=0;f<c.length;f++){const p=c[f].keys;if(!(!p||p.length===0))if(p[0].morphTargets){const g={};let v;for(v=0;v<p.length;v++)if(p[v].morphTargets)for(let _=0;_<p[v].morphTargets.length;_++)g[p[v].morphTargets[_]]=-1;for(const _ in g){const S=[],b=[];for(let T=0;T!==p[v].morphTargets.length;++T){const C=p[v];S.push(C.time),b.push(C.morphTarget===_?1:0)}i.push(new C1(".morphTargetInfluence["+_+"]",S,b))}l=g.length*a}else{const g=".bones["+e[f].name+"]";s(A1,g+".position",p,"pos",i),s(lS,g+".quaternion",p,"rot",i),s(A1,g+".scale",p,"scl",i)}}return i.length===0?null:new this(r,l,i,o)}resetDuration(){const t=this.tracks;let e=0;for(let s=0,i=t.length;s!==i;++s){const r=this.tracks[s];e=Math.max(e,r.times[r.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let s=0;s<this.tracks.length;s++)t.push(this.tracks[s].clone());const e=new this.constructor(this.name,this.duration,t,this.blendMode);return e.userData=JSON.parse(JSON.stringify(this.userData)),e}toJSON(){return this.constructor.toJSON(this)}}function NK(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return C1;case"vector":case"vector2":case"vector3":case"vector4":return A1;case"color":return y3;case"quaternion":return lS;case"bool":case"boolean":return Lg;case"string":return Fg}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function MK(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=NK(n.type);if(n.times===void 0){const e=[],s=[];m3(n.keys,e,s,"value"),n.times=e,n.values=s}return t.parse!==void 0?t.parse(n):new t(n.name,n.times,n.values,n.interpolation)}const eh={enabled:!1,files:{},add:function(n,t){this.enabled!==!1&&(this.files[n]=t)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class x3{constructor(t,e,s){const i=this;let r=!1,a=0,o=0,l;const c=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=s,this._abortController=null,this.itemStart=function(h){o++,r===!1&&i.onStart!==void 0&&i.onStart(h,a,o),r=!0},this.itemEnd=function(h){a++,i.onProgress!==void 0&&i.onProgress(h,a,o),a===o&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(h){i.onError!==void 0&&i.onError(h)},this.resolveURL=function(h){return l?l(h):h},this.setURLModifier=function(h){return l=h,this},this.addHandler=function(h,f){return c.push(h,f),this},this.removeHandler=function(h){const f=c.indexOf(h);return f!==-1&&c.splice(f,2),this},this.getHandler=function(h){for(let f=0,p=c.length;f<p;f+=2){const g=c[f],v=c[f+1];if(g.global&&(g.lastIndex=0),g.test(h))return v}return null},this.abort=function(){return this.abortController.abort(),this._abortController=null,this}}get abortController(){return this._abortController||(this._abortController=new AbortController),this._abortController}}const V4=new x3;class nl{constructor(t){this.manager=t!==void 0?t:V4,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const s=this;return new Promise(function(i,r){s.load(t,i,e,r)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}abort(){return this}}nl.DEFAULT_MATERIAL_NAME="__DEFAULT";const uf={};class IK extends Error{constructor(t,e){super(t),this.response=e}}class wf extends nl{constructor(t){super(t),this.mimeType="",this.responseType="",this._abortController=new AbortController}load(t,e,s,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=eh.get(`file:${t}`);if(r!==void 0)return this.manager.itemStart(t),setTimeout(()=>{e&&e(r),this.manager.itemEnd(t)},0),r;if(uf[t]!==void 0){uf[t].push({onLoad:e,onProgress:s,onError:i});return}uf[t]=[],uf[t].push({onLoad:e,onProgress:s,onError:i});const a=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin",signal:typeof AbortSignal.any=="function"?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal}),o=this.mimeType,l=this.responseType;fetch(a).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&Oe("FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const h=uf[t],f=c.body.getReader(),p=c.headers.get("X-File-Size")||c.headers.get("Content-Length"),g=p?parseInt(p):0,v=g!==0;let _=0;const S=new ReadableStream({start(b){T();function T(){f.read().then(({done:C,value:A})=>{if(C)b.close();else{_+=A.byteLength;const I=new ProgressEvent("progress",{lengthComputable:v,loaded:_,total:g});for(let D=0,F=h.length;D<F;D++){const z=h[D];z.onProgress&&z.onProgress(I)}b.enqueue(A),T()}},C=>{b.error(C)})}}});return new Response(S)}else throw new IK(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(h=>new DOMParser().parseFromString(h,o));case"json":return c.json();default:if(o==="")return c.text();{const f=/charset="?([^;"\s]*)"?/i.exec(o),p=f&&f[1]?f[1].toLowerCase():void 0,g=new TextDecoder(p);return c.arrayBuffer().then(v=>g.decode(v))}}}).then(c=>{eh.add(`file:${t}`,c);const h=uf[t];delete uf[t];for(let f=0,p=h.length;f<p;f++){const g=h[f];g.onLoad&&g.onLoad(c)}}).catch(c=>{const h=uf[t];if(h===void 0)throw this.manager.itemError(t),c;delete uf[t];for(let f=0,p=h.length;f<p;f++){const g=h[f];g.onError&&g.onError(c)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}class RK extends nl{constructor(t){super(t)}load(t,e,s,i){const r=this,a=new wf(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(o){try{e(r.parse(JSON.parse(o)))}catch(l){i?i(l):on(l),r.manager.itemError(t)}},s,i)}parse(t){const e=[];for(let s=0;s<t.length;s++){const i=N1.parse(t[s]);e.push(i)}return e}}class DK extends nl{constructor(t){super(t)}load(t,e,s,i){const r=this,a=[],o=new EC,l=new wf(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(r.withCredentials);let c=0;function h(f){l.load(t[f],function(p){const g=r.parse(p,!0);a[f]={width:g.width,height:g.height,format:g.format,mipmaps:g.mipmaps},c+=1,c===6&&(g.mipmapCount===1&&(o.minFilter=Hs),o.image=a,o.format=g.format,o.needsUpdate=!0,e&&e(o))},s,i)}if(Array.isArray(t))for(let f=0,p=t.length;f<p;++f)h(f);else l.load(t,function(f){const p=r.parse(f,!0);if(p.isCubemap){const g=p.mipmaps.length/p.mipmapCount;for(let v=0;v<g;v++){a[v]={mipmaps:[]};for(let _=0;_<p.mipmapCount;_++)a[v].mipmaps.push(p.mipmaps[v*p.mipmapCount+_]),a[v].format=p.format,a[v].width=p.width,a[v].height=p.height}o.image=a}else o.image.width=p.width,o.image.height=p.height,o.mipmaps=p.mipmaps;p.mipmapCount===1&&(o.minFilter=Hs),o.format=p.format,o.needsUpdate=!0,e&&e(o)},s,i);return o}}const by=new WeakMap;class M1 extends nl{constructor(t){super(t)}load(t,e,s,i){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,a=eh.get(`image:${t}`);if(a!==void 0){if(a.complete===!0)r.manager.itemStart(t),setTimeout(function(){e&&e(a),r.manager.itemEnd(t)},0);else{let f=by.get(a);f===void 0&&(f=[],by.set(a,f)),f.push({onLoad:e,onError:i})}return a}const o=b1("img");function l(){h(),e&&e(this);const f=by.get(this)||[];for(let p=0;p<f.length;p++){const g=f[p];g.onLoad&&g.onLoad(this)}by.delete(this),r.manager.itemEnd(t)}function c(f){h(),i&&i(f),eh.remove(`image:${t}`);const p=by.get(this)||[];for(let g=0;g<p.length;g++){const v=p[g];v.onError&&v.onError(f)}by.delete(this),r.manager.itemError(t),r.manager.itemEnd(t)}function h(){o.removeEventListener("load",l,!1),o.removeEventListener("error",c,!1)}return o.addEventListener("load",l,!1),o.addEventListener("error",c,!1),t.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),eh.add(`image:${t}`,o),r.manager.itemStart(t),o.src=t,o}}class kK extends nl{constructor(t){super(t)}load(t,e,s,i){const r=new nS;r.colorSpace=Ms;const a=new M1(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let o=0;function l(c){a.load(t[c],function(h){r.images[c]=h,o++,o===6&&(r.needsUpdate=!0,e&&e(r))},void 0,i)}for(let c=0;c<t.length;++c)l(c);return r}}class OK extends nl{constructor(t){super(t)}load(t,e,s,i){const r=this,a=new Jc,o=new wf(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(t,function(l){let c;try{c=r.parse(l)}catch(h){if(i!==void 0)i(h);else{h(h);return}}c.image!==void 0?a.image=c.image:c.data!==void 0&&(a.image.width=c.width,a.image.height=c.height,a.image.data=c.data),a.wrapS=c.wrapS!==void 0?c.wrapS:Yo,a.wrapT=c.wrapT!==void 0?c.wrapT:Yo,a.magFilter=c.magFilter!==void 0?c.magFilter:Hs,a.minFilter=c.minFilter!==void 0?c.minFilter:Hs,a.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.colorSpace!==void 0&&(a.colorSpace=c.colorSpace),c.flipY!==void 0&&(a.flipY=c.flipY),c.format!==void 0&&(a.format=c.format),c.type!==void 0&&(a.type=c.type),c.mipmaps!==void 0&&(a.mipmaps=c.mipmaps,a.minFilter=th),c.mipmapCount===1&&(a.minFilter=Hs),c.generateMipmaps!==void 0&&(a.generateMipmaps=c.generateMipmaps),a.needsUpdate=!0,e&&e(a,c)},s,i),a}}class G4 extends nl{constructor(t){super(t)}load(t,e,s,i){const r=new wi,a=new M1(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(t,function(o){r.image=o,r.needsUpdate=!0,e!==void 0&&e(r)},s,i),r}}class hp extends ps{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new ke(t),this.intensity=e}dispose(){this.dispatchEvent({type:"dispose"})}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,e}}class H4 extends hp{constructor(t,e,s){super(t,s),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(ps.DEFAULT_UP),this.updateMatrix(),this.groundColor=new ke(e)}copy(t,e){return super.copy(t,e),this.groundColor.copy(t.groundColor),this}toJSON(t){const e=super.toJSON(t);return e.object.groundColor=this.groundColor.getHex(),e}}const XM=new Tn,OF=new at,$F=new at;class v3{constructor(t){this.camera=t,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Yt(512,512),this.mapType=Gi,this.map=null,this.mapPass=null,this.matrix=new Tn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Tx,this._frameExtents=new Yt(1,1),this._viewportCount=1,this._viewports=[new Gs(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,s=this.matrix;OF.setFromMatrixPosition(t.matrixWorld),e.position.copy(OF),$F.setFromMatrixPosition(t.target.matrixWorld),e.lookAt($F),e.updateMatrixWorld(),XM.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(XM,e.coordinateSystem,e.reversedDepth),e.reversedDepth?s.set(.5,0,0,.5,0,.5,0,.5,0,0,1,0,0,0,0,1):s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(XM)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.intensity=t.intensity,this.bias=t.bias,this.radius=t.radius,this.autoUpdate=t.autoUpdate,this.needsUpdate=t.needsUpdate,this.normalBias=t.normalBias,this.blurSamples=t.blurSamples,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.intensity!==1&&(t.intensity=this.intensity),this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class $K extends v3{constructor(){super(new Vi(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.aspect=1}updateMatrices(t){const e=this.camera,s=ex*2*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height*this.aspect,r=t.distance||e.far;(s!==e.fov||i!==e.aspect||r!==e.far)&&(e.fov=s,e.aspect=i,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class W4 extends hp{constructor(t,e,s=0,i=Math.PI/3,r=0,a=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(ps.DEFAULT_UP),this.updateMatrix(),this.target=new ps,this.distance=s,this.angle=i,this.penumbra=r,this.decay=a,this.map=null,this.shadow=new $K}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){super.dispose(),this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.map=t.map,this.shadow=t.shadow.clone(),this}toJSON(t){const e=super.toJSON(t);return e.object.distance=this.distance,e.object.angle=this.angle,e.object.decay=this.decay,e.object.penumbra=this.penumbra,e.object.target=this.target.uuid,this.map&&this.map.isTexture&&(e.object.map=this.map.toJSON(t).uuid),e.object.shadow=this.shadow.toJSON(),e}}class LK extends v3{constructor(){super(new Vi(90,1,.5,500)),this.isPointLightShadow=!0}}class q4 extends hp{constructor(t,e,s=0,i=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=s,this.decay=i,this.shadow=new LK}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){super.dispose(),this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}toJSON(t){const e=super.toJSON(t);return e.object.distance=this.distance,e.object.decay=this.decay,e.object.shadow=this.shadow.toJSON(),e}}class rh extends vC{constructor(t=-1,e=1,s=1,i=-1,r=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=s,this.bottom=i,this.near=r,this.far=a,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,s,i,r,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=s,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=s-t,a=s+t,o=i+e,l=i-e;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=c*this.view.offsetX,a=r+c*this.view.width,o-=h*this.view.offsetY,l=o-h*this.view.height}this.projectionMatrix.makeOrthographic(r,a,o,l,this.near,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}class FK extends v3{constructor(){super(new rh(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class X4 extends hp{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(ps.DEFAULT_UP),this.updateMatrix(),this.target=new ps,this.shadow=new FK}dispose(){super.dispose(),this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}toJSON(t){const e=super.toJSON(t);return e.object.shadow=this.shadow.toJSON(),e.object.target=this.target.uuid,e}}class j4 extends hp{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class K4 extends hp{constructor(t,e,s=10,i=10){super(t,e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=s,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}class b3{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new at)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const s=t.x,i=t.y,r=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.282095),e.addScaledVector(a[1],.488603*i),e.addScaledVector(a[2],.488603*r),e.addScaledVector(a[3],.488603*s),e.addScaledVector(a[4],1.092548*(s*i)),e.addScaledVector(a[5],1.092548*(i*r)),e.addScaledVector(a[6],.315392*(3*r*r-1)),e.addScaledVector(a[7],1.092548*(s*r)),e.addScaledVector(a[8],.546274*(s*s-i*i)),e}getIrradianceAt(t,e){const s=t.x,i=t.y,r=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.886227),e.addScaledVector(a[1],2*.511664*i),e.addScaledVector(a[2],2*.511664*r),e.addScaledVector(a[3],2*.511664*s),e.addScaledVector(a[4],2*.429043*s*i),e.addScaledVector(a[5],2*.429043*i*r),e.addScaledVector(a[6],.743125*r*r-.247708),e.addScaledVector(a[7],2*.429043*s*r),e.addScaledVector(a[8],.429043*(s*s-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let s=0;s<9;s++)this.coefficients[s].addScaledVector(t.coefficients[s],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let s=0;s<9;s++)this.coefficients[s].lerp(t.coefficients[s],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const s=this.coefficients;for(let i=0;i<9;i++)s[i].fromArray(t,e+i*3);return this}toArray(t=[],e=0){const s=this.coefficients;for(let i=0;i<9;i++)s[i].toArray(t,e+i*3);return t}static getBasisAt(t,e){const s=t.x,i=t.y,r=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*r,e[3]=.488603*s,e[4]=1.092548*s*i,e[5]=1.092548*i*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*s*r,e[8]=.546274*(s*s-i*i)}}class Y4 extends hp{constructor(t=new b3,e=1){super(void 0,e),this.isLightProbe=!0,this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}class UC extends nl{constructor(t){super(t),this.textures={}}load(t,e,s,i){const r=this,a=new wf(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(t,function(o){try{e(r.parse(JSON.parse(o)))}catch(l){i?i(l):on(l),r.manager.itemError(t)}},s,i)}parse(t){const e=this.textures;function s(r){return e[r]===void 0&&Oe("MaterialLoader: Undefined texture",r),e[r]}const i=this.createMaterialFromType(t.type);if(t.uuid!==void 0&&(i.uuid=t.uuid),t.name!==void 0&&(i.name=t.name),t.color!==void 0&&i.color!==void 0&&i.color.setHex(t.color),t.roughness!==void 0&&(i.roughness=t.roughness),t.metalness!==void 0&&(i.metalness=t.metalness),t.sheen!==void 0&&(i.sheen=t.sheen),t.sheenColor!==void 0&&(i.sheenColor=new ke().setHex(t.sheenColor)),t.sheenRoughness!==void 0&&(i.sheenRoughness=t.sheenRoughness),t.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(t.emissive),t.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(t.specular),t.specularIntensity!==void 0&&(i.specularIntensity=t.specularIntensity),t.specularColor!==void 0&&i.specularColor!==void 0&&i.specularColor.setHex(t.specularColor),t.shininess!==void 0&&(i.shininess=t.shininess),t.clearcoat!==void 0&&(i.clearcoat=t.clearcoat),t.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=t.clearcoatRoughness),t.dispersion!==void 0&&(i.dispersion=t.dispersion),t.iridescence!==void 0&&(i.iridescence=t.iridescence),t.iridescenceIOR!==void 0&&(i.iridescenceIOR=t.iridescenceIOR),t.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=t.iridescenceThicknessRange),t.transmission!==void 0&&(i.transmission=t.transmission),t.thickness!==void 0&&(i.thickness=t.thickness),t.attenuationDistance!==void 0&&(i.attenuationDistance=t.attenuationDistance),t.attenuationColor!==void 0&&i.attenuationColor!==void 0&&i.attenuationColor.setHex(t.attenuationColor),t.anisotropy!==void 0&&(i.anisotropy=t.anisotropy),t.anisotropyRotation!==void 0&&(i.anisotropyRotation=t.anisotropyRotation),t.fog!==void 0&&(i.fog=t.fog),t.flatShading!==void 0&&(i.flatShading=t.flatShading),t.blending!==void 0&&(i.blending=t.blending),t.combine!==void 0&&(i.combine=t.combine),t.side!==void 0&&(i.side=t.side),t.shadowSide!==void 0&&(i.shadowSide=t.shadowSide),t.opacity!==void 0&&(i.opacity=t.opacity),t.transparent!==void 0&&(i.transparent=t.transparent),t.alphaTest!==void 0&&(i.alphaTest=t.alphaTest),t.alphaHash!==void 0&&(i.alphaHash=t.alphaHash),t.depthFunc!==void 0&&(i.depthFunc=t.depthFunc),t.depthTest!==void 0&&(i.depthTest=t.depthTest),t.depthWrite!==void 0&&(i.depthWrite=t.depthWrite),t.colorWrite!==void 0&&(i.colorWrite=t.colorWrite),t.blendSrc!==void 0&&(i.blendSrc=t.blendSrc),t.blendDst!==void 0&&(i.blendDst=t.blendDst),t.blendEquation!==void 0&&(i.blendEquation=t.blendEquation),t.blendSrcAlpha!==void 0&&(i.blendSrcAlpha=t.blendSrcAlpha),t.blendDstAlpha!==void 0&&(i.blendDstAlpha=t.blendDstAlpha),t.blendEquationAlpha!==void 0&&(i.blendEquationAlpha=t.blendEquationAlpha),t.blendColor!==void 0&&i.blendColor!==void 0&&i.blendColor.setHex(t.blendColor),t.blendAlpha!==void 0&&(i.blendAlpha=t.blendAlpha),t.stencilWriteMask!==void 0&&(i.stencilWriteMask=t.stencilWriteMask),t.stencilFunc!==void 0&&(i.stencilFunc=t.stencilFunc),t.stencilRef!==void 0&&(i.stencilRef=t.stencilRef),t.stencilFuncMask!==void 0&&(i.stencilFuncMask=t.stencilFuncMask),t.stencilFail!==void 0&&(i.stencilFail=t.stencilFail),t.stencilZFail!==void 0&&(i.stencilZFail=t.stencilZFail),t.stencilZPass!==void 0&&(i.stencilZPass=t.stencilZPass),t.stencilWrite!==void 0&&(i.stencilWrite=t.stencilWrite),t.wireframe!==void 0&&(i.wireframe=t.wireframe),t.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=t.wireframeLinewidth),t.wireframeLinecap!==void 0&&(i.wireframeLinecap=t.wireframeLinecap),t.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=t.wireframeLinejoin),t.rotation!==void 0&&(i.rotation=t.rotation),t.linewidth!==void 0&&(i.linewidth=t.linewidth),t.dashSize!==void 0&&(i.dashSize=t.dashSize),t.gapSize!==void 0&&(i.gapSize=t.gapSize),t.scale!==void 0&&(i.scale=t.scale),t.polygonOffset!==void 0&&(i.polygonOffset=t.polygonOffset),t.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=t.polygonOffsetFactor),t.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=t.polygonOffsetUnits),t.dithering!==void 0&&(i.dithering=t.dithering),t.alphaToCoverage!==void 0&&(i.alphaToCoverage=t.alphaToCoverage),t.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=t.premultipliedAlpha),t.forceSinglePass!==void 0&&(i.forceSinglePass=t.forceSinglePass),t.allowOverride!==void 0&&(i.allowOverride=t.allowOverride),t.visible!==void 0&&(i.visible=t.visible),t.toneMapped!==void 0&&(i.toneMapped=t.toneMapped),t.userData!==void 0&&(i.userData=t.userData),t.vertexColors!==void 0&&(typeof t.vertexColors=="number"?i.vertexColors=t.vertexColors>0:i.vertexColors=t.vertexColors),t.uniforms!==void 0)for(const r in t.uniforms){const a=t.uniforms[r];switch(i.uniforms[r]={},a.type){case"t":i.uniforms[r].value=s(a.value);break;case"c":i.uniforms[r].value=new ke().setHex(a.value);break;case"v2":i.uniforms[r].value=new Yt().fromArray(a.value);break;case"v3":i.uniforms[r].value=new at().fromArray(a.value);break;case"v4":i.uniforms[r].value=new Gs().fromArray(a.value);break;case"m3":i.uniforms[r].value=new On().fromArray(a.value);break;case"m4":i.uniforms[r].value=new Tn().fromArray(a.value);break;default:i.uniforms[r].value=a.value}}if(t.defines!==void 0&&(i.defines=t.defines),t.vertexShader!==void 0&&(i.vertexShader=t.vertexShader),t.fragmentShader!==void 0&&(i.fragmentShader=t.fragmentShader),t.glslVersion!==void 0&&(i.glslVersion=t.glslVersion),t.extensions!==void 0)for(const r in t.extensions)i.extensions[r]=t.extensions[r];if(t.lights!==void 0&&(i.lights=t.lights),t.clipping!==void 0&&(i.clipping=t.clipping),t.size!==void 0&&(i.size=t.size),t.sizeAttenuation!==void 0&&(i.sizeAttenuation=t.sizeAttenuation),t.map!==void 0&&(i.map=s(t.map)),t.matcap!==void 0&&(i.matcap=s(t.matcap)),t.alphaMap!==void 0&&(i.alphaMap=s(t.alphaMap)),t.bumpMap!==void 0&&(i.bumpMap=s(t.bumpMap)),t.bumpScale!==void 0&&(i.bumpScale=t.bumpScale),t.normalMap!==void 0&&(i.normalMap=s(t.normalMap)),t.normalMapType!==void 0&&(i.normalMapType=t.normalMapType),t.normalScale!==void 0){let r=t.normalScale;Array.isArray(r)===!1&&(r=[r,r]),i.normalScale=new Yt().fromArray(r)}return t.displacementMap!==void 0&&(i.displacementMap=s(t.displacementMap)),t.displacementScale!==void 0&&(i.displacementScale=t.displacementScale),t.displacementBias!==void 0&&(i.displacementBias=t.displacementBias),t.roughnessMap!==void 0&&(i.roughnessMap=s(t.roughnessMap)),t.metalnessMap!==void 0&&(i.metalnessMap=s(t.metalnessMap)),t.emissiveMap!==void 0&&(i.emissiveMap=s(t.emissiveMap)),t.emissiveIntensity!==void 0&&(i.emissiveIntensity=t.emissiveIntensity),t.specularMap!==void 0&&(i.specularMap=s(t.specularMap)),t.specularIntensityMap!==void 0&&(i.specularIntensityMap=s(t.specularIntensityMap)),t.specularColorMap!==void 0&&(i.specularColorMap=s(t.specularColorMap)),t.envMap!==void 0&&(i.envMap=s(t.envMap)),t.envMapRotation!==void 0&&i.envMapRotation.fromArray(t.envMapRotation),t.envMapIntensity!==void 0&&(i.envMapIntensity=t.envMapIntensity),t.reflectivity!==void 0&&(i.reflectivity=t.reflectivity),t.refractionRatio!==void 0&&(i.refractionRatio=t.refractionRatio),t.lightMap!==void 0&&(i.lightMap=s(t.lightMap)),t.lightMapIntensity!==void 0&&(i.lightMapIntensity=t.lightMapIntensity),t.aoMap!==void 0&&(i.aoMap=s(t.aoMap)),t.aoMapIntensity!==void 0&&(i.aoMapIntensity=t.aoMapIntensity),t.gradientMap!==void 0&&(i.gradientMap=s(t.gradientMap)),t.clearcoatMap!==void 0&&(i.clearcoatMap=s(t.clearcoatMap)),t.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=s(t.clearcoatRoughnessMap)),t.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=s(t.clearcoatNormalMap)),t.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new Yt().fromArray(t.clearcoatNormalScale)),t.iridescenceMap!==void 0&&(i.iridescenceMap=s(t.iridescenceMap)),t.iridescenceThicknessMap!==void 0&&(i.iridescenceThicknessMap=s(t.iridescenceThicknessMap)),t.transmissionMap!==void 0&&(i.transmissionMap=s(t.transmissionMap)),t.thicknessMap!==void 0&&(i.thicknessMap=s(t.thicknessMap)),t.anisotropyMap!==void 0&&(i.anisotropyMap=s(t.anisotropyMap)),t.sheenColorMap!==void 0&&(i.sheenColorMap=s(t.sheenColorMap)),t.sheenRoughnessMap!==void 0&&(i.sheenRoughnessMap=s(t.sheenRoughnessMap)),i}setTextures(t){return this.textures=t,this}createMaterialFromType(t){return UC.createMaterialFromType(t)}static createMaterialFromType(t){const e={ShadowMaterial:R4,SpriteMaterial:t3,RawShaderMaterial:u3,ShaderMaterial:ar,PointsMaterial:n3,MeshPhysicalMaterial:D4,MeshStandardMaterial:h3,MeshPhongMaterial:k4,MeshToonMaterial:O4,MeshNormalMaterial:f3,MeshLambertMaterial:$4,MeshDepthMaterial:d3,MeshDistanceMaterial:p3,MeshBasicMaterial:cp,MeshMatcapMaterial:L4,LineDashedMaterial:F4,LineBasicMaterial:Ao,Material:Jr};return new e[t]}}class aR{static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.slice(0,e+1)}static resolveURL(t,e){return typeof t!="string"||t===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class Z4 extends Nn{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}toJSON(){const t=super.toJSON();return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}class Q4 extends nl{constructor(t){super(t)}load(t,e,s,i){const r=this,a=new wf(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(t,function(o){try{e(r.parse(JSON.parse(o)))}catch(l){i?i(l):on(l),r.manager.itemError(t)}},s,i)}parse(t){const e={},s={};function i(g,v){if(e[v]!==void 0)return e[v];const S=g.interleavedBuffers[v],b=r(g,S.buffer),T=Uy(S.type,b),C=new _C(T,S.stride);return C.uuid=S.uuid,e[v]=C,C}function r(g,v){if(s[v]!==void 0)return s[v];const S=g.arrayBuffers[v],b=new Uint32Array(S).buffer;return s[v]=b,b}const a=t.isInstancedBufferGeometry?new Z4:new Nn,o=t.data.index;if(o!==void 0){const g=Uy(o.type,o.array);a.setIndex(new Fs(g,1))}const l=t.data.attributes;for(const g in l){const v=l[g];let _;if(v.isInterleavedBufferAttribute){const S=i(t.data,v.data);_=new og(S,v.itemSize,v.offset,v.normalized)}else{const S=Uy(v.type,v.array),b=v.isInstancedBufferAttribute?ix:Fs;_=new b(S,v.itemSize,v.normalized)}v.name!==void 0&&(_.name=v.name),v.usage!==void 0&&_.setUsage(v.usage),a.setAttribute(g,_)}const c=t.data.morphAttributes;if(c)for(const g in c){const v=c[g],_=[];for(let S=0,b=v.length;S<b;S++){const T=v[S];let C;if(T.isInterleavedBufferAttribute){const A=i(t.data,T.data);C=new og(A,T.itemSize,T.offset,T.normalized)}else{const A=Uy(T.type,T.array);C=new Fs(A,T.itemSize,T.normalized)}T.name!==void 0&&(C.name=T.name),_.push(C)}a.morphAttributes[g]=_}t.data.morphTargetsRelative&&(a.morphTargetsRelative=!0);const f=t.data.groups||t.data.drawcalls||t.data.offsets;if(f!==void 0)for(let g=0,v=f.length;g!==v;++g){const _=f[g];a.addGroup(_.start,_.count,_.materialIndex)}const p=t.data.boundingSphere;return p!==void 0&&(a.boundingSphere=new pa().fromJSON(p)),t.name&&(a.name=t.name),t.userData&&(a.userData=t.userData),a}}class zK extends nl{constructor(t){super(t)}load(t,e,s,i){const r=this,a=this.path===""?aR.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||a;const o=new wf(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,function(l){let c=null;try{c=JSON.parse(l)}catch(f){i!==void 0&&i(f),f("ObjectLoader: Can't parse "+t+".",f.message);return}const h=c.metadata;if(h===void 0||h.type===void 0||h.type.toLowerCase()==="geometry"){i!==void 0&&i(new Error("THREE.ObjectLoader: Can't load "+t)),on("ObjectLoader: Can't load "+t);return}r.parse(c,e)},s,i)}async loadAsync(t,e){const s=this,i=this.path===""?aR.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||i;const r=new wf(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const a=await r.loadAsync(t,e),o=JSON.parse(a),l=o.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+t);return await s.parseAsync(o)}parse(t,e){const s=this.parseAnimations(t.animations),i=this.parseShapes(t.shapes),r=this.parseGeometries(t.geometries,i),a=this.parseImages(t.images,function(){e!==void 0&&e(c)}),o=this.parseTextures(t.textures,a),l=this.parseMaterials(t.materials,o),c=this.parseObject(t.object,r,l,o,s),h=this.parseSkeletons(t.skeletons,c);if(this.bindSkeletons(c,h),this.bindLightTargets(c),e!==void 0){let f=!1;for(const p in a)if(a[p].data instanceof HTMLImageElement){f=!0;break}f===!1&&e(c)}return c}async parseAsync(t){const e=this.parseAnimations(t.animations),s=this.parseShapes(t.shapes),i=this.parseGeometries(t.geometries,s),r=await this.parseImagesAsync(t.images),a=this.parseTextures(t.textures,r),o=this.parseMaterials(t.materials,a),l=this.parseObject(t.object,i,o,a,e),c=this.parseSkeletons(t.skeletons,l);return this.bindSkeletons(l,c),this.bindLightTargets(l),l}parseShapes(t){const e={};if(t!==void 0)for(let s=0,i=t.length;s<i;s++){const r=new Bd().fromJSON(t[s]);e[r.uuid]=r}return e}parseSkeletons(t,e){const s={},i={};if(e.traverse(function(r){r.isBone&&(i[r.uuid]=r)}),t!==void 0)for(let r=0,a=t.length;r<a;r++){const o=new wC().fromJSON(t[r],i);s[o.uuid]=o}return s}parseGeometries(t,e){const s={};if(t!==void 0){const i=new Q4;for(let r=0,a=t.length;r<a;r++){let o;const l=t[r];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":o=i.parse(l);break;default:l.type in kF?o=kF[l.type].fromJSON(l,e):Oe(`ObjectLoader: Unsupported geometry type "${l.type}"`)}o.uuid=l.uuid,l.name!==void 0&&(o.name=l.name),l.userData!==void 0&&(o.userData=l.userData),s[l.uuid]=o}}return s}parseMaterials(t,e){const s={},i={};if(t!==void 0){const r=new UC;r.setTextures(e);for(let a=0,o=t.length;a<o;a++){const l=t[a];s[l.uuid]===void 0&&(s[l.uuid]=r.parse(l)),i[l.uuid]=s[l.uuid]}}return i}parseAnimations(t){const e={};if(t!==void 0)for(let s=0;s<t.length;s++){const i=t[s],r=N1.parse(i);e[r.uuid]=r}return e}parseImages(t,e){const s=this,i={};let r;function a(l){return s.manager.itemStart(l),r.load(l,function(){s.manager.itemEnd(l)},void 0,function(){s.manager.itemError(l),s.manager.itemEnd(l)})}function o(l){if(typeof l=="string"){const c=l,h=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:s.resourcePath+c;return a(h)}else return l.data?{data:Uy(l.type,l.data),width:l.width,height:l.height}:null}if(t!==void 0&&t.length>0){const l=new x3(e);r=new M1(l),r.setCrossOrigin(this.crossOrigin);for(let c=0,h=t.length;c<h;c++){const f=t[c],p=f.url;if(Array.isArray(p)){const g=[];for(let v=0,_=p.length;v<_;v++){const S=p[v],b=o(S);b!==null&&(b instanceof HTMLImageElement?g.push(b):g.push(new Jc(b.data,b.width,b.height)))}i[f.uuid]=new Od(g)}else{const g=o(f.url);i[f.uuid]=new Od(g)}}}return i}async parseImagesAsync(t){const e=this,s={};let i;async function r(a){if(typeof a=="string"){const o=a,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(o)?o:e.resourcePath+o;return await i.loadAsync(l)}else return a.data?{data:Uy(a.type,a.data),width:a.width,height:a.height}:null}if(t!==void 0&&t.length>0){i=new M1(this.manager),i.setCrossOrigin(this.crossOrigin);for(let a=0,o=t.length;a<o;a++){const l=t[a],c=l.url;if(Array.isArray(c)){const h=[];for(let f=0,p=c.length;f<p;f++){const g=c[f],v=await r(g);v!==null&&(v instanceof HTMLImageElement?h.push(v):h.push(new Jc(v.data,v.width,v.height)))}s[l.uuid]=new Od(h)}else{const h=await r(l.url);s[l.uuid]=new Od(h)}}}return s}parseTextures(t,e){function s(r,a){return typeof r=="number"?r:(Oe("ObjectLoader.parseTexture: Constant should be in numeric form.",r),a[r])}const i={};if(t!==void 0)for(let r=0,a=t.length;r<a;r++){const o=t[r];o.image===void 0&&Oe('ObjectLoader: No "image" specified for',o.uuid),e[o.image]===void 0&&Oe("ObjectLoader: Undefined image",o.image);const l=e[o.image],c=l.data;let h;Array.isArray(c)?(h=new nS,c.length===6&&(h.needsUpdate=!0)):(c&&c.data?h=new Jc:h=new wi,c&&(h.needsUpdate=!0)),h.source=l,h.uuid=o.uuid,o.name!==void 0&&(h.name=o.name),o.mapping!==void 0&&(h.mapping=s(o.mapping,UK)),o.channel!==void 0&&(h.channel=o.channel),o.offset!==void 0&&h.offset.fromArray(o.offset),o.repeat!==void 0&&h.repeat.fromArray(o.repeat),o.center!==void 0&&h.center.fromArray(o.center),o.rotation!==void 0&&(h.rotation=o.rotation),o.wrap!==void 0&&(h.wrapS=s(o.wrap[0],LF),h.wrapT=s(o.wrap[1],LF)),o.format!==void 0&&(h.format=o.format),o.internalFormat!==void 0&&(h.internalFormat=o.internalFormat),o.type!==void 0&&(h.type=o.type),o.colorSpace!==void 0&&(h.colorSpace=o.colorSpace),o.minFilter!==void 0&&(h.minFilter=s(o.minFilter,FF)),o.magFilter!==void 0&&(h.magFilter=s(o.magFilter,FF)),o.anisotropy!==void 0&&(h.anisotropy=o.anisotropy),o.flipY!==void 0&&(h.flipY=o.flipY),o.generateMipmaps!==void 0&&(h.generateMipmaps=o.generateMipmaps),o.premultiplyAlpha!==void 0&&(h.premultiplyAlpha=o.premultiplyAlpha),o.unpackAlignment!==void 0&&(h.unpackAlignment=o.unpackAlignment),o.compareFunction!==void 0&&(h.compareFunction=o.compareFunction),o.userData!==void 0&&(h.userData=o.userData),i[o.uuid]=h}return i}parseObject(t,e,s,i,r){let a;function o(p){return e[p]===void 0&&Oe("ObjectLoader: Undefined geometry",p),e[p]}function l(p){if(p!==void 0){if(Array.isArray(p)){const g=[];for(let v=0,_=p.length;v<_;v++){const S=p[v];s[S]===void 0&&Oe("ObjectLoader: Undefined material",S),g.push(s[S])}return g}return s[p]===void 0&&Oe("ObjectLoader: Undefined material",p),s[p]}}function c(p){return i[p]===void 0&&Oe("ObjectLoader: Undefined texture",p),i[p]}let h,f;switch(t.type){case"Scene":a=new _1,t.background!==void 0&&(Number.isInteger(t.background)?a.background=new ke(t.background):a.background=c(t.background)),t.environment!==void 0&&(a.environment=c(t.environment)),t.fog!==void 0&&(t.fog.type==="Fog"?a.fog=new SC(t.fog.color,t.fog.near,t.fog.far):t.fog.type==="FogExp2"&&(a.fog=new bC(t.fog.color,t.fog.density)),t.fog.name!==""&&(a.fog.name=t.fog.name)),t.backgroundBlurriness!==void 0&&(a.backgroundBlurriness=t.backgroundBlurriness),t.backgroundIntensity!==void 0&&(a.backgroundIntensity=t.backgroundIntensity),t.backgroundRotation!==void 0&&a.backgroundRotation.fromArray(t.backgroundRotation),t.environmentIntensity!==void 0&&(a.environmentIntensity=t.environmentIntensity),t.environmentRotation!==void 0&&a.environmentRotation.fromArray(t.environmentRotation);break;case"PerspectiveCamera":a=new Vi(t.fov,t.aspect,t.near,t.far),t.focus!==void 0&&(a.focus=t.focus),t.zoom!==void 0&&(a.zoom=t.zoom),t.filmGauge!==void 0&&(a.filmGauge=t.filmGauge),t.filmOffset!==void 0&&(a.filmOffset=t.filmOffset),t.view!==void 0&&(a.view=Object.assign({},t.view));break;case"OrthographicCamera":a=new rh(t.left,t.right,t.top,t.bottom,t.near,t.far),t.zoom!==void 0&&(a.zoom=t.zoom),t.view!==void 0&&(a.view=Object.assign({},t.view));break;case"AmbientLight":a=new j4(t.color,t.intensity);break;case"DirectionalLight":a=new X4(t.color,t.intensity),a.target=t.target||"";break;case"PointLight":a=new q4(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":a=new K4(t.color,t.intensity,t.width,t.height);break;case"SpotLight":a=new W4(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay),a.target=t.target||"";break;case"HemisphereLight":a=new H4(t.color,t.groundColor,t.intensity);break;case"LightProbe":const p=new b3().fromArray(t.sh);a=new Y4(p,t.intensity);break;case"SkinnedMesh":h=o(t.geometry),f=l(t.material),a=new f4(h,f),t.bindMode!==void 0&&(a.bindMode=t.bindMode),t.bindMatrix!==void 0&&a.bindMatrix.fromArray(t.bindMatrix),t.skeleton!==void 0&&(a.skeleton=t.skeleton);break;case"Mesh":h=o(t.geometry),f=l(t.material),a=new rr(h,f);break;case"InstancedMesh":h=o(t.geometry),f=l(t.material);const g=t.count,v=t.instanceMatrix,_=t.instanceColor;a=new d4(h,f,g),a.instanceMatrix=new ix(new Float32Array(v.array),16),_!==void 0&&(a.instanceColor=new ix(new Float32Array(_.array),_.itemSize));break;case"BatchedMesh":h=o(t.geometry),f=l(t.material),a=new p4(t.maxInstanceCount,t.maxVertexCount,t.maxIndexCount,f),a.geometry=h,a.perObjectFrustumCulled=t.perObjectFrustumCulled,a.sortObjects=t.sortObjects,a._drawRanges=t.drawRanges,a._reservedRanges=t.reservedRanges,a._geometryInfo=t.geometryInfo.map(S=>{let b=null,T=null;return S.boundingBox!==void 0&&(b=new Ga().fromJSON(S.boundingBox)),S.boundingSphere!==void 0&&(T=new pa().fromJSON(S.boundingSphere)),{...S,boundingBox:b,boundingSphere:T}}),a._instanceInfo=t.instanceInfo,a._availableInstanceIds=t._availableInstanceIds,a._availableGeometryIds=t._availableGeometryIds,a._nextIndexStart=t.nextIndexStart,a._nextVertexStart=t.nextVertexStart,a._geometryCount=t.geometryCount,a._maxInstanceCount=t.maxInstanceCount,a._maxVertexCount=t.maxVertexCount,a._maxIndexCount=t.maxIndexCount,a._geometryInitialized=t.geometryInitialized,a._matricesTexture=c(t.matricesTexture.uuid),a._indirectTexture=c(t.indirectTexture.uuid),t.colorsTexture!==void 0&&(a._colorsTexture=c(t.colorsTexture.uuid)),t.boundingSphere!==void 0&&(a.boundingSphere=new pa().fromJSON(t.boundingSphere)),t.boundingBox!==void 0&&(a.boundingBox=new Ga().fromJSON(t.boundingBox));break;case"LOD":a=new h4;break;case"Line":a=new Kd(o(t.geometry),l(t.material));break;case"LineLoop":a=new m4(o(t.geometry),l(t.material));break;case"LineSegments":a=new bh(o(t.geometry),l(t.material));break;case"PointCloud":case"Points":a=new g4(o(t.geometry),l(t.material));break;case"Sprite":a=new u4(l(t.material));break;case"Group":a=new By;break;case"Bone":a=new e3;break;default:a=new ps}if(a.uuid=t.uuid,t.name!==void 0&&(a.name=t.name),t.matrix!==void 0?(a.matrix.fromArray(t.matrix),t.matrixAutoUpdate!==void 0&&(a.matrixAutoUpdate=t.matrixAutoUpdate),a.matrixAutoUpdate&&a.matrix.decompose(a.position,a.quaternion,a.scale)):(t.position!==void 0&&a.position.fromArray(t.position),t.rotation!==void 0&&a.rotation.fromArray(t.rotation),t.quaternion!==void 0&&a.quaternion.fromArray(t.quaternion),t.scale!==void 0&&a.scale.fromArray(t.scale)),t.up!==void 0&&a.up.fromArray(t.up),t.castShadow!==void 0&&(a.castShadow=t.castShadow),t.receiveShadow!==void 0&&(a.receiveShadow=t.receiveShadow),t.shadow&&(t.shadow.intensity!==void 0&&(a.shadow.intensity=t.shadow.intensity),t.shadow.bias!==void 0&&(a.shadow.bias=t.shadow.bias),t.shadow.normalBias!==void 0&&(a.shadow.normalBias=t.shadow.normalBias),t.shadow.radius!==void 0&&(a.shadow.radius=t.shadow.radius),t.shadow.mapSize!==void 0&&a.shadow.mapSize.fromArray(t.shadow.mapSize),t.shadow.camera!==void 0&&(a.shadow.camera=this.parseObject(t.shadow.camera))),t.visible!==void 0&&(a.visible=t.visible),t.frustumCulled!==void 0&&(a.frustumCulled=t.frustumCulled),t.renderOrder!==void 0&&(a.renderOrder=t.renderOrder),t.userData!==void 0&&(a.userData=t.userData),t.layers!==void 0&&(a.layers.mask=t.layers),t.children!==void 0){const p=t.children;for(let g=0;g<p.length;g++)a.add(this.parseObject(p[g],e,s,i,r))}if(t.animations!==void 0){const p=t.animations;for(let g=0;g<p.length;g++){const v=p[g];a.animations.push(r[v])}}if(t.type==="LOD"){t.autoUpdate!==void 0&&(a.autoUpdate=t.autoUpdate);const p=t.levels;for(let g=0;g<p.length;g++){const v=p[g],_=a.getObjectByProperty("uuid",v.object);_!==void 0&&a.addLevel(_,v.distance,v.hysteresis)}}return a}bindSkeletons(t,e){Object.keys(e).length!==0&&t.traverse(function(s){if(s.isSkinnedMesh===!0&&s.skeleton!==void 0){const i=e[s.skeleton];i===void 0?Oe("ObjectLoader: No skeleton found with UUID:",s.skeleton):s.bind(i,s.bindMatrix)}})}bindLightTargets(t){t.traverse(function(e){if(e.isDirectionalLight||e.isSpotLight){const s=e.target,i=t.getObjectByProperty("uuid",s);i!==void 0?e.target=i:e.target=new ps}})}}const UK={UVMapping:oC,CubeReflectionMapping:ph,CubeRefractionMapping:Xd,EquirectangularReflectionMapping:f1,EquirectangularRefractionMapping:d1,CubeUVReflectionMapping:wx},LF={RepeatWrapping:p1,ClampToEdgeWrapping:Yo,MirroredRepeatWrapping:m1},FF={NearestFilter:hi,NearestMipmapNearestFilter:PD,NearestMipmapLinearFilter:zy,LinearFilter:Hs,LinearMipmapNearestFilter:Qb,LinearMipmapLinearFilter:th},jM=new WeakMap;class BK extends nl{constructor(t){super(t),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&Oe("ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&Oe("ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"},this._abortController=new AbortController}setOptions(t){return this.options=t,this}load(t,e,s,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,a=eh.get(`image-bitmap:${t}`);if(a!==void 0){if(r.manager.itemStart(t),a.then){a.then(c=>{if(jM.has(a)===!0)i&&i(jM.get(a)),r.manager.itemError(t),r.manager.itemEnd(t);else return e&&e(c),r.manager.itemEnd(t),c});return}return setTimeout(function(){e&&e(a),r.manager.itemEnd(t)},0),a}const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,o.signal=typeof AbortSignal.any=="function"?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal;const l=fetch(t,o).then(function(c){return c.blob()}).then(function(c){return createImageBitmap(c,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(c){return eh.add(`image-bitmap:${t}`,c),e&&e(c),r.manager.itemEnd(t),c}).catch(function(c){i&&i(c),jM.set(l,c),eh.remove(`image-bitmap:${t}`),r.manager.itemError(t),r.manager.itemEnd(t)});eh.add(`image-bitmap:${t}`,l),r.manager.itemStart(t)}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}let IT;class S3{static getContext(){return IT===void 0&&(IT=new(window.AudioContext||window.webkitAudioContext)),IT}static setContext(t){IT=t}}class PK extends nl{constructor(t){super(t)}load(t,e,s,i){const r=this,a=new wf(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(l){try{const c=l.slice(0);S3.getContext().decodeAudioData(c,function(f){e(f)}).catch(o)}catch(c){o(c)}},s,i);function o(l){i?i(l):on(l),r.manager.itemError(t)}}}const zF=new Tn,UF=new Tn,Sm=new Tn;class VK{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Vi,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Vi,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep,Sm.copy(t.projectionMatrix);const i=e.eyeSep/2,r=i*e.near/e.focus,a=e.near*Math.tan(Qm*e.fov*.5)/e.zoom;let o,l;UF.elements[12]=-i,zF.elements[12]=i,o=-a*e.aspect+r,l=a*e.aspect+r,Sm.elements[0]=2*e.near/(l-o),Sm.elements[8]=(l+o)/(l-o),this.cameraL.projectionMatrix.copy(Sm),o=-a*e.aspect-r,l=a*e.aspect-r,Sm.elements[0]=2*e.near/(l-o),Sm.elements[8]=(l+o)/(l-o),this.cameraR.projectionMatrix.copy(Sm)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(UF),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(zF)}}class J4 extends Vi{constructor(t=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=t}}class _3{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=performance.now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=performance.now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}const _m=new at,KM=new Va,GK=new at,wm=new at,Tm=new at;class HK extends ps{constructor(){super(),this.type="AudioListener",this.context=S3.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new _3}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(_m,KM,GK),wm.set(0,0,-1).applyQuaternion(KM),Tm.set(0,1,0).applyQuaternion(KM),e.positionX){const s=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(_m.x,s),e.positionY.linearRampToValueAtTime(_m.y,s),e.positionZ.linearRampToValueAtTime(_m.z,s),e.forwardX.linearRampToValueAtTime(wm.x,s),e.forwardY.linearRampToValueAtTime(wm.y,s),e.forwardZ.linearRampToValueAtTime(wm.z,s),e.upX.linearRampToValueAtTime(Tm.x,s),e.upY.linearRampToValueAtTime(Tm.y,s),e.upZ.linearRampToValueAtTime(Tm.z,s)}else e.setPosition(_m.x,_m.y,_m.z),e.setOrientation(wm.x,wm.y,wm.z,Tm.x,Tm.y,Tm.z)}}let tV=class extends ps{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(this.isPlaying===!0){Oe("Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){Oe("Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){Oe("Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(t=0){if(this.hasPlaybackControl===!1){Oe("Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(this.context.currentTime+t),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(t){return t||(t=[]),this._connected===!0?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){return this.detune=t,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(this.hasPlaybackControl===!1){Oe("Audio: this Audio has no playback control.");return}return this.playbackRate=t,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return this.hasPlaybackControl===!1?(Oe("Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(this.hasPlaybackControl===!1){Oe("Audio: this Audio has no playback control.");return}return this.loop=t,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}copy(t,e){return super.copy(t,e),t.sourceType!=="buffer"?(Oe("Audio: Audio source type cannot be copied."),this):(this.autoplay=t.autoplay,this.buffer=t.buffer,this.detune=t.detune,this.loop=t.loop,this.loopStart=t.loopStart,this.loopEnd=t.loopEnd,this.offset=t.offset,this.duration=t.duration,this.playbackRate=t.playbackRate,this.hasPlaybackControl=t.hasPlaybackControl,this.sourceType=t.sourceType,this.filters=t.filters.slice(),this)}clone(t){return new this.constructor(this.listener).copy(this,t)}};const Em=new at,BF=new Va,WK=new at,Cm=new at;class qK extends tV{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){return super.connect(),this.panner.connect(this.gain),this}disconnect(){return super.disconnect(),this.panner.disconnect(this.gain),this}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,e,s){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=s,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(Em,BF,WK),Cm.set(0,0,1).applyQuaternion(BF);const e=this.panner;if(e.positionX){const s=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(Em.x,s),e.positionY.linearRampToValueAtTime(Em.y,s),e.positionZ.linearRampToValueAtTime(Em.z,s),e.orientationX.linearRampToValueAtTime(Cm.x,s),e.orientationY.linearRampToValueAtTime(Cm.y,s),e.orientationZ.linearRampToValueAtTime(Cm.z,s)}else e.setPosition(Em.x,Em.y,Em.z),e.setOrientation(Cm.x,Cm.y,Cm.z)}}class XK{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let s=0;s<e.length;s++)t+=e[s];return t/e.length}}class eV{constructor(t,e,s){this.binding=t,this.valueSize=s;let i,r,a;switch(e){case"quaternion":i=this._slerp,r=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(s*6),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(s*5);break;default:i=this._lerp,r=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(s*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const s=this.buffer,i=this.valueSize,r=t*i+i;let a=this.cumulativeWeight;if(a===0){for(let o=0;o!==i;++o)s[r+o]=s[o];a=e}else{a+=e;const o=e/a;this._mixBufferRegion(s,r,0,o,i)}this.cumulativeWeight=a}accumulateAdditive(t){const e=this.buffer,s=this.valueSize,i=s*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,s),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,s=this.buffer,i=t*e+e,r=this.cumulativeWeight,a=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const l=e*this._origIndex;this._mixBufferRegion(s,i,l,1-r,e)}a>0&&this._mixBufferRegionAdditive(s,i,this._addIndex*e,1,e);for(let l=e,c=e+e;l!==c;++l)if(s[l]!==s[l+e]){o.setValue(s,i);break}}saveOriginalState(){const t=this.binding,e=this.buffer,s=this.valueSize,i=s*this._origIndex;t.getValue(e,i);for(let r=s,a=i;r!==a;++r)e[r]=e[i+r%s];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let s=t;s<e;s++)this.buffer[s]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let s=0;s<this.valueSize;s++)this.buffer[e+s]=this.buffer[t+s]}_select(t,e,s,i,r){if(i>=.5)for(let a=0;a!==r;++a)t[e+a]=t[s+a]}_slerp(t,e,s,i){Va.slerpFlat(t,e,t,e,t,s,i)}_slerpAdditive(t,e,s,i,r){const a=this._workIndex*r;Va.multiplyQuaternionsFlat(t,a,t,e,t,s),Va.slerpFlat(t,e,t,e,t,a,i)}_lerp(t,e,s,i,r){const a=1-i;for(let o=0;o!==r;++o){const l=e+o;t[l]=t[l]*a+t[s+o]*i}}_lerpAdditive(t,e,s,i,r){for(let a=0;a!==r;++a){const o=e+a;t[o]=t[o]+t[s+a]*i}}}const w3="\\[\\]\\.:\\/",jK=new RegExp("["+w3+"]","g"),T3="[^"+w3+"]",KK="[^"+w3.replace("\\.","")+"]",YK=/((?:WC+[\/:])*)/.source.replace("WC",T3),ZK=/(WCOD+)?/.source.replace("WCOD",KK),QK=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",T3),JK=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",T3),tY=new RegExp("^"+YK+ZK+QK+JK+"$"),eY=["material","materials","bones","map"];class nY{constructor(t,e,s){const i=s||vs.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}getValue(t,e){this.bind();const s=this._targetGroup.nCachedObjects_,i=this._bindings[s];i!==void 0&&i.getValue(t,e)}setValue(t,e){const s=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=s.length;i!==r;++i)s[i].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,s=t.length;e!==s;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,s=t.length;e!==s;++e)t[e].unbind()}}class vs{constructor(t,e,s){this.path=e,this.parsedPath=s||vs.parseTrackName(e),this.node=vs.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,s){return t&&t.isAnimationObjectGroup?new vs.Composite(t,e,s):new vs(t,e,s)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(jK,"")}static parseTrackName(t){const e=tY.exec(t);if(e===null)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const s={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=s.nodeName&&s.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=s.nodeName.substring(i+1);eY.indexOf(r)!==-1&&(s.nodeName=s.nodeName.substring(0,i),s.objectName=r)}if(s.propertyName===null||s.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return s}static findNode(t,e){if(e===void 0||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const s=t.skeleton.getBoneByName(e);if(s!==void 0)return s}if(t.children){const s=function(r){for(let a=0;a<r.length;a++){const o=r[a];if(o.name===e||o.uuid===e)return o;const l=s(o.children);if(l)return l}return null},i=s(t.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)t[e++]=s[i]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,s=e.objectName,i=e.propertyName;let r=e.propertyIndex;if(t||(t=vs.findNode(this.rootNode,e.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){Oe("PropertyBinding: No target node found for track: "+this.path+".");return}if(s){let c=e.objectIndex;switch(s){case"materials":if(!t.material){on("PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){on("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){on("PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let h=0;h<t.length;h++)if(t[h].name===c){c=h;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material){on("PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.map){on("PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}t=t.material.map;break;default:if(t[s]===void 0){on("PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[s]}if(c!==void 0){if(t[c]===void 0){on("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[c]}}const a=t[i];if(a===void 0){const c=e.nodeName;on("PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",t);return}let o=this.Versioning.None;this.targetObject=t,t.isMaterial===!0?o=this.Versioning.NeedsUpdate:t.isObject3D===!0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!t.geometry){on("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!t.geometry.morphAttributes){on("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[r]!==void 0&&(r=t.morphTargetDictionary[r])}l=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=r}else a.fromArray!==void 0&&a.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(l=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}vs.Composite=nY;vs.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};vs.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};vs.prototype.GetterByBindingType=[vs.prototype._getValue_direct,vs.prototype._getValue_array,vs.prototype._getValue_arrayElement,vs.prototype._getValue_toArray];vs.prototype.SetterByBindingTypeAndVersioning=[[vs.prototype._setValue_direct,vs.prototype._setValue_direct_setNeedsUpdate,vs.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[vs.prototype._setValue_array,vs.prototype._setValue_array_setNeedsUpdate,vs.prototype._setValue_array_setMatrixWorldNeedsUpdate],[vs.prototype._setValue_arrayElement,vs.prototype._setValue_arrayElement_setNeedsUpdate,vs.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[vs.prototype._setValue_fromArray,vs.prototype._setValue_fromArray_setNeedsUpdate,vs.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class sY{constructor(){this.isAnimationObjectGroup=!0,this.uuid=El(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let s=0,i=arguments.length;s!==i;++s)t[arguments[s].uuid]=s;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}add(){const t=this._objects,e=this._indicesByUUID,s=this._paths,i=this._parsedPaths,r=this._bindings,a=r.length;let o,l=t.length,c=this.nCachedObjects_;for(let h=0,f=arguments.length;h!==f;++h){const p=arguments[h],g=p.uuid;let v=e[g];if(v===void 0){v=l++,e[g]=v,t.push(p);for(let _=0,S=a;_!==S;++_)r[_].push(new vs(p,s[_],i[_]))}else if(v<c){o=t[v];const _=--c,S=t[_];e[S.uuid]=v,t[v]=S,e[g]=_,t[_]=p;for(let b=0,T=a;b!==T;++b){const C=r[b],A=C[_];let I=C[v];C[v]=A,I===void 0&&(I=new vs(p,s[b],i[b])),C[_]=I}}else t[v]!==o&&on("AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}remove(){const t=this._objects,e=this._indicesByUUID,s=this._bindings,i=s.length;let r=this.nCachedObjects_;for(let a=0,o=arguments.length;a!==o;++a){const l=arguments[a],c=l.uuid,h=e[c];if(h!==void 0&&h>=r){const f=r++,p=t[f];e[p.uuid]=h,t[h]=p,e[c]=f,t[f]=l;for(let g=0,v=i;g!==v;++g){const _=s[g],S=_[f],b=_[h];_[h]=S,_[f]=b}}}this.nCachedObjects_=r}uncache(){const t=this._objects,e=this._indicesByUUID,s=this._bindings,i=s.length;let r=this.nCachedObjects_,a=t.length;for(let o=0,l=arguments.length;o!==l;++o){const c=arguments[o],h=c.uuid,f=e[h];if(f!==void 0)if(delete e[h],f<r){const p=--r,g=t[p],v=--a,_=t[v];e[g.uuid]=f,t[f]=g,e[_.uuid]=p,t[p]=_,t.pop();for(let S=0,b=i;S!==b;++S){const T=s[S],C=T[p],A=T[v];T[f]=C,T[p]=A,T.pop()}}else{const p=--a,g=t[p];p>0&&(e[g.uuid]=f),t[f]=g,t.pop();for(let v=0,_=i;v!==_;++v){const S=s[v];S[f]=S[p],S.pop()}}}this.nCachedObjects_=r}subscribe_(t,e){const s=this._bindingsIndicesByPath;let i=s[t];const r=this._bindings;if(i!==void 0)return r[i];const a=this._paths,o=this._parsedPaths,l=this._objects,c=l.length,h=this.nCachedObjects_,f=new Array(c);i=r.length,s[t]=i,a.push(t),o.push(e),r.push(f);for(let p=h,g=l.length;p!==g;++p){const v=l[p];f[p]=new vs(v,t,e)}return f}unsubscribe_(t){const e=this._bindingsIndicesByPath,s=e[t];if(s!==void 0){const i=this._paths,r=this._parsedPaths,a=this._bindings,o=a.length-1,l=a[o],c=t[o];e[c]=s,a[s]=l,a.pop(),r[s]=r[o],r.pop(),i[s]=i[o],i.pop()}}}class nV{constructor(t,e,s=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=s,this.blendMode=i;const r=e.tracks,a=r.length,o=new Array(a),l={endingStart:Gm,endingEnd:Gm};for(let c=0;c!==a;++c){const h=r[c].createInterpolant(null);o[c]=h,h.settings=l}this._interpolantSettings=l,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=WP,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,s=!1){if(t.fadeOut(e),this.fadeIn(e),s===!0){const i=this._clip.duration,r=t._clip.duration,a=r/i,o=i/r;t.warp(1,a,e),this.warp(o,1,e)}return this}crossFadeTo(t,e,s=!1){return t.crossFadeFrom(this,e,s)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,s){const i=this._mixer,r=i.time,a=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const l=o.parameterPositions,c=o.sampleValues;return l[0]=r,l[1]=r+s,c[0]=t/a,c[1]=e/a,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,s,i){if(!this.enabled){this._updateWeight(t);return}const r=this._startTime;if(r!==null){const l=(t-r)*s;l<0||s===0?e=0:(this._startTime=null,e=s*l)}e*=this._updateTimeScale(t);const a=this._updateTime(e),o=this._updateWeight(t);if(o>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case jD:for(let h=0,f=l.length;h!==f;++h)l[h].evaluate(a),c[h].accumulateAdditive(o);break;case pC:default:for(let h=0,f=l.length;h!==f;++h)l[h].evaluate(a),c[h].accumulate(i,o)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const s=this._weightInterpolant;if(s!==null){const i=s.evaluate(t)[0];e*=i,t>s.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const s=this._timeScaleInterpolant;if(s!==null){const i=s.evaluate(t)[0];e*=i,t>s.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e)}}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,s=this.loop;let i=this.time+t,r=this._loopCount;const a=s===qP;if(t===0)return r===-1?i:a&&(r&1)===1?e-i:i;if(s===HP){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else if(i<0)i=0;else{this.time=i;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(r===-1&&(t>=0?(r=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),i>=e||i<0){const o=Math.floor(i/e);i-=e*o,r+=Math.abs(o);const l=this.repetitions-r;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(l===1){const c=t<0;this._setEndings(c,!c,a)}else this._setEndings(!1,!1,a);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=i;if(a&&(r&1)===1)return e-i}return i}_setEndings(t,e,s){const i=this._interpolantSettings;s?(i.endingStart=Hm,i.endingEnd=Hm):(t?i.endingStart=this.zeroSlopeAtStart?Hm:Gm:i.endingStart=y1,e?i.endingEnd=this.zeroSlopeAtEnd?Hm:Gm:i.endingEnd=y1)}_scheduleFading(t,e,s){const i=this._mixer,r=i.time;let a=this._weightInterpolant;a===null&&(a=i._lendControlInterpolant(),this._weightInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=r,l[0]=e,o[1]=r+t,l[1]=s,this}}const iY=new Float32Array(1);class rY extends Rl{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const s=t._localRoot||this._root,i=t._clip.tracks,r=i.length,a=t._propertyBindings,o=t._interpolants,l=s.uuid,c=this._bindingsByRootAndName;let h=c[l];h===void 0&&(h={},c[l]=h);for(let f=0;f!==r;++f){const p=i[f],g=p.name;let v=h[g];if(v!==void 0)++v.referenceCount,a[f]=v;else{if(v=a[f],v!==void 0){v._cacheIndex===null&&(++v.referenceCount,this._addInactiveBinding(v,l,g));continue}const _=e&&e._propertyBindings[f].binding.parsedPath;v=new eV(vs.create(s,g,_),p.ValueTypeName,p.getValueSize()),++v.referenceCount,this._addInactiveBinding(v,l,g),a[f]=v}o[f].resultBuffer=v.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const s=(t._localRoot||this._root).uuid,i=t._clip.uuid,r=this._actionsByClip[i];this._bindAction(t,r&&r.knownActions[0]),this._addInactiveAction(t,i,s)}const e=t._propertyBindings;for(let s=0,i=e.length;s!==i;++s){const r=e[s];r.useCount++===0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let s=0,i=e.length;s!==i;++s){const r=e[s];--r.useCount===0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,s){const i=this._actions,r=this._actionsByClip;let a=r[e];if(a===void 0)a={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=a;else{const o=a.knownActions;t._byClipCacheIndex=o.length,o.push(t)}t._cacheIndex=i.length,i.push(t),a.actionByRoot[s]=t}_removeInactiveAction(t){const e=this._actions,s=e[e.length-1],i=t._cacheIndex;s._cacheIndex=i,e[i]=s,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,a=this._actionsByClip,o=a[r],l=o.knownActions,c=l[l.length-1],h=t._byClipCacheIndex;c._byClipCacheIndex=h,l[h]=c,l.pop(),t._byClipCacheIndex=null;const f=o.actionByRoot,p=(t._localRoot||this._root).uuid;delete f[p],l.length===0&&delete a[r],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let s=0,i=e.length;s!==i;++s){const r=e[s];--r.referenceCount===0&&this._removeInactiveBinding(r)}}_lendAction(t){const e=this._actions,s=t._cacheIndex,i=this._nActiveActions++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=s,e[s]=r}_takeBackAction(t){const e=this._actions,s=t._cacheIndex,i=--this._nActiveActions,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=s,e[s]=r}_addInactiveBinding(t,e,s){const i=this._bindingsByRootAndName,r=this._bindings;let a=i[e];a===void 0&&(a={},i[e]=a),a[s]=t,t._cacheIndex=r.length,r.push(t)}_removeInactiveBinding(t){const e=this._bindings,s=t.binding,i=s.rootNode.uuid,r=s.path,a=this._bindingsByRootAndName,o=a[i],l=e[e.length-1],c=t._cacheIndex;l._cacheIndex=c,e[c]=l,e.pop(),delete o[r],Object.keys(o).length===0&&delete a[i]}_lendBinding(t){const e=this._bindings,s=t._cacheIndex,i=this._nActiveBindings++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=s,e[s]=r}_takeBackBinding(t){const e=this._bindings,s=t._cacheIndex,i=--this._nActiveBindings,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=s,e[s]=r}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let s=t[e];return s===void 0&&(s=new g3(new Float32Array(2),new Float32Array(2),1,iY),s.__cacheIndex=e,t[e]=s),s}_takeBackControlInterpolant(t){const e=this._controlInterpolants,s=t.__cacheIndex,i=--this._nActiveControlInterpolants,r=e[i];t.__cacheIndex=i,e[i]=t,r.__cacheIndex=s,e[s]=r}clipAction(t,e,s){const i=e||this._root,r=i.uuid;let a=typeof t=="string"?N1.findByName(i,t):t;const o=a!==null?a.uuid:t,l=this._actionsByClip[o];let c=null;if(s===void 0&&(a!==null?s=a.blendMode:s=pC),l!==void 0){const f=l.actionByRoot[r];if(f!==void 0&&f.blendMode===s)return f;c=l.knownActions[0],a===null&&(a=c._clip)}if(a===null)return null;const h=new nV(this,a,e,s);return this._bindAction(h,c),this._addInactiveAction(h,o,r),h}existingAction(t,e){const s=e||this._root,i=s.uuid,r=typeof t=="string"?N1.findByName(s,t):t,a=r?r.uuid:t,o=this._actionsByClip[a];return o!==void 0&&o.actionByRoot[i]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let s=e-1;s>=0;--s)t[s].stop();return this}update(t){t*=this.timeScale;const e=this._actions,s=this._nActiveActions,i=this.time+=t,r=Math.sign(t),a=this._accuIndex^=1;for(let c=0;c!==s;++c)e[c]._update(i,t,r,a);const o=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)o[c].apply(a);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,s=t.uuid,i=this._actionsByClip,r=i[s];if(r!==void 0){const a=r.knownActions;for(let o=0,l=a.length;o!==l;++o){const c=a[o];this._deactivateAction(c);const h=c._cacheIndex,f=e[e.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,f._cacheIndex=h,e[h]=f,e.pop(),this._removeInactiveBindingsForAction(c)}delete i[s]}}uncacheRoot(t){const e=t.uuid,s=this._actionsByClip;for(const a in s){const o=s[a].actionByRoot,l=o[e];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,r=i[e];if(r!==void 0)for(const a in r){const o=r[a];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(t,e){const s=this.existingAction(t,e);s!==null&&(this._deactivateAction(s),this._removeInactiveAction(s))}}class aY extends YD{constructor(t=1,e=1,s=1,i={}){super(t,e,i),this.isRenderTarget3D=!0,this.depth=s,this.texture=new xC(null,t,e,s),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class Qn{constructor(t){this.value=t}clone(){return new Qn(this.value.clone===void 0?this.value:this.value.clone())}}let oY=0;class lY extends Rl{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:oY++}),this.name="",this.usage=v1,this.uniforms=[]}add(t){return this.uniforms.push(t),this}remove(t){const e=this.uniforms.indexOf(t);return e!==-1&&this.uniforms.splice(e,1),this}setName(t){return this.name=t,this}setUsage(t){return this.usage=t,this}dispose(){this.dispatchEvent({type:"dispose"})}copy(t){this.name=t.name,this.usage=t.usage;const e=t.uniforms;this.uniforms.length=0;for(let s=0,i=e.length;s<i;s++){const r=Array.isArray(e[s])?e[s]:[e[s]];for(let a=0;a<r.length;a++)this.uniforms.push(r[a].clone())}return this}clone(){return new this.constructor().copy(this)}}class cY extends _C{constructor(t,e,s=1){super(t,e),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=s}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}class uY{constructor(t,e,s,i,r,a=!1){this.isGLBufferAttribute=!0,this.name="",this.buffer=t,this.type=e,this.itemSize=s,this.elementSize=i,this.count=r,this.normalized=a,this.version=0}set needsUpdate(t){t===!0&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}}const PF=new Tn;class sV{constructor(t,e,s=0,i=1/0){this.ray=new Og(t,e),this.near=s,this.far=i,this.camera=null,this.layers=new nx,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):on("Raycaster: Unsupported camera type: "+e.type)}setFromXRController(t){return PF.identity().extractRotation(t.matrixWorld),this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(PF),this}intersectObject(t,e=!0,s=[]){return oR(t,this,s,e),s.sort(VF),s}intersectObjects(t,e=!0,s=[]){for(let i=0,r=t.length;i<r;i++)oR(t[i],this,s,e);return s.sort(VF),s}}function VF(n,t){return n.distance-t.distance}function oR(n,t,e,s){let i=!0;if(n.layers.test(t.layers)&&n.raycast(t,e)===!1&&(i=!1),i===!0&&s===!0){const r=n.children;for(let a=0,o=r.length;a<o;a++)oR(r[a],t,e,!0)}}let hY=class{constructor(){this._previousTime=0,this._currentTime=0,this._startTime=performance.now(),this._delta=0,this._elapsed=0,this._timescale=1,this._document=null,this._pageVisibilityHandler=null}connect(t){this._document=t,t.hidden!==void 0&&(this._pageVisibilityHandler=fY.bind(this),t.addEventListener("visibilitychange",this._pageVisibilityHandler,!1))}disconnect(){this._pageVisibilityHandler!==null&&(this._document.removeEventListener("visibilitychange",this._pageVisibilityHandler),this._pageVisibilityHandler=null),this._document=null}getDelta(){return this._delta/1e3}getElapsed(){return this._elapsed/1e3}getTimescale(){return this._timescale}setTimescale(t){return this._timescale=t,this}reset(){return this._currentTime=performance.now()-this._startTime,this}dispose(){this.disconnect()}update(t){return this._pageVisibilityHandler!==null&&this._document.hidden===!0?this._delta=0:(this._previousTime=this._currentTime,this._currentTime=(t!==void 0?t:performance.now())-this._startTime,this._delta=(this._currentTime-this._previousTime)*this._timescale,this._elapsed+=this._delta),this}};function fY(){this._document.hidden===!1&&this.reset()}class p2{constructor(t=1,e=0,s=0){this.radius=t,this.phi=e,this.theta=s}set(t,e,s){return this.radius=t,this.phi=e,this.theta=s,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){return this.phi=Sn(this.phi,1e-6,Math.PI-1e-6),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,s){return this.radius=Math.sqrt(t*t+e*e+s*s),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,s),this.phi=Math.acos(Sn(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class dY{constructor(t=1,e=0,s=0){this.radius=t,this.theta=e,this.y=s}set(t,e,s){return this.radius=t,this.theta=e,this.y=s,this}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,s){return this.radius=Math.sqrt(t*t+s*s),this.theta=Math.atan2(t,s),this.y=e,this}clone(){return new this.constructor().copy(this)}}class E3{constructor(t,e,s,i){E3.prototype.isMatrix2=!0,this.elements=[1,0,0,1],t!==void 0&&this.set(t,e,s,i)}identity(){return this.set(1,0,0,1),this}fromArray(t,e=0){for(let s=0;s<4;s++)this.elements[s]=t[s+e];return this}set(t,e,s,i){const r=this.elements;return r[0]=t,r[2]=e,r[1]=s,r[3]=i,this}}const GF=new Yt;class pY{constructor(t=new Yt(1/0,1/0),e=new Yt(-1/0,-1/0)){this.isBox2=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const s=GF.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(s),this.max.copy(t).add(s),this}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,GF).distanceTo(t)}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const HF=new at,RT=new at,Sy=new at,_y=new at,YM=new at,mY=new at,gY=new at;class yY{constructor(t=new at,e=new at){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){HF.subVectors(t,this.start),RT.subVectors(this.end,this.start);const s=RT.dot(RT);let r=RT.dot(HF)/s;return e&&(r=Sn(r,0,1)),r}closestPointToPoint(t,e,s){const i=this.closestPointToPointParameter(t,e);return this.delta(s).multiplyScalar(i).add(this.start)}distanceSqToLine3(t,e=mY,s=gY){const i=10000000000000001e-32;let r,a;const o=this.start,l=t.start,c=this.end,h=t.end;Sy.subVectors(c,o),_y.subVectors(h,l),YM.subVectors(o,l);const f=Sy.dot(Sy),p=_y.dot(_y),g=_y.dot(YM);if(f<=i&&p<=i)return e.copy(o),s.copy(l),e.sub(s),e.dot(e);if(f<=i)r=0,a=g/p,a=Sn(a,0,1);else{const v=Sy.dot(YM);if(p<=i)a=0,r=Sn(-v/f,0,1);else{const _=Sy.dot(_y),S=f*p-_*_;S!==0?r=Sn((_*g-v*p)/S,0,1):r=0,a=(_*r+g)/p,a<0?(a=0,r=Sn(-v/f,0,1)):a>1&&(a=1,r=Sn((_-v)/f,0,1))}}return e.copy(o).add(Sy.multiplyScalar(r)),s.copy(l).add(_y.multiplyScalar(a)),e.sub(s),e.dot(e)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const WF=new at;class xY extends ps{constructor(t,e){super(),this.light=t,this.matrixAutoUpdate=!1,this.color=e,this.type="SpotLightHelper";const s=new Nn,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let a=0,o=1,l=32;a<l;a++,o++){const c=a/l*Math.PI*2,h=o/l*Math.PI*2;i.push(Math.cos(c),Math.sin(c),1,Math.cos(h),Math.sin(h),1)}s.setAttribute("position",new je(i,3));const r=new Ao({fog:!1,toneMapped:!1});this.cone=new bh(s,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),WF.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(WF),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Nd=new at,DT=new Tn,ZM=new Tn;class vY extends bh{constructor(t){const e=iV(t),s=new Nn,i=[],r=[];for(let c=0;c<e.length;c++){const h=e[c];h.parent&&h.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(0,0,0),r.push(0,0,0))}s.setAttribute("position",new je(i,3)),s.setAttribute("color",new je(r,3));const a=new Ao({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(s,a),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1;const o=new ke(255),l=new ke(65280);this.setColors(o,l)}updateMatrixWorld(t){const e=this.bones,s=this.geometry,i=s.getAttribute("position");ZM.copy(this.root.matrixWorld).invert();for(let r=0,a=0;r<e.length;r++){const o=e[r];o.parent&&o.parent.isBone&&(DT.multiplyMatrices(ZM,o.matrixWorld),Nd.setFromMatrixPosition(DT),i.setXYZ(a,Nd.x,Nd.y,Nd.z),DT.multiplyMatrices(ZM,o.parent.matrixWorld),Nd.setFromMatrixPosition(DT),i.setXYZ(a+1,Nd.x,Nd.y,Nd.z),a+=2)}s.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}setColors(t,e){const i=this.geometry.getAttribute("color");for(let r=0;r<i.count;r+=2)i.setXYZ(r,t.r,t.g,t.b),i.setXYZ(r+1,e.r,e.g,e.b);return i.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}function iV(n){const t=[];n.isBone===!0&&t.push(n);for(let e=0;e<n.children.length;e++)t.push(...iV(n.children[e]));return t}class bY extends rr{constructor(t,e,s){const i=new aS(e,4,2),r=new cp({wireframe:!0,fog:!1,toneMapped:!1});super(i,r),this.light=t,this.color=s,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const SY=new at,qF=new ke,XF=new ke;class _Y extends ps{constructor(t,e,s){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=s,this.type="HemisphereLightHelper";const i=new rS(e);i.rotateY(Math.PI*.5),this.material=new cp({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const r=i.getAttribute("position"),a=new Float32Array(r.count*3);i.setAttribute("color",new Fs(a,3)),this.add(new rr(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const e=t.geometry.getAttribute("color");qF.copy(this.light.color),XF.copy(this.light.groundColor);for(let s=0,i=e.count;s<i;s++){const r=s<i/2?qF:XF;e.setXYZ(s,r.r,r.g,r.b)}e.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),t.lookAt(SY.setFromMatrixPosition(this.light.matrixWorld).negate())}}class wY extends bh{constructor(t=10,e=10,s=4473924,i=8947848){s=new ke(s),i=new ke(i);const r=e/2,a=t/e,o=t/2,l=[],c=[];for(let p=0,g=0,v=-o;p<=e;p++,v+=a){l.push(-o,0,v,o,0,v),l.push(v,0,-o,v,0,o);const _=p===r?s:i;_.toArray(c,g),g+=3,_.toArray(c,g),g+=3,_.toArray(c,g),g+=3,_.toArray(c,g),g+=3}const h=new Nn;h.setAttribute("position",new je(l,3)),h.setAttribute("color",new je(c,3));const f=new Ao({vertexColors:!0,toneMapped:!1});super(h,f),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class TY extends bh{constructor(t=10,e=16,s=8,i=64,r=4473924,a=8947848){r=new ke(r),a=new ke(a);const o=[],l=[];if(e>1)for(let f=0;f<e;f++){const p=f/e*(Math.PI*2),g=Math.sin(p)*t,v=Math.cos(p)*t;o.push(0,0,0),o.push(g,0,v);const _=f&1?r:a;l.push(_.r,_.g,_.b),l.push(_.r,_.g,_.b)}for(let f=0;f<s;f++){const p=f&1?r:a,g=t-t/s*f;for(let v=0;v<i;v++){let _=v/i*(Math.PI*2),S=Math.sin(_)*g,b=Math.cos(_)*g;o.push(S,0,b),l.push(p.r,p.g,p.b),_=(v+1)/i*(Math.PI*2),S=Math.sin(_)*g,b=Math.cos(_)*g,o.push(S,0,b),l.push(p.r,p.g,p.b)}}const c=new Nn;c.setAttribute("position",new je(o,3)),c.setAttribute("color",new je(l,3));const h=new Ao({vertexColors:!0,toneMapped:!1});super(c,h),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const jF=new at,kT=new at,KF=new at;class EY extends ps{constructor(t,e,s){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=s,this.type="DirectionalLightHelper",e===void 0&&(e=1);let i=new Nn;i.setAttribute("position",new je([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const r=new Ao({fog:!1,toneMapped:!1});this.lightPlane=new Kd(i,r),this.add(this.lightPlane),i=new Nn,i.setAttribute("position",new je([0,0,0,0,0,1],3)),this.targetLine=new Kd(i,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),jF.setFromMatrixPosition(this.light.matrixWorld),kT.setFromMatrixPosition(this.light.target.matrixWorld),KF.subVectors(kT,jF),this.lightPlane.lookAt(kT),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(kT),this.targetLine.scale.z=KF.length()}}const OT=new at,Pi=new vC;class CY extends bh{constructor(t){const e=new Nn,s=new Ao({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],a={};o("n1","n2"),o("n2","n4"),o("n4","n3"),o("n3","n1"),o("f1","f2"),o("f2","f4"),o("f4","f3"),o("f3","f1"),o("n1","f1"),o("n2","f2"),o("n3","f3"),o("n4","f4"),o("p","n1"),o("p","n2"),o("p","n3"),o("p","n4"),o("u1","u2"),o("u2","u3"),o("u3","u1"),o("c","t"),o("p","c"),o("cn1","cn2"),o("cn3","cn4"),o("cf1","cf2"),o("cf3","cf4");function o(v,_){l(v),l(_)}function l(v){i.push(0,0,0),r.push(0,0,0),a[v]===void 0&&(a[v]=[]),a[v].push(i.length/3-1)}e.setAttribute("position",new je(i,3)),e.setAttribute("color",new je(r,3)),super(e,s),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=a,this.update();const c=new ke(16755200),h=new ke(16711680),f=new ke(43775),p=new ke(16777215),g=new ke(3355443);this.setColors(c,h,f,p,g)}setColors(t,e,s,i,r){const o=this.geometry.getAttribute("color");return o.setXYZ(0,t.r,t.g,t.b),o.setXYZ(1,t.r,t.g,t.b),o.setXYZ(2,t.r,t.g,t.b),o.setXYZ(3,t.r,t.g,t.b),o.setXYZ(4,t.r,t.g,t.b),o.setXYZ(5,t.r,t.g,t.b),o.setXYZ(6,t.r,t.g,t.b),o.setXYZ(7,t.r,t.g,t.b),o.setXYZ(8,t.r,t.g,t.b),o.setXYZ(9,t.r,t.g,t.b),o.setXYZ(10,t.r,t.g,t.b),o.setXYZ(11,t.r,t.g,t.b),o.setXYZ(12,t.r,t.g,t.b),o.setXYZ(13,t.r,t.g,t.b),o.setXYZ(14,t.r,t.g,t.b),o.setXYZ(15,t.r,t.g,t.b),o.setXYZ(16,t.r,t.g,t.b),o.setXYZ(17,t.r,t.g,t.b),o.setXYZ(18,t.r,t.g,t.b),o.setXYZ(19,t.r,t.g,t.b),o.setXYZ(20,t.r,t.g,t.b),o.setXYZ(21,t.r,t.g,t.b),o.setXYZ(22,t.r,t.g,t.b),o.setXYZ(23,t.r,t.g,t.b),o.setXYZ(24,e.r,e.g,e.b),o.setXYZ(25,e.r,e.g,e.b),o.setXYZ(26,e.r,e.g,e.b),o.setXYZ(27,e.r,e.g,e.b),o.setXYZ(28,e.r,e.g,e.b),o.setXYZ(29,e.r,e.g,e.b),o.setXYZ(30,e.r,e.g,e.b),o.setXYZ(31,e.r,e.g,e.b),o.setXYZ(32,s.r,s.g,s.b),o.setXYZ(33,s.r,s.g,s.b),o.setXYZ(34,s.r,s.g,s.b),o.setXYZ(35,s.r,s.g,s.b),o.setXYZ(36,s.r,s.g,s.b),o.setXYZ(37,s.r,s.g,s.b),o.setXYZ(38,i.r,i.g,i.b),o.setXYZ(39,i.r,i.g,i.b),o.setXYZ(40,r.r,r.g,r.b),o.setXYZ(41,r.r,r.g,r.b),o.setXYZ(42,r.r,r.g,r.b),o.setXYZ(43,r.r,r.g,r.b),o.setXYZ(44,r.r,r.g,r.b),o.setXYZ(45,r.r,r.g,r.b),o.setXYZ(46,r.r,r.g,r.b),o.setXYZ(47,r.r,r.g,r.b),o.setXYZ(48,r.r,r.g,r.b),o.setXYZ(49,r.r,r.g,r.b),o.needsUpdate=!0,this}update(){const t=this.geometry,e=this.pointMap,s=1,i=1;let r,a;if(Pi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),this.camera.reversedDepth===!0)r=1,a=0;else if(this.camera.coordinateSystem===Sl)r=-1,a=1;else if(this.camera.coordinateSystem===Jy)r=0,a=1;else throw new Error("THREE.CameraHelper.update(): Invalid coordinate system: "+this.camera.coordinateSystem);er("c",e,t,Pi,0,0,r),er("t",e,t,Pi,0,0,a),er("n1",e,t,Pi,-s,-i,r),er("n2",e,t,Pi,s,-i,r),er("n3",e,t,Pi,-s,i,r),er("n4",e,t,Pi,s,i,r),er("f1",e,t,Pi,-s,-i,a),er("f2",e,t,Pi,s,-i,a),er("f3",e,t,Pi,-s,i,a),er("f4",e,t,Pi,s,i,a),er("u1",e,t,Pi,s*.7,i*1.1,r),er("u2",e,t,Pi,-s*.7,i*1.1,r),er("u3",e,t,Pi,0,i*2,r),er("cf1",e,t,Pi,-s,0,a),er("cf2",e,t,Pi,s,0,a),er("cf3",e,t,Pi,0,-i,a),er("cf4",e,t,Pi,0,i,a),er("cn1",e,t,Pi,-s,0,r),er("cn2",e,t,Pi,s,0,r),er("cn3",e,t,Pi,0,-i,r),er("cn4",e,t,Pi,0,i,r),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function er(n,t,e,s,i,r,a){OT.set(i,r,a).unproject(s);const o=t[n];if(o!==void 0){const l=e.getAttribute("position");for(let c=0,h=o.length;c<h;c++)l.setXYZ(o[c],OT.x,OT.y,OT.z)}}const $T=new Ga;class AY extends bh{constructor(t,e=16776960){const s=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),r=new Nn;r.setIndex(new Fs(s,1)),r.setAttribute("position",new Fs(i,3)),super(r,new Ao({color:e,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(){if(this.object!==void 0&&$T.setFromObject(this.object),$T.isEmpty())return;const t=$T.min,e=$T.max,s=this.geometry.attributes.position,i=s.array;i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=t.x,i[4]=e.y,i[5]=e.z,i[6]=t.x,i[7]=t.y,i[8]=e.z,i[9]=e.x,i[10]=t.y,i[11]=e.z,i[12]=e.x,i[13]=e.y,i[14]=t.z,i[15]=t.x,i[16]=e.y,i[17]=t.z,i[18]=t.x,i[19]=t.y,i[20]=t.z,i[21]=e.x,i[22]=t.y,i[23]=t.z,s.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t,e){return super.copy(t,e),this.object=t.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class NY extends bh{constructor(t,e=16776960){const s=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],r=new Nn;r.setIndex(new Fs(s,1)),r.setAttribute("position",new je(i,3)),super(r,new Ao({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}dispose(){this.geometry.dispose(),this.material.dispose()}}class MY extends Kd{constructor(t,e=1,s=16776960){const i=s,r=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],a=new Nn;a.setAttribute("position",new je(r,3)),a.computeBoundingSphere(),super(a,new Ao({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const o=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new Nn;l.setAttribute("position",new je(o,3)),l.computeBoundingSphere(),this.add(new rr(l,new cp({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const YF=new at;let LT,QM;class IY extends ps{constructor(t=new at(0,0,1),e=new at(0,0,0),s=1,i=16776960,r=s*.2,a=r*.2){super(),this.type="ArrowHelper",LT===void 0&&(LT=new Nn,LT.setAttribute("position",new je([0,0,0,0,1,0],3)),QM=new iS(.5,1,5,1),QM.translate(0,-.5,0)),this.position.copy(e),this.line=new Kd(LT,new Ao({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new rr(QM,new cp({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(s,r,a)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{YF.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(YF,e)}}setLength(t,e=t*.2,s=e*.2){this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(s,e,s),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class RY extends bh{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],s=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new Nn;i.setAttribute("position",new je(e,3)),i.setAttribute("color",new je(s,3));const r=new Ao({vertexColors:!0,toneMapped:!1});super(i,r),this.type="AxesHelper"}setColors(t,e,s){const i=new ke,r=this.geometry.attributes.color.array;return i.set(t),i.toArray(r,0),i.toArray(r,3),i.set(e),i.toArray(r,6),i.toArray(r,9),i.set(s),i.toArray(r,12),i.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class DY{constructor(){this.type="ShapePath",this.color=new ke,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new d2,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,s,i){return this.currentPath.quadraticCurveTo(t,e,s,i),this}bezierCurveTo(t,e,s,i,r,a){return this.currentPath.bezierCurveTo(t,e,s,i,r,a),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t){function e(b){const T=[];for(let C=0,A=b.length;C<A;C++){const I=b[C],D=new Bd;D.curves=I.curves,T.push(D)}return T}function s(b,T){const C=T.length;let A=!1;for(let I=C-1,D=0;D<C;I=D++){let F=T[I],z=T[D],k=z.x-F.x,O=z.y-F.y;if(Math.abs(O)>Number.EPSILON){if(O<0&&(F=T[D],k=-k,z=T[I],O=-O),b.y<F.y||b.y>z.y)continue;if(b.y===F.y){if(b.x===F.x)return!0}else{const L=O*(b.x-F.x)-k*(b.y-F.y);if(L===0)return!0;if(L<0)continue;A=!A}}else{if(b.y!==F.y)continue;if(z.x<=b.x&&b.x<=F.x||F.x<=b.x&&b.x<=z.x)return!0}}return A}const i=Zc.isClockWise,r=this.subPaths;if(r.length===0)return[];let a,o,l;const c=[];if(r.length===1)return o=r[0],l=new Bd,l.curves=o.curves,c.push(l),c;let h=!i(r[0].getPoints());h=t?!h:h;const f=[],p=[];let g=[],v=0,_;p[v]=void 0,g[v]=[];for(let b=0,T=r.length;b<T;b++)o=r[b],_=o.getPoints(),a=i(_),a=t?!a:a,a?(!h&&p[v]&&v++,p[v]={s:new Bd,p:_},p[v].s.curves=o.curves,h&&v++,g[v]=[]):g[v].push({h:o,p:_[0]});if(!p[0])return e(r);if(p.length>1){let b=!1,T=0;for(let C=0,A=p.length;C<A;C++)f[C]=[];for(let C=0,A=p.length;C<A;C++){const I=g[C];for(let D=0;D<I.length;D++){const F=I[D];let z=!0;for(let k=0;k<p.length;k++)s(F.p,p[k].p)&&(C!==k&&T++,z?(z=!1,f[k].push(F)):b=!0);z&&f[C].push(F)}}T>0&&b===!1&&(g=f)}let S;for(let b=0,T=p.length;b<T;b++){l=p[b].s,c.push(l),S=g[b];for(let C=0,A=S.length;C<A;C++)l.holes.push(S[C].h)}return c}}class kY extends Rl{constructor(t,e=null){super(),this.object=t,this.domElement=e,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(t){if(t===void 0){Oe("Controls: connect() now requires an element.");return}this.domElement!==null&&this.disconnect(),this.domElement=t}disconnect(){}dispose(){}update(){}}function OY(n,t){const e=n.image&&n.image.width?n.image.width/n.image.height:1;return e>t?(n.repeat.x=1,n.repeat.y=e/t,n.offset.x=0,n.offset.y=(1-n.repeat.y)/2):(n.repeat.x=t/e,n.repeat.y=1,n.offset.x=(1-n.repeat.x)/2,n.offset.y=0),n}function $Y(n,t){const e=n.image&&n.image.width?n.image.width/n.image.height:1;return e>t?(n.repeat.x=t/e,n.repeat.y=1,n.offset.x=(1-n.repeat.x)/2,n.offset.y=0):(n.repeat.x=1,n.repeat.y=e/t,n.offset.x=0,n.offset.y=(1-n.repeat.y)/2),n}function LY(n){return n.repeat.x=1,n.repeat.y=1,n.offset.x=0,n.offset.y=0,n}function lR(n,t,e,s){const i=FY(s);switch(e){case qD:return n*t;case hC:return n*t/i.components*i.byteLength;case eS:return n*t/i.components*i.byteLength;case ag:return n*t*2/i.components*i.byteLength;case fC:return n*t*2/i.components*i.byteLength;case XD:return n*t*3/i.components*i.byteLength;case Ba:return n*t*4/i.components*i.byteLength;case dC:return n*t*4/i.components*i.byteLength;case Jb:case t1:return Math.floor((n+3)/4)*Math.floor((t+3)/4)*8;case e1:case n1:return Math.floor((n+3)/4)*Math.floor((t+3)/4)*16;case DE:case OE:return Math.max(n,16)*Math.max(t,8)/4;case RE:case kE:return Math.max(n,8)*Math.max(t,8)/2;case $E:case LE:case zE:case UE:return Math.floor((n+3)/4)*Math.floor((t+3)/4)*8;case FE:case BE:case PE:return Math.floor((n+3)/4)*Math.floor((t+3)/4)*16;case VE:return Math.floor((n+3)/4)*Math.floor((t+3)/4)*16;case GE:return Math.floor((n+4)/5)*Math.floor((t+3)/4)*16;case HE:return Math.floor((n+4)/5)*Math.floor((t+4)/5)*16;case WE:return Math.floor((n+5)/6)*Math.floor((t+4)/5)*16;case qE:return Math.floor((n+5)/6)*Math.floor((t+5)/6)*16;case XE:return Math.floor((n+7)/8)*Math.floor((t+4)/5)*16;case jE:return Math.floor((n+7)/8)*Math.floor((t+5)/6)*16;case KE:return Math.floor((n+7)/8)*Math.floor((t+7)/8)*16;case YE:return Math.floor((n+9)/10)*Math.floor((t+4)/5)*16;case ZE:return Math.floor((n+9)/10)*Math.floor((t+5)/6)*16;case QE:return Math.floor((n+9)/10)*Math.floor((t+7)/8)*16;case JE:return Math.floor((n+9)/10)*Math.floor((t+9)/10)*16;case t2:return Math.floor((n+11)/12)*Math.floor((t+9)/10)*16;case e2:return Math.floor((n+11)/12)*Math.floor((t+11)/12)*16;case n2:case s2:case i2:return Math.ceil(n/4)*Math.ceil(t/4)*16;case r2:case a2:return Math.ceil(n/4)*Math.ceil(t/4)*8;case o2:case l2:return Math.ceil(n/4)*Math.ceil(t/4)*16}throw new Error(`Unable to determine texture byte length for ${e} format.`)}function FY(n){switch(n){case Gi:case VD:return{byteLength:1,components:1};case Qy:case GD:case ru:return{byteLength:2,components:1};case cC:case uC:return{byteLength:2,components:4};case Nl:case lC:case Ua:return{byteLength:4,components:1};case HD:case WD:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${n}.`)}class zY{static contain(t,e){return OY(t,e)}static cover(t,e){return $Y(t,e)}static fill(t){return LY(t)}static getByteLength(t,e,s,i){return lR(t,e,s,i)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:kg}}));typeof window<"u"&&(window.__THREE__?Oe("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=kg);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function rV(){let n=null,t=!1,e=null,s=null;function i(r,a){e(r,a),s=n.requestAnimationFrame(i)}return{start:function(){t!==!0&&e!==null&&(s=n.requestAnimationFrame(i),t=!0)},stop:function(){n.cancelAnimationFrame(s),t=!1},setAnimationLoop:function(r){e=r},setContext:function(r){n=r}}}function UY(n){const t=new WeakMap;function e(o,l){const c=o.array,h=o.usage,f=c.byteLength,p=n.createBuffer();n.bindBuffer(l,p),n.bufferData(l,c,h),o.onUploadCallback();let g;if(c instanceof Float32Array)g=n.FLOAT;else if(typeof Float16Array<"u"&&c instanceof Float16Array)g=n.HALF_FLOAT;else if(c instanceof Uint16Array)o.isFloat16BufferAttribute?g=n.HALF_FLOAT:g=n.UNSIGNED_SHORT;else if(c instanceof Int16Array)g=n.SHORT;else if(c instanceof Uint32Array)g=n.UNSIGNED_INT;else if(c instanceof Int32Array)g=n.INT;else if(c instanceof Int8Array)g=n.BYTE;else if(c instanceof Uint8Array)g=n.UNSIGNED_BYTE;else if(c instanceof Uint8ClampedArray)g=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+c);return{buffer:p,type:g,bytesPerElement:c.BYTES_PER_ELEMENT,version:o.version,size:f}}function s(o,l,c){const h=l.array,f=l.updateRanges;if(n.bindBuffer(c,o),f.length===0)n.bufferSubData(c,0,h);else{f.sort((g,v)=>g.start-v.start);let p=0;for(let g=1;g<f.length;g++){const v=f[p],_=f[g];_.start<=v.start+v.count+1?v.count=Math.max(v.count,_.start+_.count-v.start):(++p,f[p]=_)}f.length=p+1;for(let g=0,v=f.length;g<v;g++){const _=f[g];n.bufferSubData(c,_.start*h.BYTES_PER_ELEMENT,h,_.start,_.count)}l.clearUpdateRanges()}l.onUploadCallback()}function i(o){return o.isInterleavedBufferAttribute&&(o=o.data),t.get(o)}function r(o){o.isInterleavedBufferAttribute&&(o=o.data);const l=t.get(o);l&&(n.deleteBuffer(l.buffer),t.delete(o))}function a(o,l){if(o.isInterleavedBufferAttribute&&(o=o.data),o.isGLBufferAttribute){const h=t.get(o);(!h||h.version<o.version)&&t.set(o,{buffer:o.buffer,type:o.type,bytesPerElement:o.elementSize,version:o.version});return}const c=t.get(o);if(c===void 0)t.set(o,e(o,l));else if(c.version<o.version){if(c.size!==o.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");s(c.buffer,o,l),c.version=o.version}}return{get:i,remove:r,update:a}}var BY=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,PY=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,VY=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,GY=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,HY=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,WY=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,qY=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,XY=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,jY=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,KY=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,YY=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,ZY=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,QY=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,JY=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,tZ=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,eZ=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,nZ=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,sZ=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,iZ=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,rZ=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,aZ=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,oZ=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,lZ=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,cZ=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,uZ=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,hZ=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,fZ=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,dZ=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,pZ=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,mZ=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,gZ="gl_FragColor = linearToOutputTexel( gl_FragColor );",yZ=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,xZ=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,vZ=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
#endif`,bZ=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,SZ=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,_Z=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,wZ=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,TZ=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,EZ=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,CZ=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,AZ=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,NZ=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,MZ=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,IZ=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,RZ=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,DZ=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,kZ=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,OZ=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,$Z=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,LZ=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,FZ=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.diffuseContribution = diffuseColor.rgb * ( 1.0 - metalnessFactor );
material.metalness = metalnessFactor;
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor;
	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = vec3( 0.04 );
	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.0001, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,zZ=`uniform sampler2D dfgLUT;
struct PhysicalMaterial {
	vec3 diffuseColor;
	vec3 diffuseContribution;
	vec3 specularColor;
	vec3 specularColorBlended;
	float roughness;
	float metalness;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
		vec3 iridescenceFresnelDielectric;
		vec3 iridescenceFresnelMetallic;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return v;
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColorBlended;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float rInv = 1.0 / ( roughness + 0.1 );
	float a = -1.9362 + 1.0678 * roughness + 0.4573 * r2 - 0.8469 * rInv;
	float b = -0.6014 + 0.5538 * roughness - 0.4670 * r2 - 0.1255 * rInv;
	float DG = exp( a * dotNV + b );
	return saturate( DG );
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
vec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 dfgV = texture2D( dfgLUT, vec2( material.roughness, dotNV ) ).rg;
	vec2 dfgL = texture2D( dfgLUT, vec2( material.roughness, dotNL ) ).rg;
	vec3 FssEss_V = material.specularColorBlended * dfgV.x + material.specularF90 * dfgV.y;
	vec3 FssEss_L = material.specularColorBlended * dfgL.x + material.specularF90 * dfgL.y;
	float Ess_V = dfgV.x + dfgV.y;
	float Ess_L = dfgL.x + dfgL.y;
	float Ems_V = 1.0 - Ess_V;
	float Ems_L = 1.0 - Ess_L;
	vec3 Favg = material.specularColorBlended + ( 1.0 - material.specularColorBlended ) * 0.047619;
	vec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg + EPSILON );
	float compensationFactor = Ems_V * Ems_L;
	vec3 multiScatter = Fms * compensationFactor;
	return singleScatter + multiScatter;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColorBlended * t2.x + ( vec3( 1.0 ) - material.specularColorBlended ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseContribution * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
 
 		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
 
 		float sheenAlbedoV = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
 		float sheenAlbedoL = IBLSheenBRDF( geometryNormal, directLight.direction, material.sheenRoughness );
 
 		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * max( sheenAlbedoV, sheenAlbedoL );
 
 		irradiance *= sheenEnergyComp;
 
 	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseContribution );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 diffuse = irradiance * BRDF_Lambert( material.diffuseContribution );
	#ifdef USE_SHEEN
		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;
		diffuse *= sheenEnergyComp;
	#endif
	reflectedLight.indirectDiffuse += diffuse;
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness ) * RECIPROCAL_PI;
 	#endif
	vec3 singleScatteringDielectric = vec3( 0.0 );
	vec3 multiScatteringDielectric = vec3( 0.0 );
	vec3 singleScatteringMetallic = vec3( 0.0 );
	vec3 multiScatteringMetallic = vec3( 0.0 );
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnelDielectric, material.roughness, singleScatteringDielectric, multiScatteringDielectric );
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.iridescence, material.iridescenceFresnelMetallic, material.roughness, singleScatteringMetallic, multiScatteringMetallic );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScatteringDielectric, multiScatteringDielectric );
		computeMultiscattering( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.roughness, singleScatteringMetallic, multiScatteringMetallic );
	#endif
	vec3 singleScattering = mix( singleScatteringDielectric, singleScatteringMetallic, material.metalness );
	vec3 multiScattering = mix( multiScatteringDielectric, multiScatteringMetallic, material.metalness );
	vec3 totalScatteringDielectric = singleScatteringDielectric + multiScatteringDielectric;
	vec3 diffuse = material.diffuseContribution * ( 1.0 - totalScatteringDielectric );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	vec3 indirectSpecular = radiance * singleScattering;
	indirectSpecular += multiScattering * cosineWeightedIrradiance;
	vec3 indirectDiffuse = diffuse * cosineWeightedIrradiance;
	#ifdef USE_SHEEN
		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;
		indirectSpecular *= sheenEnergyComp;
		indirectDiffuse *= sheenEnergyComp;
	#endif
	reflectedLight.indirectSpecular += indirectSpecular;
	reflectedLight.indirectDiffuse += indirectDiffuse;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,UZ=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnelDielectric = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceFresnelMetallic = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.diffuseColor );
		material.iridescenceFresnel = mix( material.iridescenceFresnelDielectric, material.iridescenceFresnelMetallic, material.metalness );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS ) && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,BZ=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,PZ=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,VZ=`#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,GZ=`#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,HZ=`#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,WZ=`#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,qZ=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,XZ=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,jZ=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,KZ=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,YZ=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,ZZ=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,QZ=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,JZ=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,tQ=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,eQ=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,nQ=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,sQ=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,iQ=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,rQ=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,aQ=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,oQ=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,lQ=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,cQ=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,uQ=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,hQ=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,fQ=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,dQ=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,pQ=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,mQ=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,gQ=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,yQ=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,xQ=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,vQ=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,bQ=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,SQ=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform sampler2DShadow directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		#else
			uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		#endif
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform sampler2DShadow spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		#else
			uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		#endif
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform samplerCubeShadow pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		#elif defined( SHADOWMAP_TYPE_BASIC )
			uniform samplerCube pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		#endif
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	#if defined( SHADOWMAP_TYPE_PCF )
		float interleavedGradientNoise( vec2 position ) {
			return fract( 52.9829189 * fract( dot( position, vec2( 0.06711056, 0.00583715 ) ) ) );
		}
		vec2 vogelDiskSample( int sampleIndex, int samplesCount, float phi ) {
			const float goldenAngle = 2.399963229728653;
			float r = sqrt( ( float( sampleIndex ) + 0.5 ) / float( samplesCount ) );
			float theta = float( sampleIndex ) * goldenAngle + phi;
			return vec2( cos( theta ), sin( theta ) ) * r;
		}
	#endif
	#if defined( SHADOWMAP_TYPE_PCF )
		float getShadow( sampler2DShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
				float radius = shadowRadius * texelSize.x;
				float phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;
				shadow = (
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 0, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 1, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 2, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 3, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 4, 5, phi ) * radius, shadowCoord.z ) )
				) * 0.2;
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#elif defined( SHADOWMAP_TYPE_VSM )
		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				vec2 distribution = texture2D( shadowMap, shadowCoord.xy ).rg;
				float mean = distribution.x;
				float variance = distribution.y * distribution.y;
				#ifdef USE_REVERSED_DEPTH_BUFFER
					float hard_shadow = step( mean, shadowCoord.z );
				#else
					float hard_shadow = step( shadowCoord.z, mean );
				#endif
				if ( hard_shadow == 1.0 ) {
					shadow = 1.0;
				} else {
					variance = max( variance, 0.0000001 );
					float d = shadowCoord.z - mean;
					float p_max = variance / ( variance + d * d );
					p_max = clamp( ( p_max - 0.3 ) / 0.65, 0.0, 1.0 );
					shadow = max( hard_shadow, p_max );
				}
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#else
		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				float depth = texture2D( shadowMap, shadowCoord.xy ).r;
				#ifdef USE_REVERSED_DEPTH_BUFFER
					shadow = step( depth, shadowCoord.z );
				#else
					shadow = step( shadowCoord.z, depth );
				#endif
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#if defined( SHADOWMAP_TYPE_PCF )
	float getPointShadow( samplerCubeShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		vec3 bd3D = normalize( lightToPosition );
		vec3 absVec = abs( lightToPosition );
		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );
		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {
			float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );
			dp += shadowBias;
			float texelSize = shadowRadius / shadowMapSize.x;
			vec3 absDir = abs( bd3D );
			vec3 tangent = absDir.x > absDir.z ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 );
			tangent = normalize( cross( bd3D, tangent ) );
			vec3 bitangent = cross( bd3D, tangent );
			float phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;
			shadow = (
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 0, 5, phi ).x + bitangent * vogelDiskSample( 0, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 1, 5, phi ).x + bitangent * vogelDiskSample( 1, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 2, 5, phi ).x + bitangent * vogelDiskSample( 2, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 3, 5, phi ).x + bitangent * vogelDiskSample( 3, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 4, 5, phi ).x + bitangent * vogelDiskSample( 4, 5, phi ).y ) * texelSize, dp ) )
			) * 0.2;
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	#elif defined( SHADOWMAP_TYPE_BASIC )
	float getPointShadow( samplerCube shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		vec3 bd3D = normalize( lightToPosition );
		vec3 absVec = abs( lightToPosition );
		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );
		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {
			float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );
			dp += shadowBias;
			float depth = textureCube( shadowMap, bd3D ).r;
			#ifdef USE_REVERSED_DEPTH_BUFFER
				shadow = step( depth, dp );
			#else
				shadow = step( dp, depth );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	#endif
	#endif
#endif`,_Q=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,wQ=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,TQ=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0 && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,EQ=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,CQ=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,AQ=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,NQ=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,MQ=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,IQ=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,RQ=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,DQ=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,kQ=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseContribution, material.specularColorBlended, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,OQ=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,$Q=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,LQ=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,FQ=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,zQ=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const UQ=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,BQ=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,PQ=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,VQ=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,GQ=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,HQ=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,WQ=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,qQ=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,XQ=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,jQ=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = vec4( dist, 0.0, 0.0, 1.0 );
}`,KQ=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,YQ=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,ZQ=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,QQ=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,JQ=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,tJ=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,eJ=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,nJ=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,sJ=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,iJ=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,rJ=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,aJ=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( normalize( normal ) * 0.5 + 0.5, diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,oJ=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,lJ=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,cJ=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,uJ=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
 
		outgoingLight = outgoingLight + sheenSpecularDirect + sheenSpecularIndirect;
 
 	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,hJ=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fJ=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,dJ=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,pJ=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,mJ=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,gJ=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,yJ=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,xJ=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Pn={alphahash_fragment:BY,alphahash_pars_fragment:PY,alphamap_fragment:VY,alphamap_pars_fragment:GY,alphatest_fragment:HY,alphatest_pars_fragment:WY,aomap_fragment:qY,aomap_pars_fragment:XY,batching_pars_vertex:jY,batching_vertex:KY,begin_vertex:YY,beginnormal_vertex:ZY,bsdfs:QY,iridescence_fragment:JY,bumpmap_pars_fragment:tZ,clipping_planes_fragment:eZ,clipping_planes_pars_fragment:nZ,clipping_planes_pars_vertex:sZ,clipping_planes_vertex:iZ,color_fragment:rZ,color_pars_fragment:aZ,color_pars_vertex:oZ,color_vertex:lZ,common:cZ,cube_uv_reflection_fragment:uZ,defaultnormal_vertex:hZ,displacementmap_pars_vertex:fZ,displacementmap_vertex:dZ,emissivemap_fragment:pZ,emissivemap_pars_fragment:mZ,colorspace_fragment:gZ,colorspace_pars_fragment:yZ,envmap_fragment:xZ,envmap_common_pars_fragment:vZ,envmap_pars_fragment:bZ,envmap_pars_vertex:SZ,envmap_physical_pars_fragment:DZ,envmap_vertex:_Z,fog_vertex:wZ,fog_pars_vertex:TZ,fog_fragment:EZ,fog_pars_fragment:CZ,gradientmap_pars_fragment:AZ,lightmap_pars_fragment:NZ,lights_lambert_fragment:MZ,lights_lambert_pars_fragment:IZ,lights_pars_begin:RZ,lights_toon_fragment:kZ,lights_toon_pars_fragment:OZ,lights_phong_fragment:$Z,lights_phong_pars_fragment:LZ,lights_physical_fragment:FZ,lights_physical_pars_fragment:zZ,lights_fragment_begin:UZ,lights_fragment_maps:BZ,lights_fragment_end:PZ,logdepthbuf_fragment:VZ,logdepthbuf_pars_fragment:GZ,logdepthbuf_pars_vertex:HZ,logdepthbuf_vertex:WZ,map_fragment:qZ,map_pars_fragment:XZ,map_particle_fragment:jZ,map_particle_pars_fragment:KZ,metalnessmap_fragment:YZ,metalnessmap_pars_fragment:ZZ,morphinstance_vertex:QZ,morphcolor_vertex:JZ,morphnormal_vertex:tQ,morphtarget_pars_vertex:eQ,morphtarget_vertex:nQ,normal_fragment_begin:sQ,normal_fragment_maps:iQ,normal_pars_fragment:rQ,normal_pars_vertex:aQ,normal_vertex:oQ,normalmap_pars_fragment:lQ,clearcoat_normal_fragment_begin:cQ,clearcoat_normal_fragment_maps:uQ,clearcoat_pars_fragment:hQ,iridescence_pars_fragment:fQ,opaque_fragment:dQ,packing:pQ,premultiplied_alpha_fragment:mQ,project_vertex:gQ,dithering_fragment:yQ,dithering_pars_fragment:xQ,roughnessmap_fragment:vQ,roughnessmap_pars_fragment:bQ,shadowmap_pars_fragment:SQ,shadowmap_pars_vertex:_Q,shadowmap_vertex:wQ,shadowmask_pars_fragment:TQ,skinbase_vertex:EQ,skinning_pars_vertex:CQ,skinning_vertex:AQ,skinnormal_vertex:NQ,specularmap_fragment:MQ,specularmap_pars_fragment:IQ,tonemapping_fragment:RQ,tonemapping_pars_fragment:DQ,transmission_fragment:kQ,transmission_pars_fragment:OQ,uv_pars_fragment:$Q,uv_pars_vertex:LQ,uv_vertex:FQ,worldpos_vertex:zQ,background_vert:UQ,background_frag:BQ,backgroundCube_vert:PQ,backgroundCube_frag:VQ,cube_vert:GQ,cube_frag:HQ,depth_vert:WQ,depth_frag:qQ,distance_vert:XQ,distance_frag:jQ,equirect_vert:KQ,equirect_frag:YQ,linedashed_vert:ZQ,linedashed_frag:QQ,meshbasic_vert:JQ,meshbasic_frag:tJ,meshlambert_vert:eJ,meshlambert_frag:nJ,meshmatcap_vert:sJ,meshmatcap_frag:iJ,meshnormal_vert:rJ,meshnormal_frag:aJ,meshphong_vert:oJ,meshphong_frag:lJ,meshphysical_vert:cJ,meshphysical_frag:uJ,meshtoon_vert:hJ,meshtoon_frag:fJ,points_vert:dJ,points_frag:pJ,shadow_vert:mJ,shadow_frag:gJ,sprite_vert:yJ,sprite_frag:xJ},Le={common:{diffuse:{value:new ke(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new On},alphaMap:{value:null},alphaMapTransform:{value:new On},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new On}},envmap:{envMap:{value:null},envMapRotation:{value:new On},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},dfgLUT:{value:null}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new On}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new On}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new On},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new On},normalScale:{value:new Yt(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new On},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new On}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new On}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new On}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ke(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new ke(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new On},alphaTest:{value:0},uvTransform:{value:new On}},sprite:{diffuse:{value:new ke(16777215)},opacity:{value:1},center:{value:new Yt(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new On},alphaMap:{value:null},alphaMapTransform:{value:new On},alphaTest:{value:0}}},qc={basic:{uniforms:go([Le.common,Le.specularmap,Le.envmap,Le.aomap,Le.lightmap,Le.fog]),vertexShader:Pn.meshbasic_vert,fragmentShader:Pn.meshbasic_frag},lambert:{uniforms:go([Le.common,Le.specularmap,Le.envmap,Le.aomap,Le.lightmap,Le.emissivemap,Le.bumpmap,Le.normalmap,Le.displacementmap,Le.fog,Le.lights,{emissive:{value:new ke(0)}}]),vertexShader:Pn.meshlambert_vert,fragmentShader:Pn.meshlambert_frag},phong:{uniforms:go([Le.common,Le.specularmap,Le.envmap,Le.aomap,Le.lightmap,Le.emissivemap,Le.bumpmap,Le.normalmap,Le.displacementmap,Le.fog,Le.lights,{emissive:{value:new ke(0)},specular:{value:new ke(1118481)},shininess:{value:30}}]),vertexShader:Pn.meshphong_vert,fragmentShader:Pn.meshphong_frag},standard:{uniforms:go([Le.common,Le.envmap,Le.aomap,Le.lightmap,Le.emissivemap,Le.bumpmap,Le.normalmap,Le.displacementmap,Le.roughnessmap,Le.metalnessmap,Le.fog,Le.lights,{emissive:{value:new ke(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Pn.meshphysical_vert,fragmentShader:Pn.meshphysical_frag},toon:{uniforms:go([Le.common,Le.aomap,Le.lightmap,Le.emissivemap,Le.bumpmap,Le.normalmap,Le.displacementmap,Le.gradientmap,Le.fog,Le.lights,{emissive:{value:new ke(0)}}]),vertexShader:Pn.meshtoon_vert,fragmentShader:Pn.meshtoon_frag},matcap:{uniforms:go([Le.common,Le.bumpmap,Le.normalmap,Le.displacementmap,Le.fog,{matcap:{value:null}}]),vertexShader:Pn.meshmatcap_vert,fragmentShader:Pn.meshmatcap_frag},points:{uniforms:go([Le.points,Le.fog]),vertexShader:Pn.points_vert,fragmentShader:Pn.points_frag},dashed:{uniforms:go([Le.common,Le.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Pn.linedashed_vert,fragmentShader:Pn.linedashed_frag},depth:{uniforms:go([Le.common,Le.displacementmap]),vertexShader:Pn.depth_vert,fragmentShader:Pn.depth_frag},normal:{uniforms:go([Le.common,Le.bumpmap,Le.normalmap,Le.displacementmap,{opacity:{value:1}}]),vertexShader:Pn.meshnormal_vert,fragmentShader:Pn.meshnormal_frag},sprite:{uniforms:go([Le.sprite,Le.fog]),vertexShader:Pn.sprite_vert,fragmentShader:Pn.sprite_frag},background:{uniforms:{uvTransform:{value:new On},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Pn.background_vert,fragmentShader:Pn.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new On}},vertexShader:Pn.backgroundCube_vert,fragmentShader:Pn.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Pn.cube_vert,fragmentShader:Pn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Pn.equirect_vert,fragmentShader:Pn.equirect_frag},distance:{uniforms:go([Le.common,Le.displacementmap,{referencePosition:{value:new at},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Pn.distance_vert,fragmentShader:Pn.distance_frag},shadow:{uniforms:go([Le.lights,Le.fog,{color:{value:new ke(0)},opacity:{value:1}}]),vertexShader:Pn.shadow_vert,fragmentShader:Pn.shadow_frag}};qc.physical={uniforms:go([qc.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new On},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new On},clearcoatNormalScale:{value:new Yt(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new On},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new On},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new On},sheen:{value:0},sheenColor:{value:new ke(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new On},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new On},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new On},transmissionSamplerSize:{value:new Yt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new On},attenuationDistance:{value:0},attenuationColor:{value:new ke(0)},specularColor:{value:new ke(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new On},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new On},anisotropyVector:{value:new Yt},anisotropyMap:{value:null},anisotropyMapTransform:{value:new On}}]),vertexShader:Pn.meshphysical_vert,fragmentShader:Pn.meshphysical_frag};const FT={r:0,b:0,g:0},Am=new Ml,vJ=new Tn;function bJ(n,t,e,s,i,r,a){const o=new ke(0);let l=r===!0?0:1,c,h,f=null,p=0,g=null;function v(C){let A=C.isScene===!0?C.background:null;return A&&A.isTexture&&(A=(C.backgroundBlurriness>0?e:t).get(A)),A}function _(C){let A=!1;const I=v(C);I===null?b(o,l):I&&I.isColor&&(b(I,1),A=!0);const D=n.xr.getEnvironmentBlendMode();D==="additive"?s.buffers.color.setClear(0,0,0,1,a):D==="alpha-blend"&&s.buffers.color.setClear(0,0,0,0,a),(n.autoClear||A)&&(s.buffers.depth.setTest(!0),s.buffers.depth.setMask(!0),s.buffers.color.setMask(!0),n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil))}function S(C,A){const I=v(A);I&&(I.isCubeTexture||I.mapping===wx)?(h===void 0&&(h=new rr(new $g(1,1,1),new ar({name:"BackgroundCubeMaterial",uniforms:sx(qc.backgroundCube.uniforms),vertexShader:qc.backgroundCube.vertexShader,fragmentShader:qc.backgroundCube.fragmentShader,side:kr,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),h.geometry.deleteAttribute("normal"),h.geometry.deleteAttribute("uv"),h.onBeforeRender=function(D,F,z){this.matrixWorld.copyPosition(z.matrixWorld)},Object.defineProperty(h.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(h)),Am.copy(A.backgroundRotation),Am.x*=-1,Am.y*=-1,Am.z*=-1,I.isCubeTexture&&I.isRenderTargetTexture===!1&&(Am.y*=-1,Am.z*=-1),h.material.uniforms.envMap.value=I,h.material.uniforms.flipEnvMap.value=I.isCubeTexture&&I.isRenderTargetTexture===!1?-1:1,h.material.uniforms.backgroundBlurriness.value=A.backgroundBlurriness,h.material.uniforms.backgroundIntensity.value=A.backgroundIntensity,h.material.uniforms.backgroundRotation.value.setFromMatrix4(vJ.makeRotationFromEuler(Am)),h.material.toneMapped=ss.getTransfer(I.colorSpace)!==Ls,(f!==I||p!==I.version||g!==n.toneMapping)&&(h.material.needsUpdate=!0,f=I,p=I.version,g=n.toneMapping),h.layers.enableAll(),C.unshift(h,h.geometry,h.material,0,0,null)):I&&I.isTexture&&(c===void 0&&(c=new rr(new Ex(2,2),new ar({name:"BackgroundMaterial",uniforms:sx(qc.background.uniforms),vertexShader:qc.background.vertexShader,fragmentShader:qc.background.fragmentShader,side:dh,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(c)),c.material.uniforms.t2D.value=I,c.material.uniforms.backgroundIntensity.value=A.backgroundIntensity,c.material.toneMapped=ss.getTransfer(I.colorSpace)!==Ls,I.matrixAutoUpdate===!0&&I.updateMatrix(),c.material.uniforms.uvTransform.value.copy(I.matrix),(f!==I||p!==I.version||g!==n.toneMapping)&&(c.material.needsUpdate=!0,f=I,p=I.version,g=n.toneMapping),c.layers.enableAll(),C.unshift(c,c.geometry,c.material,0,0,null))}function b(C,A){C.getRGB(FT,a4(n)),s.buffers.color.setClear(FT.r,FT.g,FT.b,A,a)}function T(){h!==void 0&&(h.geometry.dispose(),h.material.dispose(),h=void 0),c!==void 0&&(c.geometry.dispose(),c.material.dispose(),c=void 0)}return{getClearColor:function(){return o},setClearColor:function(C,A=1){o.set(C),l=A,b(o,l)},getClearAlpha:function(){return l},setClearAlpha:function(C){l=C,b(o,l)},render:_,addToRenderList:S,dispose:T}}function SJ(n,t){const e=n.getParameter(n.MAX_VERTEX_ATTRIBS),s={},i=p(null);let r=i,a=!1;function o(O,L,H,q,K){let Y=!1;const P=f(q,H,L);r!==P&&(r=P,c(r.object)),Y=g(O,q,H,K),Y&&v(O,q,H,K),K!==null&&t.update(K,n.ELEMENT_ARRAY_BUFFER),(Y||a)&&(a=!1,A(O,L,H,q),K!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t.get(K).buffer))}function l(){return n.createVertexArray()}function c(O){return n.bindVertexArray(O)}function h(O){return n.deleteVertexArray(O)}function f(O,L,H){const q=H.wireframe===!0;let K=s[O.id];K===void 0&&(K={},s[O.id]=K);let Y=K[L.id];Y===void 0&&(Y={},K[L.id]=Y);let P=Y[q];return P===void 0&&(P=p(l()),Y[q]=P),P}function p(O){const L=[],H=[],q=[];for(let K=0;K<e;K++)L[K]=0,H[K]=0,q[K]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:L,enabledAttributes:H,attributeDivisors:q,object:O,attributes:{},index:null}}function g(O,L,H,q){const K=r.attributes,Y=L.attributes;let P=0;const W=H.getAttributes();for(const j in W)if(W[j].location>=0){const ot=K[j];let X=Y[j];if(X===void 0&&(j==="instanceMatrix"&&O.instanceMatrix&&(X=O.instanceMatrix),j==="instanceColor"&&O.instanceColor&&(X=O.instanceColor)),ot===void 0||ot.attribute!==X||X&&ot.data!==X.data)return!0;P++}return r.attributesNum!==P||r.index!==q}function v(O,L,H,q){const K={},Y=L.attributes;let P=0;const W=H.getAttributes();for(const j in W)if(W[j].location>=0){let ot=Y[j];ot===void 0&&(j==="instanceMatrix"&&O.instanceMatrix&&(ot=O.instanceMatrix),j==="instanceColor"&&O.instanceColor&&(ot=O.instanceColor));const X={};X.attribute=ot,ot&&ot.data&&(X.data=ot.data),K[j]=X,P++}r.attributes=K,r.attributesNum=P,r.index=q}function _(){const O=r.newAttributes;for(let L=0,H=O.length;L<H;L++)O[L]=0}function S(O){b(O,0)}function b(O,L){const H=r.newAttributes,q=r.enabledAttributes,K=r.attributeDivisors;H[O]=1,q[O]===0&&(n.enableVertexAttribArray(O),q[O]=1),K[O]!==L&&(n.vertexAttribDivisor(O,L),K[O]=L)}function T(){const O=r.newAttributes,L=r.enabledAttributes;for(let H=0,q=L.length;H<q;H++)L[H]!==O[H]&&(n.disableVertexAttribArray(H),L[H]=0)}function C(O,L,H,q,K,Y,P){P===!0?n.vertexAttribIPointer(O,L,H,K,Y):n.vertexAttribPointer(O,L,H,q,K,Y)}function A(O,L,H,q){_();const K=q.attributes,Y=H.getAttributes(),P=L.defaultAttributeValues;for(const W in Y){const j=Y[W];if(j.location>=0){let st=K[W];if(st===void 0&&(W==="instanceMatrix"&&O.instanceMatrix&&(st=O.instanceMatrix),W==="instanceColor"&&O.instanceColor&&(st=O.instanceColor)),st!==void 0){const ot=st.normalized,X=st.itemSize,it=t.get(st);if(it===void 0)continue;const ct=it.buffer,yt=it.type,Rt=it.bytesPerElement,ft=yt===n.INT||yt===n.UNSIGNED_INT||st.gpuType===lC;if(st.isInterleavedBufferAttribute){const _t=st.data,qt=_t.stride,Qt=st.offset;if(_t.isInstancedInterleavedBuffer){for(let se=0;se<j.locationSize;se++)b(j.location+se,_t.meshPerAttribute);O.isInstancedMesh!==!0&&q._maxInstanceCount===void 0&&(q._maxInstanceCount=_t.meshPerAttribute*_t.count)}else for(let se=0;se<j.locationSize;se++)S(j.location+se);n.bindBuffer(n.ARRAY_BUFFER,ct);for(let se=0;se<j.locationSize;se++)C(j.location+se,X/j.locationSize,yt,ot,qt*Rt,(Qt+X/j.locationSize*se)*Rt,ft)}else{if(st.isInstancedBufferAttribute){for(let _t=0;_t<j.locationSize;_t++)b(j.location+_t,st.meshPerAttribute);O.isInstancedMesh!==!0&&q._maxInstanceCount===void 0&&(q._maxInstanceCount=st.meshPerAttribute*st.count)}else for(let _t=0;_t<j.locationSize;_t++)S(j.location+_t);n.bindBuffer(n.ARRAY_BUFFER,ct);for(let _t=0;_t<j.locationSize;_t++)C(j.location+_t,X/j.locationSize,yt,ot,X*Rt,X/j.locationSize*_t*Rt,ft)}}else if(P!==void 0){const ot=P[W];if(ot!==void 0)switch(ot.length){case 2:n.vertexAttrib2fv(j.location,ot);break;case 3:n.vertexAttrib3fv(j.location,ot);break;case 4:n.vertexAttrib4fv(j.location,ot);break;default:n.vertexAttrib1fv(j.location,ot)}}}}T()}function I(){z();for(const O in s){const L=s[O];for(const H in L){const q=L[H];for(const K in q)h(q[K].object),delete q[K];delete L[H]}delete s[O]}}function D(O){if(s[O.id]===void 0)return;const L=s[O.id];for(const H in L){const q=L[H];for(const K in q)h(q[K].object),delete q[K];delete L[H]}delete s[O.id]}function F(O){for(const L in s){const H=s[L];if(H[O.id]===void 0)continue;const q=H[O.id];for(const K in q)h(q[K].object),delete q[K];delete H[O.id]}}function z(){k(),a=!0,r!==i&&(r=i,c(r.object))}function k(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:o,reset:z,resetDefaultState:k,dispose:I,releaseStatesOfGeometry:D,releaseStatesOfProgram:F,initAttributes:_,enableAttribute:S,disableUnusedAttributes:T}}function _J(n,t,e){let s;function i(c){s=c}function r(c,h){n.drawArrays(s,c,h),e.update(h,s,1)}function a(c,h,f){f!==0&&(n.drawArraysInstanced(s,c,h,f),e.update(h,s,f))}function o(c,h,f){if(f===0)return;t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(s,c,0,h,0,f);let g=0;for(let v=0;v<f;v++)g+=h[v];e.update(g,s,1)}function l(c,h,f,p){if(f===0)return;const g=t.get("WEBGL_multi_draw");if(g===null)for(let v=0;v<c.length;v++)a(c[v],h[v],p[v]);else{g.multiDrawArraysInstancedWEBGL(s,c,0,h,0,p,0,f);let v=0;for(let _=0;_<f;_++)v+=h[_]*p[_];e.update(v,s,1)}}this.setMode=i,this.render=r,this.renderInstances=a,this.renderMultiDraw=o,this.renderMultiDrawInstances=l}function wJ(n,t,e,s){let i;function r(){if(i!==void 0)return i;if(t.has("EXT_texture_filter_anisotropic")===!0){const F=t.get("EXT_texture_filter_anisotropic");i=n.getParameter(F.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function a(F){return!(F!==Ba&&s.convert(F)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))}function o(F){const z=F===ru&&(t.has("EXT_color_buffer_half_float")||t.has("EXT_color_buffer_float"));return!(F!==Gi&&s.convert(F)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE)&&F!==Ua&&!z)}function l(F){if(F==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";F="mediump"}return F==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let c=e.precision!==void 0?e.precision:"highp";const h=l(c);h!==c&&(Oe("WebGLRenderer:",c,"not supported, using",h,"instead."),c=h);const f=e.logarithmicDepthBuffer===!0,p=e.reversedDepthBuffer===!0&&t.has("EXT_clip_control"),g=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),v=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),_=n.getParameter(n.MAX_TEXTURE_SIZE),S=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),b=n.getParameter(n.MAX_VERTEX_ATTRIBS),T=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),C=n.getParameter(n.MAX_VARYING_VECTORS),A=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),I=n.getParameter(n.MAX_SAMPLES),D=n.getParameter(n.SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:r,getMaxPrecision:l,textureFormatReadable:a,textureTypeReadable:o,precision:c,logarithmicDepthBuffer:f,reversedDepthBuffer:p,maxTextures:g,maxVertexTextures:v,maxTextureSize:_,maxCubemapSize:S,maxAttributes:b,maxVertexUniforms:T,maxVaryings:C,maxFragmentUniforms:A,maxSamples:I,samples:D}}function TJ(n){const t=this;let e=null,s=0,i=!1,r=!1;const a=new hf,o=new On,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(f,p){const g=f.length!==0||p||s!==0||i;return i=p,s=f.length,g},this.beginShadows=function(){r=!0,h(null)},this.endShadows=function(){r=!1},this.setGlobalState=function(f,p){e=h(f,p,0)},this.setState=function(f,p,g){const v=f.clippingPlanes,_=f.clipIntersection,S=f.clipShadows,b=n.get(f);if(!i||v===null||v.length===0||r&&!S)r?h(null):c();else{const T=r?0:s,C=T*4;let A=b.clippingState||null;l.value=A,A=h(v,p,C,g);for(let I=0;I!==C;++I)A[I]=e[I];b.clippingState=A,this.numIntersection=_?this.numPlanes:0,this.numPlanes+=T}};function c(){l.value!==e&&(l.value=e,l.needsUpdate=s>0),t.numPlanes=s,t.numIntersection=0}function h(f,p,g,v){const _=f!==null?f.length:0;let S=null;if(_!==0){if(S=l.value,v!==!0||S===null){const b=g+_*4,T=p.matrixWorldInverse;o.getNormalMatrix(T),(S===null||S.length<b)&&(S=new Float32Array(b));for(let C=0,A=g;C!==_;++C,A+=4)a.copy(f[C]).applyMatrix4(T,o),a.normal.toArray(S,A),S[A+3]=a.constant}l.value=S,l.needsUpdate=!0}return t.numPlanes=_,t.numIntersection=0,S}}function EJ(n){let t=new WeakMap;function e(a,o){return o===f1?a.mapping=ph:o===d1&&(a.mapping=Xd),a}function s(a){if(a&&a.isTexture){const o=a.mapping;if(o===f1||o===d1)if(t.has(a)){const l=t.get(a).texture;return e(l,a.mapping)}else{const l=a.image;if(l&&l.height>0){const c=new JD(l.height);return c.fromEquirectangularTexture(n,a),t.set(a,c),a.addEventListener("dispose",i),e(c.texture,a.mapping)}else return null}}return a}function i(a){const o=a.target;o.removeEventListener("dispose",i);const l=t.get(o);l!==void 0&&(t.delete(o),l.dispose())}function r(){t=new WeakMap}return{get:s,dispose:r}}const $d=4,ZF=[.125,.215,.35,.446,.526,.582],Lm=20,CJ=256,Ib=new rh,QF=new ke;let JM=null,tI=0,eI=0,nI=!1;const AJ=new at;class cR{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._backgroundBox=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._blurMaterial=null,this._ggxMaterial=null}fromScene(t,e=0,s=.1,i=100,r={}){const{size:a=256,position:o=AJ}=r;JM=this._renderer.getRenderTarget(),tI=this._renderer.getActiveCubeFace(),eI=this._renderer.getActiveMipmapLevel(),nI=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(a);const l=this._allocateTargets();return l.depthBuffer=!0,this._sceneToCubeUV(t,s,i,l,o),e>0&&this._blur(l,0,0,e),this._applyPMREM(l),this._cleanup(l),l}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=ez(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=tz(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose(),this._backgroundBox!==null&&(this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose())}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._ggxMaterial!==null&&this._ggxMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodMeshes.length;t++)this._lodMeshes[t].geometry.dispose()}_cleanup(t){this._renderer.setRenderTarget(JM,tI,eI),this._renderer.xr.enabled=nI,t.scissorTest=!1,wy(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===ph||t.mapping===Xd?this._setSize(t.image.length===0?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),JM=this._renderer.getRenderTarget(),tI=this._renderer.getActiveCubeFace(),eI=this._renderer.getActiveMipmapLevel(),nI=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const s=e||this._allocateTargets();return this._textureToCubeUV(t,s),this._applyPMREM(s),this._cleanup(s),s}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,s={magFilter:Hs,minFilter:Hs,generateMipmaps:!1,type:ru,format:Ba,colorSpace:gh,depthBuffer:!1},i=JF(t,e,s);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=JF(t,e,s);const{_lodMax:r}=this;({lodMeshes:this._lodMeshes,sizeLods:this._sizeLods,sigmas:this._sigmas}=NJ(r)),this._blurMaterial=IJ(r,t,e),this._ggxMaterial=MJ(r,t,e)}return i}_compileMaterial(t){const e=new rr(new Nn,t);this._renderer.compile(e,Ib)}_sceneToCubeUV(t,e,s,i,r){const l=new Vi(90,1,e,s),c=[1,-1,1,1,1,1],h=[1,1,1,-1,-1,-1],f=this._renderer,p=f.autoClear,g=f.toneMapping;f.getClearColor(QF),f.toneMapping=Tl,f.autoClear=!1,f.state.buffers.depth.getReversed()&&(f.setRenderTarget(i),f.clearDepth(),f.setRenderTarget(null)),this._backgroundBox===null&&(this._backgroundBox=new rr(new $g,new cp({name:"PMREM.Background",side:kr,depthWrite:!1,depthTest:!1})));const _=this._backgroundBox,S=_.material;let b=!1;const T=t.background;T?T.isColor&&(S.color.copy(T),t.background=null,b=!0):(S.color.copy(QF),b=!0);for(let C=0;C<6;C++){const A=C%3;A===0?(l.up.set(0,c[C],0),l.position.set(r.x,r.y,r.z),l.lookAt(r.x+h[C],r.y,r.z)):A===1?(l.up.set(0,0,c[C]),l.position.set(r.x,r.y,r.z),l.lookAt(r.x,r.y+h[C],r.z)):(l.up.set(0,c[C],0),l.position.set(r.x,r.y,r.z),l.lookAt(r.x,r.y,r.z+h[C]));const I=this._cubeSize;wy(i,A*I,C>2?I:0,I,I),f.setRenderTarget(i),b&&f.render(_,l),f.render(t,l)}f.toneMapping=g,f.autoClear=p,t.background=T}_textureToCubeUV(t,e){const s=this._renderer,i=t.mapping===ph||t.mapping===Xd;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=ez()),this._cubemapMaterial.uniforms.flipEnvMap.value=t.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=tz());const r=i?this._cubemapMaterial:this._equirectMaterial,a=this._lodMeshes[0];a.material=r;const o=r.uniforms;o.envMap.value=t;const l=this._cubeSize;wy(e,0,0,3*l,2*l),s.setRenderTarget(e),s.render(a,Ib)}_applyPMREM(t){const e=this._renderer,s=e.autoClear;e.autoClear=!1;const i=this._lodMeshes.length;for(let r=1;r<i;r++)this._applyGGXFilter(t,r-1,r);e.autoClear=s}_applyGGXFilter(t,e,s){const i=this._renderer,r=this._pingPongRenderTarget,a=this._ggxMaterial,o=this._lodMeshes[s];o.material=a;const l=a.uniforms,c=s/(this._lodMeshes.length-1),h=e/(this._lodMeshes.length-1),f=Math.sqrt(c*c-h*h),p=0+c*1.25,g=f*p,{_lodMax:v}=this,_=this._sizeLods[s],S=3*_*(s>v-$d?s-v+$d:0),b=4*(this._cubeSize-_);l.envMap.value=t.texture,l.roughness.value=g,l.mipInt.value=v-e,wy(r,S,b,3*_,2*_),i.setRenderTarget(r),i.render(o,Ib),l.envMap.value=r.texture,l.roughness.value=0,l.mipInt.value=v-s,wy(t,S,b,3*_,2*_),i.setRenderTarget(t),i.render(o,Ib)}_blur(t,e,s,i,r){const a=this._pingPongRenderTarget;this._halfBlur(t,a,e,s,i,"latitudinal",r),this._halfBlur(a,t,s,s,i,"longitudinal",r)}_halfBlur(t,e,s,i,r,a,o){const l=this._renderer,c=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&on("blur direction must be either latitudinal or longitudinal!");const h=3,f=this._lodMeshes[i];f.material=c;const p=c.uniforms,g=this._sizeLods[s]-1,v=isFinite(r)?Math.PI/(2*g):2*Math.PI/(2*Lm-1),_=r/v,S=isFinite(r)?1+Math.floor(h*_):Lm;S>Lm&&Oe(`sigmaRadians, ${r}, is too large and will clip, as it requested ${S} samples when the maximum is set to ${Lm}`);const b=[];let T=0;for(let F=0;F<Lm;++F){const z=F/_,k=Math.exp(-z*z/2);b.push(k),F===0?T+=k:F<S&&(T+=2*k)}for(let F=0;F<b.length;F++)b[F]=b[F]/T;p.envMap.value=t.texture,p.samples.value=S,p.weights.value=b,p.latitudinal.value=a==="latitudinal",o&&(p.poleAxis.value=o);const{_lodMax:C}=this;p.dTheta.value=v,p.mipInt.value=C-s;const A=this._sizeLods[i],I=3*A*(i>C-$d?i-C+$d:0),D=4*(this._cubeSize-A);wy(e,I,D,3*A,2*A),l.setRenderTarget(e),l.render(f,Ib)}}function NJ(n){const t=[],e=[],s=[];let i=n;const r=n-$d+1+ZF.length;for(let a=0;a<r;a++){const o=Math.pow(2,i);t.push(o);let l=1/o;a>n-$d?l=ZF[a-n+$d-1]:a===0&&(l=0),e.push(l);const c=1/(o-2),h=-c,f=1+c,p=[h,h,f,h,f,f,h,h,f,f,h,f],g=6,v=6,_=3,S=2,b=1,T=new Float32Array(_*v*g),C=new Float32Array(S*v*g),A=new Float32Array(b*v*g);for(let D=0;D<g;D++){const F=D%3*2/3-1,z=D>2?0:-1,k=[F,z,0,F+2/3,z,0,F+2/3,z+1,0,F,z,0,F+2/3,z+1,0,F,z+1,0];T.set(k,_*v*D),C.set(p,S*v*D);const O=[D,D,D,D,D,D];A.set(O,b*v*D)}const I=new Nn;I.setAttribute("position",new Fs(T,_)),I.setAttribute("uv",new Fs(C,S)),I.setAttribute("faceIndex",new Fs(A,b)),s.push(new rr(I,null)),i>$d&&i--}return{lodMeshes:s,sizeLods:t,sigmas:e}}function JF(n,t,e){const s=new ki(n,t,e);return s.texture.mapping=wx,s.texture.name="PMREM.cubeUv",s.scissorTest=!0,s}function wy(n,t,e,s,i){n.viewport.set(t,e,s,i),n.scissor.set(t,e,s,i)}function MJ(n,t,e){return new ar({name:"PMREMGGXConvolution",defines:{GGX_SAMPLES:CJ,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},roughness:{value:0},mipInt:{value:0}},vertexShader:BC(),fragmentShader:`

			precision highp float;
			precision highp int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 3.2: Transform view direction to hemisphere configuration
				vec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));

				// Section 4.1: Orthonormal basis
				float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
				vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(Vh, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + Vh.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`,blending:da,depthTest:!1,depthWrite:!1})}function IJ(n,t,e){const s=new Float32Array(Lm),i=new at(0,1,0);return new ar({name:"SphericalGaussianBlur",defines:{n:Lm,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:s},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:BC(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:da,depthTest:!1,depthWrite:!1})}function tz(){return new ar({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:BC(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:da,depthTest:!1,depthWrite:!1})}function ez(){return new ar({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:BC(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:da,depthTest:!1,depthWrite:!1})}function BC(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function RJ(n){let t=new WeakMap,e=null;function s(o){if(o&&o.isTexture){const l=o.mapping,c=l===f1||l===d1,h=l===ph||l===Xd;if(c||h){let f=t.get(o);const p=f!==void 0?f.texture.pmremVersion:0;if(o.isRenderTargetTexture&&o.pmremVersion!==p)return e===null&&(e=new cR(n)),f=c?e.fromEquirectangular(o,f):e.fromCubemap(o,f),f.texture.pmremVersion=o.pmremVersion,t.set(o,f),f.texture;if(f!==void 0)return f.texture;{const g=o.image;return c&&g&&g.height>0||h&&g&&i(g)?(e===null&&(e=new cR(n)),f=c?e.fromEquirectangular(o):e.fromCubemap(o),f.texture.pmremVersion=o.pmremVersion,t.set(o,f),o.addEventListener("dispose",r),f.texture):null}}}return o}function i(o){let l=0;const c=6;for(let h=0;h<c;h++)o[h]!==void 0&&l++;return l===c}function r(o){const l=o.target;l.removeEventListener("dispose",r);const c=t.get(l);c!==void 0&&(t.delete(l),c.dispose())}function a(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:s,dispose:a}}function DJ(n){const t={};function e(s){if(t[s]!==void 0)return t[s];const i=n.getExtension(s);return t[s]=i,i}return{has:function(s){return e(s)!==null},init:function(){e("EXT_color_buffer_float"),e("WEBGL_clip_cull_distance"),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture"),e("WEBGL_render_shared_exponent")},get:function(s){const i=e(s);return i===null&&tx("WebGLRenderer: "+s+" extension not supported."),i}}}function kJ(n,t,e,s){const i={},r=new WeakMap;function a(f){const p=f.target;p.index!==null&&t.remove(p.index);for(const v in p.attributes)t.remove(p.attributes[v]);p.removeEventListener("dispose",a),delete i[p.id];const g=r.get(p);g&&(t.remove(g),r.delete(p)),s.releaseStatesOfGeometry(p),p.isInstancedBufferGeometry===!0&&delete p._maxInstanceCount,e.memory.geometries--}function o(f,p){return i[p.id]===!0||(p.addEventListener("dispose",a),i[p.id]=!0,e.memory.geometries++),p}function l(f){const p=f.attributes;for(const g in p)t.update(p[g],n.ARRAY_BUFFER)}function c(f){const p=[],g=f.index,v=f.attributes.position;let _=0;if(g!==null){const T=g.array;_=g.version;for(let C=0,A=T.length;C<A;C+=3){const I=T[C+0],D=T[C+1],F=T[C+2];p.push(I,D,D,F,F,I)}}else if(v!==void 0){const T=v.array;_=v.version;for(let C=0,A=T.length/3-1;C<A;C+=3){const I=C+0,D=C+1,F=C+2;p.push(I,D,D,F,F,I)}}else return;const S=new(t4(p)?QD:ZD)(p,1);S.version=_;const b=r.get(f);b&&t.remove(b),r.set(f,S)}function h(f){const p=r.get(f);if(p){const g=f.index;g!==null&&p.version<g.version&&c(f)}else c(f);return r.get(f)}return{get:o,update:l,getWireframeAttribute:h}}function OJ(n,t,e){let s;function i(p){s=p}let r,a;function o(p){r=p.type,a=p.bytesPerElement}function l(p,g){n.drawElements(s,g,r,p*a),e.update(g,s,1)}function c(p,g,v){v!==0&&(n.drawElementsInstanced(s,g,r,p*a,v),e.update(g,s,v))}function h(p,g,v){if(v===0)return;t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(s,g,0,r,p,0,v);let S=0;for(let b=0;b<v;b++)S+=g[b];e.update(S,s,1)}function f(p,g,v,_){if(v===0)return;const S=t.get("WEBGL_multi_draw");if(S===null)for(let b=0;b<p.length;b++)c(p[b]/a,g[b],_[b]);else{S.multiDrawElementsInstancedWEBGL(s,g,0,r,p,0,_,0,v);let b=0;for(let T=0;T<v;T++)b+=g[T]*_[T];e.update(b,s,1)}}this.setMode=i,this.setIndex=o,this.render=l,this.renderInstances=c,this.renderMultiDraw=h,this.renderMultiDrawInstances=f}function $J(n){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function s(r,a,o){switch(e.calls++,a){case n.TRIANGLES:e.triangles+=o*(r/3);break;case n.LINES:e.lines+=o*(r/2);break;case n.LINE_STRIP:e.lines+=o*(r-1);break;case n.LINE_LOOP:e.lines+=o*r;break;case n.POINTS:e.points+=o*r;break;default:on("WebGLInfo: Unknown draw mode:",a);break}}function i(){e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:i,update:s}}function LJ(n,t,e){const s=new WeakMap,i=new Gs;function r(a,o,l){const c=a.morphTargetInfluences,h=o.morphAttributes.position||o.morphAttributes.normal||o.morphAttributes.color,f=h!==void 0?h.length:0;let p=s.get(o);if(p===void 0||p.count!==f){let O=function(){z.dispose(),s.delete(o),o.removeEventListener("dispose",O)};var g=O;p!==void 0&&p.texture.dispose();const v=o.morphAttributes.position!==void 0,_=o.morphAttributes.normal!==void 0,S=o.morphAttributes.color!==void 0,b=o.morphAttributes.position||[],T=o.morphAttributes.normal||[],C=o.morphAttributes.color||[];let A=0;v===!0&&(A=1),_===!0&&(A=2),S===!0&&(A=3);let I=o.attributes.position.count*A,D=1;I>t.maxTextureSize&&(D=Math.ceil(I/t.maxTextureSize),I=t.maxTextureSize);const F=new Float32Array(I*D*4*f),z=new yC(F,I,D,f);z.type=Ua,z.needsUpdate=!0;const k=A*4;for(let L=0;L<f;L++){const H=b[L],q=T[L],K=C[L],Y=I*D*4*L;for(let P=0;P<H.count;P++){const W=P*k;v===!0&&(i.fromBufferAttribute(H,P),F[Y+W+0]=i.x,F[Y+W+1]=i.y,F[Y+W+2]=i.z,F[Y+W+3]=0),_===!0&&(i.fromBufferAttribute(q,P),F[Y+W+4]=i.x,F[Y+W+5]=i.y,F[Y+W+6]=i.z,F[Y+W+7]=0),S===!0&&(i.fromBufferAttribute(K,P),F[Y+W+8]=i.x,F[Y+W+9]=i.y,F[Y+W+10]=i.z,F[Y+W+11]=K.itemSize===4?i.w:1)}}p={count:f,texture:z,size:new Yt(I,D)},s.set(o,p),o.addEventListener("dispose",O)}if(a.isInstancedMesh===!0&&a.morphTexture!==null)l.getUniforms().setValue(n,"morphTexture",a.morphTexture,e);else{let v=0;for(let S=0;S<c.length;S++)v+=c[S];const _=o.morphTargetsRelative?1:1-v;l.getUniforms().setValue(n,"morphTargetBaseInfluence",_),l.getUniforms().setValue(n,"morphTargetInfluences",c)}l.getUniforms().setValue(n,"morphTargetsTexture",p.texture,e),l.getUniforms().setValue(n,"morphTargetsTextureSize",p.size)}return{update:r}}function FJ(n,t,e,s){let i=new WeakMap;function r(l){const c=s.render.frame,h=l.geometry,f=t.get(l,h);if(i.get(f)!==c&&(t.update(f),i.set(f,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",o)===!1&&l.addEventListener("dispose",o),i.get(l)!==c&&(e.update(l.instanceMatrix,n.ARRAY_BUFFER),l.instanceColor!==null&&e.update(l.instanceColor,n.ARRAY_BUFFER),i.set(l,c))),l.isSkinnedMesh){const p=l.skeleton;i.get(p)!==c&&(p.update(),i.set(p,c))}return f}function a(){i=new WeakMap}function o(l){const c=l.target;c.removeEventListener("dispose",o),e.remove(c.instanceMatrix),c.instanceColor!==null&&e.remove(c.instanceColor)}return{update:r,dispose:a}}const zJ={[$D]:"LINEAR_TONE_MAPPING",[LD]:"REINHARD_TONE_MAPPING",[FD]:"CINEON_TONE_MAPPING",[aC]:"ACES_FILMIC_TONE_MAPPING",[UD]:"AGX_TONE_MAPPING",[BD]:"NEUTRAL_TONE_MAPPING",[zD]:"CUSTOM_TONE_MAPPING"};function UJ(n,t,e,s,i){const r=new ki(t,e,{type:n,depthBuffer:s,stencilBuffer:i}),a=new ki(t,e,{type:ru,depthBuffer:!1,stencilBuffer:!1}),o=new Nn;o.setAttribute("position",new je([-1,3,0,-1,-1,0,3,-1,0],3)),o.setAttribute("uv",new je([0,2,0,0,2,0],2));const l=new u3({uniforms:{tDiffuse:{value:null}},vertexShader:`
			precision highp float;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}`,fragmentShader:`
			precision highp float;

			uniform sampler2D tDiffuse;

			varying vec2 vUv;

			#include <tonemapping_pars_fragment>
			#include <colorspace_pars_fragment>

			void main() {
				gl_FragColor = texture2D( tDiffuse, vUv );

				#ifdef LINEAR_TONE_MAPPING
					gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );
				#elif defined( REINHARD_TONE_MAPPING )
					gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );
				#elif defined( CINEON_TONE_MAPPING )
					gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );
				#elif defined( ACES_FILMIC_TONE_MAPPING )
					gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );
				#elif defined( AGX_TONE_MAPPING )
					gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );
				#elif defined( NEUTRAL_TONE_MAPPING )
					gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );
				#elif defined( CUSTOM_TONE_MAPPING )
					gl_FragColor.rgb = CustomToneMapping( gl_FragColor.rgb );
				#endif

				#ifdef SRGB_TRANSFER
					gl_FragColor = sRGBTransferOETF( gl_FragColor );
				#endif
			}`,depthTest:!1,depthWrite:!1}),c=new rr(o,l),h=new rh(-1,1,1,-1,0,1);let f=null,p=null,g=!1,v,_=null,S=[],b=!1;this.setSize=function(T,C){r.setSize(T,C),a.setSize(T,C);for(let A=0;A<S.length;A++){const I=S[A];I.setSize&&I.setSize(T,C)}},this.setEffects=function(T){S=T,b=S.length>0&&S[0].isRenderPass===!0;const C=r.width,A=r.height;for(let I=0;I<S.length;I++){const D=S[I];D.setSize&&D.setSize(C,A)}},this.begin=function(T,C){if(g||T.toneMapping===Tl&&S.length===0)return!1;if(_=C,C!==null){const A=C.width,I=C.height;(r.width!==A||r.height!==I)&&this.setSize(A,I)}return b===!1&&T.setRenderTarget(r),v=T.toneMapping,T.toneMapping=Tl,!0},this.hasRenderPass=function(){return b},this.end=function(T,C){T.toneMapping=v,g=!0;let A=r,I=a;for(let D=0;D<S.length;D++){const F=S[D];if(F.enabled!==!1&&(F.render(T,I,A,C),F.needsSwap!==!1)){const z=A;A=I,I=z}}if(f!==T.outputColorSpace||p!==T.toneMapping){f=T.outputColorSpace,p=T.toneMapping,l.defines={},ss.getTransfer(f)===Ls&&(l.defines.SRGB_TRANSFER="");const D=zJ[p];D&&(l.defines[D]=""),l.needsUpdate=!0}l.uniforms.tDiffuse.value=A.texture,T.setRenderTarget(_),T.render(c,h),_=null,g=!1},this.isCompositing=function(){return g},this.dispose=function(){r.dispose(),a.dispose(),o.dispose(),l.dispose()}}const aV=new wi,uR=new lg(1,1),oV=new yC,lV=new xC,cV=new nS,nz=[],sz=[],iz=new Float32Array(16),rz=new Float32Array(9),az=new Float32Array(4);function Cx(n,t,e){const s=n[0];if(s<=0||s>0)return n;const i=t*e;let r=nz[i];if(r===void 0&&(r=new Float32Array(i),nz[i]=r),t!==0){s.toArray(r,0);for(let a=1,o=0;a!==t;++a)o+=e,n[a].toArray(r,o)}return r}function $r(n,t){if(n.length!==t.length)return!1;for(let e=0,s=n.length;e<s;e++)if(n[e]!==t[e])return!1;return!0}function Lr(n,t){for(let e=0,s=t.length;e<s;e++)n[e]=t[e]}function PC(n,t){let e=sz[t];e===void 0&&(e=new Int32Array(t),sz[t]=e);for(let s=0;s!==t;++s)e[s]=n.allocateTextureUnit();return e}function BJ(n,t){const e=this.cache;e[0]!==t&&(n.uniform1f(this.addr,t),e[0]=t)}function PJ(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(n.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if($r(e,t))return;n.uniform2fv(this.addr,t),Lr(e,t)}}function VJ(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(n.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(n.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if($r(e,t))return;n.uniform3fv(this.addr,t),Lr(e,t)}}function GJ(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(n.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if($r(e,t))return;n.uniform4fv(this.addr,t),Lr(e,t)}}function HJ(n,t){const e=this.cache,s=t.elements;if(s===void 0){if($r(e,t))return;n.uniformMatrix2fv(this.addr,!1,t),Lr(e,t)}else{if($r(e,s))return;az.set(s),n.uniformMatrix2fv(this.addr,!1,az),Lr(e,s)}}function WJ(n,t){const e=this.cache,s=t.elements;if(s===void 0){if($r(e,t))return;n.uniformMatrix3fv(this.addr,!1,t),Lr(e,t)}else{if($r(e,s))return;rz.set(s),n.uniformMatrix3fv(this.addr,!1,rz),Lr(e,s)}}function qJ(n,t){const e=this.cache,s=t.elements;if(s===void 0){if($r(e,t))return;n.uniformMatrix4fv(this.addr,!1,t),Lr(e,t)}else{if($r(e,s))return;iz.set(s),n.uniformMatrix4fv(this.addr,!1,iz),Lr(e,s)}}function XJ(n,t){const e=this.cache;e[0]!==t&&(n.uniform1i(this.addr,t),e[0]=t)}function jJ(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(n.uniform2i(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if($r(e,t))return;n.uniform2iv(this.addr,t),Lr(e,t)}}function KJ(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(n.uniform3i(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if($r(e,t))return;n.uniform3iv(this.addr,t),Lr(e,t)}}function YJ(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(n.uniform4i(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if($r(e,t))return;n.uniform4iv(this.addr,t),Lr(e,t)}}function ZJ(n,t){const e=this.cache;e[0]!==t&&(n.uniform1ui(this.addr,t),e[0]=t)}function QJ(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(n.uniform2ui(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if($r(e,t))return;n.uniform2uiv(this.addr,t),Lr(e,t)}}function JJ(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(n.uniform3ui(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if($r(e,t))return;n.uniform3uiv(this.addr,t),Lr(e,t)}}function ttt(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(n.uniform4ui(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if($r(e,t))return;n.uniform4uiv(this.addr,t),Lr(e,t)}}function ett(n,t,e){const s=this.cache,i=e.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i);let r;this.type===n.SAMPLER_2D_SHADOW?(uR.compareFunction=e.isReversedDepthBuffer()?gC:mC,r=uR):r=aV,e.setTexture2D(t||r,i)}function ntt(n,t,e){const s=this.cache,i=e.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),e.setTexture3D(t||lV,i)}function stt(n,t,e){const s=this.cache,i=e.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),e.setTextureCube(t||cV,i)}function itt(n,t,e){const s=this.cache,i=e.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),e.setTexture2DArray(t||oV,i)}function rtt(n){switch(n){case 5126:return BJ;case 35664:return PJ;case 35665:return VJ;case 35666:return GJ;case 35674:return HJ;case 35675:return WJ;case 35676:return qJ;case 5124:case 35670:return XJ;case 35667:case 35671:return jJ;case 35668:case 35672:return KJ;case 35669:case 35673:return YJ;case 5125:return ZJ;case 36294:return QJ;case 36295:return JJ;case 36296:return ttt;case 35678:case 36198:case 36298:case 36306:case 35682:return ett;case 35679:case 36299:case 36307:return ntt;case 35680:case 36300:case 36308:case 36293:return stt;case 36289:case 36303:case 36311:case 36292:return itt}}function att(n,t){n.uniform1fv(this.addr,t)}function ott(n,t){const e=Cx(t,this.size,2);n.uniform2fv(this.addr,e)}function ltt(n,t){const e=Cx(t,this.size,3);n.uniform3fv(this.addr,e)}function ctt(n,t){const e=Cx(t,this.size,4);n.uniform4fv(this.addr,e)}function utt(n,t){const e=Cx(t,this.size,4);n.uniformMatrix2fv(this.addr,!1,e)}function htt(n,t){const e=Cx(t,this.size,9);n.uniformMatrix3fv(this.addr,!1,e)}function ftt(n,t){const e=Cx(t,this.size,16);n.uniformMatrix4fv(this.addr,!1,e)}function dtt(n,t){n.uniform1iv(this.addr,t)}function ptt(n,t){n.uniform2iv(this.addr,t)}function mtt(n,t){n.uniform3iv(this.addr,t)}function gtt(n,t){n.uniform4iv(this.addr,t)}function ytt(n,t){n.uniform1uiv(this.addr,t)}function xtt(n,t){n.uniform2uiv(this.addr,t)}function vtt(n,t){n.uniform3uiv(this.addr,t)}function btt(n,t){n.uniform4uiv(this.addr,t)}function Stt(n,t,e){const s=this.cache,i=t.length,r=PC(e,i);$r(s,r)||(n.uniform1iv(this.addr,r),Lr(s,r));let a;this.type===n.SAMPLER_2D_SHADOW?a=uR:a=aV;for(let o=0;o!==i;++o)e.setTexture2D(t[o]||a,r[o])}function _tt(n,t,e){const s=this.cache,i=t.length,r=PC(e,i);$r(s,r)||(n.uniform1iv(this.addr,r),Lr(s,r));for(let a=0;a!==i;++a)e.setTexture3D(t[a]||lV,r[a])}function wtt(n,t,e){const s=this.cache,i=t.length,r=PC(e,i);$r(s,r)||(n.uniform1iv(this.addr,r),Lr(s,r));for(let a=0;a!==i;++a)e.setTextureCube(t[a]||cV,r[a])}function Ttt(n,t,e){const s=this.cache,i=t.length,r=PC(e,i);$r(s,r)||(n.uniform1iv(this.addr,r),Lr(s,r));for(let a=0;a!==i;++a)e.setTexture2DArray(t[a]||oV,r[a])}function Ett(n){switch(n){case 5126:return att;case 35664:return ott;case 35665:return ltt;case 35666:return ctt;case 35674:return utt;case 35675:return htt;case 35676:return ftt;case 5124:case 35670:return dtt;case 35667:case 35671:return ptt;case 35668:case 35672:return mtt;case 35669:case 35673:return gtt;case 5125:return ytt;case 36294:return xtt;case 36295:return vtt;case 36296:return btt;case 35678:case 36198:case 36298:case 36306:case 35682:return Stt;case 35679:case 36299:case 36307:return _tt;case 35680:case 36300:case 36308:case 36293:return wtt;case 36289:case 36303:case 36311:case 36292:return Ttt}}class Ctt{constructor(t,e,s){this.id=t,this.addr=s,this.cache=[],this.type=e.type,this.setValue=rtt(e.type)}}class Att{constructor(t,e,s){this.id=t,this.addr=s,this.cache=[],this.type=e.type,this.size=e.size,this.setValue=Ett(e.type)}}class Ntt{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,s){const i=this.seq;for(let r=0,a=i.length;r!==a;++r){const o=i[r];o.setValue(t,e[o.id],s)}}}const sI=/(\w+)(\])?(\[|\.)?/g;function oz(n,t){n.seq.push(t),n.map[t.id]=t}function Mtt(n,t,e){const s=n.name,i=s.length;for(sI.lastIndex=0;;){const r=sI.exec(s),a=sI.lastIndex;let o=r[1];const l=r[2]==="]",c=r[3];if(l&&(o=o|0),c===void 0||c==="["&&a+2===i){oz(e,c===void 0?new Ctt(o,n,t):new Att(o,n,t));break}else{let f=e.map[o];f===void 0&&(f=new Ntt(o),oz(e,f)),e=f}}}class aE{constructor(t,e){this.seq=[],this.map={};const s=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let a=0;a<s;++a){const o=t.getActiveUniform(e,a),l=t.getUniformLocation(e,o.name);Mtt(o,l,this)}const i=[],r=[];for(const a of this.seq)a.type===t.SAMPLER_2D_SHADOW||a.type===t.SAMPLER_CUBE_SHADOW||a.type===t.SAMPLER_2D_ARRAY_SHADOW?i.push(a):r.push(a);i.length>0&&(this.seq=i.concat(r))}setValue(t,e,s,i){const r=this.map[e];r!==void 0&&r.setValue(t,s,i)}setOptional(t,e,s){const i=e[s];i!==void 0&&this.setValue(t,s,i)}static upload(t,e,s,i){for(let r=0,a=e.length;r!==a;++r){const o=e[r],l=s[o.id];l.needsUpdate!==!1&&o.setValue(t,l.value,i)}}static seqWithValue(t,e){const s=[];for(let i=0,r=t.length;i!==r;++i){const a=t[i];a.id in e&&s.push(a)}return s}}function lz(n,t,e){const s=n.createShader(t);return n.shaderSource(s,e),n.compileShader(s),s}const Itt=37297;let Rtt=0;function Dtt(n,t){const e=n.split(`
`),s=[],i=Math.max(t-6,0),r=Math.min(t+6,e.length);for(let a=i;a<r;a++){const o=a+1;s.push(`${o===t?">":" "} ${o}: ${e[a]}`)}return s.join(`
`)}const cz=new On;function ktt(n){ss._getMatrix(cz,ss.workingColorSpace,n);const t=`mat3( ${cz.elements.map(e=>e.toFixed(4))} )`;switch(ss.getTransfer(n)){case x1:return[t,"LinearTransferOETF"];case Ls:return[t,"sRGBTransferOETF"];default:return Oe("WebGLProgram: Unsupported color space: ",n),[t,"LinearTransferOETF"]}}function uz(n,t,e){const s=n.getShaderParameter(t,n.COMPILE_STATUS),r=(n.getShaderInfoLog(t)||"").trim();if(s&&r==="")return"";const a=/ERROR: 0:(\d+)/.exec(r);if(a){const o=parseInt(a[1]);return e.toUpperCase()+`

`+r+`

`+Dtt(n.getShaderSource(t),o)}else return r}function Ott(n,t){const e=ktt(t);return[`vec4 ${n}( vec4 value ) {`,`	return ${e[1]}( vec4( value.rgb * ${e[0]}, value.a ) );`,"}"].join(`
`)}const $tt={[$D]:"Linear",[LD]:"Reinhard",[FD]:"Cineon",[aC]:"ACESFilmic",[UD]:"AgX",[BD]:"Neutral",[zD]:"Custom"};function Ltt(n,t){const e=$tt[t];return e===void 0?(Oe("WebGLProgram: Unsupported toneMapping:",t),"vec3 "+n+"( vec3 color ) { return LinearToneMapping( color ); }"):"vec3 "+n+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}const zT=new at;function Ftt(){ss.getLuminanceCoefficients(zT);const n=zT.x.toFixed(4),t=zT.y.toFixed(4),e=zT.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${n}, ${t}, ${e} );`,"	return dot( weights, rgb );","}"].join(`
`)}function ztt(n){return[n.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",n.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Vb).join(`
`)}function Utt(n){const t=[];for(const e in n){const s=n[e];s!==!1&&t.push("#define "+e+" "+s)}return t.join(`
`)}function Btt(n,t){const e={},s=n.getProgramParameter(t,n.ACTIVE_ATTRIBUTES);for(let i=0;i<s;i++){const r=n.getActiveAttrib(t,i),a=r.name;let o=1;r.type===n.FLOAT_MAT2&&(o=2),r.type===n.FLOAT_MAT3&&(o=3),r.type===n.FLOAT_MAT4&&(o=4),e[a]={type:r.type,location:n.getAttribLocation(t,a),locationSize:o}}return e}function Vb(n){return n!==""}function hz(n,t){const e=t.numSpotLightShadows+t.numSpotLightMaps-t.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,e).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function fz(n,t){return n.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const Ptt=/^[ \t]*#include +<([\w\d./]+)>/gm;function hR(n){return n.replace(Ptt,Gtt)}const Vtt=new Map;function Gtt(n,t){let e=Pn[t];if(e===void 0){const s=Vtt.get(t);if(s!==void 0)e=Pn[s],Oe('WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',t,s);else throw new Error("Can not resolve #include <"+t+">")}return hR(e)}const Htt=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function dz(n){return n.replace(Htt,Wtt)}function Wtt(n,t,e,s){let i="";for(let r=parseInt(t);r<parseInt(e);r++)i+=s.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function pz(n){let t=`precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;return n.precision==="highp"?t+=`
#define HIGH_PRECISION`:n.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}const qtt={[Py]:"SHADOWMAP_TYPE_PCF",[Vm]:"SHADOWMAP_TYPE_VSM"};function Xtt(n){return qtt[n.shadowMapType]||"SHADOWMAP_TYPE_BASIC"}const jtt={[ph]:"ENVMAP_TYPE_CUBE",[Xd]:"ENVMAP_TYPE_CUBE",[wx]:"ENVMAP_TYPE_CUBE_UV"};function Ktt(n){return n.envMap===!1?"ENVMAP_TYPE_CUBE":jtt[n.envMapMode]||"ENVMAP_TYPE_CUBE"}const Ytt={[Xd]:"ENVMAP_MODE_REFRACTION"};function Ztt(n){return n.envMap===!1?"ENVMAP_MODE_REFLECTION":Ytt[n.envMapMode]||"ENVMAP_MODE_REFLECTION"}const Qtt={[tS]:"ENVMAP_BLENDING_MULTIPLY",[PP]:"ENVMAP_BLENDING_MIX",[VP]:"ENVMAP_BLENDING_ADD"};function Jtt(n){return n.envMap===!1?"ENVMAP_BLENDING_NONE":Qtt[n.combine]||"ENVMAP_BLENDING_NONE"}function tet(n){const t=n.envMapCubeUVHeight;if(t===null)return null;const e=Math.log2(t)-2,s=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,e),112)),texelHeight:s,maxMip:e}}function eet(n,t,e,s){const i=n.getContext(),r=e.defines;let a=e.vertexShader,o=e.fragmentShader;const l=Xtt(e),c=Ktt(e),h=Ztt(e),f=Jtt(e),p=tet(e),g=ztt(e),v=Utt(r),_=i.createProgram();let S,b,T=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(S=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,v].filter(Vb).join(`
`),S.length>0&&(S+=`
`),b=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,v].filter(Vb).join(`
`),b.length>0&&(b+=`
`)):(S=[pz(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,v,e.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",e.batching?"#define USE_BATCHING":"",e.batchingColor?"#define USE_BATCHING_COLOR":"",e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.instancingMorph?"#define USE_INSTANCING_MORPH":"",e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+h:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.displacementMap?"#define USE_DISPLACEMENTMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.mapUv?"#define MAP_UV "+e.mapUv:"",e.alphaMapUv?"#define ALPHAMAP_UV "+e.alphaMapUv:"",e.lightMapUv?"#define LIGHTMAP_UV "+e.lightMapUv:"",e.aoMapUv?"#define AOMAP_UV "+e.aoMapUv:"",e.emissiveMapUv?"#define EMISSIVEMAP_UV "+e.emissiveMapUv:"",e.bumpMapUv?"#define BUMPMAP_UV "+e.bumpMapUv:"",e.normalMapUv?"#define NORMALMAP_UV "+e.normalMapUv:"",e.displacementMapUv?"#define DISPLACEMENTMAP_UV "+e.displacementMapUv:"",e.metalnessMapUv?"#define METALNESSMAP_UV "+e.metalnessMapUv:"",e.roughnessMapUv?"#define ROUGHNESSMAP_UV "+e.roughnessMapUv:"",e.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+e.anisotropyMapUv:"",e.clearcoatMapUv?"#define CLEARCOATMAP_UV "+e.clearcoatMapUv:"",e.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+e.clearcoatNormalMapUv:"",e.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+e.clearcoatRoughnessMapUv:"",e.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+e.iridescenceMapUv:"",e.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+e.iridescenceThicknessMapUv:"",e.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+e.sheenColorMapUv:"",e.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+e.sheenRoughnessMapUv:"",e.specularMapUv?"#define SPECULARMAP_UV "+e.specularMapUv:"",e.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+e.specularColorMapUv:"",e.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+e.specularIntensityMapUv:"",e.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+e.transmissionMapUv:"",e.thicknessMapUv?"#define THICKNESSMAP_UV "+e.thicknessMapUv:"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphColors?"#define USE_MORPHCOLORS":"",e.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+e.morphTextureStride:"",e.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",e.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Vb).join(`
`),b=[pz(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,v,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+c:"",e.envMap?"#define "+h:"",e.envMap?"#define "+f:"",p?"#define CUBEUV_TEXEL_WIDTH "+p.texelWidth:"",p?"#define CUBEUV_TEXEL_HEIGHT "+p.texelHeight:"",p?"#define CUBEUV_MAX_MIP "+p.maxMip+".0":"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.dispersion?"#define USE_DISPERSION":"",e.iridescence?"#define USE_IRIDESCENCE":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor||e.batchingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",e.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",e.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",e.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==Tl?"#define TONE_MAPPING":"",e.toneMapping!==Tl?Pn.tonemapping_pars_fragment:"",e.toneMapping!==Tl?Ltt("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.opaque?"#define OPAQUE":"",Pn.colorspace_pars_fragment,Ott("linearToOutputTexel",e.outputColorSpace),Ftt(),e.useDepthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Vb).join(`
`)),a=hR(a),a=hz(a,e),a=fz(a,e),o=hR(o),o=hz(o,e),o=fz(o,e),a=dz(a),o=dz(o),e.isRawShaderMaterial!==!0&&(T=`#version 300 es
`,S=[g,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+S,b=["#define varying in",e.glslVersion===eR?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===eR?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+b);const C=T+S+a,A=T+b+o,I=lz(i,i.VERTEX_SHADER,C),D=lz(i,i.FRAGMENT_SHADER,A);i.attachShader(_,I),i.attachShader(_,D),e.index0AttributeName!==void 0?i.bindAttribLocation(_,0,e.index0AttributeName):e.morphTargets===!0&&i.bindAttribLocation(_,0,"position"),i.linkProgram(_);function F(L){if(n.debug.checkShaderErrors){const H=i.getProgramInfoLog(_)||"",q=i.getShaderInfoLog(I)||"",K=i.getShaderInfoLog(D)||"",Y=H.trim(),P=q.trim(),W=K.trim();let j=!0,st=!0;if(i.getProgramParameter(_,i.LINK_STATUS)===!1)if(j=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(i,_,I,D);else{const ot=uz(i,I,"vertex"),X=uz(i,D,"fragment");on("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(_,i.VALIDATE_STATUS)+`

Material Name: `+L.name+`
Material Type: `+L.type+`

Program Info Log: `+Y+`
`+ot+`
`+X)}else Y!==""?Oe("WebGLProgram: Program Info Log:",Y):(P===""||W==="")&&(st=!1);st&&(L.diagnostics={runnable:j,programLog:Y,vertexShader:{log:P,prefix:S},fragmentShader:{log:W,prefix:b}})}i.deleteShader(I),i.deleteShader(D),z=new aE(i,_),k=Btt(i,_)}let z;this.getUniforms=function(){return z===void 0&&F(this),z};let k;this.getAttributes=function(){return k===void 0&&F(this),k};let O=e.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return O===!1&&(O=i.getProgramParameter(_,Itt)),O},this.destroy=function(){s.releaseStatesOfProgram(this),i.deleteProgram(_),this.program=void 0},this.type=e.shaderType,this.name=e.shaderName,this.id=Rtt++,this.cacheKey=t,this.usedTimes=1,this.program=_,this.vertexShader=I,this.fragmentShader=D,this}let net=0;class set{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,s=t.fragmentShader,i=this._getShaderStage(e),r=this._getShaderStage(s),a=this._getShaderCacheForMaterial(t);return a.has(i)===!1&&(a.add(i),i.usedTimes++),a.has(r)===!1&&(a.add(r),r.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const s of e)s.usedTimes--,s.usedTimes===0&&this.shaderCache.delete(s.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;let s=e.get(t);return s===void 0&&(s=new Set,e.set(t,s)),s}_getShaderStage(t){const e=this.shaderCache;let s=e.get(t);return s===void 0&&(s=new iet(t),e.set(t,s)),s}}class iet{constructor(t){this.id=net++,this.code=t,this.usedTimes=0}}function ret(n,t,e,s,i,r,a){const o=new nx,l=new set,c=new Set,h=[],f=new Map,p=i.logarithmicDepthBuffer;let g=i.precision;const v={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distance",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function _(k){return c.add(k),k===0?"uv":`uv${k}`}function S(k,O,L,H,q){const K=H.fog,Y=q.geometry,P=k.isMeshStandardMaterial?H.environment:null,W=(k.isMeshStandardMaterial?e:t).get(k.envMap||P),j=W&&W.mapping===wx?W.image.height:null,st=v[k.type];k.precision!==null&&(g=i.getMaxPrecision(k.precision),g!==k.precision&&Oe("WebGLProgram.getParameters:",k.precision,"not supported, using",g,"instead."));const ot=Y.morphAttributes.position||Y.morphAttributes.normal||Y.morphAttributes.color,X=ot!==void 0?ot.length:0;let it=0;Y.morphAttributes.position!==void 0&&(it=1),Y.morphAttributes.normal!==void 0&&(it=2),Y.morphAttributes.color!==void 0&&(it=3);let ct,yt,Rt,ft;if(st){const Mn=qc[st];ct=Mn.vertexShader,yt=Mn.fragmentShader}else ct=k.vertexShader,yt=k.fragmentShader,l.update(k),Rt=l.getVertexShaderID(k),ft=l.getFragmentShaderID(k);const _t=n.getRenderTarget(),qt=n.state.buffers.depth.getReversed(),Qt=q.isInstancedMesh===!0,se=q.isBatchedMesh===!0,Ee=!!k.map,He=!!k.matcap,Ae=!!W,Ht=!!k.aoMap,Jt=!!k.lightMap,Xt=!!k.bumpMap,ce=!!k.normalMap,rt=!!k.displacementMap,Fe=!!k.emissiveMap,he=!!k.metalnessMap,Pe=!!k.roughnessMap,pe=k.anisotropy>0,nt=k.clearcoat>0,G=k.dispersion>0,vt=k.iridescence>0,Vt=k.sheen>0,te=k.transmission>0,Pt=pe&&!!k.anisotropyMap,Ue=nt&&!!k.clearcoatMap,we=nt&&!!k.clearcoatNormalMap,ze=nt&&!!k.clearcoatRoughnessMap,nn=vt&&!!k.iridescenceMap,ae=vt&&!!k.iridescenceThicknessMap,de=Vt&&!!k.sheenColorMap,Ne=Vt&&!!k.sheenRoughnessMap,ut=!!k.specularMap,kt=!!k.specularColorMap,Se=!!k.specularIntensityMap,dt=te&&!!k.transmissionMap,ye=te&&!!k.thicknessMap,fe=!!k.gradientMap,Ce=!!k.alphaMap,ue=k.alphaTest>0,ie=!!k.alphaHash,ve=!!k.extensions;let Je=Tl;k.toneMapped&&(_t===null||_t.isXRRenderTarget===!0)&&(Je=n.toneMapping);const zn={shaderID:st,shaderType:k.type,shaderName:k.name,vertexShader:ct,fragmentShader:yt,defines:k.defines,customVertexShaderID:Rt,customFragmentShaderID:ft,isRawShaderMaterial:k.isRawShaderMaterial===!0,glslVersion:k.glslVersion,precision:g,batching:se,batchingColor:se&&q._colorsTexture!==null,instancing:Qt,instancingColor:Qt&&q.instanceColor!==null,instancingMorph:Qt&&q.morphTexture!==null,outputColorSpace:_t===null?n.outputColorSpace:_t.isXRRenderTarget===!0?_t.texture.colorSpace:gh,alphaToCoverage:!!k.alphaToCoverage,map:Ee,matcap:He,envMap:Ae,envMapMode:Ae&&W.mapping,envMapCubeUVHeight:j,aoMap:Ht,lightMap:Jt,bumpMap:Xt,normalMap:ce,displacementMap:rt,emissiveMap:Fe,normalMapObjectSpace:ce&&k.normalMapType===XP,normalMapTangentSpace:ce&&k.normalMapType===lp,metalnessMap:he,roughnessMap:Pe,anisotropy:pe,anisotropyMap:Pt,clearcoat:nt,clearcoatMap:Ue,clearcoatNormalMap:we,clearcoatRoughnessMap:ze,dispersion:G,iridescence:vt,iridescenceMap:nn,iridescenceThicknessMap:ae,sheen:Vt,sheenColorMap:de,sheenRoughnessMap:Ne,specularMap:ut,specularColorMap:kt,specularIntensityMap:Se,transmission:te,transmissionMap:dt,thicknessMap:ye,gradientMap:fe,opaque:k.transparent===!1&&k.blending===Zm&&k.alphaToCoverage===!1,alphaMap:Ce,alphaTest:ue,alphaHash:ie,combine:k.combine,mapUv:Ee&&_(k.map.channel),aoMapUv:Ht&&_(k.aoMap.channel),lightMapUv:Jt&&_(k.lightMap.channel),bumpMapUv:Xt&&_(k.bumpMap.channel),normalMapUv:ce&&_(k.normalMap.channel),displacementMapUv:rt&&_(k.displacementMap.channel),emissiveMapUv:Fe&&_(k.emissiveMap.channel),metalnessMapUv:he&&_(k.metalnessMap.channel),roughnessMapUv:Pe&&_(k.roughnessMap.channel),anisotropyMapUv:Pt&&_(k.anisotropyMap.channel),clearcoatMapUv:Ue&&_(k.clearcoatMap.channel),clearcoatNormalMapUv:we&&_(k.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:ze&&_(k.clearcoatRoughnessMap.channel),iridescenceMapUv:nn&&_(k.iridescenceMap.channel),iridescenceThicknessMapUv:ae&&_(k.iridescenceThicknessMap.channel),sheenColorMapUv:de&&_(k.sheenColorMap.channel),sheenRoughnessMapUv:Ne&&_(k.sheenRoughnessMap.channel),specularMapUv:ut&&_(k.specularMap.channel),specularColorMapUv:kt&&_(k.specularColorMap.channel),specularIntensityMapUv:Se&&_(k.specularIntensityMap.channel),transmissionMapUv:dt&&_(k.transmissionMap.channel),thicknessMapUv:ye&&_(k.thicknessMap.channel),alphaMapUv:Ce&&_(k.alphaMap.channel),vertexTangents:!!Y.attributes.tangent&&(ce||pe),vertexColors:k.vertexColors,vertexAlphas:k.vertexColors===!0&&!!Y.attributes.color&&Y.attributes.color.itemSize===4,pointsUvs:q.isPoints===!0&&!!Y.attributes.uv&&(Ee||Ce),fog:!!K,useFog:k.fog===!0,fogExp2:!!K&&K.isFogExp2,flatShading:k.flatShading===!0&&k.wireframe===!1,sizeAttenuation:k.sizeAttenuation===!0,logarithmicDepthBuffer:p,reversedDepthBuffer:qt,skinning:q.isSkinnedMesh===!0,morphTargets:Y.morphAttributes.position!==void 0,morphNormals:Y.morphAttributes.normal!==void 0,morphColors:Y.morphAttributes.color!==void 0,morphTargetsCount:X,morphTextureStride:it,numDirLights:O.directional.length,numPointLights:O.point.length,numSpotLights:O.spot.length,numSpotLightMaps:O.spotLightMap.length,numRectAreaLights:O.rectArea.length,numHemiLights:O.hemi.length,numDirLightShadows:O.directionalShadowMap.length,numPointLightShadows:O.pointShadowMap.length,numSpotLightShadows:O.spotShadowMap.length,numSpotLightShadowsWithMaps:O.numSpotLightShadowsWithMaps,numLightProbes:O.numLightProbes,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:k.dithering,shadowMapEnabled:n.shadowMap.enabled&&L.length>0,shadowMapType:n.shadowMap.type,toneMapping:Je,decodeVideoTexture:Ee&&k.map.isVideoTexture===!0&&ss.getTransfer(k.map.colorSpace)===Ls,decodeVideoTextureEmissive:Fe&&k.emissiveMap.isVideoTexture===!0&&ss.getTransfer(k.emissiveMap.colorSpace)===Ls,premultipliedAlpha:k.premultipliedAlpha,doubleSided:k.side===Fa,flipSided:k.side===kr,useDepthPacking:k.depthPacking>=0,depthPacking:k.depthPacking||0,index0AttributeName:k.index0AttributeName,extensionClipCullDistance:ve&&k.extensions.clipCullDistance===!0&&s.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(ve&&k.extensions.multiDraw===!0||se)&&s.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:s.has("KHR_parallel_shader_compile"),customProgramCacheKey:k.customProgramCacheKey()};return zn.vertexUv1s=c.has(1),zn.vertexUv2s=c.has(2),zn.vertexUv3s=c.has(3),c.clear(),zn}function b(k){const O=[];if(k.shaderID?O.push(k.shaderID):(O.push(k.customVertexShaderID),O.push(k.customFragmentShaderID)),k.defines!==void 0)for(const L in k.defines)O.push(L),O.push(k.defines[L]);return k.isRawShaderMaterial===!1&&(T(O,k),C(O,k),O.push(n.outputColorSpace)),O.push(k.customProgramCacheKey),O.join()}function T(k,O){k.push(O.precision),k.push(O.outputColorSpace),k.push(O.envMapMode),k.push(O.envMapCubeUVHeight),k.push(O.mapUv),k.push(O.alphaMapUv),k.push(O.lightMapUv),k.push(O.aoMapUv),k.push(O.bumpMapUv),k.push(O.normalMapUv),k.push(O.displacementMapUv),k.push(O.emissiveMapUv),k.push(O.metalnessMapUv),k.push(O.roughnessMapUv),k.push(O.anisotropyMapUv),k.push(O.clearcoatMapUv),k.push(O.clearcoatNormalMapUv),k.push(O.clearcoatRoughnessMapUv),k.push(O.iridescenceMapUv),k.push(O.iridescenceThicknessMapUv),k.push(O.sheenColorMapUv),k.push(O.sheenRoughnessMapUv),k.push(O.specularMapUv),k.push(O.specularColorMapUv),k.push(O.specularIntensityMapUv),k.push(O.transmissionMapUv),k.push(O.thicknessMapUv),k.push(O.combine),k.push(O.fogExp2),k.push(O.sizeAttenuation),k.push(O.morphTargetsCount),k.push(O.morphAttributeCount),k.push(O.numDirLights),k.push(O.numPointLights),k.push(O.numSpotLights),k.push(O.numSpotLightMaps),k.push(O.numHemiLights),k.push(O.numRectAreaLights),k.push(O.numDirLightShadows),k.push(O.numPointLightShadows),k.push(O.numSpotLightShadows),k.push(O.numSpotLightShadowsWithMaps),k.push(O.numLightProbes),k.push(O.shadowMapType),k.push(O.toneMapping),k.push(O.numClippingPlanes),k.push(O.numClipIntersection),k.push(O.depthPacking)}function C(k,O){o.disableAll(),O.instancing&&o.enable(0),O.instancingColor&&o.enable(1),O.instancingMorph&&o.enable(2),O.matcap&&o.enable(3),O.envMap&&o.enable(4),O.normalMapObjectSpace&&o.enable(5),O.normalMapTangentSpace&&o.enable(6),O.clearcoat&&o.enable(7),O.iridescence&&o.enable(8),O.alphaTest&&o.enable(9),O.vertexColors&&o.enable(10),O.vertexAlphas&&o.enable(11),O.vertexUv1s&&o.enable(12),O.vertexUv2s&&o.enable(13),O.vertexUv3s&&o.enable(14),O.vertexTangents&&o.enable(15),O.anisotropy&&o.enable(16),O.alphaHash&&o.enable(17),O.batching&&o.enable(18),O.dispersion&&o.enable(19),O.batchingColor&&o.enable(20),O.gradientMap&&o.enable(21),k.push(o.mask),o.disableAll(),O.fog&&o.enable(0),O.useFog&&o.enable(1),O.flatShading&&o.enable(2),O.logarithmicDepthBuffer&&o.enable(3),O.reversedDepthBuffer&&o.enable(4),O.skinning&&o.enable(5),O.morphTargets&&o.enable(6),O.morphNormals&&o.enable(7),O.morphColors&&o.enable(8),O.premultipliedAlpha&&o.enable(9),O.shadowMapEnabled&&o.enable(10),O.doubleSided&&o.enable(11),O.flipSided&&o.enable(12),O.useDepthPacking&&o.enable(13),O.dithering&&o.enable(14),O.transmission&&o.enable(15),O.sheen&&o.enable(16),O.opaque&&o.enable(17),O.pointsUvs&&o.enable(18),O.decodeVideoTexture&&o.enable(19),O.decodeVideoTextureEmissive&&o.enable(20),O.alphaToCoverage&&o.enable(21),k.push(o.mask)}function A(k){const O=v[k.type];let L;if(O){const H=qc[O];L=o4.clone(H.uniforms)}else L=k.uniforms;return L}function I(k,O){let L=f.get(O);return L!==void 0?++L.usedTimes:(L=new eet(n,O,k,r),h.push(L),f.set(O,L)),L}function D(k){if(--k.usedTimes===0){const O=h.indexOf(k);h[O]=h[h.length-1],h.pop(),f.delete(k.cacheKey),k.destroy()}}function F(k){l.remove(k)}function z(){l.dispose()}return{getParameters:S,getProgramCacheKey:b,getUniforms:A,acquireProgram:I,releaseProgram:D,releaseShaderCache:F,programs:h,dispose:z}}function aet(){let n=new WeakMap;function t(a){return n.has(a)}function e(a){let o=n.get(a);return o===void 0&&(o={},n.set(a,o)),o}function s(a){n.delete(a)}function i(a,o,l){n.get(a)[o]=l}function r(){n=new WeakMap}return{has:t,get:e,remove:s,update:i,dispose:r}}function oet(n,t){return n.groupOrder!==t.groupOrder?n.groupOrder-t.groupOrder:n.renderOrder!==t.renderOrder?n.renderOrder-t.renderOrder:n.material.id!==t.material.id?n.material.id-t.material.id:n.z!==t.z?n.z-t.z:n.id-t.id}function mz(n,t){return n.groupOrder!==t.groupOrder?n.groupOrder-t.groupOrder:n.renderOrder!==t.renderOrder?n.renderOrder-t.renderOrder:n.z!==t.z?t.z-n.z:n.id-t.id}function gz(){const n=[];let t=0;const e=[],s=[],i=[];function r(){t=0,e.length=0,s.length=0,i.length=0}function a(f,p,g,v,_,S){let b=n[t];return b===void 0?(b={id:f.id,object:f,geometry:p,material:g,groupOrder:v,renderOrder:f.renderOrder,z:_,group:S},n[t]=b):(b.id=f.id,b.object=f,b.geometry=p,b.material=g,b.groupOrder=v,b.renderOrder=f.renderOrder,b.z=_,b.group=S),t++,b}function o(f,p,g,v,_,S){const b=a(f,p,g,v,_,S);g.transmission>0?s.push(b):g.transparent===!0?i.push(b):e.push(b)}function l(f,p,g,v,_,S){const b=a(f,p,g,v,_,S);g.transmission>0?s.unshift(b):g.transparent===!0?i.unshift(b):e.unshift(b)}function c(f,p){e.length>1&&e.sort(f||oet),s.length>1&&s.sort(p||mz),i.length>1&&i.sort(p||mz)}function h(){for(let f=t,p=n.length;f<p;f++){const g=n[f];if(g.id===null)break;g.id=null,g.object=null,g.geometry=null,g.material=null,g.group=null}}return{opaque:e,transmissive:s,transparent:i,init:r,push:o,unshift:l,finish:h,sort:c}}function cet(){let n=new WeakMap;function t(s,i){const r=n.get(s);let a;return r===void 0?(a=new gz,n.set(s,[a])):i>=r.length?(a=new gz,r.push(a)):a=r[i],a}function e(){n=new WeakMap}return{get:t,dispose:e}}function uet(){const n={};return{get:function(t){if(n[t.id]!==void 0)return n[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new at,color:new ke};break;case"SpotLight":e={position:new at,direction:new at,color:new ke,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new at,color:new ke,distance:0,decay:0};break;case"HemisphereLight":e={direction:new at,skyColor:new ke,groundColor:new ke};break;case"RectAreaLight":e={color:new ke,position:new at,halfWidth:new at,halfHeight:new at};break}return n[t.id]=e,e}}}function het(){const n={};return{get:function(t){if(n[t.id]!==void 0)return n[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Yt};break;case"SpotLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Yt};break;case"PointLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Yt,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[t.id]=e,e}}}let fet=0;function det(n,t){return(t.castShadow?2:0)-(n.castShadow?2:0)+(t.map?1:0)-(n.map?1:0)}function pet(n){const t=new uet,e=het(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let c=0;c<9;c++)s.probe.push(new at);const i=new at,r=new Tn,a=new Tn;function o(c){let h=0,f=0,p=0;for(let k=0;k<9;k++)s.probe[k].set(0,0,0);let g=0,v=0,_=0,S=0,b=0,T=0,C=0,A=0,I=0,D=0,F=0;c.sort(det);for(let k=0,O=c.length;k<O;k++){const L=c[k],H=L.color,q=L.intensity,K=L.distance;let Y=null;if(L.shadow&&L.shadow.map&&(L.shadow.map.texture.format===ag?Y=L.shadow.map.texture:Y=L.shadow.map.depthTexture||L.shadow.map.texture),L.isAmbientLight)h+=H.r*q,f+=H.g*q,p+=H.b*q;else if(L.isLightProbe){for(let P=0;P<9;P++)s.probe[P].addScaledVector(L.sh.coefficients[P],q);F++}else if(L.isDirectionalLight){const P=t.get(L);if(P.color.copy(L.color).multiplyScalar(L.intensity),L.castShadow){const W=L.shadow,j=e.get(L);j.shadowIntensity=W.intensity,j.shadowBias=W.bias,j.shadowNormalBias=W.normalBias,j.shadowRadius=W.radius,j.shadowMapSize=W.mapSize,s.directionalShadow[g]=j,s.directionalShadowMap[g]=Y,s.directionalShadowMatrix[g]=L.shadow.matrix,T++}s.directional[g]=P,g++}else if(L.isSpotLight){const P=t.get(L);P.position.setFromMatrixPosition(L.matrixWorld),P.color.copy(H).multiplyScalar(q),P.distance=K,P.coneCos=Math.cos(L.angle),P.penumbraCos=Math.cos(L.angle*(1-L.penumbra)),P.decay=L.decay,s.spot[_]=P;const W=L.shadow;if(L.map&&(s.spotLightMap[I]=L.map,I++,W.updateMatrices(L),L.castShadow&&D++),s.spotLightMatrix[_]=W.matrix,L.castShadow){const j=e.get(L);j.shadowIntensity=W.intensity,j.shadowBias=W.bias,j.shadowNormalBias=W.normalBias,j.shadowRadius=W.radius,j.shadowMapSize=W.mapSize,s.spotShadow[_]=j,s.spotShadowMap[_]=Y,A++}_++}else if(L.isRectAreaLight){const P=t.get(L);P.color.copy(H).multiplyScalar(q),P.halfWidth.set(L.width*.5,0,0),P.halfHeight.set(0,L.height*.5,0),s.rectArea[S]=P,S++}else if(L.isPointLight){const P=t.get(L);if(P.color.copy(L.color).multiplyScalar(L.intensity),P.distance=L.distance,P.decay=L.decay,L.castShadow){const W=L.shadow,j=e.get(L);j.shadowIntensity=W.intensity,j.shadowBias=W.bias,j.shadowNormalBias=W.normalBias,j.shadowRadius=W.radius,j.shadowMapSize=W.mapSize,j.shadowCameraNear=W.camera.near,j.shadowCameraFar=W.camera.far,s.pointShadow[v]=j,s.pointShadowMap[v]=Y,s.pointShadowMatrix[v]=L.shadow.matrix,C++}s.point[v]=P,v++}else if(L.isHemisphereLight){const P=t.get(L);P.skyColor.copy(L.color).multiplyScalar(q),P.groundColor.copy(L.groundColor).multiplyScalar(q),s.hemi[b]=P,b++}}S>0&&(n.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=Le.LTC_FLOAT_1,s.rectAreaLTC2=Le.LTC_FLOAT_2):(s.rectAreaLTC1=Le.LTC_HALF_1,s.rectAreaLTC2=Le.LTC_HALF_2)),s.ambient[0]=h,s.ambient[1]=f,s.ambient[2]=p;const z=s.hash;(z.directionalLength!==g||z.pointLength!==v||z.spotLength!==_||z.rectAreaLength!==S||z.hemiLength!==b||z.numDirectionalShadows!==T||z.numPointShadows!==C||z.numSpotShadows!==A||z.numSpotMaps!==I||z.numLightProbes!==F)&&(s.directional.length=g,s.spot.length=_,s.rectArea.length=S,s.point.length=v,s.hemi.length=b,s.directionalShadow.length=T,s.directionalShadowMap.length=T,s.pointShadow.length=C,s.pointShadowMap.length=C,s.spotShadow.length=A,s.spotShadowMap.length=A,s.directionalShadowMatrix.length=T,s.pointShadowMatrix.length=C,s.spotLightMatrix.length=A+I-D,s.spotLightMap.length=I,s.numSpotLightShadowsWithMaps=D,s.numLightProbes=F,z.directionalLength=g,z.pointLength=v,z.spotLength=_,z.rectAreaLength=S,z.hemiLength=b,z.numDirectionalShadows=T,z.numPointShadows=C,z.numSpotShadows=A,z.numSpotMaps=I,z.numLightProbes=F,s.version=fet++)}function l(c,h){let f=0,p=0,g=0,v=0,_=0;const S=h.matrixWorldInverse;for(let b=0,T=c.length;b<T;b++){const C=c[b];if(C.isDirectionalLight){const A=s.directional[f];A.direction.setFromMatrixPosition(C.matrixWorld),i.setFromMatrixPosition(C.target.matrixWorld),A.direction.sub(i),A.direction.transformDirection(S),f++}else if(C.isSpotLight){const A=s.spot[g];A.position.setFromMatrixPosition(C.matrixWorld),A.position.applyMatrix4(S),A.direction.setFromMatrixPosition(C.matrixWorld),i.setFromMatrixPosition(C.target.matrixWorld),A.direction.sub(i),A.direction.transformDirection(S),g++}else if(C.isRectAreaLight){const A=s.rectArea[v];A.position.setFromMatrixPosition(C.matrixWorld),A.position.applyMatrix4(S),a.identity(),r.copy(C.matrixWorld),r.premultiply(S),a.extractRotation(r),A.halfWidth.set(C.width*.5,0,0),A.halfHeight.set(0,C.height*.5,0),A.halfWidth.applyMatrix4(a),A.halfHeight.applyMatrix4(a),v++}else if(C.isPointLight){const A=s.point[p];A.position.setFromMatrixPosition(C.matrixWorld),A.position.applyMatrix4(S),p++}else if(C.isHemisphereLight){const A=s.hemi[_];A.direction.setFromMatrixPosition(C.matrixWorld),A.direction.transformDirection(S),_++}}}return{setup:o,setupView:l,state:s}}function yz(n){const t=new pet(n),e=[],s=[];function i(h){c.camera=h,e.length=0,s.length=0}function r(h){e.push(h)}function a(h){s.push(h)}function o(){t.setup(e)}function l(h){t.setupView(e,h)}const c={lightsArray:e,shadowsArray:s,camera:null,lights:t,transmissionRenderTarget:{}};return{init:i,state:c,setupLights:o,setupLightsView:l,pushLight:r,pushShadow:a}}function met(n){let t=new WeakMap;function e(i,r=0){const a=t.get(i);let o;return a===void 0?(o=new yz(n),t.set(i,[o])):r>=a.length?(o=new yz(n),a.push(o)):o=a[r],o}function s(){t=new WeakMap}return{get:e,dispose:s}}const get=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,yet=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ).rg;
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ).r;
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( max( 0.0, squared_mean - mean * mean ) );
	gl_FragColor = vec4( mean, std_dev, 0.0, 1.0 );
}`,xet=[new at(1,0,0),new at(-1,0,0),new at(0,1,0),new at(0,-1,0),new at(0,0,1),new at(0,0,-1)],vet=[new at(0,-1,0),new at(0,-1,0),new at(0,0,1),new at(0,0,-1),new at(0,-1,0),new at(0,-1,0)],xz=new Tn,Rb=new at,iI=new at;function bet(n,t,e){let s=new Tx;const i=new Yt,r=new Yt,a=new Gs,o=new d3,l=new p3,c={},h=e.maxTextureSize,f={[dh]:kr,[kr]:dh,[Fa]:Fa},p=new ar({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Yt},radius:{value:4}},vertexShader:get,fragmentShader:yet}),g=p.clone();g.defines.HORIZONTAL_PASS=1;const v=new Nn;v.setAttribute("position",new Fs(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const _=new rr(v,p),S=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Py;let b=this.type;this.render=function(D,F,z){if(S.enabled===!1||S.autoUpdate===!1&&S.needsUpdate===!1||D.length===0)return;D.type===Zb&&(Oe("WebGLShadowMap: PCFSoftShadowMap has been deprecated. Using PCFShadowMap instead."),D.type=Py);const k=n.getRenderTarget(),O=n.getActiveCubeFace(),L=n.getActiveMipmapLevel(),H=n.state;H.setBlending(da),H.buffers.depth.getReversed()===!0?H.buffers.color.setClear(0,0,0,0):H.buffers.color.setClear(1,1,1,1),H.buffers.depth.setTest(!0),H.setScissorTest(!1);const q=b!==this.type;q&&F.traverse(function(K){K.material&&(Array.isArray(K.material)?K.material.forEach(Y=>Y.needsUpdate=!0):K.material.needsUpdate=!0)});for(let K=0,Y=D.length;K<Y;K++){const P=D[K],W=P.shadow;if(W===void 0){Oe("WebGLShadowMap:",P,"has no shadow.");continue}if(W.autoUpdate===!1&&W.needsUpdate===!1)continue;i.copy(W.mapSize);const j=W.getFrameExtents();if(i.multiply(j),r.copy(W.mapSize),(i.x>h||i.y>h)&&(i.x>h&&(r.x=Math.floor(h/j.x),i.x=r.x*j.x,W.mapSize.x=r.x),i.y>h&&(r.y=Math.floor(h/j.y),i.y=r.y*j.y,W.mapSize.y=r.y)),W.map===null||q===!0){if(W.map!==null&&(W.map.depthTexture!==null&&(W.map.depthTexture.dispose(),W.map.depthTexture=null),W.map.dispose()),this.type===Vm){if(P.isPointLight){Oe("WebGLShadowMap: VSM shadow maps are not supported for PointLights. Use PCF or BasicShadowMap instead.");continue}W.map=new ki(i.x,i.y,{format:ag,type:ru,minFilter:Hs,magFilter:Hs,generateMipmaps:!1}),W.map.texture.name=P.name+".shadowMap",W.map.depthTexture=new lg(i.x,i.y,Ua),W.map.depthTexture.name=P.name+".shadowMapDepth",W.map.depthTexture.format=mh,W.map.depthTexture.compareFunction=null,W.map.depthTexture.minFilter=hi,W.map.depthTexture.magFilter=hi}else{P.isPointLight?(W.map=new JD(i.x),W.map.depthTexture=new v4(i.x,Nl)):(W.map=new ki(i.x,i.y),W.map.depthTexture=new lg(i.x,i.y,Nl)),W.map.depthTexture.name=P.name+".shadowMap",W.map.depthTexture.format=mh;const ot=n.state.buffers.depth.getReversed();this.type===Py?(W.map.depthTexture.compareFunction=ot?gC:mC,W.map.depthTexture.minFilter=Hs,W.map.depthTexture.magFilter=Hs):(W.map.depthTexture.compareFunction=null,W.map.depthTexture.minFilter=hi,W.map.depthTexture.magFilter=hi)}W.camera.updateProjectionMatrix()}const st=W.map.isWebGLCubeRenderTarget?6:1;for(let ot=0;ot<st;ot++){if(W.map.isWebGLCubeRenderTarget)n.setRenderTarget(W.map,ot),n.clear();else{ot===0&&(n.setRenderTarget(W.map),n.clear());const X=W.getViewport(ot);a.set(r.x*X.x,r.y*X.y,r.x*X.z,r.y*X.w),H.viewport(a)}if(P.isPointLight){const X=W.camera,it=W.matrix,ct=P.distance||X.far;ct!==X.far&&(X.far=ct,X.updateProjectionMatrix()),Rb.setFromMatrixPosition(P.matrixWorld),X.position.copy(Rb),iI.copy(X.position),iI.add(xet[ot]),X.up.copy(vet[ot]),X.lookAt(iI),X.updateMatrixWorld(),it.makeTranslation(-Rb.x,-Rb.y,-Rb.z),xz.multiplyMatrices(X.projectionMatrix,X.matrixWorldInverse),W._frustum.setFromProjectionMatrix(xz,X.coordinateSystem,X.reversedDepth)}else W.updateMatrices(P);s=W.getFrustum(),A(F,z,W.camera,P,this.type)}W.isPointLightShadow!==!0&&this.type===Vm&&T(W,z),W.needsUpdate=!1}b=this.type,S.needsUpdate=!1,n.setRenderTarget(k,O,L)};function T(D,F){const z=t.update(_);p.defines.VSM_SAMPLES!==D.blurSamples&&(p.defines.VSM_SAMPLES=D.blurSamples,g.defines.VSM_SAMPLES=D.blurSamples,p.needsUpdate=!0,g.needsUpdate=!0),D.mapPass===null&&(D.mapPass=new ki(i.x,i.y,{format:ag,type:ru})),p.uniforms.shadow_pass.value=D.map.depthTexture,p.uniforms.resolution.value=D.mapSize,p.uniforms.radius.value=D.radius,n.setRenderTarget(D.mapPass),n.clear(),n.renderBufferDirect(F,null,z,p,_,null),g.uniforms.shadow_pass.value=D.mapPass.texture,g.uniforms.resolution.value=D.mapSize,g.uniforms.radius.value=D.radius,n.setRenderTarget(D.map),n.clear(),n.renderBufferDirect(F,null,z,g,_,null)}function C(D,F,z,k){let O=null;const L=z.isPointLight===!0?D.customDistanceMaterial:D.customDepthMaterial;if(L!==void 0)O=L;else if(O=z.isPointLight===!0?l:o,n.localClippingEnabled&&F.clipShadows===!0&&Array.isArray(F.clippingPlanes)&&F.clippingPlanes.length!==0||F.displacementMap&&F.displacementScale!==0||F.alphaMap&&F.alphaTest>0||F.map&&F.alphaTest>0||F.alphaToCoverage===!0){const H=O.uuid,q=F.uuid;let K=c[H];K===void 0&&(K={},c[H]=K);let Y=K[q];Y===void 0&&(Y=O.clone(),K[q]=Y,F.addEventListener("dispose",I)),O=Y}if(O.visible=F.visible,O.wireframe=F.wireframe,k===Vm?O.side=F.shadowSide!==null?F.shadowSide:F.side:O.side=F.shadowSide!==null?F.shadowSide:f[F.side],O.alphaMap=F.alphaMap,O.alphaTest=F.alphaToCoverage===!0?.5:F.alphaTest,O.map=F.map,O.clipShadows=F.clipShadows,O.clippingPlanes=F.clippingPlanes,O.clipIntersection=F.clipIntersection,O.displacementMap=F.displacementMap,O.displacementScale=F.displacementScale,O.displacementBias=F.displacementBias,O.wireframeLinewidth=F.wireframeLinewidth,O.linewidth=F.linewidth,z.isPointLight===!0&&O.isMeshDistanceMaterial===!0){const H=n.properties.get(O);H.light=z}return O}function A(D,F,z,k,O){if(D.visible===!1)return;if(D.layers.test(F.layers)&&(D.isMesh||D.isLine||D.isPoints)&&(D.castShadow||D.receiveShadow&&O===Vm)&&(!D.frustumCulled||s.intersectsObject(D))){D.modelViewMatrix.multiplyMatrices(z.matrixWorldInverse,D.matrixWorld);const q=t.update(D),K=D.material;if(Array.isArray(K)){const Y=q.groups;for(let P=0,W=Y.length;P<W;P++){const j=Y[P],st=K[j.materialIndex];if(st&&st.visible){const ot=C(D,st,k,O);D.onBeforeShadow(n,D,F,z,q,ot,j),n.renderBufferDirect(z,null,q,ot,D,j),D.onAfterShadow(n,D,F,z,q,ot,j)}}}else if(K.visible){const Y=C(D,K,k,O);D.onBeforeShadow(n,D,F,z,q,Y,null),n.renderBufferDirect(z,null,q,Y,D,null),D.onAfterShadow(n,D,F,z,q,Y,null)}}const H=D.children;for(let q=0,K=H.length;q<K;q++)A(H[q],F,z,k,O)}function I(D){D.target.removeEventListener("dispose",I);for(const z in c){const k=c[z],O=D.target.uuid;O in k&&(k[O].dispose(),delete k[O])}}}const _et={[EE]:h1,[CE]:ME,[AE]:IE,[ig]:NE,[h1]:EE,[ME]:CE,[IE]:AE,[NE]:ig};function wet(n,t){function e(){let dt=!1;const ye=new Gs;let fe=null;const Ce=new Gs(0,0,0,0);return{setMask:function(ue){fe!==ue&&!dt&&(n.colorMask(ue,ue,ue,ue),fe=ue)},setLocked:function(ue){dt=ue},setClear:function(ue,ie,ve,Je,zn){zn===!0&&(ue*=Je,ie*=Je,ve*=Je),ye.set(ue,ie,ve,Je),Ce.equals(ye)===!1&&(n.clearColor(ue,ie,ve,Je),Ce.copy(ye))},reset:function(){dt=!1,fe=null,Ce.set(-1,0,0,0)}}}function s(){let dt=!1,ye=!1,fe=null,Ce=null,ue=null;return{setReversed:function(ie){if(ye!==ie){const ve=t.get("EXT_clip_control");ie?ve.clipControlEXT(ve.LOWER_LEFT_EXT,ve.ZERO_TO_ONE_EXT):ve.clipControlEXT(ve.LOWER_LEFT_EXT,ve.NEGATIVE_ONE_TO_ONE_EXT),ye=ie;const Je=ue;ue=null,this.setClear(Je)}},getReversed:function(){return ye},setTest:function(ie){ie?_t(n.DEPTH_TEST):qt(n.DEPTH_TEST)},setMask:function(ie){fe!==ie&&!dt&&(n.depthMask(ie),fe=ie)},setFunc:function(ie){if(ye&&(ie=_et[ie]),Ce!==ie){switch(ie){case EE:n.depthFunc(n.NEVER);break;case h1:n.depthFunc(n.ALWAYS);break;case CE:n.depthFunc(n.LESS);break;case ig:n.depthFunc(n.LEQUAL);break;case AE:n.depthFunc(n.EQUAL);break;case NE:n.depthFunc(n.GEQUAL);break;case ME:n.depthFunc(n.GREATER);break;case IE:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}Ce=ie}},setLocked:function(ie){dt=ie},setClear:function(ie){ue!==ie&&(ye&&(ie=1-ie),n.clearDepth(ie),ue=ie)},reset:function(){dt=!1,fe=null,Ce=null,ue=null,ye=!1}}}function i(){let dt=!1,ye=null,fe=null,Ce=null,ue=null,ie=null,ve=null,Je=null,zn=null;return{setTest:function(Mn){dt||(Mn?_t(n.STENCIL_TEST):qt(n.STENCIL_TEST))},setMask:function(Mn){ye!==Mn&&!dt&&(n.stencilMask(Mn),ye=Mn)},setFunc:function(Mn,li,wr){(fe!==Mn||Ce!==li||ue!==wr)&&(n.stencilFunc(Mn,li,wr),fe=Mn,Ce=li,ue=wr)},setOp:function(Mn,li,wr){(ie!==Mn||ve!==li||Je!==wr)&&(n.stencilOp(Mn,li,wr),ie=Mn,ve=li,Je=wr)},setLocked:function(Mn){dt=Mn},setClear:function(Mn){zn!==Mn&&(n.clearStencil(Mn),zn=Mn)},reset:function(){dt=!1,ye=null,fe=null,Ce=null,ue=null,ie=null,ve=null,Je=null,zn=null}}}const r=new e,a=new s,o=new i,l=new WeakMap,c=new WeakMap;let h={},f={},p=new WeakMap,g=[],v=null,_=!1,S=null,b=null,T=null,C=null,A=null,I=null,D=null,F=new ke(0,0,0),z=0,k=!1,O=null,L=null,H=null,q=null,K=null;const Y=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let P=!1,W=0;const j=n.getParameter(n.VERSION);j.indexOf("WebGL")!==-1?(W=parseFloat(/^WebGL (\d)/.exec(j)[1]),P=W>=1):j.indexOf("OpenGL ES")!==-1&&(W=parseFloat(/^OpenGL ES (\d)/.exec(j)[1]),P=W>=2);let st=null,ot={};const X=n.getParameter(n.SCISSOR_BOX),it=n.getParameter(n.VIEWPORT),ct=new Gs().fromArray(X),yt=new Gs().fromArray(it);function Rt(dt,ye,fe,Ce){const ue=new Uint8Array(4),ie=n.createTexture();n.bindTexture(dt,ie),n.texParameteri(dt,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(dt,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let ve=0;ve<fe;ve++)dt===n.TEXTURE_3D||dt===n.TEXTURE_2D_ARRAY?n.texImage3D(ye,0,n.RGBA,1,1,Ce,0,n.RGBA,n.UNSIGNED_BYTE,ue):n.texImage2D(ye+ve,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,ue);return ie}const ft={};ft[n.TEXTURE_2D]=Rt(n.TEXTURE_2D,n.TEXTURE_2D,1),ft[n.TEXTURE_CUBE_MAP]=Rt(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),ft[n.TEXTURE_2D_ARRAY]=Rt(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),ft[n.TEXTURE_3D]=Rt(n.TEXTURE_3D,n.TEXTURE_3D,1,1),r.setClear(0,0,0,1),a.setClear(1),o.setClear(0),_t(n.DEPTH_TEST),a.setFunc(ig),Xt(!1),ce(YI),_t(n.CULL_FACE),Ht(da);function _t(dt){h[dt]!==!0&&(n.enable(dt),h[dt]=!0)}function qt(dt){h[dt]!==!1&&(n.disable(dt),h[dt]=!1)}function Qt(dt,ye){return f[dt]!==ye?(n.bindFramebuffer(dt,ye),f[dt]=ye,dt===n.DRAW_FRAMEBUFFER&&(f[n.FRAMEBUFFER]=ye),dt===n.FRAMEBUFFER&&(f[n.DRAW_FRAMEBUFFER]=ye),!0):!1}function se(dt,ye){let fe=g,Ce=!1;if(dt){fe=p.get(ye),fe===void 0&&(fe=[],p.set(ye,fe));const ue=dt.textures;if(fe.length!==ue.length||fe[0]!==n.COLOR_ATTACHMENT0){for(let ie=0,ve=ue.length;ie<ve;ie++)fe[ie]=n.COLOR_ATTACHMENT0+ie;fe.length=ue.length,Ce=!0}}else fe[0]!==n.BACK&&(fe[0]=n.BACK,Ce=!0);Ce&&n.drawBuffers(fe)}function Ee(dt){return v!==dt?(n.useProgram(dt),v=dt,!0):!1}const He={[Dd]:n.FUNC_ADD,[TP]:n.FUNC_SUBTRACT,[EP]:n.FUNC_REVERSE_SUBTRACT};He[CP]=n.MIN,He[AP]=n.MAX;const Ae={[NP]:n.ZERO,[MP]:n.ONE,[IP]:n.SRC_COLOR,[wE]:n.SRC_ALPHA,[LP]:n.SRC_ALPHA_SATURATE,[OP]:n.DST_COLOR,[DP]:n.DST_ALPHA,[RP]:n.ONE_MINUS_SRC_COLOR,[TE]:n.ONE_MINUS_SRC_ALPHA,[$P]:n.ONE_MINUS_DST_COLOR,[kP]:n.ONE_MINUS_DST_ALPHA,[FP]:n.CONSTANT_COLOR,[zP]:n.ONE_MINUS_CONSTANT_COLOR,[UP]:n.CONSTANT_ALPHA,[BP]:n.ONE_MINUS_CONSTANT_ALPHA};function Ht(dt,ye,fe,Ce,ue,ie,ve,Je,zn,Mn){if(dt===da){_===!0&&(qt(n.BLEND),_=!1);return}if(_===!1&&(_t(n.BLEND),_=!0),dt!==wP){if(dt!==S||Mn!==k){if((b!==Dd||A!==Dd)&&(n.blendEquation(n.FUNC_ADD),b=Dd,A=Dd),Mn)switch(dt){case Zm:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case Zy:n.blendFunc(n.ONE,n.ONE);break;case ZI:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case QI:n.blendFuncSeparate(n.DST_COLOR,n.ONE_MINUS_SRC_ALPHA,n.ZERO,n.ONE);break;default:on("WebGLState: Invalid blending: ",dt);break}else switch(dt){case Zm:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case Zy:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE,n.ONE,n.ONE);break;case ZI:on("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case QI:on("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:on("WebGLState: Invalid blending: ",dt);break}T=null,C=null,I=null,D=null,F.set(0,0,0),z=0,S=dt,k=Mn}return}ue=ue||ye,ie=ie||fe,ve=ve||Ce,(ye!==b||ue!==A)&&(n.blendEquationSeparate(He[ye],He[ue]),b=ye,A=ue),(fe!==T||Ce!==C||ie!==I||ve!==D)&&(n.blendFuncSeparate(Ae[fe],Ae[Ce],Ae[ie],Ae[ve]),T=fe,C=Ce,I=ie,D=ve),(Je.equals(F)===!1||zn!==z)&&(n.blendColor(Je.r,Je.g,Je.b,zn),F.copy(Je),z=zn),S=dt,k=!1}function Jt(dt,ye){dt.side===Fa?qt(n.CULL_FACE):_t(n.CULL_FACE);let fe=dt.side===kr;ye&&(fe=!fe),Xt(fe),dt.blending===Zm&&dt.transparent===!1?Ht(da):Ht(dt.blending,dt.blendEquation,dt.blendSrc,dt.blendDst,dt.blendEquationAlpha,dt.blendSrcAlpha,dt.blendDstAlpha,dt.blendColor,dt.blendAlpha,dt.premultipliedAlpha),a.setFunc(dt.depthFunc),a.setTest(dt.depthTest),a.setMask(dt.depthWrite),r.setMask(dt.colorWrite);const Ce=dt.stencilWrite;o.setTest(Ce),Ce&&(o.setMask(dt.stencilWriteMask),o.setFunc(dt.stencilFunc,dt.stencilRef,dt.stencilFuncMask),o.setOp(dt.stencilFail,dt.stencilZFail,dt.stencilZPass)),Fe(dt.polygonOffset,dt.polygonOffsetFactor,dt.polygonOffsetUnits),dt.alphaToCoverage===!0?_t(n.SAMPLE_ALPHA_TO_COVERAGE):qt(n.SAMPLE_ALPHA_TO_COVERAGE)}function Xt(dt){O!==dt&&(dt?n.frontFace(n.CW):n.frontFace(n.CCW),O=dt)}function ce(dt){dt!==bP?(_t(n.CULL_FACE),dt!==L&&(dt===YI?n.cullFace(n.BACK):dt===SP?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):qt(n.CULL_FACE),L=dt}function rt(dt){dt!==H&&(P&&n.lineWidth(dt),H=dt)}function Fe(dt,ye,fe){dt?(_t(n.POLYGON_OFFSET_FILL),(q!==ye||K!==fe)&&(n.polygonOffset(ye,fe),q=ye,K=fe)):qt(n.POLYGON_OFFSET_FILL)}function he(dt){dt?_t(n.SCISSOR_TEST):qt(n.SCISSOR_TEST)}function Pe(dt){dt===void 0&&(dt=n.TEXTURE0+Y-1),st!==dt&&(n.activeTexture(dt),st=dt)}function pe(dt,ye,fe){fe===void 0&&(st===null?fe=n.TEXTURE0+Y-1:fe=st);let Ce=ot[fe];Ce===void 0&&(Ce={type:void 0,texture:void 0},ot[fe]=Ce),(Ce.type!==dt||Ce.texture!==ye)&&(st!==fe&&(n.activeTexture(fe),st=fe),n.bindTexture(dt,ye||ft[dt]),Ce.type=dt,Ce.texture=ye)}function nt(){const dt=ot[st];dt!==void 0&&dt.type!==void 0&&(n.bindTexture(dt.type,null),dt.type=void 0,dt.texture=void 0)}function G(){try{n.compressedTexImage2D(...arguments)}catch(dt){on("WebGLState:",dt)}}function vt(){try{n.compressedTexImage3D(...arguments)}catch(dt){on("WebGLState:",dt)}}function Vt(){try{n.texSubImage2D(...arguments)}catch(dt){on("WebGLState:",dt)}}function te(){try{n.texSubImage3D(...arguments)}catch(dt){on("WebGLState:",dt)}}function Pt(){try{n.compressedTexSubImage2D(...arguments)}catch(dt){on("WebGLState:",dt)}}function Ue(){try{n.compressedTexSubImage3D(...arguments)}catch(dt){on("WebGLState:",dt)}}function we(){try{n.texStorage2D(...arguments)}catch(dt){on("WebGLState:",dt)}}function ze(){try{n.texStorage3D(...arguments)}catch(dt){on("WebGLState:",dt)}}function nn(){try{n.texImage2D(...arguments)}catch(dt){on("WebGLState:",dt)}}function ae(){try{n.texImage3D(...arguments)}catch(dt){on("WebGLState:",dt)}}function de(dt){ct.equals(dt)===!1&&(n.scissor(dt.x,dt.y,dt.z,dt.w),ct.copy(dt))}function Ne(dt){yt.equals(dt)===!1&&(n.viewport(dt.x,dt.y,dt.z,dt.w),yt.copy(dt))}function ut(dt,ye){let fe=c.get(ye);fe===void 0&&(fe=new WeakMap,c.set(ye,fe));let Ce=fe.get(dt);Ce===void 0&&(Ce=n.getUniformBlockIndex(ye,dt.name),fe.set(dt,Ce))}function kt(dt,ye){const Ce=c.get(ye).get(dt);l.get(ye)!==Ce&&(n.uniformBlockBinding(ye,Ce,dt.__bindingPointIndex),l.set(ye,Ce))}function Se(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),a.setReversed(!1),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),h={},st=null,ot={},f={},p=new WeakMap,g=[],v=null,_=!1,S=null,b=null,T=null,C=null,A=null,I=null,D=null,F=new ke(0,0,0),z=0,k=!1,O=null,L=null,H=null,q=null,K=null,ct.set(0,0,n.canvas.width,n.canvas.height),yt.set(0,0,n.canvas.width,n.canvas.height),r.reset(),a.reset(),o.reset()}return{buffers:{color:r,depth:a,stencil:o},enable:_t,disable:qt,bindFramebuffer:Qt,drawBuffers:se,useProgram:Ee,setBlending:Ht,setMaterial:Jt,setFlipSided:Xt,setCullFace:ce,setLineWidth:rt,setPolygonOffset:Fe,setScissorTest:he,activeTexture:Pe,bindTexture:pe,unbindTexture:nt,compressedTexImage2D:G,compressedTexImage3D:vt,texImage2D:nn,texImage3D:ae,updateUBOMapping:ut,uniformBlockBinding:kt,texStorage2D:we,texStorage3D:ze,texSubImage2D:Vt,texSubImage3D:te,compressedTexSubImage2D:Pt,compressedTexSubImage3D:Ue,scissor:de,viewport:Ne,reset:Se}}function Tet(n,t,e,s,i,r,a){const o=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,l=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),c=new Yt,h=new WeakMap;let f;const p=new WeakMap;let g=!1;try{g=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function v(nt,G){return g?new OffscreenCanvas(nt,G):b1("canvas")}function _(nt,G,vt){let Vt=1;const te=pe(nt);if((te.width>vt||te.height>vt)&&(Vt=vt/Math.max(te.width,te.height)),Vt<1)if(typeof HTMLImageElement<"u"&&nt instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&nt instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&nt instanceof ImageBitmap||typeof VideoFrame<"u"&&nt instanceof VideoFrame){const Pt=Math.floor(Vt*te.width),Ue=Math.floor(Vt*te.height);f===void 0&&(f=v(Pt,Ue));const we=G?v(Pt,Ue):f;return we.width=Pt,we.height=Ue,we.getContext("2d").drawImage(nt,0,0,Pt,Ue),Oe("WebGLRenderer: Texture has been resized from ("+te.width+"x"+te.height+") to ("+Pt+"x"+Ue+")."),we}else return"data"in nt&&Oe("WebGLRenderer: Image in DataTexture is too big ("+te.width+"x"+te.height+")."),nt;return nt}function S(nt){return nt.generateMipmaps}function b(nt){n.generateMipmap(nt)}function T(nt){return nt.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:nt.isWebGL3DRenderTarget?n.TEXTURE_3D:nt.isWebGLArrayRenderTarget||nt.isCompressedArrayTexture?n.TEXTURE_2D_ARRAY:n.TEXTURE_2D}function C(nt,G,vt,Vt,te=!1){if(nt!==null){if(n[nt]!==void 0)return n[nt];Oe("WebGLRenderer: Attempt to use non-existing WebGL internal format '"+nt+"'")}let Pt=G;if(G===n.RED&&(vt===n.FLOAT&&(Pt=n.R32F),vt===n.HALF_FLOAT&&(Pt=n.R16F),vt===n.UNSIGNED_BYTE&&(Pt=n.R8)),G===n.RED_INTEGER&&(vt===n.UNSIGNED_BYTE&&(Pt=n.R8UI),vt===n.UNSIGNED_SHORT&&(Pt=n.R16UI),vt===n.UNSIGNED_INT&&(Pt=n.R32UI),vt===n.BYTE&&(Pt=n.R8I),vt===n.SHORT&&(Pt=n.R16I),vt===n.INT&&(Pt=n.R32I)),G===n.RG&&(vt===n.FLOAT&&(Pt=n.RG32F),vt===n.HALF_FLOAT&&(Pt=n.RG16F),vt===n.UNSIGNED_BYTE&&(Pt=n.RG8)),G===n.RG_INTEGER&&(vt===n.UNSIGNED_BYTE&&(Pt=n.RG8UI),vt===n.UNSIGNED_SHORT&&(Pt=n.RG16UI),vt===n.UNSIGNED_INT&&(Pt=n.RG32UI),vt===n.BYTE&&(Pt=n.RG8I),vt===n.SHORT&&(Pt=n.RG16I),vt===n.INT&&(Pt=n.RG32I)),G===n.RGB_INTEGER&&(vt===n.UNSIGNED_BYTE&&(Pt=n.RGB8UI),vt===n.UNSIGNED_SHORT&&(Pt=n.RGB16UI),vt===n.UNSIGNED_INT&&(Pt=n.RGB32UI),vt===n.BYTE&&(Pt=n.RGB8I),vt===n.SHORT&&(Pt=n.RGB16I),vt===n.INT&&(Pt=n.RGB32I)),G===n.RGBA_INTEGER&&(vt===n.UNSIGNED_BYTE&&(Pt=n.RGBA8UI),vt===n.UNSIGNED_SHORT&&(Pt=n.RGBA16UI),vt===n.UNSIGNED_INT&&(Pt=n.RGBA32UI),vt===n.BYTE&&(Pt=n.RGBA8I),vt===n.SHORT&&(Pt=n.RGBA16I),vt===n.INT&&(Pt=n.RGBA32I)),G===n.RGB&&(vt===n.UNSIGNED_INT_5_9_9_9_REV&&(Pt=n.RGB9_E5),vt===n.UNSIGNED_INT_10F_11F_11F_REV&&(Pt=n.R11F_G11F_B10F)),G===n.RGBA){const Ue=te?x1:ss.getTransfer(Vt);vt===n.FLOAT&&(Pt=n.RGBA32F),vt===n.HALF_FLOAT&&(Pt=n.RGBA16F),vt===n.UNSIGNED_BYTE&&(Pt=Ue===Ls?n.SRGB8_ALPHA8:n.RGBA8),vt===n.UNSIGNED_SHORT_4_4_4_4&&(Pt=n.RGBA4),vt===n.UNSIGNED_SHORT_5_5_5_1&&(Pt=n.RGB5_A1)}return(Pt===n.R16F||Pt===n.R32F||Pt===n.RG16F||Pt===n.RG32F||Pt===n.RGBA16F||Pt===n.RGBA32F)&&t.get("EXT_color_buffer_float"),Pt}function A(nt,G){let vt;return nt?G===null||G===Nl||G===rg?vt=n.DEPTH24_STENCIL8:G===Ua?vt=n.DEPTH32F_STENCIL8:G===Qy&&(vt=n.DEPTH24_STENCIL8,Oe("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):G===null||G===Nl||G===rg?vt=n.DEPTH_COMPONENT24:G===Ua?vt=n.DEPTH_COMPONENT32F:G===Qy&&(vt=n.DEPTH_COMPONENT16),vt}function I(nt,G){return S(nt)===!0||nt.isFramebufferTexture&&nt.minFilter!==hi&&nt.minFilter!==Hs?Math.log2(Math.max(G.width,G.height))+1:nt.mipmaps!==void 0&&nt.mipmaps.length>0?nt.mipmaps.length:nt.isCompressedTexture&&Array.isArray(nt.image)?G.mipmaps.length:1}function D(nt){const G=nt.target;G.removeEventListener("dispose",D),z(G),G.isVideoTexture&&h.delete(G)}function F(nt){const G=nt.target;G.removeEventListener("dispose",F),O(G)}function z(nt){const G=s.get(nt);if(G.__webglInit===void 0)return;const vt=nt.source,Vt=p.get(vt);if(Vt){const te=Vt[G.__cacheKey];te.usedTimes--,te.usedTimes===0&&k(nt),Object.keys(Vt).length===0&&p.delete(vt)}s.remove(nt)}function k(nt){const G=s.get(nt);n.deleteTexture(G.__webglTexture);const vt=nt.source,Vt=p.get(vt);delete Vt[G.__cacheKey],a.memory.textures--}function O(nt){const G=s.get(nt);if(nt.depthTexture&&(nt.depthTexture.dispose(),s.remove(nt.depthTexture)),nt.isWebGLCubeRenderTarget)for(let Vt=0;Vt<6;Vt++){if(Array.isArray(G.__webglFramebuffer[Vt]))for(let te=0;te<G.__webglFramebuffer[Vt].length;te++)n.deleteFramebuffer(G.__webglFramebuffer[Vt][te]);else n.deleteFramebuffer(G.__webglFramebuffer[Vt]);G.__webglDepthbuffer&&n.deleteRenderbuffer(G.__webglDepthbuffer[Vt])}else{if(Array.isArray(G.__webglFramebuffer))for(let Vt=0;Vt<G.__webglFramebuffer.length;Vt++)n.deleteFramebuffer(G.__webglFramebuffer[Vt]);else n.deleteFramebuffer(G.__webglFramebuffer);if(G.__webglDepthbuffer&&n.deleteRenderbuffer(G.__webglDepthbuffer),G.__webglMultisampledFramebuffer&&n.deleteFramebuffer(G.__webglMultisampledFramebuffer),G.__webglColorRenderbuffer)for(let Vt=0;Vt<G.__webglColorRenderbuffer.length;Vt++)G.__webglColorRenderbuffer[Vt]&&n.deleteRenderbuffer(G.__webglColorRenderbuffer[Vt]);G.__webglDepthRenderbuffer&&n.deleteRenderbuffer(G.__webglDepthRenderbuffer)}const vt=nt.textures;for(let Vt=0,te=vt.length;Vt<te;Vt++){const Pt=s.get(vt[Vt]);Pt.__webglTexture&&(n.deleteTexture(Pt.__webglTexture),a.memory.textures--),s.remove(vt[Vt])}s.remove(nt)}let L=0;function H(){L=0}function q(){const nt=L;return nt>=i.maxTextures&&Oe("WebGLTextures: Trying to use "+nt+" texture units while this GPU supports only "+i.maxTextures),L+=1,nt}function K(nt){const G=[];return G.push(nt.wrapS),G.push(nt.wrapT),G.push(nt.wrapR||0),G.push(nt.magFilter),G.push(nt.minFilter),G.push(nt.anisotropy),G.push(nt.internalFormat),G.push(nt.format),G.push(nt.type),G.push(nt.generateMipmaps),G.push(nt.premultiplyAlpha),G.push(nt.flipY),G.push(nt.unpackAlignment),G.push(nt.colorSpace),G.join()}function Y(nt,G){const vt=s.get(nt);if(nt.isVideoTexture&&he(nt),nt.isRenderTargetTexture===!1&&nt.isExternalTexture!==!0&&nt.version>0&&vt.__version!==nt.version){const Vt=nt.image;if(Vt===null)Oe("WebGLRenderer: Texture marked for update but no image data found.");else if(Vt.complete===!1)Oe("WebGLRenderer: Texture marked for update but image is incomplete");else{ft(vt,nt,G);return}}else nt.isExternalTexture&&(vt.__webglTexture=nt.sourceTexture?nt.sourceTexture:null);e.bindTexture(n.TEXTURE_2D,vt.__webglTexture,n.TEXTURE0+G)}function P(nt,G){const vt=s.get(nt);if(nt.isRenderTargetTexture===!1&&nt.version>0&&vt.__version!==nt.version){ft(vt,nt,G);return}else nt.isExternalTexture&&(vt.__webglTexture=nt.sourceTexture?nt.sourceTexture:null);e.bindTexture(n.TEXTURE_2D_ARRAY,vt.__webglTexture,n.TEXTURE0+G)}function W(nt,G){const vt=s.get(nt);if(nt.isRenderTargetTexture===!1&&nt.version>0&&vt.__version!==nt.version){ft(vt,nt,G);return}e.bindTexture(n.TEXTURE_3D,vt.__webglTexture,n.TEXTURE0+G)}function j(nt,G){const vt=s.get(nt);if(nt.isCubeDepthTexture!==!0&&nt.version>0&&vt.__version!==nt.version){_t(vt,nt,G);return}e.bindTexture(n.TEXTURE_CUBE_MAP,vt.__webglTexture,n.TEXTURE0+G)}const st={[p1]:n.REPEAT,[Yo]:n.CLAMP_TO_EDGE,[m1]:n.MIRRORED_REPEAT},ot={[hi]:n.NEAREST,[PD]:n.NEAREST_MIPMAP_NEAREST,[zy]:n.NEAREST_MIPMAP_LINEAR,[Hs]:n.LINEAR,[Qb]:n.LINEAR_MIPMAP_NEAREST,[th]:n.LINEAR_MIPMAP_LINEAR},X={[jP]:n.NEVER,[JP]:n.ALWAYS,[KP]:n.LESS,[mC]:n.LEQUAL,[YP]:n.EQUAL,[gC]:n.GEQUAL,[ZP]:n.GREATER,[QP]:n.NOTEQUAL};function it(nt,G){if(G.type===Ua&&t.has("OES_texture_float_linear")===!1&&(G.magFilter===Hs||G.magFilter===Qb||G.magFilter===zy||G.magFilter===th||G.minFilter===Hs||G.minFilter===Qb||G.minFilter===zy||G.minFilter===th)&&Oe("WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),n.texParameteri(nt,n.TEXTURE_WRAP_S,st[G.wrapS]),n.texParameteri(nt,n.TEXTURE_WRAP_T,st[G.wrapT]),(nt===n.TEXTURE_3D||nt===n.TEXTURE_2D_ARRAY)&&n.texParameteri(nt,n.TEXTURE_WRAP_R,st[G.wrapR]),n.texParameteri(nt,n.TEXTURE_MAG_FILTER,ot[G.magFilter]),n.texParameteri(nt,n.TEXTURE_MIN_FILTER,ot[G.minFilter]),G.compareFunction&&(n.texParameteri(nt,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(nt,n.TEXTURE_COMPARE_FUNC,X[G.compareFunction])),t.has("EXT_texture_filter_anisotropic")===!0){if(G.magFilter===hi||G.minFilter!==zy&&G.minFilter!==th||G.type===Ua&&t.has("OES_texture_float_linear")===!1)return;if(G.anisotropy>1||s.get(G).__currentAnisotropy){const vt=t.get("EXT_texture_filter_anisotropic");n.texParameterf(nt,vt.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(G.anisotropy,i.getMaxAnisotropy())),s.get(G).__currentAnisotropy=G.anisotropy}}}function ct(nt,G){let vt=!1;nt.__webglInit===void 0&&(nt.__webglInit=!0,G.addEventListener("dispose",D));const Vt=G.source;let te=p.get(Vt);te===void 0&&(te={},p.set(Vt,te));const Pt=K(G);if(Pt!==nt.__cacheKey){te[Pt]===void 0&&(te[Pt]={texture:n.createTexture(),usedTimes:0},a.memory.textures++,vt=!0),te[Pt].usedTimes++;const Ue=te[nt.__cacheKey];Ue!==void 0&&(te[nt.__cacheKey].usedTimes--,Ue.usedTimes===0&&k(G)),nt.__cacheKey=Pt,nt.__webglTexture=te[Pt].texture}return vt}function yt(nt,G,vt){return Math.floor(Math.floor(nt/vt)/G)}function Rt(nt,G,vt,Vt){const Pt=nt.updateRanges;if(Pt.length===0)e.texSubImage2D(n.TEXTURE_2D,0,0,0,G.width,G.height,vt,Vt,G.data);else{Pt.sort((ae,de)=>ae.start-de.start);let Ue=0;for(let ae=1;ae<Pt.length;ae++){const de=Pt[Ue],Ne=Pt[ae],ut=de.start+de.count,kt=yt(Ne.start,G.width,4),Se=yt(de.start,G.width,4);Ne.start<=ut+1&&kt===Se&&yt(Ne.start+Ne.count-1,G.width,4)===kt?de.count=Math.max(de.count,Ne.start+Ne.count-de.start):(++Ue,Pt[Ue]=Ne)}Pt.length=Ue+1;const we=n.getParameter(n.UNPACK_ROW_LENGTH),ze=n.getParameter(n.UNPACK_SKIP_PIXELS),nn=n.getParameter(n.UNPACK_SKIP_ROWS);n.pixelStorei(n.UNPACK_ROW_LENGTH,G.width);for(let ae=0,de=Pt.length;ae<de;ae++){const Ne=Pt[ae],ut=Math.floor(Ne.start/4),kt=Math.ceil(Ne.count/4),Se=ut%G.width,dt=Math.floor(ut/G.width),ye=kt,fe=1;n.pixelStorei(n.UNPACK_SKIP_PIXELS,Se),n.pixelStorei(n.UNPACK_SKIP_ROWS,dt),e.texSubImage2D(n.TEXTURE_2D,0,Se,dt,ye,fe,vt,Vt,G.data)}nt.clearUpdateRanges(),n.pixelStorei(n.UNPACK_ROW_LENGTH,we),n.pixelStorei(n.UNPACK_SKIP_PIXELS,ze),n.pixelStorei(n.UNPACK_SKIP_ROWS,nn)}}function ft(nt,G,vt){let Vt=n.TEXTURE_2D;(G.isDataArrayTexture||G.isCompressedArrayTexture)&&(Vt=n.TEXTURE_2D_ARRAY),G.isData3DTexture&&(Vt=n.TEXTURE_3D);const te=ct(nt,G),Pt=G.source;e.bindTexture(Vt,nt.__webglTexture,n.TEXTURE0+vt);const Ue=s.get(Pt);if(Pt.version!==Ue.__version||te===!0){e.activeTexture(n.TEXTURE0+vt);const we=ss.getPrimaries(ss.workingColorSpace),ze=G.colorSpace===Yc?null:ss.getPrimaries(G.colorSpace),nn=G.colorSpace===Yc||we===ze?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,G.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,G.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,G.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,nn);let ae=_(G.image,!1,i.maxTextureSize);ae=Pe(G,ae);const de=r.convert(G.format,G.colorSpace),Ne=r.convert(G.type);let ut=C(G.internalFormat,de,Ne,G.colorSpace,G.isVideoTexture);it(Vt,G);let kt;const Se=G.mipmaps,dt=G.isVideoTexture!==!0,ye=Ue.__version===void 0||te===!0,fe=Pt.dataReady,Ce=I(G,ae);if(G.isDepthTexture)ut=A(G.format===vf,G.type),ye&&(dt?e.texStorage2D(n.TEXTURE_2D,1,ut,ae.width,ae.height):e.texImage2D(n.TEXTURE_2D,0,ut,ae.width,ae.height,0,de,Ne,null));else if(G.isDataTexture)if(Se.length>0){dt&&ye&&e.texStorage2D(n.TEXTURE_2D,Ce,ut,Se[0].width,Se[0].height);for(let ue=0,ie=Se.length;ue<ie;ue++)kt=Se[ue],dt?fe&&e.texSubImage2D(n.TEXTURE_2D,ue,0,0,kt.width,kt.height,de,Ne,kt.data):e.texImage2D(n.TEXTURE_2D,ue,ut,kt.width,kt.height,0,de,Ne,kt.data);G.generateMipmaps=!1}else dt?(ye&&e.texStorage2D(n.TEXTURE_2D,Ce,ut,ae.width,ae.height),fe&&Rt(G,ae,de,Ne)):e.texImage2D(n.TEXTURE_2D,0,ut,ae.width,ae.height,0,de,Ne,ae.data);else if(G.isCompressedTexture)if(G.isCompressedArrayTexture){dt&&ye&&e.texStorage3D(n.TEXTURE_2D_ARRAY,Ce,ut,Se[0].width,Se[0].height,ae.depth);for(let ue=0,ie=Se.length;ue<ie;ue++)if(kt=Se[ue],G.format!==Ba)if(de!==null)if(dt){if(fe)if(G.layerUpdates.size>0){const ve=lR(kt.width,kt.height,G.format,G.type);for(const Je of G.layerUpdates){const zn=kt.data.subarray(Je*ve/kt.data.BYTES_PER_ELEMENT,(Je+1)*ve/kt.data.BYTES_PER_ELEMENT);e.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,ue,0,0,Je,kt.width,kt.height,1,de,zn)}G.clearLayerUpdates()}else e.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,ue,0,0,0,kt.width,kt.height,ae.depth,de,kt.data)}else e.compressedTexImage3D(n.TEXTURE_2D_ARRAY,ue,ut,kt.width,kt.height,ae.depth,0,kt.data,0,0);else Oe("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else dt?fe&&e.texSubImage3D(n.TEXTURE_2D_ARRAY,ue,0,0,0,kt.width,kt.height,ae.depth,de,Ne,kt.data):e.texImage3D(n.TEXTURE_2D_ARRAY,ue,ut,kt.width,kt.height,ae.depth,0,de,Ne,kt.data)}else{dt&&ye&&e.texStorage2D(n.TEXTURE_2D,Ce,ut,Se[0].width,Se[0].height);for(let ue=0,ie=Se.length;ue<ie;ue++)kt=Se[ue],G.format!==Ba?de!==null?dt?fe&&e.compressedTexSubImage2D(n.TEXTURE_2D,ue,0,0,kt.width,kt.height,de,kt.data):e.compressedTexImage2D(n.TEXTURE_2D,ue,ut,kt.width,kt.height,0,kt.data):Oe("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):dt?fe&&e.texSubImage2D(n.TEXTURE_2D,ue,0,0,kt.width,kt.height,de,Ne,kt.data):e.texImage2D(n.TEXTURE_2D,ue,ut,kt.width,kt.height,0,de,Ne,kt.data)}else if(G.isDataArrayTexture)if(dt){if(ye&&e.texStorage3D(n.TEXTURE_2D_ARRAY,Ce,ut,ae.width,ae.height,ae.depth),fe)if(G.layerUpdates.size>0){const ue=lR(ae.width,ae.height,G.format,G.type);for(const ie of G.layerUpdates){const ve=ae.data.subarray(ie*ue/ae.data.BYTES_PER_ELEMENT,(ie+1)*ue/ae.data.BYTES_PER_ELEMENT);e.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,ie,ae.width,ae.height,1,de,Ne,ve)}G.clearLayerUpdates()}else e.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,ae.width,ae.height,ae.depth,de,Ne,ae.data)}else e.texImage3D(n.TEXTURE_2D_ARRAY,0,ut,ae.width,ae.height,ae.depth,0,de,Ne,ae.data);else if(G.isData3DTexture)dt?(ye&&e.texStorage3D(n.TEXTURE_3D,Ce,ut,ae.width,ae.height,ae.depth),fe&&e.texSubImage3D(n.TEXTURE_3D,0,0,0,0,ae.width,ae.height,ae.depth,de,Ne,ae.data)):e.texImage3D(n.TEXTURE_3D,0,ut,ae.width,ae.height,ae.depth,0,de,Ne,ae.data);else if(G.isFramebufferTexture){if(ye)if(dt)e.texStorage2D(n.TEXTURE_2D,Ce,ut,ae.width,ae.height);else{let ue=ae.width,ie=ae.height;for(let ve=0;ve<Ce;ve++)e.texImage2D(n.TEXTURE_2D,ve,ut,ue,ie,0,de,Ne,null),ue>>=1,ie>>=1}}else if(Se.length>0){if(dt&&ye){const ue=pe(Se[0]);e.texStorage2D(n.TEXTURE_2D,Ce,ut,ue.width,ue.height)}for(let ue=0,ie=Se.length;ue<ie;ue++)kt=Se[ue],dt?fe&&e.texSubImage2D(n.TEXTURE_2D,ue,0,0,de,Ne,kt):e.texImage2D(n.TEXTURE_2D,ue,ut,de,Ne,kt);G.generateMipmaps=!1}else if(dt){if(ye){const ue=pe(ae);e.texStorage2D(n.TEXTURE_2D,Ce,ut,ue.width,ue.height)}fe&&e.texSubImage2D(n.TEXTURE_2D,0,0,0,de,Ne,ae)}else e.texImage2D(n.TEXTURE_2D,0,ut,de,Ne,ae);S(G)&&b(Vt),Ue.__version=Pt.version,G.onUpdate&&G.onUpdate(G)}nt.__version=G.version}function _t(nt,G,vt){if(G.image.length!==6)return;const Vt=ct(nt,G),te=G.source;e.bindTexture(n.TEXTURE_CUBE_MAP,nt.__webglTexture,n.TEXTURE0+vt);const Pt=s.get(te);if(te.version!==Pt.__version||Vt===!0){e.activeTexture(n.TEXTURE0+vt);const Ue=ss.getPrimaries(ss.workingColorSpace),we=G.colorSpace===Yc?null:ss.getPrimaries(G.colorSpace),ze=G.colorSpace===Yc||Ue===we?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,G.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,G.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,G.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,ze);const nn=G.isCompressedTexture||G.image[0].isCompressedTexture,ae=G.image[0]&&G.image[0].isDataTexture,de=[];for(let ie=0;ie<6;ie++)!nn&&!ae?de[ie]=_(G.image[ie],!0,i.maxCubemapSize):de[ie]=ae?G.image[ie].image:G.image[ie],de[ie]=Pe(G,de[ie]);const Ne=de[0],ut=r.convert(G.format,G.colorSpace),kt=r.convert(G.type),Se=C(G.internalFormat,ut,kt,G.colorSpace),dt=G.isVideoTexture!==!0,ye=Pt.__version===void 0||Vt===!0,fe=te.dataReady;let Ce=I(G,Ne);it(n.TEXTURE_CUBE_MAP,G);let ue;if(nn){dt&&ye&&e.texStorage2D(n.TEXTURE_CUBE_MAP,Ce,Se,Ne.width,Ne.height);for(let ie=0;ie<6;ie++){ue=de[ie].mipmaps;for(let ve=0;ve<ue.length;ve++){const Je=ue[ve];G.format!==Ba?ut!==null?dt?fe&&e.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ie,ve,0,0,Je.width,Je.height,ut,Je.data):e.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ie,ve,Se,Je.width,Je.height,0,Je.data):Oe("WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):dt?fe&&e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ie,ve,0,0,Je.width,Je.height,ut,kt,Je.data):e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ie,ve,Se,Je.width,Je.height,0,ut,kt,Je.data)}}}else{if(ue=G.mipmaps,dt&&ye){ue.length>0&&Ce++;const ie=pe(de[0]);e.texStorage2D(n.TEXTURE_CUBE_MAP,Ce,Se,ie.width,ie.height)}for(let ie=0;ie<6;ie++)if(ae){dt?fe&&e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ie,0,0,0,de[ie].width,de[ie].height,ut,kt,de[ie].data):e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ie,0,Se,de[ie].width,de[ie].height,0,ut,kt,de[ie].data);for(let ve=0;ve<ue.length;ve++){const zn=ue[ve].image[ie].image;dt?fe&&e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ie,ve+1,0,0,zn.width,zn.height,ut,kt,zn.data):e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ie,ve+1,Se,zn.width,zn.height,0,ut,kt,zn.data)}}else{dt?fe&&e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ie,0,0,0,ut,kt,de[ie]):e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ie,0,Se,ut,kt,de[ie]);for(let ve=0;ve<ue.length;ve++){const Je=ue[ve];dt?fe&&e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ie,ve+1,0,0,ut,kt,Je.image[ie]):e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ie,ve+1,Se,ut,kt,Je.image[ie])}}}S(G)&&b(n.TEXTURE_CUBE_MAP),Pt.__version=te.version,G.onUpdate&&G.onUpdate(G)}nt.__version=G.version}function qt(nt,G,vt,Vt,te,Pt){const Ue=r.convert(vt.format,vt.colorSpace),we=r.convert(vt.type),ze=C(vt.internalFormat,Ue,we,vt.colorSpace),nn=s.get(G),ae=s.get(vt);if(ae.__renderTarget=G,!nn.__hasExternalTextures){const de=Math.max(1,G.width>>Pt),Ne=Math.max(1,G.height>>Pt);te===n.TEXTURE_3D||te===n.TEXTURE_2D_ARRAY?e.texImage3D(te,Pt,ze,de,Ne,G.depth,0,Ue,we,null):e.texImage2D(te,Pt,ze,de,Ne,0,Ue,we,null)}e.bindFramebuffer(n.FRAMEBUFFER,nt),Fe(G)?o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,Vt,te,ae.__webglTexture,0,rt(G)):(te===n.TEXTURE_2D||te>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&te<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,Vt,te,ae.__webglTexture,Pt),e.bindFramebuffer(n.FRAMEBUFFER,null)}function Qt(nt,G,vt){if(n.bindRenderbuffer(n.RENDERBUFFER,nt),G.depthBuffer){const Vt=G.depthTexture,te=Vt&&Vt.isDepthTexture?Vt.type:null,Pt=A(G.stencilBuffer,te),Ue=G.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT;Fe(G)?o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,rt(G),Pt,G.width,G.height):vt?n.renderbufferStorageMultisample(n.RENDERBUFFER,rt(G),Pt,G.width,G.height):n.renderbufferStorage(n.RENDERBUFFER,Pt,G.width,G.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,Ue,n.RENDERBUFFER,nt)}else{const Vt=G.textures;for(let te=0;te<Vt.length;te++){const Pt=Vt[te],Ue=r.convert(Pt.format,Pt.colorSpace),we=r.convert(Pt.type),ze=C(Pt.internalFormat,Ue,we,Pt.colorSpace);Fe(G)?o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,rt(G),ze,G.width,G.height):vt?n.renderbufferStorageMultisample(n.RENDERBUFFER,rt(G),ze,G.width,G.height):n.renderbufferStorage(n.RENDERBUFFER,ze,G.width,G.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function se(nt,G,vt){const Vt=G.isWebGLCubeRenderTarget===!0;if(e.bindFramebuffer(n.FRAMEBUFFER,nt),!(G.depthTexture&&G.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const te=s.get(G.depthTexture);if(te.__renderTarget=G,(!te.__webglTexture||G.depthTexture.image.width!==G.width||G.depthTexture.image.height!==G.height)&&(G.depthTexture.image.width=G.width,G.depthTexture.image.height=G.height,G.depthTexture.needsUpdate=!0),Vt){if(te.__webglInit===void 0&&(te.__webglInit=!0,G.depthTexture.addEventListener("dispose",D)),te.__webglTexture===void 0){te.__webglTexture=n.createTexture(),e.bindTexture(n.TEXTURE_CUBE_MAP,te.__webglTexture),it(n.TEXTURE_CUBE_MAP,G.depthTexture);const nn=r.convert(G.depthTexture.format),ae=r.convert(G.depthTexture.type);let de;G.depthTexture.format===mh?de=n.DEPTH_COMPONENT24:G.depthTexture.format===vf&&(de=n.DEPTH24_STENCIL8);for(let Ne=0;Ne<6;Ne++)n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Ne,0,de,G.width,G.height,0,nn,ae,null)}}else Y(G.depthTexture,0);const Pt=te.__webglTexture,Ue=rt(G),we=Vt?n.TEXTURE_CUBE_MAP_POSITIVE_X+vt:n.TEXTURE_2D,ze=G.depthTexture.format===vf?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT;if(G.depthTexture.format===mh)Fe(G)?o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,ze,we,Pt,0,Ue):n.framebufferTexture2D(n.FRAMEBUFFER,ze,we,Pt,0);else if(G.depthTexture.format===vf)Fe(G)?o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,ze,we,Pt,0,Ue):n.framebufferTexture2D(n.FRAMEBUFFER,ze,we,Pt,0);else throw new Error("Unknown depthTexture format")}function Ee(nt){const G=s.get(nt),vt=nt.isWebGLCubeRenderTarget===!0;if(G.__boundDepthTexture!==nt.depthTexture){const Vt=nt.depthTexture;if(G.__depthDisposeCallback&&G.__depthDisposeCallback(),Vt){const te=()=>{delete G.__boundDepthTexture,delete G.__depthDisposeCallback,Vt.removeEventListener("dispose",te)};Vt.addEventListener("dispose",te),G.__depthDisposeCallback=te}G.__boundDepthTexture=Vt}if(nt.depthTexture&&!G.__autoAllocateDepthBuffer)if(vt)for(let Vt=0;Vt<6;Vt++)se(G.__webglFramebuffer[Vt],nt,Vt);else{const Vt=nt.texture.mipmaps;Vt&&Vt.length>0?se(G.__webglFramebuffer[0],nt,0):se(G.__webglFramebuffer,nt,0)}else if(vt){G.__webglDepthbuffer=[];for(let Vt=0;Vt<6;Vt++)if(e.bindFramebuffer(n.FRAMEBUFFER,G.__webglFramebuffer[Vt]),G.__webglDepthbuffer[Vt]===void 0)G.__webglDepthbuffer[Vt]=n.createRenderbuffer(),Qt(G.__webglDepthbuffer[Vt],nt,!1);else{const te=nt.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Pt=G.__webglDepthbuffer[Vt];n.bindRenderbuffer(n.RENDERBUFFER,Pt),n.framebufferRenderbuffer(n.FRAMEBUFFER,te,n.RENDERBUFFER,Pt)}}else{const Vt=nt.texture.mipmaps;if(Vt&&Vt.length>0?e.bindFramebuffer(n.FRAMEBUFFER,G.__webglFramebuffer[0]):e.bindFramebuffer(n.FRAMEBUFFER,G.__webglFramebuffer),G.__webglDepthbuffer===void 0)G.__webglDepthbuffer=n.createRenderbuffer(),Qt(G.__webglDepthbuffer,nt,!1);else{const te=nt.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Pt=G.__webglDepthbuffer;n.bindRenderbuffer(n.RENDERBUFFER,Pt),n.framebufferRenderbuffer(n.FRAMEBUFFER,te,n.RENDERBUFFER,Pt)}}e.bindFramebuffer(n.FRAMEBUFFER,null)}function He(nt,G,vt){const Vt=s.get(nt);G!==void 0&&qt(Vt.__webglFramebuffer,nt,nt.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),vt!==void 0&&Ee(nt)}function Ae(nt){const G=nt.texture,vt=s.get(nt),Vt=s.get(G);nt.addEventListener("dispose",F);const te=nt.textures,Pt=nt.isWebGLCubeRenderTarget===!0,Ue=te.length>1;if(Ue||(Vt.__webglTexture===void 0&&(Vt.__webglTexture=n.createTexture()),Vt.__version=G.version,a.memory.textures++),Pt){vt.__webglFramebuffer=[];for(let we=0;we<6;we++)if(G.mipmaps&&G.mipmaps.length>0){vt.__webglFramebuffer[we]=[];for(let ze=0;ze<G.mipmaps.length;ze++)vt.__webglFramebuffer[we][ze]=n.createFramebuffer()}else vt.__webglFramebuffer[we]=n.createFramebuffer()}else{if(G.mipmaps&&G.mipmaps.length>0){vt.__webglFramebuffer=[];for(let we=0;we<G.mipmaps.length;we++)vt.__webglFramebuffer[we]=n.createFramebuffer()}else vt.__webglFramebuffer=n.createFramebuffer();if(Ue)for(let we=0,ze=te.length;we<ze;we++){const nn=s.get(te[we]);nn.__webglTexture===void 0&&(nn.__webglTexture=n.createTexture(),a.memory.textures++)}if(nt.samples>0&&Fe(nt)===!1){vt.__webglMultisampledFramebuffer=n.createFramebuffer(),vt.__webglColorRenderbuffer=[],e.bindFramebuffer(n.FRAMEBUFFER,vt.__webglMultisampledFramebuffer);for(let we=0;we<te.length;we++){const ze=te[we];vt.__webglColorRenderbuffer[we]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,vt.__webglColorRenderbuffer[we]);const nn=r.convert(ze.format,ze.colorSpace),ae=r.convert(ze.type),de=C(ze.internalFormat,nn,ae,ze.colorSpace,nt.isXRRenderTarget===!0),Ne=rt(nt);n.renderbufferStorageMultisample(n.RENDERBUFFER,Ne,de,nt.width,nt.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+we,n.RENDERBUFFER,vt.__webglColorRenderbuffer[we])}n.bindRenderbuffer(n.RENDERBUFFER,null),nt.depthBuffer&&(vt.__webglDepthRenderbuffer=n.createRenderbuffer(),Qt(vt.__webglDepthRenderbuffer,nt,!0)),e.bindFramebuffer(n.FRAMEBUFFER,null)}}if(Pt){e.bindTexture(n.TEXTURE_CUBE_MAP,Vt.__webglTexture),it(n.TEXTURE_CUBE_MAP,G);for(let we=0;we<6;we++)if(G.mipmaps&&G.mipmaps.length>0)for(let ze=0;ze<G.mipmaps.length;ze++)qt(vt.__webglFramebuffer[we][ze],nt,G,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+we,ze);else qt(vt.__webglFramebuffer[we],nt,G,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+we,0);S(G)&&b(n.TEXTURE_CUBE_MAP),e.unbindTexture()}else if(Ue){for(let we=0,ze=te.length;we<ze;we++){const nn=te[we],ae=s.get(nn);let de=n.TEXTURE_2D;(nt.isWebGL3DRenderTarget||nt.isWebGLArrayRenderTarget)&&(de=nt.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY),e.bindTexture(de,ae.__webglTexture),it(de,nn),qt(vt.__webglFramebuffer,nt,nn,n.COLOR_ATTACHMENT0+we,de,0),S(nn)&&b(de)}e.unbindTexture()}else{let we=n.TEXTURE_2D;if((nt.isWebGL3DRenderTarget||nt.isWebGLArrayRenderTarget)&&(we=nt.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY),e.bindTexture(we,Vt.__webglTexture),it(we,G),G.mipmaps&&G.mipmaps.length>0)for(let ze=0;ze<G.mipmaps.length;ze++)qt(vt.__webglFramebuffer[ze],nt,G,n.COLOR_ATTACHMENT0,we,ze);else qt(vt.__webglFramebuffer,nt,G,n.COLOR_ATTACHMENT0,we,0);S(G)&&b(we),e.unbindTexture()}nt.depthBuffer&&Ee(nt)}function Ht(nt){const G=nt.textures;for(let vt=0,Vt=G.length;vt<Vt;vt++){const te=G[vt];if(S(te)){const Pt=T(nt),Ue=s.get(te).__webglTexture;e.bindTexture(Pt,Ue),b(Pt),e.unbindTexture()}}}const Jt=[],Xt=[];function ce(nt){if(nt.samples>0){if(Fe(nt)===!1){const G=nt.textures,vt=nt.width,Vt=nt.height;let te=n.COLOR_BUFFER_BIT;const Pt=nt.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Ue=s.get(nt),we=G.length>1;if(we)for(let nn=0;nn<G.length;nn++)e.bindFramebuffer(n.FRAMEBUFFER,Ue.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+nn,n.RENDERBUFFER,null),e.bindFramebuffer(n.FRAMEBUFFER,Ue.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+nn,n.TEXTURE_2D,null,0);e.bindFramebuffer(n.READ_FRAMEBUFFER,Ue.__webglMultisampledFramebuffer);const ze=nt.texture.mipmaps;ze&&ze.length>0?e.bindFramebuffer(n.DRAW_FRAMEBUFFER,Ue.__webglFramebuffer[0]):e.bindFramebuffer(n.DRAW_FRAMEBUFFER,Ue.__webglFramebuffer);for(let nn=0;nn<G.length;nn++){if(nt.resolveDepthBuffer&&(nt.depthBuffer&&(te|=n.DEPTH_BUFFER_BIT),nt.stencilBuffer&&nt.resolveStencilBuffer&&(te|=n.STENCIL_BUFFER_BIT)),we){n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,Ue.__webglColorRenderbuffer[nn]);const ae=s.get(G[nn]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,ae,0)}n.blitFramebuffer(0,0,vt,Vt,0,0,vt,Vt,te,n.NEAREST),l===!0&&(Jt.length=0,Xt.length=0,Jt.push(n.COLOR_ATTACHMENT0+nn),nt.depthBuffer&&nt.resolveDepthBuffer===!1&&(Jt.push(Pt),Xt.push(Pt),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,Xt)),n.invalidateFramebuffer(n.READ_FRAMEBUFFER,Jt))}if(e.bindFramebuffer(n.READ_FRAMEBUFFER,null),e.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),we)for(let nn=0;nn<G.length;nn++){e.bindFramebuffer(n.FRAMEBUFFER,Ue.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+nn,n.RENDERBUFFER,Ue.__webglColorRenderbuffer[nn]);const ae=s.get(G[nn]).__webglTexture;e.bindFramebuffer(n.FRAMEBUFFER,Ue.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+nn,n.TEXTURE_2D,ae,0)}e.bindFramebuffer(n.DRAW_FRAMEBUFFER,Ue.__webglMultisampledFramebuffer)}else if(nt.depthBuffer&&nt.resolveDepthBuffer===!1&&l){const G=nt.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT;n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[G])}}}function rt(nt){return Math.min(i.maxSamples,nt.samples)}function Fe(nt){const G=s.get(nt);return nt.samples>0&&t.has("WEBGL_multisampled_render_to_texture")===!0&&G.__useRenderToTexture!==!1}function he(nt){const G=a.render.frame;h.get(nt)!==G&&(h.set(nt,G),nt.update())}function Pe(nt,G){const vt=nt.colorSpace,Vt=nt.format,te=nt.type;return nt.isCompressedTexture===!0||nt.isVideoTexture===!0||vt!==gh&&vt!==Yc&&(ss.getTransfer(vt)===Ls?(Vt!==Ba||te!==Gi)&&Oe("WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):on("WebGLTextures: Unsupported texture color space:",vt)),G}function pe(nt){return typeof HTMLImageElement<"u"&&nt instanceof HTMLImageElement?(c.width=nt.naturalWidth||nt.width,c.height=nt.naturalHeight||nt.height):typeof VideoFrame<"u"&&nt instanceof VideoFrame?(c.width=nt.displayWidth,c.height=nt.displayHeight):(c.width=nt.width,c.height=nt.height),c}this.allocateTextureUnit=q,this.resetTextureUnits=H,this.setTexture2D=Y,this.setTexture2DArray=P,this.setTexture3D=W,this.setTextureCube=j,this.rebindTextures=He,this.setupRenderTarget=Ae,this.updateRenderTargetMipmap=Ht,this.updateMultisampleRenderTarget=ce,this.setupDepthRenderbuffer=Ee,this.setupFrameBufferTexture=qt,this.useMultisampledRTT=Fe,this.isReversedDepthBuffer=function(){return e.buffers.depth.getReversed()}}function uV(n,t){function e(s,i=Yc){let r;const a=ss.getTransfer(i);if(s===Gi)return n.UNSIGNED_BYTE;if(s===cC)return n.UNSIGNED_SHORT_4_4_4_4;if(s===uC)return n.UNSIGNED_SHORT_5_5_5_1;if(s===HD)return n.UNSIGNED_INT_5_9_9_9_REV;if(s===WD)return n.UNSIGNED_INT_10F_11F_11F_REV;if(s===VD)return n.BYTE;if(s===GD)return n.SHORT;if(s===Qy)return n.UNSIGNED_SHORT;if(s===lC)return n.INT;if(s===Nl)return n.UNSIGNED_INT;if(s===Ua)return n.FLOAT;if(s===ru)return n.HALF_FLOAT;if(s===qD)return n.ALPHA;if(s===XD)return n.RGB;if(s===Ba)return n.RGBA;if(s===mh)return n.DEPTH_COMPONENT;if(s===vf)return n.DEPTH_STENCIL;if(s===hC)return n.RED;if(s===eS)return n.RED_INTEGER;if(s===ag)return n.RG;if(s===fC)return n.RG_INTEGER;if(s===dC)return n.RGBA_INTEGER;if(s===Jb||s===t1||s===e1||s===n1)if(a===Ls)if(r=t.get("WEBGL_compressed_texture_s3tc_srgb"),r!==null){if(s===Jb)return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===t1)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===e1)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===n1)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(r=t.get("WEBGL_compressed_texture_s3tc"),r!==null){if(s===Jb)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===t1)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===e1)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===n1)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===RE||s===DE||s===kE||s===OE)if(r=t.get("WEBGL_compressed_texture_pvrtc"),r!==null){if(s===RE)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===DE)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===kE)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===OE)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===$E||s===LE||s===FE||s===zE||s===UE||s===BE||s===PE)if(r=t.get("WEBGL_compressed_texture_etc"),r!==null){if(s===$E||s===LE)return a===Ls?r.COMPRESSED_SRGB8_ETC2:r.COMPRESSED_RGB8_ETC2;if(s===FE)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:r.COMPRESSED_RGBA8_ETC2_EAC;if(s===zE)return r.COMPRESSED_R11_EAC;if(s===UE)return r.COMPRESSED_SIGNED_R11_EAC;if(s===BE)return r.COMPRESSED_RG11_EAC;if(s===PE)return r.COMPRESSED_SIGNED_RG11_EAC}else return null;if(s===VE||s===GE||s===HE||s===WE||s===qE||s===XE||s===jE||s===KE||s===YE||s===ZE||s===QE||s===JE||s===t2||s===e2)if(r=t.get("WEBGL_compressed_texture_astc"),r!==null){if(s===VE)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:r.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===GE)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:r.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===HE)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:r.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===WE)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:r.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===qE)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:r.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===XE)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:r.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===jE)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:r.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===KE)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:r.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===YE)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:r.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===ZE)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:r.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===QE)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:r.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===JE)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:r.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===t2)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:r.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===e2)return a===Ls?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:r.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===n2||s===s2||s===i2)if(r=t.get("EXT_texture_compression_bptc"),r!==null){if(s===n2)return a===Ls?r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:r.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(s===s2)return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(s===i2)return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(s===r2||s===a2||s===o2||s===l2)if(r=t.get("EXT_texture_compression_rgtc"),r!==null){if(s===r2)return r.COMPRESSED_RED_RGTC1_EXT;if(s===a2)return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(s===o2)return r.COMPRESSED_RED_GREEN_RGTC2_EXT;if(s===l2)return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return s===rg?n.UNSIGNED_INT_24_8:n[s]!==void 0?n[s]:null}return{convert:e}}const Eet=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,Cet=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class Aet{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(t,e){if(this.texture===null){const s=new s3(t.texture);(t.depthNear!==e.depthNear||t.depthFar!==e.depthFar)&&(this.depthNear=t.depthNear,this.depthFar=t.depthFar),this.texture=s}}getMesh(t){if(this.texture!==null&&this.mesh===null){const e=t.cameras[0].viewport,s=new ar({vertexShader:Eet,fragmentShader:Cet,uniforms:{depthColor:{value:this.texture},depthWidth:{value:e.z},depthHeight:{value:e.w}}});this.mesh=new rr(new Ex(20,20),s)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class Net extends Rl{constructor(t,e){super();const s=this;let i=null,r=1,a=null,o="local-floor",l=1,c=null,h=null,f=null,p=null,g=null,v=null;const _=typeof XRWebGLBinding<"u",S=new Aet,b={},T=e.getContextAttributes();let C=null,A=null;const I=[],D=[],F=new Yt;let z=null;const k=new Vi;k.viewport=new Gs;const O=new Vi;O.viewport=new Gs;const L=[k,O],H=new J4;let q=null,K=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(ft){let _t=I[ft];return _t===void 0&&(_t=new rE,I[ft]=_t),_t.getTargetRaySpace()},this.getControllerGrip=function(ft){let _t=I[ft];return _t===void 0&&(_t=new rE,I[ft]=_t),_t.getGripSpace()},this.getHand=function(ft){let _t=I[ft];return _t===void 0&&(_t=new rE,I[ft]=_t),_t.getHandSpace()};function Y(ft){const _t=D.indexOf(ft.inputSource);if(_t===-1)return;const qt=I[_t];qt!==void 0&&(qt.update(ft.inputSource,ft.frame,c||a),qt.dispatchEvent({type:ft.type,data:ft.inputSource}))}function P(){i.removeEventListener("select",Y),i.removeEventListener("selectstart",Y),i.removeEventListener("selectend",Y),i.removeEventListener("squeeze",Y),i.removeEventListener("squeezestart",Y),i.removeEventListener("squeezeend",Y),i.removeEventListener("end",P),i.removeEventListener("inputsourceschange",W);for(let ft=0;ft<I.length;ft++){const _t=D[ft];_t!==null&&(D[ft]=null,I[ft].disconnect(_t))}q=null,K=null,S.reset();for(const ft in b)delete b[ft];t.setRenderTarget(C),g=null,p=null,f=null,i=null,A=null,Rt.stop(),s.isPresenting=!1,t.setPixelRatio(z),t.setSize(F.width,F.height,!1),s.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(ft){r=ft,s.isPresenting===!0&&Oe("WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(ft){o=ft,s.isPresenting===!0&&Oe("WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||a},this.setReferenceSpace=function(ft){c=ft},this.getBaseLayer=function(){return p!==null?p:g},this.getBinding=function(){return f===null&&_&&(f=new XRWebGLBinding(i,e)),f},this.getFrame=function(){return v},this.getSession=function(){return i},this.setSession=async function(ft){if(i=ft,i!==null){if(C=t.getRenderTarget(),i.addEventListener("select",Y),i.addEventListener("selectstart",Y),i.addEventListener("selectend",Y),i.addEventListener("squeeze",Y),i.addEventListener("squeezestart",Y),i.addEventListener("squeezeend",Y),i.addEventListener("end",P),i.addEventListener("inputsourceschange",W),T.xrCompatible!==!0&&await e.makeXRCompatible(),z=t.getPixelRatio(),t.getSize(F),_&&"createProjectionLayer"in XRWebGLBinding.prototype){let qt=null,Qt=null,se=null;T.depth&&(se=T.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,qt=T.stencil?vf:mh,Qt=T.stencil?rg:Nl);const Ee={colorFormat:e.RGBA8,depthFormat:se,scaleFactor:r};f=this.getBinding(),p=f.createProjectionLayer(Ee),i.updateRenderState({layers:[p]}),t.setPixelRatio(1),t.setSize(p.textureWidth,p.textureHeight,!1),A=new ki(p.textureWidth,p.textureHeight,{format:Ba,type:Gi,depthTexture:new lg(p.textureWidth,p.textureHeight,Qt,void 0,void 0,void 0,void 0,void 0,void 0,qt),stencilBuffer:T.stencil,colorSpace:t.outputColorSpace,samples:T.antialias?4:0,resolveDepthBuffer:p.ignoreDepthValues===!1,resolveStencilBuffer:p.ignoreDepthValues===!1})}else{const qt={antialias:T.antialias,alpha:!0,depth:T.depth,stencil:T.stencil,framebufferScaleFactor:r};g=new XRWebGLLayer(i,e,qt),i.updateRenderState({baseLayer:g}),t.setPixelRatio(1),t.setSize(g.framebufferWidth,g.framebufferHeight,!1),A=new ki(g.framebufferWidth,g.framebufferHeight,{format:Ba,type:Gi,colorSpace:t.outputColorSpace,stencilBuffer:T.stencil,resolveDepthBuffer:g.ignoreDepthValues===!1,resolveStencilBuffer:g.ignoreDepthValues===!1})}A.isXRRenderTarget=!0,this.setFoveation(l),c=null,a=await i.requestReferenceSpace(o),Rt.setContext(i),Rt.start(),s.isPresenting=!0,s.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode},this.getDepthTexture=function(){return S.getDepthTexture()};function W(ft){for(let _t=0;_t<ft.removed.length;_t++){const qt=ft.removed[_t],Qt=D.indexOf(qt);Qt>=0&&(D[Qt]=null,I[Qt].disconnect(qt))}for(let _t=0;_t<ft.added.length;_t++){const qt=ft.added[_t];let Qt=D.indexOf(qt);if(Qt===-1){for(let Ee=0;Ee<I.length;Ee++)if(Ee>=D.length){D.push(qt),Qt=Ee;break}else if(D[Ee]===null){D[Ee]=qt,Qt=Ee;break}if(Qt===-1)break}const se=I[Qt];se&&se.connect(qt)}}const j=new at,st=new at;function ot(ft,_t,qt){j.setFromMatrixPosition(_t.matrixWorld),st.setFromMatrixPosition(qt.matrixWorld);const Qt=j.distanceTo(st),se=_t.projectionMatrix.elements,Ee=qt.projectionMatrix.elements,He=se[14]/(se[10]-1),Ae=se[14]/(se[10]+1),Ht=(se[9]+1)/se[5],Jt=(se[9]-1)/se[5],Xt=(se[8]-1)/se[0],ce=(Ee[8]+1)/Ee[0],rt=He*Xt,Fe=He*ce,he=Qt/(-Xt+ce),Pe=he*-Xt;if(_t.matrixWorld.decompose(ft.position,ft.quaternion,ft.scale),ft.translateX(Pe),ft.translateZ(he),ft.matrixWorld.compose(ft.position,ft.quaternion,ft.scale),ft.matrixWorldInverse.copy(ft.matrixWorld).invert(),se[10]===-1)ft.projectionMatrix.copy(_t.projectionMatrix),ft.projectionMatrixInverse.copy(_t.projectionMatrixInverse);else{const pe=He+he,nt=Ae+he,G=rt-Pe,vt=Fe+(Qt-Pe),Vt=Ht*Ae/nt*pe,te=Jt*Ae/nt*pe;ft.projectionMatrix.makePerspective(G,vt,Vt,te,pe,nt),ft.projectionMatrixInverse.copy(ft.projectionMatrix).invert()}}function X(ft,_t){_t===null?ft.matrixWorld.copy(ft.matrix):ft.matrixWorld.multiplyMatrices(_t.matrixWorld,ft.matrix),ft.matrixWorldInverse.copy(ft.matrixWorld).invert()}this.updateCamera=function(ft){if(i===null)return;let _t=ft.near,qt=ft.far;S.texture!==null&&(S.depthNear>0&&(_t=S.depthNear),S.depthFar>0&&(qt=S.depthFar)),H.near=O.near=k.near=_t,H.far=O.far=k.far=qt,(q!==H.near||K!==H.far)&&(i.updateRenderState({depthNear:H.near,depthFar:H.far}),q=H.near,K=H.far),H.layers.mask=ft.layers.mask|6,k.layers.mask=H.layers.mask&3,O.layers.mask=H.layers.mask&5;const Qt=ft.parent,se=H.cameras;X(H,Qt);for(let Ee=0;Ee<se.length;Ee++)X(se[Ee],Qt);se.length===2?ot(H,k,O):H.projectionMatrix.copy(k.projectionMatrix),it(ft,H,Qt)};function it(ft,_t,qt){qt===null?ft.matrix.copy(_t.matrixWorld):(ft.matrix.copy(qt.matrixWorld),ft.matrix.invert(),ft.matrix.multiply(_t.matrixWorld)),ft.matrix.decompose(ft.position,ft.quaternion,ft.scale),ft.updateMatrixWorld(!0),ft.projectionMatrix.copy(_t.projectionMatrix),ft.projectionMatrixInverse.copy(_t.projectionMatrixInverse),ft.isPerspectiveCamera&&(ft.fov=ex*2*Math.atan(1/ft.projectionMatrix.elements[5]),ft.zoom=1)}this.getCamera=function(){return H},this.getFoveation=function(){if(!(p===null&&g===null))return l},this.setFoveation=function(ft){l=ft,p!==null&&(p.fixedFoveation=ft),g!==null&&g.fixedFoveation!==void 0&&(g.fixedFoveation=ft)},this.hasDepthSensing=function(){return S.texture!==null},this.getDepthSensingMesh=function(){return S.getMesh(H)},this.getCameraTexture=function(ft){return b[ft]};let ct=null;function yt(ft,_t){if(h=_t.getViewerPose(c||a),v=_t,h!==null){const qt=h.views;g!==null&&(t.setRenderTargetFramebuffer(A,g.framebuffer),t.setRenderTarget(A));let Qt=!1;qt.length!==H.cameras.length&&(H.cameras.length=0,Qt=!0);for(let Ae=0;Ae<qt.length;Ae++){const Ht=qt[Ae];let Jt=null;if(g!==null)Jt=g.getViewport(Ht);else{const ce=f.getViewSubImage(p,Ht);Jt=ce.viewport,Ae===0&&(t.setRenderTargetTextures(A,ce.colorTexture,ce.depthStencilTexture),t.setRenderTarget(A))}let Xt=L[Ae];Xt===void 0&&(Xt=new Vi,Xt.layers.enable(Ae),Xt.viewport=new Gs,L[Ae]=Xt),Xt.matrix.fromArray(Ht.transform.matrix),Xt.matrix.decompose(Xt.position,Xt.quaternion,Xt.scale),Xt.projectionMatrix.fromArray(Ht.projectionMatrix),Xt.projectionMatrixInverse.copy(Xt.projectionMatrix).invert(),Xt.viewport.set(Jt.x,Jt.y,Jt.width,Jt.height),Ae===0&&(H.matrix.copy(Xt.matrix),H.matrix.decompose(H.position,H.quaternion,H.scale)),Qt===!0&&H.cameras.push(Xt)}const se=i.enabledFeatures;if(se&&se.includes("depth-sensing")&&i.depthUsage=="gpu-optimized"&&_){f=s.getBinding();const Ae=f.getDepthInformation(qt[0]);Ae&&Ae.isValid&&Ae.texture&&S.init(Ae,i.renderState)}if(se&&se.includes("camera-access")&&_){t.state.unbindTexture(),f=s.getBinding();for(let Ae=0;Ae<qt.length;Ae++){const Ht=qt[Ae].camera;if(Ht){let Jt=b[Ht];Jt||(Jt=new s3,b[Ht]=Jt);const Xt=f.getCameraImage(Ht);Jt.sourceTexture=Xt}}}}for(let qt=0;qt<I.length;qt++){const Qt=D[qt],se=I[qt];Qt!==null&&se!==void 0&&se.update(Qt,_t,c||a)}ct&&ct(ft,_t),_t.detectedPlanes&&s.dispatchEvent({type:"planesdetected",data:_t}),v=null}const Rt=new rV;Rt.setAnimationLoop(yt),this.setAnimationLoop=function(ft){ct=ft},this.dispose=function(){}}}const Nm=new Ml,Met=new Tn;function Iet(n,t){function e(S,b){S.matrixAutoUpdate===!0&&S.updateMatrix(),b.value.copy(S.matrix)}function s(S,b){b.color.getRGB(S.fogColor.value,a4(n)),b.isFog?(S.fogNear.value=b.near,S.fogFar.value=b.far):b.isFogExp2&&(S.fogDensity.value=b.density)}function i(S,b,T,C,A){b.isMeshBasicMaterial||b.isMeshLambertMaterial?r(S,b):b.isMeshToonMaterial?(r(S,b),f(S,b)):b.isMeshPhongMaterial?(r(S,b),h(S,b)):b.isMeshStandardMaterial?(r(S,b),p(S,b),b.isMeshPhysicalMaterial&&g(S,b,A)):b.isMeshMatcapMaterial?(r(S,b),v(S,b)):b.isMeshDepthMaterial?r(S,b):b.isMeshDistanceMaterial?(r(S,b),_(S,b)):b.isMeshNormalMaterial?r(S,b):b.isLineBasicMaterial?(a(S,b),b.isLineDashedMaterial&&o(S,b)):b.isPointsMaterial?l(S,b,T,C):b.isSpriteMaterial?c(S,b):b.isShadowMaterial?(S.color.value.copy(b.color),S.opacity.value=b.opacity):b.isShaderMaterial&&(b.uniformsNeedUpdate=!1)}function r(S,b){S.opacity.value=b.opacity,b.color&&S.diffuse.value.copy(b.color),b.emissive&&S.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity),b.map&&(S.map.value=b.map,e(b.map,S.mapTransform)),b.alphaMap&&(S.alphaMap.value=b.alphaMap,e(b.alphaMap,S.alphaMapTransform)),b.bumpMap&&(S.bumpMap.value=b.bumpMap,e(b.bumpMap,S.bumpMapTransform),S.bumpScale.value=b.bumpScale,b.side===kr&&(S.bumpScale.value*=-1)),b.normalMap&&(S.normalMap.value=b.normalMap,e(b.normalMap,S.normalMapTransform),S.normalScale.value.copy(b.normalScale),b.side===kr&&S.normalScale.value.negate()),b.displacementMap&&(S.displacementMap.value=b.displacementMap,e(b.displacementMap,S.displacementMapTransform),S.displacementScale.value=b.displacementScale,S.displacementBias.value=b.displacementBias),b.emissiveMap&&(S.emissiveMap.value=b.emissiveMap,e(b.emissiveMap,S.emissiveMapTransform)),b.specularMap&&(S.specularMap.value=b.specularMap,e(b.specularMap,S.specularMapTransform)),b.alphaTest>0&&(S.alphaTest.value=b.alphaTest);const T=t.get(b),C=T.envMap,A=T.envMapRotation;C&&(S.envMap.value=C,Nm.copy(A),Nm.x*=-1,Nm.y*=-1,Nm.z*=-1,C.isCubeTexture&&C.isRenderTargetTexture===!1&&(Nm.y*=-1,Nm.z*=-1),S.envMapRotation.value.setFromMatrix4(Met.makeRotationFromEuler(Nm)),S.flipEnvMap.value=C.isCubeTexture&&C.isRenderTargetTexture===!1?-1:1,S.reflectivity.value=b.reflectivity,S.ior.value=b.ior,S.refractionRatio.value=b.refractionRatio),b.lightMap&&(S.lightMap.value=b.lightMap,S.lightMapIntensity.value=b.lightMapIntensity,e(b.lightMap,S.lightMapTransform)),b.aoMap&&(S.aoMap.value=b.aoMap,S.aoMapIntensity.value=b.aoMapIntensity,e(b.aoMap,S.aoMapTransform))}function a(S,b){S.diffuse.value.copy(b.color),S.opacity.value=b.opacity,b.map&&(S.map.value=b.map,e(b.map,S.mapTransform))}function o(S,b){S.dashSize.value=b.dashSize,S.totalSize.value=b.dashSize+b.gapSize,S.scale.value=b.scale}function l(S,b,T,C){S.diffuse.value.copy(b.color),S.opacity.value=b.opacity,S.size.value=b.size*T,S.scale.value=C*.5,b.map&&(S.map.value=b.map,e(b.map,S.uvTransform)),b.alphaMap&&(S.alphaMap.value=b.alphaMap,e(b.alphaMap,S.alphaMapTransform)),b.alphaTest>0&&(S.alphaTest.value=b.alphaTest)}function c(S,b){S.diffuse.value.copy(b.color),S.opacity.value=b.opacity,S.rotation.value=b.rotation,b.map&&(S.map.value=b.map,e(b.map,S.mapTransform)),b.alphaMap&&(S.alphaMap.value=b.alphaMap,e(b.alphaMap,S.alphaMapTransform)),b.alphaTest>0&&(S.alphaTest.value=b.alphaTest)}function h(S,b){S.specular.value.copy(b.specular),S.shininess.value=Math.max(b.shininess,1e-4)}function f(S,b){b.gradientMap&&(S.gradientMap.value=b.gradientMap)}function p(S,b){S.metalness.value=b.metalness,b.metalnessMap&&(S.metalnessMap.value=b.metalnessMap,e(b.metalnessMap,S.metalnessMapTransform)),S.roughness.value=b.roughness,b.roughnessMap&&(S.roughnessMap.value=b.roughnessMap,e(b.roughnessMap,S.roughnessMapTransform)),b.envMap&&(S.envMapIntensity.value=b.envMapIntensity)}function g(S,b,T){S.ior.value=b.ior,b.sheen>0&&(S.sheenColor.value.copy(b.sheenColor).multiplyScalar(b.sheen),S.sheenRoughness.value=b.sheenRoughness,b.sheenColorMap&&(S.sheenColorMap.value=b.sheenColorMap,e(b.sheenColorMap,S.sheenColorMapTransform)),b.sheenRoughnessMap&&(S.sheenRoughnessMap.value=b.sheenRoughnessMap,e(b.sheenRoughnessMap,S.sheenRoughnessMapTransform))),b.clearcoat>0&&(S.clearcoat.value=b.clearcoat,S.clearcoatRoughness.value=b.clearcoatRoughness,b.clearcoatMap&&(S.clearcoatMap.value=b.clearcoatMap,e(b.clearcoatMap,S.clearcoatMapTransform)),b.clearcoatRoughnessMap&&(S.clearcoatRoughnessMap.value=b.clearcoatRoughnessMap,e(b.clearcoatRoughnessMap,S.clearcoatRoughnessMapTransform)),b.clearcoatNormalMap&&(S.clearcoatNormalMap.value=b.clearcoatNormalMap,e(b.clearcoatNormalMap,S.clearcoatNormalMapTransform),S.clearcoatNormalScale.value.copy(b.clearcoatNormalScale),b.side===kr&&S.clearcoatNormalScale.value.negate())),b.dispersion>0&&(S.dispersion.value=b.dispersion),b.iridescence>0&&(S.iridescence.value=b.iridescence,S.iridescenceIOR.value=b.iridescenceIOR,S.iridescenceThicknessMinimum.value=b.iridescenceThicknessRange[0],S.iridescenceThicknessMaximum.value=b.iridescenceThicknessRange[1],b.iridescenceMap&&(S.iridescenceMap.value=b.iridescenceMap,e(b.iridescenceMap,S.iridescenceMapTransform)),b.iridescenceThicknessMap&&(S.iridescenceThicknessMap.value=b.iridescenceThicknessMap,e(b.iridescenceThicknessMap,S.iridescenceThicknessMapTransform))),b.transmission>0&&(S.transmission.value=b.transmission,S.transmissionSamplerMap.value=T.texture,S.transmissionSamplerSize.value.set(T.width,T.height),b.transmissionMap&&(S.transmissionMap.value=b.transmissionMap,e(b.transmissionMap,S.transmissionMapTransform)),S.thickness.value=b.thickness,b.thicknessMap&&(S.thicknessMap.value=b.thicknessMap,e(b.thicknessMap,S.thicknessMapTransform)),S.attenuationDistance.value=b.attenuationDistance,S.attenuationColor.value.copy(b.attenuationColor)),b.anisotropy>0&&(S.anisotropyVector.value.set(b.anisotropy*Math.cos(b.anisotropyRotation),b.anisotropy*Math.sin(b.anisotropyRotation)),b.anisotropyMap&&(S.anisotropyMap.value=b.anisotropyMap,e(b.anisotropyMap,S.anisotropyMapTransform))),S.specularIntensity.value=b.specularIntensity,S.specularColor.value.copy(b.specularColor),b.specularColorMap&&(S.specularColorMap.value=b.specularColorMap,e(b.specularColorMap,S.specularColorMapTransform)),b.specularIntensityMap&&(S.specularIntensityMap.value=b.specularIntensityMap,e(b.specularIntensityMap,S.specularIntensityMapTransform))}function v(S,b){b.matcap&&(S.matcap.value=b.matcap)}function _(S,b){const T=t.get(b).light;S.referencePosition.value.setFromMatrixPosition(T.matrixWorld),S.nearDistance.value=T.shadow.camera.near,S.farDistance.value=T.shadow.camera.far}return{refreshFogUniforms:s,refreshMaterialUniforms:i}}function Ret(n,t,e,s){let i={},r={},a=[];const o=n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);function l(T,C){const A=C.program;s.uniformBlockBinding(T,A)}function c(T,C){let A=i[T.id];A===void 0&&(v(T),A=h(T),i[T.id]=A,T.addEventListener("dispose",S));const I=C.program;s.updateUBOMapping(T,I);const D=t.render.frame;r[T.id]!==D&&(p(T),r[T.id]=D)}function h(T){const C=f();T.__bindingPointIndex=C;const A=n.createBuffer(),I=T.__size,D=T.usage;return n.bindBuffer(n.UNIFORM_BUFFER,A),n.bufferData(n.UNIFORM_BUFFER,I,D),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,C,A),A}function f(){for(let T=0;T<o;T++)if(a.indexOf(T)===-1)return a.push(T),T;return on("WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function p(T){const C=i[T.id],A=T.uniforms,I=T.__cache;n.bindBuffer(n.UNIFORM_BUFFER,C);for(let D=0,F=A.length;D<F;D++){const z=Array.isArray(A[D])?A[D]:[A[D]];for(let k=0,O=z.length;k<O;k++){const L=z[k];if(g(L,D,k,I)===!0){const H=L.__offset,q=Array.isArray(L.value)?L.value:[L.value];let K=0;for(let Y=0;Y<q.length;Y++){const P=q[Y],W=_(P);typeof P=="number"||typeof P=="boolean"?(L.__data[0]=P,n.bufferSubData(n.UNIFORM_BUFFER,H+K,L.__data)):P.isMatrix3?(L.__data[0]=P.elements[0],L.__data[1]=P.elements[1],L.__data[2]=P.elements[2],L.__data[3]=0,L.__data[4]=P.elements[3],L.__data[5]=P.elements[4],L.__data[6]=P.elements[5],L.__data[7]=0,L.__data[8]=P.elements[6],L.__data[9]=P.elements[7],L.__data[10]=P.elements[8],L.__data[11]=0):(P.toArray(L.__data,K),K+=W.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,H,L.__data)}}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function g(T,C,A,I){const D=T.value,F=C+"_"+A;if(I[F]===void 0)return typeof D=="number"||typeof D=="boolean"?I[F]=D:I[F]=D.clone(),!0;{const z=I[F];if(typeof D=="number"||typeof D=="boolean"){if(z!==D)return I[F]=D,!0}else if(z.equals(D)===!1)return z.copy(D),!0}return!1}function v(T){const C=T.uniforms;let A=0;const I=16;for(let F=0,z=C.length;F<z;F++){const k=Array.isArray(C[F])?C[F]:[C[F]];for(let O=0,L=k.length;O<L;O++){const H=k[O],q=Array.isArray(H.value)?H.value:[H.value];for(let K=0,Y=q.length;K<Y;K++){const P=q[K],W=_(P),j=A%I,st=j%W.boundary,ot=j+st;A+=st,ot!==0&&I-ot<W.storage&&(A+=I-ot),H.__data=new Float32Array(W.storage/Float32Array.BYTES_PER_ELEMENT),H.__offset=A,A+=W.storage}}}const D=A%I;return D>0&&(A+=I-D),T.__size=A,T.__cache={},this}function _(T){const C={boundary:0,storage:0};return typeof T=="number"||typeof T=="boolean"?(C.boundary=4,C.storage=4):T.isVector2?(C.boundary=8,C.storage=8):T.isVector3||T.isColor?(C.boundary=16,C.storage=12):T.isVector4?(C.boundary=16,C.storage=16):T.isMatrix3?(C.boundary=48,C.storage=48):T.isMatrix4?(C.boundary=64,C.storage=64):T.isTexture?Oe("WebGLRenderer: Texture samplers can not be part of an uniforms group."):Oe("WebGLRenderer: Unsupported uniform value type.",T),C}function S(T){const C=T.target;C.removeEventListener("dispose",S);const A=a.indexOf(C.__bindingPointIndex);a.splice(A,1),n.deleteBuffer(i[C.id]),delete i[C.id],delete r[C.id]}function b(){for(const T in i)n.deleteBuffer(i[T]);a=[],i={},r={}}return{bind:l,update:c,dispose:b}}const Det=new Uint16Array([12469,15057,12620,14925,13266,14620,13807,14376,14323,13990,14545,13625,14713,13328,14840,12882,14931,12528,14996,12233,15039,11829,15066,11525,15080,11295,15085,10976,15082,10705,15073,10495,13880,14564,13898,14542,13977,14430,14158,14124,14393,13732,14556,13410,14702,12996,14814,12596,14891,12291,14937,11834,14957,11489,14958,11194,14943,10803,14921,10506,14893,10278,14858,9960,14484,14039,14487,14025,14499,13941,14524,13740,14574,13468,14654,13106,14743,12678,14818,12344,14867,11893,14889,11509,14893,11180,14881,10751,14852,10428,14812,10128,14765,9754,14712,9466,14764,13480,14764,13475,14766,13440,14766,13347,14769,13070,14786,12713,14816,12387,14844,11957,14860,11549,14868,11215,14855,10751,14825,10403,14782,10044,14729,9651,14666,9352,14599,9029,14967,12835,14966,12831,14963,12804,14954,12723,14936,12564,14917,12347,14900,11958,14886,11569,14878,11247,14859,10765,14828,10401,14784,10011,14727,9600,14660,9289,14586,8893,14508,8533,15111,12234,15110,12234,15104,12216,15092,12156,15067,12010,15028,11776,14981,11500,14942,11205,14902,10752,14861,10393,14812,9991,14752,9570,14682,9252,14603,8808,14519,8445,14431,8145,15209,11449,15208,11451,15202,11451,15190,11438,15163,11384,15117,11274,15055,10979,14994,10648,14932,10343,14871,9936,14803,9532,14729,9218,14645,8742,14556,8381,14461,8020,14365,7603,15273,10603,15272,10607,15267,10619,15256,10631,15231,10614,15182,10535,15118,10389,15042,10167,14963,9787,14883,9447,14800,9115,14710,8665,14615,8318,14514,7911,14411,7507,14279,7198,15314,9675,15313,9683,15309,9712,15298,9759,15277,9797,15229,9773,15166,9668,15084,9487,14995,9274,14898,8910,14800,8539,14697,8234,14590,7790,14479,7409,14367,7067,14178,6621,15337,8619,15337,8631,15333,8677,15325,8769,15305,8871,15264,8940,15202,8909,15119,8775,15022,8565,14916,8328,14804,8009,14688,7614,14569,7287,14448,6888,14321,6483,14088,6171,15350,7402,15350,7419,15347,7480,15340,7613,15322,7804,15287,7973,15229,8057,15148,8012,15046,7846,14933,7611,14810,7357,14682,7069,14552,6656,14421,6316,14251,5948,14007,5528,15356,5942,15356,5977,15353,6119,15348,6294,15332,6551,15302,6824,15249,7044,15171,7122,15070,7050,14949,6861,14818,6611,14679,6349,14538,6067,14398,5651,14189,5311,13935,4958,15359,4123,15359,4153,15356,4296,15353,4646,15338,5160,15311,5508,15263,5829,15188,6042,15088,6094,14966,6001,14826,5796,14678,5543,14527,5287,14377,4985,14133,4586,13869,4257,15360,1563,15360,1642,15358,2076,15354,2636,15341,3350,15317,4019,15273,4429,15203,4732,15105,4911,14981,4932,14836,4818,14679,4621,14517,4386,14359,4156,14083,3795,13808,3437,15360,122,15360,137,15358,285,15355,636,15344,1274,15322,2177,15281,2765,15215,3223,15120,3451,14995,3569,14846,3567,14681,3466,14511,3305,14344,3121,14037,2800,13753,2467,15360,0,15360,1,15359,21,15355,89,15346,253,15325,479,15287,796,15225,1148,15133,1492,15008,1749,14856,1882,14685,1886,14506,1783,14324,1608,13996,1398,13702,1183]);let ju=null;function ket(){return ju===null&&(ju=new Jc(Det,16,16,ag,ru),ju.name="DFG_LUT",ju.minFilter=Hs,ju.magFilter=Hs,ju.wrapS=Yo,ju.wrapT=Yo,ju.generateMipmaps=!1,ju.needsUpdate=!0),ju}class hV{constructor(t={}){const{canvas:e=n4(),context:s=null,depth:i=!0,stencil:r=!1,alpha:a=!1,antialias:o=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:h="default",failIfMajorPerformanceCaveat:f=!1,reversedDepthBuffer:p=!1,outputBufferType:g=Gi}=t;this.isWebGLRenderer=!0;let v;if(s!==null){if(typeof WebGLRenderingContext<"u"&&s instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");v=s.getContextAttributes().alpha}else v=a;const _=g,S=new Set([dC,fC,eS]),b=new Set([Gi,Nl,Qy,rg,cC,uC]),T=new Uint32Array(4),C=new Int32Array(4);let A=null,I=null;const D=[],F=[];let z=null;this.domElement=e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=Tl,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const k=this;let O=!1;this._outputColorSpace=Ms;let L=0,H=0,q=null,K=-1,Y=null;const P=new Gs,W=new Gs;let j=null;const st=new ke(0);let ot=0,X=e.width,it=e.height,ct=1,yt=null,Rt=null;const ft=new Gs(0,0,X,it),_t=new Gs(0,0,X,it);let qt=!1;const Qt=new Tx;let se=!1,Ee=!1;const He=new Tn,Ae=new at,Ht=new Gs,Jt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let Xt=!1;function ce(){return q===null?ct:1}let rt=s;function Fe(Z,Et){return e.getContext(Z,Et)}try{const Z={alpha:!0,depth:i,stencil:r,antialias:o,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:h,failIfMajorPerformanceCaveat:f};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${kg}`),e.addEventListener("webglcontextlost",Je,!1),e.addEventListener("webglcontextrestored",zn,!1),e.addEventListener("webglcontextcreationerror",Mn,!1),rt===null){const Et="webgl2";if(rt=Fe(Et,Z),rt===null)throw Fe(Et)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(Z){throw on("WebGLRenderer: "+Z.message),Z}let he,Pe,pe,nt,G,vt,Vt,te,Pt,Ue,we,ze,nn,ae,de,Ne,ut,kt,Se,dt,ye,fe,Ce,ue;function ie(){he=new DJ(rt),he.init(),fe=new uV(rt,he),Pe=new wJ(rt,he,t,fe),pe=new wet(rt,he),Pe.reversedDepthBuffer&&p&&pe.buffers.depth.setReversed(!0),nt=new $J(rt),G=new aet,vt=new Tet(rt,he,pe,G,Pe,fe,nt),Vt=new EJ(k),te=new RJ(k),Pt=new UY(rt),Ce=new SJ(rt,Pt),Ue=new kJ(rt,Pt,nt,Ce),we=new FJ(rt,Ue,Pt,nt),Se=new LJ(rt,Pe,vt),Ne=new TJ(G),ze=new ret(k,Vt,te,he,Pe,Ce,Ne),nn=new Iet(k,G),ae=new cet,de=new met(he),kt=new bJ(k,Vt,te,pe,we,v,l),ut=new bet(k,we,Pe),ue=new Ret(rt,nt,Pe,pe),dt=new _J(rt,he,nt),ye=new OJ(rt,he,nt),nt.programs=ze.programs,k.capabilities=Pe,k.extensions=he,k.properties=G,k.renderLists=ae,k.shadowMap=ut,k.state=pe,k.info=nt}ie(),_!==Gi&&(z=new UJ(_,e.width,e.height,i,r));const ve=new Net(k,rt);this.xr=ve,this.getContext=function(){return rt},this.getContextAttributes=function(){return rt.getContextAttributes()},this.forceContextLoss=function(){const Z=he.get("WEBGL_lose_context");Z&&Z.loseContext()},this.forceContextRestore=function(){const Z=he.get("WEBGL_lose_context");Z&&Z.restoreContext()},this.getPixelRatio=function(){return ct},this.setPixelRatio=function(Z){Z!==void 0&&(ct=Z,this.setSize(X,it,!1))},this.getSize=function(Z){return Z.set(X,it)},this.setSize=function(Z,Et,Gt=!0){if(ve.isPresenting){Oe("WebGLRenderer: Can't change size while VR device is presenting.");return}X=Z,it=Et,e.width=Math.floor(Z*ct),e.height=Math.floor(Et*ct),Gt===!0&&(e.style.width=Z+"px",e.style.height=Et+"px"),z!==null&&z.setSize(e.width,e.height),this.setViewport(0,0,Z,Et)},this.getDrawingBufferSize=function(Z){return Z.set(X*ct,it*ct).floor()},this.setDrawingBufferSize=function(Z,Et,Gt){X=Z,it=Et,ct=Gt,e.width=Math.floor(Z*Gt),e.height=Math.floor(Et*Gt),this.setViewport(0,0,Z,Et)},this.setEffects=function(Z){if(_===Gi){console.error("THREE.WebGLRenderer: setEffects() requires outputBufferType set to HalfFloatType or FloatType.");return}if(Z){for(let Et=0;Et<Z.length;Et++)if(Z[Et].isOutputPass===!0){console.warn("THREE.WebGLRenderer: OutputPass is not needed in setEffects(). Tone mapping and color space conversion are applied automatically.");break}}z.setEffects(Z||[])},this.getCurrentViewport=function(Z){return Z.copy(P)},this.getViewport=function(Z){return Z.copy(ft)},this.setViewport=function(Z,Et,Gt,Ft){Z.isVector4?ft.set(Z.x,Z.y,Z.z,Z.w):ft.set(Z,Et,Gt,Ft),pe.viewport(P.copy(ft).multiplyScalar(ct).round())},this.getScissor=function(Z){return Z.copy(_t)},this.setScissor=function(Z,Et,Gt,Ft){Z.isVector4?_t.set(Z.x,Z.y,Z.z,Z.w):_t.set(Z,Et,Gt,Ft),pe.scissor(W.copy(_t).multiplyScalar(ct).round())},this.getScissorTest=function(){return qt},this.setScissorTest=function(Z){pe.setScissorTest(qt=Z)},this.setOpaqueSort=function(Z){yt=Z},this.setTransparentSort=function(Z){Rt=Z},this.getClearColor=function(Z){return Z.copy(kt.getClearColor())},this.setClearColor=function(){kt.setClearColor(...arguments)},this.getClearAlpha=function(){return kt.getClearAlpha()},this.setClearAlpha=function(){kt.setClearAlpha(...arguments)},this.clear=function(Z=!0,Et=!0,Gt=!0){let Ft=0;if(Z){let Dt=!1;if(q!==null){const Me=q.texture.format;Dt=S.has(Me)}if(Dt){const Me=q.texture.type,We=b.has(Me),De=kt.getClearColor(),qe=kt.getClearAlpha(),Ke=De.r,cn=De.g,Xe=De.b;We?(T[0]=Ke,T[1]=cn,T[2]=Xe,T[3]=qe,rt.clearBufferuiv(rt.COLOR,0,T)):(C[0]=Ke,C[1]=cn,C[2]=Xe,C[3]=qe,rt.clearBufferiv(rt.COLOR,0,C))}else Ft|=rt.COLOR_BUFFER_BIT}Et&&(Ft|=rt.DEPTH_BUFFER_BIT),Gt&&(Ft|=rt.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),rt.clear(Ft)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Je,!1),e.removeEventListener("webglcontextrestored",zn,!1),e.removeEventListener("webglcontextcreationerror",Mn,!1),kt.dispose(),ae.dispose(),de.dispose(),G.dispose(),Vt.dispose(),te.dispose(),we.dispose(),Ce.dispose(),ue.dispose(),ze.dispose(),ve.dispose(),ve.removeEventListener("sessionstart",wh),ve.removeEventListener("sessionend",Ro),lr.stop()};function Je(Z){Z.preventDefault(),S1("WebGLRenderer: Context Lost."),O=!0}function zn(){S1("WebGLRenderer: Context Restored."),O=!1;const Z=nt.autoReset,Et=ut.enabled,Gt=ut.autoUpdate,Ft=ut.needsUpdate,Dt=ut.type;ie(),nt.autoReset=Z,ut.enabled=Et,ut.autoUpdate=Gt,ut.needsUpdate=Ft,ut.type=Dt}function Mn(Z){on("WebGLRenderer: A WebGL context could not be created. Reason: ",Z.statusMessage)}function li(Z){const Et=Z.target;Et.removeEventListener("dispose",li),wr(Et)}function wr(Z){Ep(Z),G.remove(Z)}function Ep(Z){const Et=G.get(Z).programs;Et!==void 0&&(Et.forEach(function(Gt){ze.releaseProgram(Gt)}),Z.isShaderMaterial&&ze.releaseShaderCache(Z))}this.renderBufferDirect=function(Z,Et,Gt,Ft,Dt,Me){Et===null&&(Et=Jt);const We=Dt.isMesh&&Dt.matrixWorld.determinant()<0,De=yc(Z,Et,Gt,Ft,Dt);pe.setMaterial(Ft,We);let qe=Gt.index,Ke=1;if(Ft.wireframe===!0){if(qe=Ue.getWireframeAttribute(Gt),qe===void 0)return;Ke=2}const cn=Gt.drawRange,Xe=Gt.attributes.position;let fn=cn.start*Ke,gs=(cn.start+cn.count)*Ke;Me!==null&&(fn=Math.max(fn,Me.start*Ke),gs=Math.min(gs,(Me.start+Me.count)*Ke)),qe!==null?(fn=Math.max(fn,0),gs=Math.min(gs,qe.count)):Xe!=null&&(fn=Math.max(fn,0),gs=Math.min(gs,Xe.count));const Zs=gs-fn;if(Zs<0||Zs===1/0)return;Ce.setup(Dt,Ft,De,Gt,qe);let Bs,ys=dt;if(qe!==null&&(Bs=Pt.get(qe),ys=ye,ys.setIndex(Bs)),Dt.isMesh)Ft.wireframe===!0?(pe.setLineWidth(Ft.wireframeLinewidth*ce()),ys.setMode(rt.LINES)):ys.setMode(rt.TRIANGLES);else if(Dt.isLine){let tn=Ft.linewidth;tn===void 0&&(tn=1),pe.setLineWidth(tn*ce()),Dt.isLineSegments?ys.setMode(rt.LINES):Dt.isLineLoop?ys.setMode(rt.LINE_LOOP):ys.setMode(rt.LINE_STRIP)}else Dt.isPoints?ys.setMode(rt.POINTS):Dt.isSprite&&ys.setMode(rt.TRIANGLES);if(Dt.isBatchedMesh)if(Dt._multiDrawInstances!==null)tx("WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),ys.renderMultiDrawInstances(Dt._multiDrawStarts,Dt._multiDrawCounts,Dt._multiDrawCount,Dt._multiDrawInstances);else if(he.get("WEBGL_multi_draw"))ys.renderMultiDraw(Dt._multiDrawStarts,Dt._multiDrawCounts,Dt._multiDrawCount);else{const tn=Dt._multiDrawStarts,ds=Dt._multiDrawCounts,wn=Dt._multiDrawCount,cr=qe?Pt.get(qe).bytesPerElement:1,$l=G.get(Ft).currentProgram.getUniforms();for(let ur=0;ur<wn;ur++)$l.setValue(rt,"_gl_DrawID",ur),ys.render(tn[ur]/cr,ds[ur])}else if(Dt.isInstancedMesh)ys.renderInstances(fn,Zs,Dt.count);else if(Gt.isInstancedBufferGeometry){const tn=Gt._maxInstanceCount!==void 0?Gt._maxInstanceCount:1/0,ds=Math.min(Gt.instanceCount,tn);ys.renderInstances(fn,Zs,ds)}else ys.render(fn,Zs)};function _h(Z,Et,Gt){Z.transparent===!0&&Z.side===Fa&&Z.forceSinglePass===!1?(Z.side=kr,Z.needsUpdate=!0,Eh(Z,Et,Gt),Z.side=dh,Z.needsUpdate=!0,Eh(Z,Et,Gt),Z.side=Fa):Eh(Z,Et,Gt)}this.compile=function(Z,Et,Gt=null){Gt===null&&(Gt=Z),I=de.get(Gt),I.init(Et),F.push(I),Gt.traverseVisible(function(Dt){Dt.isLight&&Dt.layers.test(Et.layers)&&(I.pushLight(Dt),Dt.castShadow&&I.pushShadow(Dt))}),Z!==Gt&&Z.traverseVisible(function(Dt){Dt.isLight&&Dt.layers.test(Et.layers)&&(I.pushLight(Dt),Dt.castShadow&&I.pushShadow(Dt))}),I.setupLights();const Ft=new Set;return Z.traverse(function(Dt){if(!(Dt.isMesh||Dt.isPoints||Dt.isLine||Dt.isSprite))return;const Me=Dt.material;if(Me)if(Array.isArray(Me))for(let We=0;We<Me.length;We++){const De=Me[We];_h(De,Gt,Dt),Ft.add(De)}else _h(Me,Gt,Dt),Ft.add(Me)}),I=F.pop(),Ft},this.compileAsync=function(Z,Et,Gt=null){const Ft=this.compile(Z,Et,Gt);return new Promise(Dt=>{function Me(){if(Ft.forEach(function(We){G.get(We).currentProgram.isReady()&&Ft.delete(We)}),Ft.size===0){Dt(Z);return}setTimeout(Me,10)}he.get("KHR_parallel_shader_compile")!==null?Me():setTimeout(Me,10)})};let du=null;function Io(Z){du&&du(Z)}function wh(){lr.stop()}function Ro(){lr.start()}const lr=new rV;lr.setAnimationLoop(Io),typeof self<"u"&&lr.setContext(self),this.setAnimationLoop=function(Z){du=Z,ve.setAnimationLoop(Z),Z===null?lr.stop():lr.start()},ve.addEventListener("sessionstart",wh),ve.addEventListener("sessionend",Ro),this.render=function(Z,Et){if(Et!==void 0&&Et.isCamera!==!0){on("WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(O===!0)return;const Gt=ve.enabled===!0&&ve.isPresenting===!0,Ft=z!==null&&(q===null||Gt)&&z.begin(k,q);if(Z.matrixWorldAutoUpdate===!0&&Z.updateMatrixWorld(),Et.parent===null&&Et.matrixWorldAutoUpdate===!0&&Et.updateMatrixWorld(),ve.enabled===!0&&ve.isPresenting===!0&&(z===null||z.isCompositing()===!1)&&(ve.cameraAutoUpdate===!0&&ve.updateCamera(Et),Et=ve.getCamera()),Z.isScene===!0&&Z.onBeforeRender(k,Z,Et,q),I=de.get(Z,F.length),I.init(Et),F.push(I),He.multiplyMatrices(Et.projectionMatrix,Et.matrixWorldInverse),Qt.setFromProjectionMatrix(He,Sl,Et.reversedDepth),Ee=this.localClippingEnabled,se=Ne.init(this.clippingPlanes,Ee),A=ae.get(Z,D.length),A.init(),D.push(A),ve.enabled===!0&&ve.isPresenting===!0){const We=k.xr.getDepthSensingMesh();We!==null&&ia(We,Et,-1/0,k.sortObjects)}ia(Z,Et,0,k.sortObjects),A.finish(),k.sortObjects===!0&&A.sort(yt,Rt),Xt=ve.enabled===!1||ve.isPresenting===!1||ve.hasDepthSensing()===!1,Xt&&kt.addToRenderList(A,Z),this.info.render.frame++,se===!0&&Ne.beginShadows();const Dt=I.state.shadowsArray;if(ut.render(Dt,Z,Et),se===!0&&Ne.endShadows(),this.info.autoReset===!0&&this.info.reset(),(Ft&&z.hasRenderPass())===!1){const We=A.opaque,De=A.transmissive;if(I.setupLights(),Et.isArrayCamera){const qe=Et.cameras;if(De.length>0)for(let Ke=0,cn=qe.length;Ke<cn;Ke++){const Xe=qe[Ke];Zi(We,De,Z,Xe)}Xt&&kt.render(Z);for(let Ke=0,cn=qe.length;Ke<cn;Ke++){const Xe=qe[Ke];$n(A,Z,Xe,Xe.viewport)}}else De.length>0&&Zi(We,De,Z,Et),Xt&&kt.render(Z),$n(A,Z,Et)}q!==null&&H===0&&(vt.updateMultisampleRenderTarget(q),vt.updateRenderTargetMipmap(q)),Ft&&z.end(k),Z.isScene===!0&&Z.onAfterRender(k,Z,Et),Ce.resetDefaultState(),K=-1,Y=null,F.pop(),F.length>0?(I=F[F.length-1],se===!0&&Ne.setGlobalState(k.clippingPlanes,I.state.camera)):I=null,D.pop(),D.length>0?A=D[D.length-1]:A=null};function ia(Z,Et,Gt,Ft){if(Z.visible===!1)return;if(Z.layers.test(Et.layers)){if(Z.isGroup)Gt=Z.renderOrder;else if(Z.isLOD)Z.autoUpdate===!0&&Z.update(Et);else if(Z.isLight)I.pushLight(Z),Z.castShadow&&I.pushShadow(Z);else if(Z.isSprite){if(!Z.frustumCulled||Qt.intersectsSprite(Z)){Ft&&Ht.setFromMatrixPosition(Z.matrixWorld).applyMatrix4(He);const We=we.update(Z),De=Z.material;De.visible&&A.push(Z,We,De,Gt,Ht.z,null)}}else if((Z.isMesh||Z.isLine||Z.isPoints)&&(!Z.frustumCulled||Qt.intersectsObject(Z))){const We=we.update(Z),De=Z.material;if(Ft&&(Z.boundingSphere!==void 0?(Z.boundingSphere===null&&Z.computeBoundingSphere(),Ht.copy(Z.boundingSphere.center)):(We.boundingSphere===null&&We.computeBoundingSphere(),Ht.copy(We.boundingSphere.center)),Ht.applyMatrix4(Z.matrixWorld).applyMatrix4(He)),Array.isArray(De)){const qe=We.groups;for(let Ke=0,cn=qe.length;Ke<cn;Ke++){const Xe=qe[Ke],fn=De[Xe.materialIndex];fn&&fn.visible&&A.push(Z,We,fn,Gt,Ht.z,Xe)}}else De.visible&&A.push(Z,We,De,Gt,Ht.z,null)}}const Me=Z.children;for(let We=0,De=Me.length;We<De;We++)ia(Me[We],Et,Gt,Ft)}function $n(Z,Et,Gt,Ft){const{opaque:Dt,transmissive:Me,transparent:We}=Z;I.setupLightsView(Gt),se===!0&&Ne.setGlobalState(k.clippingPlanes,Gt),Ft&&pe.viewport(P.copy(Ft)),Dt.length>0&&Ka(Dt,Et,Gt),Me.length>0&&Ka(Me,Et,Gt),We.length>0&&Ka(We,Et,Gt),pe.buffers.depth.setTest(!0),pe.buffers.depth.setMask(!0),pe.buffers.color.setMask(!0),pe.setPolygonOffset(!1)}function Zi(Z,Et,Gt,Ft){if((Gt.isScene===!0?Gt.overrideMaterial:null)!==null)return;if(I.state.transmissionRenderTarget[Ft.id]===void 0){const fn=he.has("EXT_color_buffer_half_float")||he.has("EXT_color_buffer_float");I.state.transmissionRenderTarget[Ft.id]=new ki(1,1,{generateMipmaps:!0,type:fn?ru:Gi,minFilter:th,samples:Pe.samples,stencilBuffer:r,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:ss.workingColorSpace})}const Me=I.state.transmissionRenderTarget[Ft.id],We=Ft.viewport||P;Me.setSize(We.z*k.transmissionResolutionScale,We.w*k.transmissionResolutionScale);const De=k.getRenderTarget(),qe=k.getActiveCubeFace(),Ke=k.getActiveMipmapLevel();k.setRenderTarget(Me),k.getClearColor(st),ot=k.getClearAlpha(),ot<1&&k.setClearColor(16777215,.5),k.clear(),Xt&&kt.render(Gt);const cn=k.toneMapping;k.toneMapping=Tl;const Xe=Ft.viewport;if(Ft.viewport!==void 0&&(Ft.viewport=void 0),I.setupLightsView(Ft),se===!0&&Ne.setGlobalState(k.clippingPlanes,Ft),Ka(Z,Gt,Ft),vt.updateMultisampleRenderTarget(Me),vt.updateRenderTargetMipmap(Me),he.has("WEBGL_multisampled_render_to_texture")===!1){let fn=!1;for(let gs=0,Zs=Et.length;gs<Zs;gs++){const Bs=Et[gs],{object:ys,geometry:tn,material:ds,group:wn}=Bs;if(ds.side===Fa&&ys.layers.test(Ft.layers)){const cr=ds.side;ds.side=kr,ds.needsUpdate=!0,Th(ys,Gt,Ft,tn,ds,wn),ds.side=cr,ds.needsUpdate=!0,fn=!0}}fn===!0&&(vt.updateMultisampleRenderTarget(Me),vt.updateRenderTargetMipmap(Me))}k.setRenderTarget(De,qe,Ke),k.setClearColor(st,ot),Xe!==void 0&&(Ft.viewport=Xe),k.toneMapping=cn}function Ka(Z,Et,Gt){const Ft=Et.isScene===!0?Et.overrideMaterial:null;for(let Dt=0,Me=Z.length;Dt<Me;Dt++){const We=Z[Dt],{object:De,geometry:qe,group:Ke}=We;let cn=We.material;cn.allowOverride===!0&&Ft!==null&&(cn=Ft),De.layers.test(Gt.layers)&&Th(De,Et,Gt,qe,cn,Ke)}}function Th(Z,Et,Gt,Ft,Dt,Me){Z.onBeforeRender(k,Et,Gt,Ft,Dt,Me),Z.modelViewMatrix.multiplyMatrices(Gt.matrixWorldInverse,Z.matrixWorld),Z.normalMatrix.getNormalMatrix(Z.modelViewMatrix),Dt.onBeforeRender(k,Et,Gt,Ft,Z,Me),Dt.transparent===!0&&Dt.side===Fa&&Dt.forceSinglePass===!1?(Dt.side=kr,Dt.needsUpdate=!0,k.renderBufferDirect(Gt,Et,Ft,Dt,Z,Me),Dt.side=dh,Dt.needsUpdate=!0,k.renderBufferDirect(Gt,Et,Ft,Dt,Z,Me),Dt.side=Fa):k.renderBufferDirect(Gt,Et,Ft,Dt,Z,Me),Z.onAfterRender(k,Et,Gt,Ft,Dt,Me)}function Eh(Z,Et,Gt){Et.isScene!==!0&&(Et=Jt);const Ft=G.get(Z),Dt=I.state.lights,Me=I.state.shadowsArray,We=Dt.state.version,De=ze.getParameters(Z,Dt.state,Me,Et,Gt),qe=ze.getProgramCacheKey(De);let Ke=Ft.programs;Ft.environment=Z.isMeshStandardMaterial?Et.environment:null,Ft.fog=Et.fog,Ft.envMap=(Z.isMeshStandardMaterial?te:Vt).get(Z.envMap||Ft.environment),Ft.envMapRotation=Ft.environment!==null&&Z.envMap===null?Et.environmentRotation:Z.envMapRotation,Ke===void 0&&(Z.addEventListener("dispose",li),Ke=new Map,Ft.programs=Ke);let cn=Ke.get(qe);if(cn!==void 0){if(Ft.currentProgram===cn&&Ft.lightsStateVersion===We)return Ch(Z,De),cn}else De.uniforms=ze.getUniforms(Z),Z.onBeforeCompile(De,k),cn=ze.acquireProgram(De,qe),Ke.set(qe,cn),Ft.uniforms=De.uniforms;const Xe=Ft.uniforms;return(!Z.isShaderMaterial&&!Z.isRawShaderMaterial||Z.clipping===!0)&&(Xe.clippingPlanes=Ne.uniform),Ch(Z,De),Ft.needsLights=Ei(Z),Ft.lightsStateVersion=We,Ft.needsLights&&(Xe.ambientLightColor.value=Dt.state.ambient,Xe.lightProbe.value=Dt.state.probe,Xe.directionalLights.value=Dt.state.directional,Xe.directionalLightShadows.value=Dt.state.directionalShadow,Xe.spotLights.value=Dt.state.spot,Xe.spotLightShadows.value=Dt.state.spotShadow,Xe.rectAreaLights.value=Dt.state.rectArea,Xe.ltc_1.value=Dt.state.rectAreaLTC1,Xe.ltc_2.value=Dt.state.rectAreaLTC2,Xe.pointLights.value=Dt.state.point,Xe.pointLightShadows.value=Dt.state.pointShadow,Xe.hemisphereLights.value=Dt.state.hemi,Xe.directionalShadowMap.value=Dt.state.directionalShadowMap,Xe.directionalShadowMatrix.value=Dt.state.directionalShadowMatrix,Xe.spotShadowMap.value=Dt.state.spotShadowMap,Xe.spotLightMatrix.value=Dt.state.spotLightMatrix,Xe.spotLightMap.value=Dt.state.spotLightMap,Xe.pointShadowMap.value=Dt.state.pointShadowMap,Xe.pointShadowMatrix.value=Dt.state.pointShadowMatrix),Ft.currentProgram=cn,Ft.uniformsList=null,cn}function Zg(Z){if(Z.uniformsList===null){const Et=Z.currentProgram.getUniforms();Z.uniformsList=aE.seqWithValue(Et.seq,Z.uniforms)}return Z.uniformsList}function Ch(Z,Et){const Gt=G.get(Z);Gt.outputColorSpace=Et.outputColorSpace,Gt.batching=Et.batching,Gt.batchingColor=Et.batchingColor,Gt.instancing=Et.instancing,Gt.instancingColor=Et.instancingColor,Gt.instancingMorph=Et.instancingMorph,Gt.skinning=Et.skinning,Gt.morphTargets=Et.morphTargets,Gt.morphNormals=Et.morphNormals,Gt.morphColors=Et.morphColors,Gt.morphTargetsCount=Et.morphTargetsCount,Gt.numClippingPlanes=Et.numClippingPlanes,Gt.numIntersection=Et.numClipIntersection,Gt.vertexAlphas=Et.vertexAlphas,Gt.vertexTangents=Et.vertexTangents,Gt.toneMapping=Et.toneMapping}function yc(Z,Et,Gt,Ft,Dt){Et.isScene!==!0&&(Et=Jt),vt.resetTextureUnits();const Me=Et.fog,We=Ft.isMeshStandardMaterial?Et.environment:null,De=q===null?k.outputColorSpace:q.isXRRenderTarget===!0?q.texture.colorSpace:gh,qe=(Ft.isMeshStandardMaterial?te:Vt).get(Ft.envMap||We),Ke=Ft.vertexColors===!0&&!!Gt.attributes.color&&Gt.attributes.color.itemSize===4,cn=!!Gt.attributes.tangent&&(!!Ft.normalMap||Ft.anisotropy>0),Xe=!!Gt.morphAttributes.position,fn=!!Gt.morphAttributes.normal,gs=!!Gt.morphAttributes.color;let Zs=Tl;Ft.toneMapped&&(q===null||q.isXRRenderTarget===!0)&&(Zs=k.toneMapping);const Bs=Gt.morphAttributes.position||Gt.morphAttributes.normal||Gt.morphAttributes.color,ys=Bs!==void 0?Bs.length:0,tn=G.get(Ft),ds=I.state.lights;if(se===!0&&(Ee===!0||Z!==Y)){const Li=Z===Y&&Ft.id===K;Ne.setState(Ft,Z,Li)}let wn=!1;Ft.version===tn.__version?(tn.needsLights&&tn.lightsStateVersion!==ds.state.version||tn.outputColorSpace!==De||Dt.isBatchedMesh&&tn.batching===!1||!Dt.isBatchedMesh&&tn.batching===!0||Dt.isBatchedMesh&&tn.batchingColor===!0&&Dt.colorTexture===null||Dt.isBatchedMesh&&tn.batchingColor===!1&&Dt.colorTexture!==null||Dt.isInstancedMesh&&tn.instancing===!1||!Dt.isInstancedMesh&&tn.instancing===!0||Dt.isSkinnedMesh&&tn.skinning===!1||!Dt.isSkinnedMesh&&tn.skinning===!0||Dt.isInstancedMesh&&tn.instancingColor===!0&&Dt.instanceColor===null||Dt.isInstancedMesh&&tn.instancingColor===!1&&Dt.instanceColor!==null||Dt.isInstancedMesh&&tn.instancingMorph===!0&&Dt.morphTexture===null||Dt.isInstancedMesh&&tn.instancingMorph===!1&&Dt.morphTexture!==null||tn.envMap!==qe||Ft.fog===!0&&tn.fog!==Me||tn.numClippingPlanes!==void 0&&(tn.numClippingPlanes!==Ne.numPlanes||tn.numIntersection!==Ne.numIntersection)||tn.vertexAlphas!==Ke||tn.vertexTangents!==cn||tn.morphTargets!==Xe||tn.morphNormals!==fn||tn.morphColors!==gs||tn.toneMapping!==Zs||tn.morphTargetsCount!==ys)&&(wn=!0):(wn=!0,tn.__version=Ft.version);let cr=tn.currentProgram;wn===!0&&(cr=Eh(Ft,Et,Dt));let $l=!1,ur=!1,Do=!1;const Ss=cr.getUniforms(),pi=tn.uniforms;if(pe.useProgram(cr.program)&&($l=!0,ur=!0,Do=!0),Ft.id!==K&&(K=Ft.id,ur=!0),$l||Y!==Z){pe.buffers.depth.getReversed()&&Z.reversedDepth!==!0&&(Z._reversedDepth=!0,Z.updateProjectionMatrix()),Ss.setValue(rt,"projectionMatrix",Z.projectionMatrix),Ss.setValue(rt,"viewMatrix",Z.matrixWorldInverse);const Fi=Ss.map.cameraPosition;Fi!==void 0&&Fi.setValue(rt,Ae.setFromMatrixPosition(Z.matrixWorld)),Pe.logarithmicDepthBuffer&&Ss.setValue(rt,"logDepthBufFC",2/(Math.log(Z.far+1)/Math.LN2)),(Ft.isMeshPhongMaterial||Ft.isMeshToonMaterial||Ft.isMeshLambertMaterial||Ft.isMeshBasicMaterial||Ft.isMeshStandardMaterial||Ft.isShaderMaterial)&&Ss.setValue(rt,"isOrthographic",Z.isOrthographicCamera===!0),Y!==Z&&(Y=Z,ur=!0,Do=!0)}if(tn.needsLights&&(ds.state.directionalShadowMap.length>0&&Ss.setValue(rt,"directionalShadowMap",ds.state.directionalShadowMap,vt),ds.state.spotShadowMap.length>0&&Ss.setValue(rt,"spotShadowMap",ds.state.spotShadowMap,vt),ds.state.pointShadowMap.length>0&&Ss.setValue(rt,"pointShadowMap",ds.state.pointShadowMap,vt)),Dt.isSkinnedMesh){Ss.setOptional(rt,Dt,"bindMatrix"),Ss.setOptional(rt,Dt,"bindMatrixInverse");const Li=Dt.skeleton;Li&&(Li.boneTexture===null&&Li.computeBoneTexture(),Ss.setValue(rt,"boneTexture",Li.boneTexture,vt))}Dt.isBatchedMesh&&(Ss.setOptional(rt,Dt,"batchingTexture"),Ss.setValue(rt,"batchingTexture",Dt._matricesTexture,vt),Ss.setOptional(rt,Dt,"batchingIdTexture"),Ss.setValue(rt,"batchingIdTexture",Dt._indirectTexture,vt),Ss.setOptional(rt,Dt,"batchingColorTexture"),Dt._colorsTexture!==null&&Ss.setValue(rt,"batchingColorTexture",Dt._colorsTexture,vt));const $i=Gt.morphAttributes;if(($i.position!==void 0||$i.normal!==void 0||$i.color!==void 0)&&Se.update(Dt,Gt,cr),(ur||tn.receiveShadow!==Dt.receiveShadow)&&(tn.receiveShadow=Dt.receiveShadow,Ss.setValue(rt,"receiveShadow",Dt.receiveShadow)),Ft.isMeshGouraudMaterial&&Ft.envMap!==null&&(pi.envMap.value=qe,pi.flipEnvMap.value=qe.isCubeTexture&&qe.isRenderTargetTexture===!1?-1:1),Ft.isMeshStandardMaterial&&Ft.envMap===null&&Et.environment!==null&&(pi.envMapIntensity.value=Et.environmentIntensity),pi.dfgLUT!==void 0&&(pi.dfgLUT.value=ket()),ur&&(Ss.setValue(rt,"toneMappingExposure",k.toneMappingExposure),tn.needsLights&&Ah(pi,Do),Me&&Ft.fog===!0&&nn.refreshFogUniforms(pi,Me),nn.refreshMaterialUniforms(pi,Ft,ct,it,I.state.transmissionRenderTarget[Z.id]),aE.upload(rt,Zg(tn),pi,vt)),Ft.isShaderMaterial&&Ft.uniformsNeedUpdate===!0&&(aE.upload(rt,Zg(tn),pi,vt),Ft.uniformsNeedUpdate=!1),Ft.isSpriteMaterial&&Ss.setValue(rt,"center",Dt.center),Ss.setValue(rt,"modelViewMatrix",Dt.modelViewMatrix),Ss.setValue(rt,"normalMatrix",Dt.normalMatrix),Ss.setValue(rt,"modelMatrix",Dt.matrixWorld),Ft.isShaderMaterial||Ft.isRawShaderMaterial){const Li=Ft.uniformsGroups;for(let Fi=0,Nh=Li.length;Fi<Nh;Fi++){const Ya=Li[Fi];ue.update(Ya,cr),ue.bind(Ya,cr)}}return cr}function Ah(Z,Et){Z.ambientLightColor.needsUpdate=Et,Z.lightProbe.needsUpdate=Et,Z.directionalLights.needsUpdate=Et,Z.directionalLightShadows.needsUpdate=Et,Z.pointLights.needsUpdate=Et,Z.pointLightShadows.needsUpdate=Et,Z.spotLights.needsUpdate=Et,Z.spotLightShadows.needsUpdate=Et,Z.rectAreaLights.needsUpdate=Et,Z.hemisphereLights.needsUpdate=Et}function Ei(Z){return Z.isMeshLambertMaterial||Z.isMeshToonMaterial||Z.isMeshPhongMaterial||Z.isMeshStandardMaterial||Z.isShadowMaterial||Z.isShaderMaterial&&Z.lights===!0}this.getActiveCubeFace=function(){return L},this.getActiveMipmapLevel=function(){return H},this.getRenderTarget=function(){return q},this.setRenderTargetTextures=function(Z,Et,Gt){const Ft=G.get(Z);Ft.__autoAllocateDepthBuffer=Z.resolveDepthBuffer===!1,Ft.__autoAllocateDepthBuffer===!1&&(Ft.__useRenderToTexture=!1),G.get(Z.texture).__webglTexture=Et,G.get(Z.depthTexture).__webglTexture=Ft.__autoAllocateDepthBuffer?void 0:Gt,Ft.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(Z,Et){const Gt=G.get(Z);Gt.__webglFramebuffer=Et,Gt.__useDefaultFramebuffer=Et===void 0};const Us=rt.createFramebuffer();this.setRenderTarget=function(Z,Et=0,Gt=0){q=Z,L=Et,H=Gt;let Ft=null,Dt=!1,Me=!1;if(Z){const De=G.get(Z);if(De.__useDefaultFramebuffer!==void 0){pe.bindFramebuffer(rt.FRAMEBUFFER,De.__webglFramebuffer),P.copy(Z.viewport),W.copy(Z.scissor),j=Z.scissorTest,pe.viewport(P),pe.scissor(W),pe.setScissorTest(j),K=-1;return}else if(De.__webglFramebuffer===void 0)vt.setupRenderTarget(Z);else if(De.__hasExternalTextures)vt.rebindTextures(Z,G.get(Z.texture).__webglTexture,G.get(Z.depthTexture).__webglTexture);else if(Z.depthBuffer){const cn=Z.depthTexture;if(De.__boundDepthTexture!==cn){if(cn!==null&&G.has(cn)&&(Z.width!==cn.image.width||Z.height!==cn.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");vt.setupDepthRenderbuffer(Z)}}const qe=Z.texture;(qe.isData3DTexture||qe.isDataArrayTexture||qe.isCompressedArrayTexture)&&(Me=!0);const Ke=G.get(Z).__webglFramebuffer;Z.isWebGLCubeRenderTarget?(Array.isArray(Ke[Et])?Ft=Ke[Et][Gt]:Ft=Ke[Et],Dt=!0):Z.samples>0&&vt.useMultisampledRTT(Z)===!1?Ft=G.get(Z).__webglMultisampledFramebuffer:Array.isArray(Ke)?Ft=Ke[Gt]:Ft=Ke,P.copy(Z.viewport),W.copy(Z.scissor),j=Z.scissorTest}else P.copy(ft).multiplyScalar(ct).floor(),W.copy(_t).multiplyScalar(ct).floor(),j=qt;if(Gt!==0&&(Ft=Us),pe.bindFramebuffer(rt.FRAMEBUFFER,Ft)&&pe.drawBuffers(Z,Ft),pe.viewport(P),pe.scissor(W),pe.setScissorTest(j),Dt){const De=G.get(Z.texture);rt.framebufferTexture2D(rt.FRAMEBUFFER,rt.COLOR_ATTACHMENT0,rt.TEXTURE_CUBE_MAP_POSITIVE_X+Et,De.__webglTexture,Gt)}else if(Me){const De=Et;for(let qe=0;qe<Z.textures.length;qe++){const Ke=G.get(Z.textures[qe]);rt.framebufferTextureLayer(rt.FRAMEBUFFER,rt.COLOR_ATTACHMENT0+qe,Ke.__webglTexture,Gt,De)}}else if(Z!==null&&Gt!==0){const De=G.get(Z.texture);rt.framebufferTexture2D(rt.FRAMEBUFFER,rt.COLOR_ATTACHMENT0,rt.TEXTURE_2D,De.__webglTexture,Gt)}K=-1},this.readRenderTargetPixels=function(Z,Et,Gt,Ft,Dt,Me,We,De=0){if(!(Z&&Z.isWebGLRenderTarget)){on("WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let qe=G.get(Z).__webglFramebuffer;if(Z.isWebGLCubeRenderTarget&&We!==void 0&&(qe=qe[We]),qe){pe.bindFramebuffer(rt.FRAMEBUFFER,qe);try{const Ke=Z.textures[De],cn=Ke.format,Xe=Ke.type;if(!Pe.textureFormatReadable(cn)){on("WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!Pe.textureTypeReadable(Xe)){on("WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Et>=0&&Et<=Z.width-Ft&&Gt>=0&&Gt<=Z.height-Dt&&(Z.textures.length>1&&rt.readBuffer(rt.COLOR_ATTACHMENT0+De),rt.readPixels(Et,Gt,Ft,Dt,fe.convert(cn),fe.convert(Xe),Me))}finally{const Ke=q!==null?G.get(q).__webglFramebuffer:null;pe.bindFramebuffer(rt.FRAMEBUFFER,Ke)}}},this.readRenderTargetPixelsAsync=async function(Z,Et,Gt,Ft,Dt,Me,We,De=0){if(!(Z&&Z.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let qe=G.get(Z).__webglFramebuffer;if(Z.isWebGLCubeRenderTarget&&We!==void 0&&(qe=qe[We]),qe)if(Et>=0&&Et<=Z.width-Ft&&Gt>=0&&Gt<=Z.height-Dt){pe.bindFramebuffer(rt.FRAMEBUFFER,qe);const Ke=Z.textures[De],cn=Ke.format,Xe=Ke.type;if(!Pe.textureFormatReadable(cn))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!Pe.textureTypeReadable(Xe))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const fn=rt.createBuffer();rt.bindBuffer(rt.PIXEL_PACK_BUFFER,fn),rt.bufferData(rt.PIXEL_PACK_BUFFER,Me.byteLength,rt.STREAM_READ),Z.textures.length>1&&rt.readBuffer(rt.COLOR_ATTACHMENT0+De),rt.readPixels(Et,Gt,Ft,Dt,fe.convert(cn),fe.convert(Xe),0);const gs=q!==null?G.get(q).__webglFramebuffer:null;pe.bindFramebuffer(rt.FRAMEBUFFER,gs);const Zs=rt.fenceSync(rt.SYNC_GPU_COMMANDS_COMPLETE,0);return rt.flush(),await G9(rt,Zs,4),rt.bindBuffer(rt.PIXEL_PACK_BUFFER,fn),rt.getBufferSubData(rt.PIXEL_PACK_BUFFER,0,Me),rt.deleteBuffer(fn),rt.deleteSync(Zs),Me}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")},this.copyFramebufferToTexture=function(Z,Et=null,Gt=0){const Ft=Math.pow(2,-Gt),Dt=Math.floor(Z.image.width*Ft),Me=Math.floor(Z.image.height*Ft),We=Et!==null?Et.x:0,De=Et!==null?Et.y:0;vt.setTexture2D(Z,0),rt.copyTexSubImage2D(rt.TEXTURE_2D,Gt,0,0,We,De,Dt,Me),pe.unbindTexture()};const il=rt.createFramebuffer(),rl=rt.createFramebuffer();this.copyTextureToTexture=function(Z,Et,Gt=null,Ft=null,Dt=0,Me=null){Me===null&&(Dt!==0?(tx("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),Me=Dt,Dt=0):Me=0);let We,De,qe,Ke,cn,Xe,fn,gs,Zs;const Bs=Z.isCompressedTexture?Z.mipmaps[Me]:Z.image;if(Gt!==null)We=Gt.max.x-Gt.min.x,De=Gt.max.y-Gt.min.y,qe=Gt.isBox3?Gt.max.z-Gt.min.z:1,Ke=Gt.min.x,cn=Gt.min.y,Xe=Gt.isBox3?Gt.min.z:0;else{const $i=Math.pow(2,-Dt);We=Math.floor(Bs.width*$i),De=Math.floor(Bs.height*$i),Z.isDataArrayTexture?qe=Bs.depth:Z.isData3DTexture?qe=Math.floor(Bs.depth*$i):qe=1,Ke=0,cn=0,Xe=0}Ft!==null?(fn=Ft.x,gs=Ft.y,Zs=Ft.z):(fn=0,gs=0,Zs=0);const ys=fe.convert(Et.format),tn=fe.convert(Et.type);let ds;Et.isData3DTexture?(vt.setTexture3D(Et,0),ds=rt.TEXTURE_3D):Et.isDataArrayTexture||Et.isCompressedArrayTexture?(vt.setTexture2DArray(Et,0),ds=rt.TEXTURE_2D_ARRAY):(vt.setTexture2D(Et,0),ds=rt.TEXTURE_2D),rt.pixelStorei(rt.UNPACK_FLIP_Y_WEBGL,Et.flipY),rt.pixelStorei(rt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Et.premultiplyAlpha),rt.pixelStorei(rt.UNPACK_ALIGNMENT,Et.unpackAlignment);const wn=rt.getParameter(rt.UNPACK_ROW_LENGTH),cr=rt.getParameter(rt.UNPACK_IMAGE_HEIGHT),$l=rt.getParameter(rt.UNPACK_SKIP_PIXELS),ur=rt.getParameter(rt.UNPACK_SKIP_ROWS),Do=rt.getParameter(rt.UNPACK_SKIP_IMAGES);rt.pixelStorei(rt.UNPACK_ROW_LENGTH,Bs.width),rt.pixelStorei(rt.UNPACK_IMAGE_HEIGHT,Bs.height),rt.pixelStorei(rt.UNPACK_SKIP_PIXELS,Ke),rt.pixelStorei(rt.UNPACK_SKIP_ROWS,cn),rt.pixelStorei(rt.UNPACK_SKIP_IMAGES,Xe);const Ss=Z.isDataArrayTexture||Z.isData3DTexture,pi=Et.isDataArrayTexture||Et.isData3DTexture;if(Z.isDepthTexture){const $i=G.get(Z),Li=G.get(Et),Fi=G.get($i.__renderTarget),Nh=G.get(Li.__renderTarget);pe.bindFramebuffer(rt.READ_FRAMEBUFFER,Fi.__webglFramebuffer),pe.bindFramebuffer(rt.DRAW_FRAMEBUFFER,Nh.__webglFramebuffer);for(let Ya=0;Ya<qe;Ya++)Ss&&(rt.framebufferTextureLayer(rt.READ_FRAMEBUFFER,rt.COLOR_ATTACHMENT0,G.get(Z).__webglTexture,Dt,Xe+Ya),rt.framebufferTextureLayer(rt.DRAW_FRAMEBUFFER,rt.COLOR_ATTACHMENT0,G.get(Et).__webglTexture,Me,Zs+Ya)),rt.blitFramebuffer(Ke,cn,We,De,fn,gs,We,De,rt.DEPTH_BUFFER_BIT,rt.NEAREST);pe.bindFramebuffer(rt.READ_FRAMEBUFFER,null),pe.bindFramebuffer(rt.DRAW_FRAMEBUFFER,null)}else if(Dt!==0||Z.isRenderTargetTexture||G.has(Z)){const $i=G.get(Z),Li=G.get(Et);pe.bindFramebuffer(rt.READ_FRAMEBUFFER,il),pe.bindFramebuffer(rt.DRAW_FRAMEBUFFER,rl);for(let Fi=0;Fi<qe;Fi++)Ss?rt.framebufferTextureLayer(rt.READ_FRAMEBUFFER,rt.COLOR_ATTACHMENT0,$i.__webglTexture,Dt,Xe+Fi):rt.framebufferTexture2D(rt.READ_FRAMEBUFFER,rt.COLOR_ATTACHMENT0,rt.TEXTURE_2D,$i.__webglTexture,Dt),pi?rt.framebufferTextureLayer(rt.DRAW_FRAMEBUFFER,rt.COLOR_ATTACHMENT0,Li.__webglTexture,Me,Zs+Fi):rt.framebufferTexture2D(rt.DRAW_FRAMEBUFFER,rt.COLOR_ATTACHMENT0,rt.TEXTURE_2D,Li.__webglTexture,Me),Dt!==0?rt.blitFramebuffer(Ke,cn,We,De,fn,gs,We,De,rt.COLOR_BUFFER_BIT,rt.NEAREST):pi?rt.copyTexSubImage3D(ds,Me,fn,gs,Zs+Fi,Ke,cn,We,De):rt.copyTexSubImage2D(ds,Me,fn,gs,Ke,cn,We,De);pe.bindFramebuffer(rt.READ_FRAMEBUFFER,null),pe.bindFramebuffer(rt.DRAW_FRAMEBUFFER,null)}else pi?Z.isDataTexture||Z.isData3DTexture?rt.texSubImage3D(ds,Me,fn,gs,Zs,We,De,qe,ys,tn,Bs.data):Et.isCompressedArrayTexture?rt.compressedTexSubImage3D(ds,Me,fn,gs,Zs,We,De,qe,ys,Bs.data):rt.texSubImage3D(ds,Me,fn,gs,Zs,We,De,qe,ys,tn,Bs):Z.isDataTexture?rt.texSubImage2D(rt.TEXTURE_2D,Me,fn,gs,We,De,ys,tn,Bs.data):Z.isCompressedTexture?rt.compressedTexSubImage2D(rt.TEXTURE_2D,Me,fn,gs,Bs.width,Bs.height,ys,Bs.data):rt.texSubImage2D(rt.TEXTURE_2D,Me,fn,gs,We,De,ys,tn,Bs);rt.pixelStorei(rt.UNPACK_ROW_LENGTH,wn),rt.pixelStorei(rt.UNPACK_IMAGE_HEIGHT,cr),rt.pixelStorei(rt.UNPACK_SKIP_PIXELS,$l),rt.pixelStorei(rt.UNPACK_SKIP_ROWS,ur),rt.pixelStorei(rt.UNPACK_SKIP_IMAGES,Do),Me===0&&Et.generateMipmaps&&rt.generateMipmap(ds),pe.unbindTexture()},this.initRenderTarget=function(Z){G.get(Z).__webglFramebuffer===void 0&&vt.setupRenderTarget(Z)},this.initTexture=function(Z){Z.isCubeTexture?vt.setTextureCube(Z,0):Z.isData3DTexture?vt.setTexture3D(Z,0):Z.isDataArrayTexture||Z.isCompressedArrayTexture?vt.setTexture2DArray(Z,0):vt.setTexture2D(Z,0),pe.unbindTexture()},this.resetState=function(){L=0,H=0,q=null,pe.reset(),Ce.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Sl}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t;const e=this.getContext();e.drawingBufferColorSpace=ss._getDrawingBufferColorSpace(t),e.unpackColorSpace=ss._getUnpackColorSpace()}}const Oet=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:aC,AddEquation:Dd,AddOperation:VP,AdditiveAnimationBlendMode:jD,AdditiveBlending:Zy,AgXToneMapping:UD,AlphaFormat:qD,AlwaysCompare:JP,AlwaysDepth:h1,AlwaysStencilFunc:tR,AmbientLight:j4,AnimationAction:nV,AnimationClip:N1,AnimationLoader:RK,AnimationMixer:rY,AnimationObjectGroup:sY,AnimationUtils:AK,ArcCurve:S4,ArrayCamera:J4,ArrowHelper:IY,AttachedBindMode:JI,Audio:tV,AudioAnalyser:XK,AudioContext:S3,AudioListener:HK,AudioLoader:PK,AxesHelper:RY,BackSide:kr,BasicDepthPacking:op,BasicShadowMap:_P,BatchedMesh:p4,Bone:e3,BooleanKeyframeTrack:Lg,Box2:pY,Box3:Ga,Box3Helper:NY,BoxGeometry:$g,BoxHelper:AY,BufferAttribute:Fs,BufferGeometry:Nn,BufferGeometryLoader:Q4,ByteType:VD,Cache:eh,Camera:vC,CameraHelper:CY,CanvasTexture:x4,CapsuleGeometry:CC,CatmullRomCurve3:_4,CineonToneMapping:FD,CircleGeometry:AC,ClampToEdgeWrapping:Yo,Clock:_3,Color:ke,ColorKeyframeTrack:y3,ColorManagement:ss,CompressedArrayTexture:K7,CompressedCubeTexture:Y7,CompressedTexture:EC,CompressedTextureLoader:DK,ConeGeometry:iS,ConstantAlphaFactor:UP,ConstantColorFactor:FP,Controls:kY,CubeCamera:l4,CubeDepthTexture:v4,CubeReflectionMapping:ph,CubeRefractionMapping:Xd,CubeTexture:nS,CubeTextureLoader:kK,CubeUVReflectionMapping:wx,CubicBezierCurve:r3,CubicBezierCurve3:w4,CubicInterpolant:U4,CullFaceBack:YI,CullFaceFront:SP,CullFaceFrontBack:Jj,CullFaceNone:bP,Curve:cu,CurvePath:E4,CustomBlending:wP,CustomToneMapping:zD,CylinderGeometry:sS,Cylindrical:dY,Data3DTexture:xC,DataArrayTexture:yC,DataTexture:Jc,DataTextureLoader:OK,DataUtils:b7,DecrementStencilOp:y9,DecrementWrapStencilOp:v9,DefaultLoadingManager:V4,DepthFormat:mh,DepthStencilFormat:vf,DepthTexture:lg,DetachedBindMode:GP,DirectionalLight:X4,DirectionalLightHelper:EY,DiscreteInterpolant:B4,DodecahedronGeometry:NC,DoubleSide:Fa,DstAlphaFactor:DP,DstColorFactor:OP,DynamicCopyUsage:O9,DynamicDrawUsage:N9,DynamicReadUsage:R9,EdgesGeometry:b4,EllipseCurve:MC,EqualCompare:YP,EqualDepth:AE,EqualStencilFunc:w9,EquirectangularReflectionMapping:f1,EquirectangularRefractionMapping:d1,Euler:Ml,EventDispatcher:Rl,ExternalTexture:s3,ExtrudeGeometry:IC,FileLoader:wf,Float16BufferAttribute:A7,Float32BufferAttribute:je,FloatType:Ua,Fog:SC,FogExp2:bC,FramebufferTexture:j7,FrontSide:dh,Frustum:Tx,FrustumArray:TC,GLBufferAttribute:uY,GLSL1:L9,GLSL3:eR,GreaterCompare:ZP,GreaterDepth:ME,GreaterEqualCompare:gC,GreaterEqualDepth:NE,GreaterEqualStencilFunc:A9,GreaterStencilFunc:E9,GridHelper:wY,Group:By,HalfFloatType:ru,HemisphereLight:H4,HemisphereLightHelper:_Y,IcosahedronGeometry:RC,ImageBitmapLoader:BK,ImageLoader:M1,ImageUtils:i4,IncrementStencilOp:g9,IncrementWrapStencilOp:x9,InstancedBufferAttribute:ix,InstancedBufferGeometry:Z4,InstancedInterleavedBuffer:cY,InstancedMesh:d4,Int16BufferAttribute:E7,Int32BufferAttribute:C7,Int8BufferAttribute:_7,IntType:lC,InterleavedBuffer:_C,InterleavedBufferAttribute:og,Interpolant:oS,InterpolateDiscrete:g1,InterpolateLinear:c2,InterpolateSmooth:iE,InterpolationSamplingMode:U9,InterpolationSamplingType:z9,InvertStencilOp:b9,KeepStencilOp:Om,KeyframeTrack:fc,LOD:h4,LatheGeometry:DC,Layers:nx,LessCompare:KP,LessDepth:CE,LessEqualCompare:mC,LessEqualDepth:ig,LessEqualStencilFunc:T9,LessStencilFunc:_9,Light:hp,LightProbe:Y4,Line:Kd,Line3:yY,LineBasicMaterial:Ao,LineCurve:a3,LineCurve3:T4,LineDashedMaterial:F4,LineLoop:m4,LineSegments:bh,LinearFilter:Hs,LinearInterpolant:g3,LinearMipMapLinearFilter:s9,LinearMipMapNearestFilter:n9,LinearMipmapLinearFilter:th,LinearMipmapNearestFilter:Qb,LinearSRGBColorSpace:gh,LinearToneMapping:$D,LinearTransfer:x1,Loader:nl,LoaderUtils:aR,LoadingManager:x3,LoopOnce:HP,LoopPingPong:qP,LoopRepeat:WP,MOUSE:Dm,Material:Jr,MaterialLoader:UC,MathUtils:s4,Matrix2:E3,Matrix3:On,Matrix4:Tn,MaxEquation:AP,Mesh:rr,MeshBasicMaterial:cp,MeshDepthMaterial:d3,MeshDistanceMaterial:p3,MeshLambertMaterial:$4,MeshMatcapMaterial:L4,MeshNormalMaterial:f3,MeshPhongMaterial:k4,MeshPhysicalMaterial:D4,MeshStandardMaterial:h3,MeshToonMaterial:O4,MinEquation:CP,MirroredRepeatWrapping:m1,MixOperation:PP,MultiplyBlending:QI,MultiplyOperation:tS,NearestFilter:hi,NearestMipMapLinearFilter:e9,NearestMipMapNearestFilter:t9,NearestMipmapLinearFilter:zy,NearestMipmapNearestFilter:PD,NeutralToneMapping:BD,NeverCompare:jP,NeverDepth:EE,NeverStencilFunc:S9,NoBlending:da,NoColorSpace:Yc,NoNormalPacking:h9,NoToneMapping:Tl,NormalAnimationBlendMode:pC,NormalBlending:Zm,NormalGAPacking:d9,NormalRGPacking:f9,NotEqualCompare:QP,NotEqualDepth:IE,NotEqualStencilFunc:C9,NumberKeyframeTrack:C1,Object3D:ps,ObjectLoader:zK,ObjectSpaceNormalMap:XP,OctahedronGeometry:rS,OneFactor:MP,OneMinusConstantAlphaFactor:BP,OneMinusConstantColorFactor:zP,OneMinusDstAlphaFactor:kP,OneMinusDstColorFactor:$P,OneMinusSrcAlphaFactor:TE,OneMinusSrcColorFactor:RP,OrthographicCamera:rh,PCFShadowMap:Py,PCFSoftShadowMap:Zb,PMREMGenerator:cR,Path:d2,PerspectiveCamera:Vi,Plane:hf,PlaneGeometry:Ex,PlaneHelper:MY,PointLight:q4,PointLightHelper:bY,Points:g4,PointsMaterial:n3,PolarGridHelper:TY,PolyhedronGeometry:up,PositionalAudio:qK,PropertyBinding:vs,PropertyMixer:eV,QuadraticBezierCurve:o3,QuadraticBezierCurve3:l3,Quaternion:Va,QuaternionKeyframeTrack:lS,QuaternionLinearInterpolant:P4,R11_EAC_Format:zE,RED_GREEN_RGTC2_Format:o2,RED_RGTC1_Format:r2,REVISION:kg,RG11_EAC_Format:BE,RGBADepthPacking:l9,RGBAFormat:Ba,RGBAIntegerFormat:dC,RGBA_ASTC_10x10_Format:JE,RGBA_ASTC_10x5_Format:YE,RGBA_ASTC_10x6_Format:ZE,RGBA_ASTC_10x8_Format:QE,RGBA_ASTC_12x10_Format:t2,RGBA_ASTC_12x12_Format:e2,RGBA_ASTC_4x4_Format:VE,RGBA_ASTC_5x4_Format:GE,RGBA_ASTC_5x5_Format:HE,RGBA_ASTC_6x5_Format:WE,RGBA_ASTC_6x6_Format:qE,RGBA_ASTC_8x5_Format:XE,RGBA_ASTC_8x6_Format:jE,RGBA_ASTC_8x8_Format:KE,RGBA_BPTC_Format:n2,RGBA_ETC2_EAC_Format:FE,RGBA_PVRTC_2BPPV1_Format:OE,RGBA_PVRTC_4BPPV1_Format:kE,RGBA_S3TC_DXT1_Format:t1,RGBA_S3TC_DXT3_Format:e1,RGBA_S3TC_DXT5_Format:n1,RGBDepthPacking:c9,RGBFormat:XD,RGBIntegerFormat:i9,RGB_BPTC_SIGNED_Format:s2,RGB_BPTC_UNSIGNED_Format:i2,RGB_ETC1_Format:$E,RGB_ETC2_Format:LE,RGB_PVRTC_2BPPV1_Format:DE,RGB_PVRTC_4BPPV1_Format:RE,RGB_S3TC_DXT1_Format:Jb,RGDepthPacking:u9,RGFormat:ag,RGIntegerFormat:fC,RawShaderMaterial:u3,Ray:Og,Raycaster:sV,RectAreaLight:K4,RedFormat:hC,RedIntegerFormat:eS,ReinhardToneMapping:LD,RenderTarget:YD,RenderTarget3D:aY,RepeatWrapping:p1,ReplaceStencilOp:m9,ReverseSubtractEquation:EP,RingGeometry:kC,SIGNED_R11_EAC_Format:UE,SIGNED_RED_GREEN_RGTC2_Format:l2,SIGNED_RED_RGTC1_Format:a2,SIGNED_RG11_EAC_Format:PE,SRGBColorSpace:Ms,SRGBTransfer:Ls,Scene:_1,ShaderChunk:Pn,ShaderLib:qc,ShaderMaterial:ar,ShadowMaterial:R4,Shape:Bd,ShapeGeometry:OC,ShapePath:DY,ShapeUtils:Zc,ShortType:GD,Skeleton:wC,SkeletonHelper:vY,SkinnedMesh:f4,Source:Od,Sphere:pa,SphereGeometry:aS,Spherical:p2,SphericalHarmonics3:b3,SplineCurve:c3,SpotLight:W4,SpotLightHelper:xY,Sprite:u4,SpriteMaterial:t3,SrcAlphaFactor:wE,SrcAlphaSaturateFactor:LP,SrcColorFactor:IP,StaticCopyUsage:k9,StaticDrawUsage:v1,StaticReadUsage:I9,StereoCamera:VK,StreamCopyUsage:$9,StreamDrawUsage:M9,StreamReadUsage:D9,StringKeyframeTrack:Fg,SubtractEquation:TP,SubtractiveBlending:ZI,TOUCH:km,TangentSpaceNormalMap:lp,TetrahedronGeometry:$C,Texture:wi,TextureLoader:G4,TextureUtils:zY,Timer:hY,TimestampQuery:F9,TorusGeometry:LC,TorusKnotGeometry:FC,Triangle:jo,TriangleFanDrawMode:o9,TriangleStripDrawMode:a9,TrianglesDrawMode:r9,TubeGeometry:zC,UVMapping:oC,Uint16BufferAttribute:ZD,Uint32BufferAttribute:QD,Uint8BufferAttribute:w7,Uint8ClampedBufferAttribute:T7,Uniform:Qn,UniformsGroup:lY,UniformsLib:Le,UniformsUtils:o4,UnsignedByteType:Gi,UnsignedInt101111Type:WD,UnsignedInt248Type:rg,UnsignedInt5999Type:HD,UnsignedIntType:Nl,UnsignedShort4444Type:cC,UnsignedShort5551Type:uC,UnsignedShortType:Qy,VSMShadowMap:Vm,Vector2:Yt,Vector3:at,Vector4:Gs,VectorKeyframeTrack:A1,VideoFrameTexture:X7,VideoTexture:y4,WebGL3DRenderTarget:u7,WebGLArrayRenderTarget:c7,WebGLCoordinateSystem:Sl,WebGLCubeRenderTarget:JD,WebGLRenderTarget:ki,WebGLRenderer:hV,WebGLUtils:uV,WebGPUCoordinateSystem:Jy,WebXRController:rE,WireframeGeometry:I4,WrapAroundEnding:y1,ZeroCurvatureEnding:Gm,ZeroFactor:NP,ZeroSlopeEnding:Hm,ZeroStencilOp:p9,createCanvasElement:n4,error:on,getConsoleFunction:V9,log:S1,setConsoleFunction:P9,warn:Oe,warnOnce:tx},Symbol.toStringTag,{value:"Module"}));var rI={exports:{}},aI={},oI={exports:{}},lI={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var vz;function $et(){if(vz)return lI;vz=1;var n=Dg();function t(f,p){return f===p&&(f!==0||1/f===1/p)||f!==f&&p!==p}var e=typeof Object.is=="function"?Object.is:t,s=n.useState,i=n.useEffect,r=n.useLayoutEffect,a=n.useDebugValue;function o(f,p){var g=p(),v=s({inst:{value:g,getSnapshot:p}}),_=v[0].inst,S=v[1];return r(function(){_.value=g,_.getSnapshot=p,l(_)&&S({inst:_})},[f,g,p]),i(function(){return l(_)&&S({inst:_}),f(function(){l(_)&&S({inst:_})})},[f]),a(g),g}function l(f){var p=f.getSnapshot;f=f.value;try{var g=p();return!e(f,g)}catch{return!0}}function c(f,p){return p()}var h=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?c:o;return lI.useSyncExternalStore=n.useSyncExternalStore!==void 0?n.useSyncExternalStore:h,lI}var bz;function Let(){return bz||(bz=1,oI.exports=$et()),oI.exports}/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Sz;function Fet(){if(Sz)return aI;Sz=1;var n=Dg(),t=Let();function e(c,h){return c===h&&(c!==0||1/c===1/h)||c!==c&&h!==h}var s=typeof Object.is=="function"?Object.is:e,i=t.useSyncExternalStore,r=n.useRef,a=n.useEffect,o=n.useMemo,l=n.useDebugValue;return aI.useSyncExternalStoreWithSelector=function(c,h,f,p,g){var v=r(null);if(v.current===null){var _={hasValue:!1,value:null};v.current=_}else _=v.current;v=o(function(){function b(D){if(!T){if(T=!0,C=D,D=p(D),g!==void 0&&_.hasValue){var F=_.value;if(g(F,D))return A=F}return A=D}if(F=A,s(C,D))return F;var z=p(D);return g!==void 0&&g(F,z)?(C=D,F):(C=D,A=z)}var T=!1,C,A,I=f===void 0?null:f;return[function(){return b(h())},I===null?void 0:function(){return b(I())}]},[h,f,p,g]);var S=i(c,v[0],v[1]);return a(function(){_.hasValue=!0,_.value=S},[S]),l(S),S},aI}var _z;function zet(){return _z||(_z=1,rI.exports=Fet()),rI.exports}var Uet=zet();const Bet=_x(Uet),wz=n=>{let t;const e=new Set,s=(c,h)=>{const f=typeof c=="function"?c(t):c;if(!Object.is(f,t)){const p=t;t=h??(typeof f!="object"||f===null)?f:Object.assign({},t,f),e.forEach(g=>g(t,p))}},i=()=>t,o={setState:s,getState:i,getInitialState:()=>l,subscribe:c=>(e.add(c),()=>e.delete(c))},l=t=n(s,i,o);return o},Pet=(n=>n?wz(n):wz),{useSyncExternalStoreWithSelector:Vet}=Bet,Get=n=>n;function Het(n,t=Get,e){const s=Vet(n.subscribe,n.getState,n.getInitialState,t,e);return OD.useDebugValue(s),s}const Tz=(n,t)=>{const e=Pet(n),s=(i,r=t)=>Het(e,i,r);return Object.assign(s,e),s},Wet=((n,t)=>n?Tz(n,t):Tz);var cI={exports:{}},uI={exports:{}},hI={exports:{}},fI={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ez;function qet(){return Ez||(Ez=1,(function(n){function t(P,W){var j=P.length;P.push(W);t:for(;0<j;){var st=j-1>>>1,ot=P[st];if(0<i(ot,W))P[st]=W,P[j]=ot,j=st;else break t}}function e(P){return P.length===0?null:P[0]}function s(P){if(P.length===0)return null;var W=P[0],j=P.pop();if(j!==W){P[0]=j;t:for(var st=0,ot=P.length,X=ot>>>1;st<X;){var it=2*(st+1)-1,ct=P[it],yt=it+1,Rt=P[yt];if(0>i(ct,j))yt<ot&&0>i(Rt,ct)?(P[st]=Rt,P[yt]=j,st=yt):(P[st]=ct,P[it]=j,st=it);else if(yt<ot&&0>i(Rt,j))P[st]=Rt,P[yt]=j,st=yt;else break t}}return W}function i(P,W){var j=P.sortIndex-W.sortIndex;return j!==0?j:P.id-W.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var r=performance;n.unstable_now=function(){return r.now()}}else{var a=Date,o=a.now();n.unstable_now=function(){return a.now()-o}}var l=[],c=[],h=1,f=null,p=3,g=!1,v=!1,_=!1,S=typeof setTimeout=="function"?setTimeout:null,b=typeof clearTimeout=="function"?clearTimeout:null,T=typeof setImmediate<"u"?setImmediate:null;function C(P){for(var W=e(c);W!==null;){if(W.callback===null)s(c);else if(W.startTime<=P)s(c),W.sortIndex=W.expirationTime,t(l,W);else break;W=e(c)}}function A(P){if(_=!1,C(P),!v)if(e(l)!==null)v=!0,K();else{var W=e(c);W!==null&&Y(A,W.startTime-P)}}var I=!1,D=-1,F=5,z=-1;function k(){return!(n.unstable_now()-z<F)}function O(){if(I){var P=n.unstable_now();z=P;var W=!0;try{t:{v=!1,_&&(_=!1,b(D),D=-1),g=!0;var j=p;try{e:{for(C(P),f=e(l);f!==null&&!(f.expirationTime>P&&k());){var st=f.callback;if(typeof st=="function"){f.callback=null,p=f.priorityLevel;var ot=st(f.expirationTime<=P);if(P=n.unstable_now(),typeof ot=="function"){f.callback=ot,C(P),W=!0;break e}f===e(l)&&s(l),C(P)}else s(l);f=e(l)}if(f!==null)W=!0;else{var X=e(c);X!==null&&Y(A,X.startTime-P),W=!1}}break t}finally{f=null,p=j,g=!1}W=void 0}}finally{W?L():I=!1}}}var L;if(typeof T=="function")L=function(){T(O)};else if(typeof MessageChannel<"u"){var H=new MessageChannel,q=H.port2;H.port1.onmessage=O,L=function(){q.postMessage(null)}}else L=function(){S(O,0)};function K(){I||(I=!0,L())}function Y(P,W){D=S(function(){P(n.unstable_now())},W)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(P){P.callback=null},n.unstable_continueExecution=function(){v||g||(v=!0,K())},n.unstable_forceFrameRate=function(P){0>P||125<P?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):F=0<P?Math.floor(1e3/P):5},n.unstable_getCurrentPriorityLevel=function(){return p},n.unstable_getFirstCallbackNode=function(){return e(l)},n.unstable_next=function(P){switch(p){case 1:case 2:case 3:var W=3;break;default:W=p}var j=p;p=W;try{return P()}finally{p=j}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(P,W){switch(P){case 1:case 2:case 3:case 4:case 5:break;default:P=3}var j=p;p=P;try{return W()}finally{p=j}},n.unstable_scheduleCallback=function(P,W,j){var st=n.unstable_now();switch(typeof j=="object"&&j!==null?(j=j.delay,j=typeof j=="number"&&0<j?st+j:st):j=st,P){case 1:var ot=-1;break;case 2:ot=250;break;case 5:ot=1073741823;break;case 4:ot=1e4;break;default:ot=5e3}return ot=j+ot,P={id:h++,callback:W,priorityLevel:P,startTime:j,expirationTime:ot,sortIndex:-1},j>st?(P.sortIndex=j,t(c,P),e(l)===null&&P===e(c)&&(_?(b(D),D=-1):_=!0,Y(A,j-st))):(P.sortIndex=ot,t(l,P),v||g||(v=!0,K())),P},n.unstable_shouldYield=k,n.unstable_wrapCallback=function(P){var W=p;return function(){var j=p;p=W;try{return P.apply(this,arguments)}finally{p=j}}}})(fI)),fI}var Cz;function fV(){return Cz||(Cz=1,hI.exports=qet()),hI.exports}/**
 * @license React
 * react-reconciler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Az;function Xet(){return Az||(Az=1,(function(n){n.exports=function(t){function e(m,y,E,M){return new xv(m,y,E,M)}function s(){}function i(m){var y="https://react.dev/errors/"+m;if(1<arguments.length){y+="?args[]="+encodeURIComponent(arguments[1]);for(var E=2;E<arguments.length;E++)y+="&args[]="+encodeURIComponent(arguments[E])}return"Minified React error #"+m+"; visit "+y+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(m){return m===null||typeof m!="object"?null:(m=Ev&&m[Ev]||m["@@iterator"],typeof m=="function"?m:null)}function a(m){if(m==null)return null;if(typeof m=="function")return m.$$typeof===Vh?null:m.displayName||m.name||null;if(typeof m=="string")return m;switch(m){case Jf:return"Fragment";case cl:return"Portal";case Tv:return"Profiler";case wv:return"StrictMode";case w0:return"Suspense";case Du:return"SuspenseList"}if(typeof m=="object")switch(m.$$typeof){case Gl:return(m.displayName||"Context")+".Provider";case Ru:return(m._context.displayName||"Context")+".Consumer";case td:var y=m.render;return m=m.displayName,m||(m=y.displayName||y.name||"",m=m!==""?"ForwardRef("+m+")":"ForwardRef"),m;case Wp:return y=m.displayName||null,y!==null?y:a(m.type)||"Memo";case ul:y=m._payload,m=m._init;try{return a(m(y))}catch{}}return null}function o(m){if(T0===void 0)try{throw Error()}catch(E){var y=E.stack.trim().match(/\n( *(at )?)/);T0=y&&y[1]||"",Cv=-1<E.stack.indexOf(`
    at`)?" (<anonymous>)":-1<E.stack.indexOf("@")?"@unknown:0:0":""}return`
`+T0+m+Cv}function l(m,y){if(!m||ku)return"";ku=!0;var E=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var M={DetermineComponentFrameRoot:function(){try{if(y){var $e=function(){throw Error()};if(Object.defineProperty($e.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct($e,[])}catch(En){var Ve=En}Reflect.construct(m,[],$e)}else{try{$e.call()}catch(En){Ve=En}m.call($e.prototype)}}else{try{throw Error()}catch(En){Ve=En}($e=m())&&typeof $e.catch=="function"&&$e.catch(function(){})}}catch(En){if(En&&Ve&&typeof En.stack=="string")return[En.stack,Ve.stack]}return[null,null]}};M.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var $=Object.getOwnPropertyDescriptor(M.DetermineComponentFrameRoot,"name");$&&$.configurable&&Object.defineProperty(M.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var U=M.DetermineComponentFrameRoot(),tt=U[0],mt=U[1];if(tt&&mt){var It=tt.split(`
`),ne=mt.split(`
`);for($=M=0;M<It.length&&!It[M].includes("DetermineComponentFrameRoot");)M++;for(;$<ne.length&&!ne[$].includes("DetermineComponentFrameRoot");)$++;if(M===It.length||$===ne.length)for(M=It.length-1,$=ne.length-1;1<=M&&0<=$&&It[M]!==ne[$];)$--;for(;1<=M&&0<=$;M--,$--)if(It[M]!==ne[$]){if(M!==1||$!==1)do if(M--,$--,0>$||It[M]!==ne[$]){var Te=`
`+It[M].replace(" at new "," at ");return m.displayName&&Te.includes("<anonymous>")&&(Te=Te.replace("<anonymous>",m.displayName)),Te}while(1<=M&&0<=$);break}}}finally{ku=!1,Error.prepareStackTrace=E}return(E=m?m.displayName||m.name:"")?o(E):""}function c(m){switch(m.tag){case 26:case 27:case 5:return o(m.type);case 16:return o("Lazy");case 13:return o("Suspense");case 19:return o("SuspenseList");case 0:case 15:return m=l(m.type,!1),m;case 11:return m=l(m.type.render,!1),m;case 1:return m=l(m.type,!0),m;default:return""}}function h(m){try{var y="";do y+=c(m),m=m.return;while(m);return y}catch(E){return`
Error generating stack: `+E.message+`
`+E.stack}}function f(m){var y=m,E=m;if(m.alternate)for(;y.return;)y=y.return;else{m=y;do y=m,(y.flags&4098)!==0&&(E=y.return),m=y.return;while(m)}return y.tag===3?E:null}function p(m){if(f(m)!==m)throw Error(i(188))}function g(m){var y=m.alternate;if(!y){if(y=f(m),y===null)throw Error(i(188));return y!==m?null:m}for(var E=m,M=y;;){var $=E.return;if($===null)break;var U=$.alternate;if(U===null){if(M=$.return,M!==null){E=M;continue}break}if($.child===U.child){for(U=$.child;U;){if(U===E)return p($),m;if(U===M)return p($),y;U=U.sibling}throw Error(i(188))}if(E.return!==M.return)E=$,M=U;else{for(var tt=!1,mt=$.child;mt;){if(mt===E){tt=!0,E=$,M=U;break}if(mt===M){tt=!0,M=$,E=U;break}mt=mt.sibling}if(!tt){for(mt=U.child;mt;){if(mt===E){tt=!0,E=U,M=$;break}if(mt===M){tt=!0,M=U,E=$;break}mt=mt.sibling}if(!tt)throw Error(i(189))}}if(E.alternate!==M)throw Error(i(190))}if(E.tag!==3)throw Error(i(188));return E.stateNode.current===E?m:y}function v(m){var y=m.tag;if(y===5||y===26||y===27||y===6)return m;for(m=m.child;m!==null;){if(y=v(m),y!==null)return y;m=m.sibling}return null}function _(m){var y=m.tag;if(y===5||y===26||y===27||y===6)return m;for(m=m.child;m!==null;){if(m.tag!==4&&(y=_(m),y!==null))return y;m=m.sibling}return null}function S(m){return{current:m}}function b(m){0>Rc||(m.current=tm[Rc],tm[Rc]=null,Rc--)}function T(m,y){Rc++,tm[Rc]=m.current,m.current=y}function C(m){return m>>>=0,m===0?32:31-(em(m)/ww|0)|0}function A(m){var y=m&42;if(y!==0)return y;switch(m&-m){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return m&4194176;case 4194304:case 8388608:case 16777216:case 33554432:return m&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return m}}function I(m,y){var E=m.pendingLanes;if(E===0)return 0;var M=0,$=m.suspendedLanes,U=m.pingedLanes,tt=m.warmLanes;m=m.finishedLanes!==0;var mt=E&134217727;return mt!==0?(E=mt&~$,E!==0?M=A(E):(U&=mt,U!==0?M=A(U):m||(tt=mt&~tt,tt!==0&&(M=A(tt))))):(mt=E&~$,mt!==0?M=A(mt):U!==0?M=A(U):m||(tt=E&~tt,tt!==0&&(M=A(tt)))),M===0?0:y!==0&&y!==M&&(y&$)===0&&($=M&-M,tt=y&-y,$>=tt||$===32&&(tt&4194176)!==0)?y:M}function D(m,y){return(m.pendingLanes&~(m.suspendedLanes&~m.pingedLanes)&y)===0}function F(m,y){switch(m){case 1:case 2:case 4:case 8:return y+250;case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return y+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function z(){var m=id;return id<<=1,(id&4194176)===0&&(id=128),m}function k(){var m=nm;return nm<<=1,(nm&62914560)===0&&(nm=4194304),m}function O(m){for(var y=[],E=0;31>E;E++)y.push(m);return y}function L(m,y){m.pendingLanes|=y,y!==268435456&&(m.suspendedLanes=0,m.pingedLanes=0,m.warmLanes=0)}function H(m,y,E,M,$,U){var tt=m.pendingLanes;m.pendingLanes=E,m.suspendedLanes=0,m.pingedLanes=0,m.warmLanes=0,m.expiredLanes&=E,m.entangledLanes&=E,m.errorRecoveryDisabledLanes&=E,m.shellSuspendCounter=0;var mt=m.entanglements,It=m.expirationTimes,ne=m.hiddenUpdates;for(E=tt&~E;0<E;){var Te=31-wa(E),$e=1<<Te;mt[Te]=0,It[Te]=-1;var Ve=ne[Te];if(Ve!==null)for(ne[Te]=null,Te=0;Te<Ve.length;Te++){var En=Ve[Te];En!==null&&(En.lane&=-536870913)}E&=~$e}M!==0&&q(m,M,0),U!==0&&$===0&&m.tag!==0&&(m.suspendedLanes|=U&~(tt&~y))}function q(m,y,E){m.pendingLanes|=y,m.suspendedLanes&=~y;var M=31-wa(y);m.entangledLanes|=y,m.entanglements[M]=m.entanglements[M]|1073741824|E&4194218}function K(m,y){var E=m.entangledLanes|=y;for(m=m.entanglements;E;){var M=31-wa(E),$=1<<M;$&y|m[M]&y&&(m[M]|=y),E&=~$}}function Y(m){return m&=-m,2<m?8<m?(m&134217727)!==0?32:268435456:8:2}function P(m){if(Ta&&typeof Ta.onCommitFiberRoot=="function")try{Ta.onCommitFiberRoot(ad,m,void 0,(m.current.flags&128)===128)}catch{}}function W(m){if(typeof Aw=="function"&&sb(m),Ta&&typeof Ta.setStrictMode=="function")try{Ta.setStrictMode(ad,m)}catch{}}function j(m,y){return m===y&&(m!==0||1/m===1/y)||m!==m&&y!==y}function st(m,y){if(typeof m=="object"&&m!==null){var E=P0.get(m);return E!==void 0?E:(y={value:m,source:y,stack:h(y)},P0.set(m,y),y)}return{value:m,source:y,stack:h(y)}}function ot(m,y){ti[yi++]=rm,ti[yi++]=im,im=m,rm=y}function X(m,y,E){io[ro++]=jl,io[ro++]=$o,io[ro++]=hl,hl=m;var M=jl;m=$o;var $=32-wa(M)-1;M&=~(1<<$),E+=1;var U=32-wa(y)+$;if(30<U){var tt=$-$%5;U=(M&(1<<tt)-1).toString(32),M>>=tt,$-=tt,jl=1<<32-wa(y)+$|E<<$|M,$o=U+m}else jl=1<<U|E<<$|M,$o=m}function it(m){m.return!==null&&(ot(m,1),X(m,1,0))}function ct(m){for(;m===im;)im=ti[--yi],ti[yi]=null,rm=ti[--yi],ti[yi]=null;for(;m===hl;)hl=io[--ro],io[ro]=null,$o=io[--ro],io[ro]=null,jl=io[--ro],io[ro]=null}function yt(m,y){T(fl,y),T(am,m),T(mr,null),m=Gh(y),b(mr),T(mr,m)}function Rt(){b(mr),b(am),b(fl)}function ft(m){m.memoizedState!==null&&T(od,m);var y=mr.current,E=nw(y,m.type);y!==E&&(T(am,m),T(mr,E))}function _t(m){am.current===m&&(b(mr),b(am)),od.current===m&&(b(od),Wl?xn._currentValue=_a:xn._currentValue2=_a)}function qt(m){var y=Error(i(418,""));throw Ae(st(y,m)),om}function Qt(m,y){if(!la)throw Error(i(175));DN(m.stateNode,m.type,m.memoizedProps,y,m)||qt(m)}function se(m){for(Hr=m.return;Hr;)switch(Hr.tag){case 3:case 27:Lo=!0;return;case 5:case 13:Lo=!1;return;default:Hr=Hr.return}}function Ee(m){if(!la||m!==Hr)return!1;if(!is)return se(m),is=!0,!1;var y=!1;if(Nr?m.tag!==3&&m.tag!==27&&(m.tag!==5||xw(m.type)&&!Lu(m.type,m.memoizedProps))&&(y=!0):m.tag!==3&&(m.tag!==5||xw(m.type)&&!Lu(m.type,m.memoizedProps))&&(y=!0),y&&Ir&&qt(m),se(m),m.tag===13){if(!la)throw Error(i(316));if(m=m.memoizedState,m=m!==null?m.dehydrated:null,!m)throw Error(i(317));Ir=gw(m)}else Ir=Hr?Hv(m.stateNode):null;return!0}function He(){la&&(Ir=Hr=null,is=!1)}function Ae(m){ao===null?ao=[m]:ao.push(m)}function Ht(){for(var m=zu,y=ld=zu=0;y<m;){var E=oo[y];oo[y++]=null;var M=oo[y];oo[y++]=null;var $=oo[y];oo[y++]=null;var U=oo[y];if(oo[y++]=null,M!==null&&$!==null){var tt=M.pending;tt===null?$.next=$:($.next=tt.next,tt.next=$),M.pending=$}U!==0&&rt(E,$,U)}}function Jt(m,y,E,M){oo[zu++]=m,oo[zu++]=y,oo[zu++]=E,oo[zu++]=M,ld|=M,m.lanes|=M,m=m.alternate,m!==null&&(m.lanes|=M)}function Xt(m,y,E,M){return Jt(m,y,E,M),Fe(m)}function ce(m,y){return Jt(m,null,null,y),Fe(m)}function rt(m,y,E){m.lanes|=E;var M=m.alternate;M!==null&&(M.lanes|=E);for(var $=!1,U=m.return;U!==null;)U.childLanes|=E,M=U.alternate,M!==null&&(M.childLanes|=E),U.tag===22&&(m=U.stateNode,m===null||m._visibility&1||($=!0)),m=U,U=U.return;$&&y!==null&&m.tag===3&&(U=m.stateNode,$=31-wa(E),U=U.hiddenUpdates,m=U[$],m===null?U[$]=[y]:m.push(y),y.lane=E|536870912)}function Fe(m){if(50<tf)throw tf=0,ha=null,Error(i(185));for(var y=m.return;y!==null;)m=y,y=m.return;return m.tag===3?m.stateNode:null}function he(m){m!==Xh&&m.next===null&&(Xh===null?cd=Xh=m:Xh=Xh.next=m),cm=!0,lm||(lm=!0,Vt(pe))}function Pe(m,y){if(!dl&&cm){dl=!0;do for(var E=!1,M=cd;M!==null;){if(m!==0){var $=M.pendingLanes;if($===0)var U=0;else{var tt=M.suspendedLanes,mt=M.pingedLanes;U=(1<<31-wa(42|m)+1)-1,U&=$&~(tt&~mt),U=U&201326677?U&201326677|1:U?U|2:0}U!==0&&(E=!0,vt(M,U))}else U=Un,U=I(M,M===Gn?U:0),(U&3)===0||D(M,U)||(E=!0,vt(M,U));M=M.next}while(E);dl=!1}}function pe(){cm=lm=!1;var m=0;Uu!==0&&(Fu()&&(m=Uu),Uu=0);for(var y=Mr(),E=null,M=cd;M!==null;){var $=M.next,U=nt(M,y);U===0?(M.next=null,E===null?cd=$:E.next=$,$===null&&(Xh=E)):(E=M,(m!==0||(U&3)!==0)&&(cm=!0)),M=$}Pe(m)}function nt(m,y){for(var E=m.suspendedLanes,M=m.pingedLanes,$=m.expirationTimes,U=m.pendingLanes&-62914561;0<U;){var tt=31-wa(U),mt=1<<tt,It=$[tt];It===-1?((mt&E)===0||(mt&M)!==0)&&($[tt]=F(mt,y)):It<=y&&(m.expiredLanes|=mt),U&=~mt}if(y=Gn,E=Un,E=I(m,m===y?E:0),M=m.callbackNode,E===0||m===y&&$s===2||m.cancelPendingCommit!==null)return M!==null&&M!==null&&sm(M),m.callbackNode=null,m.callbackPriority=0;if((E&3)===0||D(m,E)){if(y=E&-E,y===m.callbackPriority)return y;switch(M!==null&&sm(M),Y(E)){case 2:case 8:E=Cw;break;case 32:E=U0;break;case 268435456:E=B0;break;default:E=U0}return M=G.bind(null,m),E=rd(E,M),m.callbackPriority=y,m.callbackNode=E,y}return M!==null&&M!==null&&sm(M),m.callbackPriority=2,m.callbackNode=null,2}function G(m,y){var E=m.callbackNode;if(dr()&&m.callbackNode!==E)return null;var M=Un;return M=I(m,m===Gn?M:0),M===0?null:(Bp(m,M,y),nt(m,Mr()),m.callbackNode!=null&&m.callbackNode===E?G.bind(null,m):null)}function vt(m,y){if(dr())return null;Bp(m,y,!0)}function Vt(m){zi?N0(function(){(an&6)!==0?rd(nb,m):m()}):rd(nb,m)}function te(){return Uu===0&&(Uu=z()),Uu}function Pt(m,y){if(um===null){var E=um=[];V0=0,Ea=te(),Bu={status:"pending",value:void 0,then:function(M){E.push(M)}}}return V0++,y.then(Ue,Ue),y}function Ue(){if(--V0===0&&um!==null){Bu!==null&&(Bu.status="fulfilled");var m=um;um=null,Ea=0,Bu=null;for(var y=0;y<m.length;y++)(0,m[y])()}}function we(m,y){var E=[],M={status:"pending",value:null,reason:null,then:function($){E.push($)}};return m.then(function(){M.status="fulfilled",M.value=y;for(var $=0;$<E.length;$++)(0,E[$])(y)},function($){for(M.status="rejected",M.reason=$,$=0;$<E.length;$++)(0,E[$])(void 0)}),M}function ze(m){m.updateQueue={baseState:m.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function nn(m,y){m=m.updateQueue,y.updateQueue===m&&(y.updateQueue={baseState:m.baseState,firstBaseUpdate:m.firstBaseUpdate,lastBaseUpdate:m.lastBaseUpdate,shared:m.shared,callbacks:null})}function ae(m){return{lane:m,tag:0,payload:null,callback:null,next:null}}function de(m,y,E){var M=m.updateQueue;if(M===null)return null;if(M=M.shared,(an&2)!==0){var $=M.pending;return $===null?y.next=y:(y.next=$.next,$.next=y),M.pending=y,y=Fe(m),rt(m,null,E),y}return Jt(m,M,y,E),Fe(m)}function Ne(m,y,E){if(y=y.updateQueue,y!==null&&(y=y.shared,(E&4194176)!==0)){var M=y.lanes;M&=m.pendingLanes,E|=M,y.lanes=E,K(m,E)}}function ut(m,y){var E=m.updateQueue,M=m.alternate;if(M!==null&&(M=M.updateQueue,E===M)){var $=null,U=null;if(E=E.firstBaseUpdate,E!==null){do{var tt={lane:E.lane,tag:E.tag,payload:E.payload,callback:null,next:null};U===null?$=U=tt:U=U.next=tt,E=E.next}while(E!==null);U===null?$=U=y:U=U.next=y}else $=U=y;E={baseState:M.baseState,firstBaseUpdate:$,lastBaseUpdate:U,shared:M.shared,callbacks:M.callbacks},m.updateQueue=E;return}m=E.lastBaseUpdate,m===null?E.firstBaseUpdate=y:m.next=y,E.lastBaseUpdate=y}function kt(){if(ud){var m=Bu;if(m!==null)throw m}}function Se(m,y,E,M){ud=!1;var $=m.updateQueue;Dc=!1;var U=$.firstBaseUpdate,tt=$.lastBaseUpdate,mt=$.shared.pending;if(mt!==null){$.shared.pending=null;var It=mt,ne=It.next;It.next=null,tt===null?U=ne:tt.next=ne,tt=It;var Te=m.alternate;Te!==null&&(Te=Te.updateQueue,mt=Te.lastBaseUpdate,mt!==tt&&(mt===null?Te.firstBaseUpdate=ne:mt.next=ne,Te.lastBaseUpdate=It))}if(U!==null){var $e=$.baseState;tt=0,Te=ne=It=null,mt=U;do{var Ve=mt.lane&-536870913,En=Ve!==mt.lane;if(En?(Un&Ve)===Ve:(M&Ve)===Ve){Ve!==0&&Ve===Ea&&(ud=!0),Te!==null&&(Te=Te.next={lane:0,tag:mt.tag,payload:mt.payload,callback:null,next:null});t:{var Ma=m,pm=mt;Ve=y;var ef=E;switch(pm.tag){case 1:if(Ma=pm.payload,typeof Ma=="function"){$e=Ma.call(ef,$e,Ve);break t}$e=Ma;break t;case 3:Ma.flags=Ma.flags&-65537|128;case 0:if(Ma=pm.payload,Ve=typeof Ma=="function"?Ma.call(ef,$e,Ve):Ma,Ve==null)break t;$e=Ph({},$e,Ve);break t;case 2:Dc=!0}}Ve=mt.callback,Ve!==null&&(m.flags|=64,En&&(m.flags|=8192),En=$.callbacks,En===null?$.callbacks=[Ve]:En.push(Ve))}else En={lane:Ve,tag:mt.tag,payload:mt.payload,callback:mt.callback,next:null},Te===null?(ne=Te=En,It=$e):Te=Te.next=En,tt|=Ve;if(mt=mt.next,mt===null){if(mt=$.shared.pending,mt===null)break;En=mt,mt=En.next,En.next=null,$.lastBaseUpdate=En,$.shared.pending=null}}while(!0);Te===null&&(It=$e),$.baseState=It,$.firstBaseUpdate=ne,$.lastBaseUpdate=Te,U===null&&($.shared.lanes=0),ho|=tt,m.lanes=tt,m.memoizedState=$e}}function dt(m,y){if(typeof m!="function")throw Error(i(191,m));m.call(y)}function ye(m,y){var E=m.callbacks;if(E!==null)for(m.callbacks=null,m=0;m<E.length;m++)dt(E[m],y)}function fe(m,y){if(so(m,y))return!0;if(typeof m!="object"||m===null||typeof y!="object"||y===null)return!1;var E=Object.keys(m),M=Object.keys(y);if(E.length!==M.length)return!1;for(M=0;M<E.length;M++){var $=E[M];if(!hm.call(y,$)||!so(m[$],y[$]))return!1}return!0}function Ce(m){return m=m.status,m==="fulfilled"||m==="rejected"}function ue(){}function ie(m,y,E){switch(E=m[E],E===void 0?m.push(y):E!==y&&(y.then(ue,ue),y=E),y.status){case"fulfilled":return y.value;case"rejected":throw m=y.reason,m===Rs?Error(i(483)):m;default:if(typeof y.status=="string")y.then(ue,ue);else{if(m=Gn,m!==null&&100<m.shellSuspendCounter)throw Error(i(482));m=y,m.status="pending",m.then(function(M){if(y.status==="pending"){var $=y;$.status="fulfilled",$.value=M}},function(M){if(y.status==="pending"){var $=y;$.status="rejected",$.reason=M}})}switch(y.status){case"fulfilled":return y.value;case"rejected":throw m=y.reason,m===Rs?Error(i(483)):m}throw jh=y,Rs}}function ve(){if(jh===null)throw Error(i(459));var m=jh;return jh=null,m}function Je(m){var y=Fo;return Fo+=1,Kl===null&&(Kl=[]),ie(Kl,m,y)}function zn(m,y){y=y.props.ref,m.ref=y!==void 0?y:null}function Mn(m,y){throw y.$$typeof===_v?Error(i(525)):(m=Object.prototype.toString.call(y),Error(i(31,m==="[object Object]"?"object with keys {"+Object.keys(y).join(", ")+"}":m)))}function li(m){var y=m._init;return y(m._payload)}function wr(m){function y(zt,Nt){if(m){var Wt=zt.deletions;Wt===null?(zt.deletions=[Nt],zt.flags|=16):Wt.push(Nt)}}function E(zt,Nt){if(!m)return null;for(;Nt!==null;)y(zt,Nt),Nt=Nt.sibling;return null}function M(zt){for(var Nt=new Map;zt!==null;)zt.key!==null?Nt.set(zt.key,zt):Nt.set(zt.index,zt),zt=zt.sibling;return Nt}function $(zt,Nt){return zt=Vr(zt,Nt),zt.index=0,zt.sibling=null,zt}function U(zt,Nt,Wt){return zt.index=Wt,m?(Wt=zt.alternate,Wt!==null?(Wt=Wt.index,Wt<Nt?(zt.flags|=33554434,Nt):Wt):(zt.flags|=33554434,Nt)):(zt.flags|=1048576,Nt)}function tt(zt){return m&&zt.alternate===null&&(zt.flags|=33554434),zt}function mt(zt,Nt,Wt,xe){return Nt===null||Nt.tag!==6?(Nt=Iu(Wt,zt.mode,xe),Nt.return=zt,Nt):(Nt=$(Nt,Wt),Nt.return=zt,Nt)}function It(zt,Nt,Wt,xe){var sn=Wt.type;return sn===Jf?Te(zt,Nt,Wt.props.children,xe,Wt.key):Nt!==null&&(Nt.elementType===sn||typeof sn=="object"&&sn!==null&&sn.$$typeof===ul&&li(sn)===Nt.type)?(Nt=$(Nt,Wt.props),zn(Nt,Wt),Nt.return=zt,Nt):(Nt=ko(Wt.type,Wt.key,Wt.props,null,zt.mode,xe),zn(Nt,Wt),Nt.return=zt,Nt)}function ne(zt,Nt,Wt,xe){return Nt===null||Nt.tag!==4||Nt.stateNode.containerInfo!==Wt.containerInfo||Nt.stateNode.implementation!==Wt.implementation?(Nt=Qf(Wt,zt.mode,xe),Nt.return=zt,Nt):(Nt=$(Nt,Wt.children||[]),Nt.return=zt,Nt)}function Te(zt,Nt,Wt,xe,sn){return Nt===null||Nt.tag!==7?(Nt=Cc(Wt,zt.mode,xe,sn),Nt.return=zt,Nt):(Nt=$(Nt,Wt),Nt.return=zt,Nt)}function $e(zt,Nt,Wt){if(typeof Nt=="string"&&Nt!==""||typeof Nt=="number"||typeof Nt=="bigint")return Nt=Iu(""+Nt,zt.mode,Wt),Nt.return=zt,Nt;if(typeof Nt=="object"&&Nt!==null){switch(Nt.$$typeof){case Ac:return Wt=ko(Nt.type,Nt.key,Nt.props,null,zt.mode,Wt),zn(Wt,Nt),Wt.return=zt,Wt;case cl:return Nt=Qf(Nt,zt.mode,Wt),Nt.return=zt,Nt;case ul:var xe=Nt._init;return Nt=xe(Nt._payload),$e(zt,Nt,Wt)}if(Ou(Nt)||r(Nt))return Nt=Cc(Nt,zt.mode,Wt,null),Nt.return=zt,Nt;if(typeof Nt.then=="function")return $e(zt,Je(Nt),Wt);if(Nt.$$typeof===Gl)return $e(zt,$p(zt,Nt),Wt);Mn(zt,Nt)}return null}function Ve(zt,Nt,Wt,xe){var sn=Nt!==null?Nt.key:null;if(typeof Wt=="string"&&Wt!==""||typeof Wt=="number"||typeof Wt=="bigint")return sn!==null?null:mt(zt,Nt,""+Wt,xe);if(typeof Wt=="object"&&Wt!==null){switch(Wt.$$typeof){case Ac:return Wt.key===sn?It(zt,Nt,Wt,xe):null;case cl:return Wt.key===sn?ne(zt,Nt,Wt,xe):null;case ul:return sn=Wt._init,Wt=sn(Wt._payload),Ve(zt,Nt,Wt,xe)}if(Ou(Wt)||r(Wt))return sn!==null?null:Te(zt,Nt,Wt,xe,null);if(typeof Wt.then=="function")return Ve(zt,Nt,Je(Wt),xe);if(Wt.$$typeof===Gl)return Ve(zt,Nt,$p(zt,Wt),xe);Mn(zt,Wt)}return null}function En(zt,Nt,Wt,xe,sn){if(typeof xe=="string"&&xe!==""||typeof xe=="number"||typeof xe=="bigint")return zt=zt.get(Wt)||null,mt(Nt,zt,""+xe,sn);if(typeof xe=="object"&&xe!==null){switch(xe.$$typeof){case Ac:return zt=zt.get(xe.key===null?Wt:xe.key)||null,It(Nt,zt,xe,sn);case cl:return zt=zt.get(xe.key===null?Wt:xe.key)||null,ne(Nt,zt,xe,sn);case ul:var Xs=xe._init;return xe=Xs(xe._payload),En(zt,Nt,Wt,xe,sn)}if(Ou(xe)||r(xe))return zt=zt.get(Wt)||null,Te(Nt,zt,xe,sn,null);if(typeof xe.then=="function")return En(zt,Nt,Wt,Je(xe),sn);if(xe.$$typeof===Gl)return En(zt,Nt,Wt,$p(Nt,xe),sn);Mn(Nt,xe)}return null}function Ma(zt,Nt,Wt,xe){for(var sn=null,Xs=null,vn=Nt,as=Nt=0,tr=null;vn!==null&&as<Wt.length;as++){vn.index>as?(tr=vn,vn=null):tr=vn.sibling;var os=Ve(zt,vn,Wt[as],xe);if(os===null){vn===null&&(vn=tr);break}m&&vn&&os.alternate===null&&y(zt,vn),Nt=U(os,Nt,as),Xs===null?sn=os:Xs.sibling=os,Xs=os,vn=tr}if(as===Wt.length)return E(zt,vn),is&&ot(zt,as),sn;if(vn===null){for(;as<Wt.length;as++)vn=$e(zt,Wt[as],xe),vn!==null&&(Nt=U(vn,Nt,as),Xs===null?sn=vn:Xs.sibling=vn,Xs=vn);return is&&ot(zt,as),sn}for(vn=M(vn);as<Wt.length;as++)tr=En(vn,zt,as,Wt[as],xe),tr!==null&&(m&&tr.alternate!==null&&vn.delete(tr.key===null?as:tr.key),Nt=U(tr,Nt,as),Xs===null?sn=tr:Xs.sibling=tr,Xs=tr);return m&&vn.forEach(function(Uc){return y(zt,Uc)}),is&&ot(zt,as),sn}function pm(zt,Nt,Wt,xe){if(Wt==null)throw Error(i(151));for(var sn=null,Xs=null,vn=Nt,as=Nt=0,tr=null,os=Wt.next();vn!==null&&!os.done;as++,os=Wt.next()){vn.index>as?(tr=vn,vn=null):tr=vn.sibling;var Uc=Ve(zt,vn,os.value,xe);if(Uc===null){vn===null&&(vn=tr);break}m&&vn&&Uc.alternate===null&&y(zt,vn),Nt=U(Uc,Nt,as),Xs===null?sn=Uc:Xs.sibling=Uc,Xs=Uc,vn=tr}if(os.done)return E(zt,vn),is&&ot(zt,as),sn;if(vn===null){for(;!os.done;as++,os=Wt.next())os=$e(zt,os.value,xe),os!==null&&(Nt=U(os,Nt,as),Xs===null?sn=os:Xs.sibling=os,Xs=os);return is&&ot(zt,as),sn}for(vn=M(vn);!os.done;as++,os=Wt.next())os=En(vn,zt,as,os.value,xe),os!==null&&(m&&os.alternate!==null&&vn.delete(os.key===null?as:os.key),Nt=U(os,Nt,as),Xs===null?sn=os:Xs.sibling=os,Xs=os);return m&&vn.forEach(function(Z0){return y(zt,Z0)}),is&&ot(zt,as),sn}function ef(zt,Nt,Wt,xe){if(typeof Wt=="object"&&Wt!==null&&Wt.type===Jf&&Wt.key===null&&(Wt=Wt.props.children),typeof Wt=="object"&&Wt!==null){switch(Wt.$$typeof){case Ac:t:{for(var sn=Wt.key;Nt!==null;){if(Nt.key===sn){if(sn=Wt.type,sn===Jf){if(Nt.tag===7){E(zt,Nt.sibling),xe=$(Nt,Wt.props.children),xe.return=zt,zt=xe;break t}}else if(Nt.elementType===sn||typeof sn=="object"&&sn!==null&&sn.$$typeof===ul&&li(sn)===Nt.type){E(zt,Nt.sibling),xe=$(Nt,Wt.props),zn(xe,Wt),xe.return=zt,zt=xe;break t}E(zt,Nt);break}else y(zt,Nt);Nt=Nt.sibling}Wt.type===Jf?(xe=Cc(Wt.props.children,zt.mode,xe,Wt.key),xe.return=zt,zt=xe):(xe=ko(Wt.type,Wt.key,Wt.props,null,zt.mode,xe),zn(xe,Wt),xe.return=zt,zt=xe)}return tt(zt);case cl:t:{for(sn=Wt.key;Nt!==null;){if(Nt.key===sn)if(Nt.tag===4&&Nt.stateNode.containerInfo===Wt.containerInfo&&Nt.stateNode.implementation===Wt.implementation){E(zt,Nt.sibling),xe=$(Nt,Wt.children||[]),xe.return=zt,zt=xe;break t}else{E(zt,Nt);break}else y(zt,Nt);Nt=Nt.sibling}xe=Qf(Wt,zt.mode,xe),xe.return=zt,zt=xe}return tt(zt);case ul:return sn=Wt._init,Wt=sn(Wt._payload),ef(zt,Nt,Wt,xe)}if(Ou(Wt))return Ma(zt,Nt,Wt,xe);if(r(Wt)){if(sn=r(Wt),typeof sn!="function")throw Error(i(150));return Wt=sn.call(Wt),pm(zt,Nt,Wt,xe)}if(typeof Wt.then=="function")return ef(zt,Nt,Je(Wt),xe);if(Wt.$$typeof===Gl)return ef(zt,Nt,$p(zt,Wt),xe);Mn(zt,Wt)}return typeof Wt=="string"&&Wt!==""||typeof Wt=="number"||typeof Wt=="bigint"?(Wt=""+Wt,Nt!==null&&Nt.tag===6?(E(zt,Nt.sibling),xe=$(Nt,Wt),xe.return=zt,zt=xe):(E(zt,Nt),xe=Iu(Wt,zt.mode,xe),xe.return=zt,zt=xe),tt(zt)):E(zt,Nt)}return function(zt,Nt,Wt,xe){try{Fo=0;var sn=ef(zt,Nt,Wt,xe);return Kl=null,sn}catch(vn){if(vn===Rs)throw vn;var Xs=e(29,vn,null,zt.mode);return Xs.lanes=xe,Xs.return=zt,Xs}finally{}}}function Ep(m,y){m=pl,T(lo,m),T(Yl,y),pl=m|y.baseLanes}function _h(){T(lo,pl),T(Yl,Yl.current)}function du(){pl=lo.current,b(Yl),b(lo)}function Io(m){var y=m.alternate;T(Ui,Ui.current&1),T(co,m),zo===null&&(y===null||Yl.current!==null||y.memoizedState!==null)&&(zo=m)}function wh(m){if(m.tag===22){if(T(Ui,Ui.current),T(co,m),zo===null){var y=m.alternate;y!==null&&y.memoizedState!==null&&(zo=m)}}else Ro()}function Ro(){T(Ui,Ui.current),T(co,co.current)}function lr(m){b(co),zo===m&&(zo=null),b(Ui)}function ia(m){for(var y=m;y!==null;){if(y.tag===13){var E=y.memoizedState;if(E!==null&&(E=E.dehydrated,E===null||k0(E)||Jp(E)))return y}else if(y.tag===19&&y.memoizedProps.revealOrder!==void 0){if((y.flags&128)!==0)return y}else if(y.child!==null){y.child.return=y,y=y.child;continue}if(y===m)break;for(;y.sibling===null;){if(y.return===null||y.return===m)return null;y=y.return}y.sibling.return=y.return,y=y.sibling}return null}function $n(){throw Error(i(321))}function Zi(m,y){if(y===null)return!1;for(var E=0;E<y.length&&E<m.length;E++)if(!so(m[E],y[E]))return!1;return!0}function Ka(m,y,E,M,$,U){return Zl=U,Dn=y,y.memoizedState=null,y.updateQueue=null,y.lanes=0,dn.H=m===null||m.memoizedState===null?Bi:Wr,kc=!1,U=E(M,$),kc=!1,ei&&(U=Eh(y,E,M,$)),Th(m),U}function Th(m){dn.H=rs;var y=xs!==null&&xs.next!==null;if(Zl=0,Ai=xs=Dn=null,Uo=!1,xi=0,hd=null,y)throw Error(i(300));m===null||Ni||(m=m.dependencies,m!==null&&vu(m)&&(Ni=!0))}function Eh(m,y,E,M){Dn=m;var $=0;do{if(ei&&(hd=null),xi=0,ei=!1,25<=$)throw Error(i(301));if($+=1,Ai=xs=null,m.updateQueue!=null){var U=m.updateQueue;U.lastEffect=null,U.events=null,U.stores=null,U.memoCache!=null&&(U.memoCache.index=0)}dn.H=Vu,U=y(E,M)}while(ei);return U}function Zg(){var m=dn.H,y=m.useState()[0];return y=typeof y.then=="function"?il(y):y,m=m.useState()[0],(xs!==null?xs.memoizedState:null)!==m&&(Dn.flags|=1024),y}function Ch(){var m=fm!==0;return fm=0,m}function yc(m,y,E){y.updateQueue=m.updateQueue,y.flags&=-2053,m.lanes&=~E}function Ah(m){if(Uo){for(m=m.memoizedState;m!==null;){var y=m.queue;y!==null&&(y.pending=null),m=m.next}Uo=!1}Zl=0,Ai=xs=Dn=null,ei=!1,xi=fm=0,hd=null}function Ei(){var m={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Ai===null?Dn.memoizedState=Ai=m:Ai=Ai.next=m,Ai}function Us(){if(xs===null){var m=Dn.alternate;m=m!==null?m.memoizedState:null}else m=xs.next;var y=Ai===null?Dn.memoizedState:Ai.next;if(y!==null)Ai=y,xs=m;else{if(m===null)throw Dn.alternate===null?Error(i(467)):Error(i(310));xs=m,m={memoizedState:xs.memoizedState,baseState:xs.baseState,baseQueue:xs.baseQueue,queue:xs.queue,next:null},Ai===null?Dn.memoizedState=Ai=m:Ai=Ai.next=m}return Ai}function il(m){var y=xi;return xi+=1,hd===null&&(hd=[]),m=ie(hd,m,y),y=Dn,(Ai===null?y.memoizedState:Ai.next)===null&&(y=y.alternate,dn.H=y===null||y.memoizedState===null?Bi:Wr),m}function rl(m){if(m!==null&&typeof m=="object"){if(typeof m.then=="function")return il(m);if(m.$$typeof===Gl)return Er(m)}throw Error(i(438,String(m)))}function Z(m){var y=null,E=Dn.updateQueue;if(E!==null&&(y=E.memoCache),y==null){var M=Dn.alternate;M!==null&&(M=M.updateQueue,M!==null&&(M=M.memoCache,M!=null&&(y={data:M.data.map(function($){return $.slice()}),index:0})))}if(y==null&&(y={data:[],index:0}),E===null&&(E=H0(),Dn.updateQueue=E),E.memoCache=y,E=y.data[y.index],E===void 0)for(E=y.data[y.index]=Array(m),M=0;M<m;M++)E[M]=ew;return y.index++,E}function Et(m,y){return typeof y=="function"?y(m):y}function Gt(m){var y=Us();return Ft(y,xs,m)}function Ft(m,y,E){var M=m.queue;if(M===null)throw Error(i(311));M.lastRenderedReducer=E;var $=m.baseQueue,U=M.pending;if(U!==null){if($!==null){var tt=$.next;$.next=U.next,U.next=tt}y.baseQueue=$=U,M.pending=null}if(U=m.baseState,$===null)m.memoizedState=U;else{y=$.next;var mt=tt=null,It=null,ne=y,Te=!1;do{var $e=ne.lane&-536870913;if($e!==ne.lane?(Un&$e)===$e:(Zl&$e)===$e){var Ve=ne.revertLane;if(Ve===0)It!==null&&(It=It.next={lane:0,revertLane:0,action:ne.action,hasEagerState:ne.hasEagerState,eagerState:ne.eagerState,next:null}),$e===Ea&&(Te=!0);else if((Zl&Ve)===Ve){ne=ne.next,Ve===Ea&&(Te=!0);continue}else $e={lane:0,revertLane:ne.revertLane,action:ne.action,hasEagerState:ne.hasEagerState,eagerState:ne.eagerState,next:null},It===null?(mt=It=$e,tt=U):It=It.next=$e,Dn.lanes|=Ve,ho|=Ve;$e=ne.action,kc&&E(U,$e),U=ne.hasEagerState?ne.eagerState:E(U,$e)}else Ve={lane:$e,revertLane:ne.revertLane,action:ne.action,hasEagerState:ne.hasEagerState,eagerState:ne.eagerState,next:null},It===null?(mt=It=Ve,tt=U):It=It.next=Ve,Dn.lanes|=$e,ho|=$e;ne=ne.next}while(ne!==null&&ne!==y);if(It===null?tt=U:It.next=mt,!so(U,m.memoizedState)&&(Ni=!0,Te&&(E=Bu,E!==null)))throw E;m.memoizedState=U,m.baseState=tt,m.baseQueue=It,M.lastRenderedState=U}return $===null&&(M.lanes=0),[m.memoizedState,M.dispatch]}function Dt(m){var y=Us(),E=y.queue;if(E===null)throw Error(i(311));E.lastRenderedReducer=m;var M=E.dispatch,$=E.pending,U=y.memoizedState;if($!==null){E.pending=null;var tt=$=$.next;do U=m(U,tt.action),tt=tt.next;while(tt!==$);so(U,y.memoizedState)||(Ni=!0),y.memoizedState=U,y.baseQueue===null&&(y.baseState=U),E.lastRenderedState=U}return[U,M]}function Me(m,y,E){var M=Dn,$=Us(),U=is;if(U){if(E===void 0)throw Error(i(407));E=E()}else E=y();var tt=!so((xs||$).memoizedState,E);if(tt&&($.memoizedState=E,Ni=!0),$=$.queue,Ya(qe.bind(null,M,$,m),[m]),$.getSnapshot!==y||tt||Ai!==null&&Ai.memoizedState.tag&1){if(M.flags|=2048,pi(9,De.bind(null,M,$,E,y),{destroy:void 0},null),Gn===null)throw Error(i(349));U||(Zl&60)!==0||We(M,y,E)}return E}function We(m,y,E){m.flags|=16384,m={getSnapshot:y,value:E},y=Dn.updateQueue,y===null?(y=H0(),Dn.updateQueue=y,y.stores=[m]):(E=y.stores,E===null?y.stores=[m]:E.push(m))}function De(m,y,E,M){y.value=E,y.getSnapshot=M,Ke(y)&&cn(m)}function qe(m,y,E){return E(function(){Ke(y)&&cn(m)})}function Ke(m){var y=m.getSnapshot;m=m.value;try{var E=y();return!so(m,E)}catch{return!0}}function cn(m){var y=ce(m,2);y!==null&&Pr(y,m,2)}function Xe(m){var y=Ei();if(typeof m=="function"){var E=m;if(m=E(),kc){W(!0);try{E()}finally{W(!1)}}}return y.memoizedState=y.baseState=m,y.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Et,lastRenderedState:m},y}function fn(m,y,E,M){return m.baseState=E,Ft(m,xs,typeof M=="function"?M:Et)}function gs(m,y,E,M,$){if(Rh(m))throw Error(i(485));if(m=y.action,m!==null){var U={payload:$,action:m,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(tt){U.listeners.push(tt)}};dn.T!==null?E(!0):U.isTransition=!1,M(U),E=y.pending,E===null?(U.next=y.pending=U,Zs(y,U)):(U.next=E.next,y.pending=E.next=U)}}function Zs(m,y){var E=y.action,M=y.payload,$=m.state;if(y.isTransition){var U=dn.T,tt={};dn.T=tt;try{var mt=E($,M),It=dn.S;It!==null&&It(tt,mt),Bs(m,y,mt)}catch(ne){tn(m,y,ne)}finally{dn.T=U}}else try{U=E($,M),Bs(m,y,U)}catch(ne){tn(m,y,ne)}}function Bs(m,y,E){E!==null&&typeof E=="object"&&typeof E.then=="function"?E.then(function(M){ys(m,y,M)},function(M){return tn(m,y,M)}):ys(m,y,E)}function ys(m,y,E){y.status="fulfilled",y.value=E,ds(y),m.state=E,y=m.pending,y!==null&&(E=y.next,E===y?m.pending=null:(E=E.next,y.next=E,Zs(m,E)))}function tn(m,y,E){var M=m.pending;if(m.pending=null,M!==null){M=M.next;do y.status="rejected",y.reason=E,ds(y),y=y.next;while(y!==M)}m.action=null}function ds(m){m=m.listeners;for(var y=0;y<m.length;y++)(0,m[y])()}function wn(m,y){return y}function cr(m,y){if(is){var E=Gn.formState;if(E!==null){t:{var M=Dn;if(is){if(Ir){var $=lw(Ir,Lo);if($){Ir=Hv($),M=cw($);break t}}qt(M)}M=!1}M&&(y=E[0])}}E=Ei(),E.memoizedState=E.baseState=y,M={pending:null,lanes:0,dispatch:null,lastRenderedReducer:wn,lastRenderedState:y},E.queue=M,E=e0.bind(null,Dn,M),M.dispatch=E,M=Xe(!1);var U=n0.bind(null,Dn,!1,M.queue);return M=Ei(),$={state:y,dispatch:null,action:m,pending:null},M.queue=$,E=gs.bind(null,Dn,$,U,E),$.dispatch=E,M.memoizedState=m,[y,E,!1]}function $l(m){var y=Us();return ur(y,xs,m)}function ur(m,y,E){y=Ft(m,y,wn)[0],m=Gt(Et)[0],y=typeof y=="object"&&y!==null&&typeof y.then=="function"?il(y):y;var M=Us(),$=M.queue,U=$.dispatch;return E!==M.memoizedState&&(Dn.flags|=2048,pi(9,Do.bind(null,$,E),{destroy:void 0},null)),[y,U,m]}function Do(m,y){m.action=y}function Ss(m){var y=Us(),E=xs;if(E!==null)return ur(y,E,m);Us(),y=y.memoizedState,E=Us();var M=E.queue.dispatch;return E.memoizedState=m,[y,M,!1]}function pi(m,y,E,M){return m={tag:m,create:y,inst:E,deps:M,next:null},y=Dn.updateQueue,y===null&&(y=H0(),Dn.updateQueue=y),E=y.lastEffect,E===null?y.lastEffect=m.next=m:(M=E.next,E.next=m,m.next=M,y.lastEffect=m),m}function $i(){return Us().memoizedState}function Li(m,y,E,M){var $=Ei();Dn.flags|=m,$.memoizedState=pi(1|y,E,{destroy:void 0},M===void 0?null:M)}function Fi(m,y,E,M){var $=Us();M=M===void 0?null:M;var U=$.memoizedState.inst;xs!==null&&M!==null&&Zi(M,xs.memoizedState.deps)?$.memoizedState=pi(y,E,U,M):(Dn.flags|=m,$.memoizedState=pi(1|y,E,U,M))}function Nh(m,y){Li(8390656,8,m,y)}function Ya(m,y){Fi(2048,8,m,y)}function I_(m,y){return Fi(4,2,m,y)}function R_(m,y){return Fi(4,4,m,y)}function Cp(m,y){if(typeof y=="function"){m=m();var E=y(m);return function(){typeof E=="function"?E():y(null)}}if(y!=null)return m=m(),y.current=m,function(){y.current=null}}function Ll(m,y,E){E=E!=null?E.concat([m]):null,Fi(4,4,Cp.bind(null,y,m),E)}function Ap(){}function Qg(m,y){var E=Us();y=y===void 0?null:y;var M=E.memoizedState;return y!==null&&Zi(y,M[1])?M[0]:(E.memoizedState=[m,y],m)}function Mh(m,y){var E=Us();y=y===void 0?null:y;var M=E.memoizedState;if(y!==null&&Zi(y,M[1]))return M[0];if(M=m(),kc){W(!0);try{m()}finally{W(!1)}}return E.memoizedState=[M,y],M}function pu(m,y,E){return E===void 0||(Zl&1073741824)!==0?m.memoizedState=y:(m.memoizedState=E,m=Ul(),Dn.lanes|=m,ho|=m,E)}function jx(m,y,E,M){return so(E,y)?E:Yl.current!==null?(m=pu(m,E,M),so(m,y)||(Ni=!0),m):(Zl&42)===0?(Ni=!0,m.memoizedState=E):(m=Ul(),Dn.lanes|=m,ho|=m,y)}function Jg(m,y,E,M,$){var U=Qi();Gr(U!==0&&8>U?U:8);var tt=dn.T,mt={};dn.T=mt,n0(m,!1,y,E);try{var It=$(),ne=dn.S;if(ne!==null&&ne(mt,It),It!==null&&typeof It=="object"&&typeof It.then=="function"){var Te=we(It,M);gu(m,y,Te,oa(m))}else gu(m,y,M,oa(m))}catch($e){gu(m,y,{then:function(){},status:"rejected",reason:$e},oa())}finally{Gr(U),dn.T=tt}}function Kx(m){var y=m.memoizedState;if(y!==null)return y;y={memoizedState:_a,baseState:_a,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Et,lastRenderedState:_a},next:null};var E={};return y.next={memoizedState:E,baseState:E,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Et,lastRenderedState:E},next:null},m.memoizedState=y,m=m.alternate,m!==null&&(m.memoizedState=y),y}function Ih(){return Er(xn)}function Fl(){return Us().memoizedState}function t0(){return Us().memoizedState}function Np(m){for(var y=m.return;y!==null;){switch(y.tag){case 24:case 3:var E=oa();m=ae(E);var M=de(y,m,E);M!==null&&(Pr(M,y,E),Ne(M,y,E)),y={cache:o0()},m.payload=y;return}y=y.return}}function mu(m,y,E){var M=oa();E={lane:M,revertLane:0,action:E,hasEagerState:!1,eagerState:null,next:null},Rh(m)?Mp(y,E):(E=Xt(m,y,E,M),E!==null&&(Pr(E,m,M),Yx(E,y,M)))}function e0(m,y,E){var M=oa();gu(m,y,E,M)}function gu(m,y,E,M){var $={lane:M,revertLane:0,action:E,hasEagerState:!1,eagerState:null,next:null};if(Rh(m))Mp(y,$);else{var U=m.alternate;if(m.lanes===0&&(U===null||U.lanes===0)&&(U=y.lastRenderedReducer,U!==null))try{var tt=y.lastRenderedState,mt=U(tt,E);if($.hasEagerState=!0,$.eagerState=mt,so(mt,tt))return Jt(m,y,$,0),Gn===null&&Ht(),!1}catch{}finally{}if(E=Xt(m,y,$,M),E!==null)return Pr(E,m,M),Yx(E,y,M),!0}return!1}function n0(m,y,E,M){if(M={lane:2,revertLane:te(),action:M,hasEagerState:!1,eagerState:null,next:null},Rh(m)){if(y)throw Error(i(479))}else y=Xt(m,E,M,2),y!==null&&Pr(y,m,2)}function Rh(m){var y=m.alternate;return m===Dn||y!==null&&y===Dn}function Mp(m,y){ei=Uo=!0;var E=m.pending;E===null?y.next=y:(y.next=E.next,E.next=y),m.pending=y}function Yx(m,y,E){if((E&4194176)!==0){var M=y.lanes;M&=m.pendingLanes,E|=M,y.lanes=E,K(m,E)}}function Ur(m,y,E,M){y=m.memoizedState,E=E(M,y),E=E==null?y:Ph({},y,E),m.memoizedState=E,m.lanes===0&&(m.updateQueue.baseState=E)}function yu(m,y,E,M,$,U,tt){return m=m.stateNode,typeof m.shouldComponentUpdate=="function"?m.shouldComponentUpdate(M,U,tt):y.prototype&&y.prototype.isPureReactComponent?!fe(E,M)||!fe($,U):!0}function Ip(m,y,E,M){m=y.state,typeof y.componentWillReceiveProps=="function"&&y.componentWillReceiveProps(E,M),typeof y.UNSAFE_componentWillReceiveProps=="function"&&y.UNSAFE_componentWillReceiveProps(E,M),y.state!==m&&W0.enqueueReplaceState(y,y.state,null)}function al(m,y){var E=y;if("ref"in y){E={};for(var M in y)M!=="ref"&&(E[M]=y[M])}if(m=m.defaultProps){E===y&&(E=Ph({},E));for(var $ in m)E[$]===void 0&&(E[$]=m[$])}return E}function s0(m,y){try{var E=m.onUncaughtError;E(y.value,{componentStack:y.stack})}catch(M){setTimeout(function(){throw M})}}function i0(m,y,E){try{var M=m.onCaughtError;M(E.value,{componentStack:E.stack,errorBoundary:y.tag===1?y.stateNode:null})}catch($){setTimeout(function(){throw $})}}function Rp(m,y,E){return E=ae(E),E.tag=3,E.payload={element:null},E.callback=function(){s0(m,y)},E}function zf(m){return m=ae(m),m.tag=3,m}function Dp(m,y,E,M){var $=E.type.getDerivedStateFromError;if(typeof $=="function"){var U=M.value;m.payload=function(){return $(U)},m.callback=function(){i0(y,E,M)}}var tt=E.stateNode;tt!==null&&typeof tt.componentDidCatch=="function"&&(m.callback=function(){i0(y,E,M),typeof $!="function"&&(po===null?po=new Set([this]):po.add(this));var mt=M.stack;this.componentDidCatch(M.value,{componentStack:mt!==null?mt:""})})}function D_(m,y,E,M,$){if(E.flags|=32768,M!==null&&typeof M=="object"&&typeof M.then=="function"){if(y=E.alternate,y!==null&&Dh(y,E,$,!0),E=co.current,E!==null){switch(E.tag){case 13:return zo===null?Sa():E.alternate===null&&es===0&&(es=3),E.flags&=-257,E.flags|=65536,E.lanes=$,M===G0?E.flags|=16384:(y=E.updateQueue,y===null?E.updateQueue=new Set([M]):y.add(M),S0(m,M,$)),!1;case 22:return E.flags|=65536,M===G0?E.flags|=16384:(y=E.updateQueue,y===null?(y={transitions:null,markerInstances:null,retryQueue:new Set([M])},E.updateQueue=y):(E=y.retryQueue,E===null?y.retryQueue=new Set([M]):E.add(M)),S0(m,M,$)),!1}throw Error(i(435,E.tag))}return S0(m,M,$),Sa(),!1}if(is)return y=co.current,y!==null?((y.flags&65536)===0&&(y.flags|=256),y.flags|=65536,y.lanes=$,M!==om&&(m=Error(i(422),{cause:M}),Ae(st(m,E)))):(M!==om&&(y=Error(i(423),{cause:M}),Ae(st(y,E))),m=m.current.alternate,m.flags|=65536,$&=-$,m.lanes|=$,M=st(M,E),$=Rp(m.stateNode,M,$),ut(m,$),es!==4&&(es=2)),!1;var U=Error(i(520),{cause:M});if(U=st(U,E),dd===null?dd=[U]:dd.push(U),es!==4&&(es=2),y===null)return!0;M=st(M,E),E=y;do{switch(E.tag){case 3:return E.flags|=65536,m=$&-$,E.lanes|=m,m=Rp(E.stateNode,M,m),ut(E,m),!1;case 1:if(y=E.type,U=E.stateNode,(E.flags&128)===0&&(typeof y.getDerivedStateFromError=="function"||U!==null&&typeof U.componentDidCatch=="function"&&(po===null||!po.has(U))))return E.flags|=65536,$&=-$,E.lanes|=$,$=zf($),Dp($,m,E,M),ut(E,$),!1}E=E.return}while(E!==null);return!1}function Tr(m,y,E,M){y.child=m===null?rb(y,null,E,M):Pu(y,m.child,E,M)}function k_(m,y,E,M,$){E=E.render;var U=y.ref;if("ref"in M){var tt={};for(var mt in M)mt!=="ref"&&(tt[mt]=M[mt])}else tt=M;return kh(y),M=Ka(m,y,E,tt,U,$),mt=Ch(),m!==null&&!Ni?(yc(m,y,$),xc(m,y,$)):(is&&mt&&it(y),y.flags|=1,Tr(m,y,M,$),y.child)}function O_(m,y,E,M,$){if(m===null){var U=E.type;return typeof U=="function"&&!Tc(U)&&U.defaultProps===void 0&&E.compare===null?(y.tag=15,y.type=U,r0(m,y,U,M,$)):(m=ko(E.type,null,M,y,y.mode,$),m.ref=y.ref,m.return=y,y.child=m)}if(U=m.child,!sv(m,$)){var tt=U.memoizedProps;if(E=E.compare,E=E!==null?E:fe,E(tt,M)&&m.ref===y.ref)return xc(m,y,$)}return y.flags|=1,m=Vr(U,M),m.ref=y.ref,m.return=y,y.child=m}function r0(m,y,E,M,$){if(m!==null){var U=m.memoizedProps;if(fe(U,M)&&m.ref===y.ref)if(Ni=!1,y.pendingProps=M=U,sv(m,$))(m.flags&131072)!==0&&(Ni=!0);else return y.lanes=m.lanes,xc(m,y,$)}return Zx(m,y,E,M,$)}function $_(m,y,E){var M=y.pendingProps,$=M.children,U=(y.stateNode._pendingVisibility&2)!==0,tt=m!==null?m.memoizedState:null;if(kp(m,y),M.mode==="hidden"||U){if((y.flags&128)!==0){if(M=tt!==null?tt.baseLanes|E:E,m!==null){for($=y.child=m.child,U=0;$!==null;)U=U|$.lanes|$.childLanes,$=$.sibling;y.childLanes=U&~M}else y.childLanes=0,y.child=null;return L_(m,y,M,E)}if((E&536870912)!==0)y.memoizedState={baseLanes:0,cachePool:null},m!==null&&l0(y,tt!==null?tt.cachePool:null),tt!==null?Ep(y,tt):_h(),wh(y);else return y.lanes=y.childLanes=536870912,L_(m,y,tt!==null?tt.baseLanes|E:E,E)}else tt!==null?(l0(y,tt.cachePool),Ep(y,tt),Ro(),y.memoizedState=null):(m!==null&&l0(y,null),_h(),Ro());return Tr(m,y,$,E),y.child}function L_(m,y,E,M){var $=bu();return $=$===null?null:{parent:Wl?_s._currentValue:_s._currentValue2,pool:$},y.memoizedState={baseLanes:E,cachePool:$},m!==null&&l0(y,null),_h(),wh(y),m!==null&&Dh(m,y,M,!0),null}function kp(m,y){var E=y.ref;if(E===null)m!==null&&m.ref!==null&&(y.flags|=2097664);else{if(typeof E!="function"&&typeof E!="object")throw Error(i(284));(m===null||m.ref!==E)&&(y.flags|=2097664)}}function Zx(m,y,E,M,$){return kh(y),E=Ka(m,y,E,M,void 0,$),M=Ch(),m!==null&&!Ni?(yc(m,y,$),xc(m,y,$)):(is&&M&&it(y),y.flags|=1,Tr(m,y,E,$),y.child)}function F_(m,y,E,M,$,U){return kh(y),y.updateQueue=null,E=Eh(y,M,E,$),Th(m),M=Ch(),m!==null&&!Ni?(yc(m,y,U),xc(m,y,U)):(is&&M&&it(y),y.flags|=1,Tr(m,y,E,U),y.child)}function Qx(m,y,E,M,$){if(kh(y),y.stateNode===null){var U=qh,tt=E.contextType;typeof tt=="object"&&tt!==null&&(U=Er(tt)),U=new E(M,U),y.memoizedState=U.state!==null&&U.state!==void 0?U.state:null,U.updater=W0,y.stateNode=U,U._reactInternals=y,U=y.stateNode,U.props=M,U.state=y.memoizedState,U.refs={},ze(y),tt=E.contextType,U.context=typeof tt=="object"&&tt!==null?Er(tt):qh,U.state=y.memoizedState,tt=E.getDerivedStateFromProps,typeof tt=="function"&&(Ur(y,E,tt,M),U.state=y.memoizedState),typeof E.getDerivedStateFromProps=="function"||typeof U.getSnapshotBeforeUpdate=="function"||typeof U.UNSAFE_componentWillMount!="function"&&typeof U.componentWillMount!="function"||(tt=U.state,typeof U.componentWillMount=="function"&&U.componentWillMount(),typeof U.UNSAFE_componentWillMount=="function"&&U.UNSAFE_componentWillMount(),tt!==U.state&&W0.enqueueReplaceState(U,U.state,null),Se(y,M,U,$),kt(),U.state=y.memoizedState),typeof U.componentDidMount=="function"&&(y.flags|=4194308),M=!0}else if(m===null){U=y.stateNode;var mt=y.memoizedProps,It=al(E,mt);U.props=It;var ne=U.context,Te=E.contextType;tt=qh,typeof Te=="object"&&Te!==null&&(tt=Er(Te));var $e=E.getDerivedStateFromProps;Te=typeof $e=="function"||typeof U.getSnapshotBeforeUpdate=="function",mt=y.pendingProps!==mt,Te||typeof U.UNSAFE_componentWillReceiveProps!="function"&&typeof U.componentWillReceiveProps!="function"||(mt||ne!==tt)&&Ip(y,U,M,tt),Dc=!1;var Ve=y.memoizedState;U.state=Ve,Se(y,M,U,$),kt(),ne=y.memoizedState,mt||Ve!==ne||Dc?(typeof $e=="function"&&(Ur(y,E,$e,M),ne=y.memoizedState),(It=Dc||yu(y,E,It,M,Ve,ne,tt))?(Te||typeof U.UNSAFE_componentWillMount!="function"&&typeof U.componentWillMount!="function"||(typeof U.componentWillMount=="function"&&U.componentWillMount(),typeof U.UNSAFE_componentWillMount=="function"&&U.UNSAFE_componentWillMount()),typeof U.componentDidMount=="function"&&(y.flags|=4194308)):(typeof U.componentDidMount=="function"&&(y.flags|=4194308),y.memoizedProps=M,y.memoizedState=ne),U.props=M,U.state=ne,U.context=tt,M=It):(typeof U.componentDidMount=="function"&&(y.flags|=4194308),M=!1)}else{U=y.stateNode,nn(m,y),tt=y.memoizedProps,Te=al(E,tt),U.props=Te,$e=y.pendingProps,Ve=U.context,ne=E.contextType,It=qh,typeof ne=="object"&&ne!==null&&(It=Er(ne)),mt=E.getDerivedStateFromProps,(ne=typeof mt=="function"||typeof U.getSnapshotBeforeUpdate=="function")||typeof U.UNSAFE_componentWillReceiveProps!="function"&&typeof U.componentWillReceiveProps!="function"||(tt!==$e||Ve!==It)&&Ip(y,U,M,It),Dc=!1,Ve=y.memoizedState,U.state=Ve,Se(y,M,U,$),kt();var En=y.memoizedState;tt!==$e||Ve!==En||Dc||m!==null&&m.dependencies!==null&&vu(m.dependencies)?(typeof mt=="function"&&(Ur(y,E,mt,M),En=y.memoizedState),(Te=Dc||yu(y,E,Te,M,Ve,En,It)||m!==null&&m.dependencies!==null&&vu(m.dependencies))?(ne||typeof U.UNSAFE_componentWillUpdate!="function"&&typeof U.componentWillUpdate!="function"||(typeof U.componentWillUpdate=="function"&&U.componentWillUpdate(M,En,It),typeof U.UNSAFE_componentWillUpdate=="function"&&U.UNSAFE_componentWillUpdate(M,En,It)),typeof U.componentDidUpdate=="function"&&(y.flags|=4),typeof U.getSnapshotBeforeUpdate=="function"&&(y.flags|=1024)):(typeof U.componentDidUpdate!="function"||tt===m.memoizedProps&&Ve===m.memoizedState||(y.flags|=4),typeof U.getSnapshotBeforeUpdate!="function"||tt===m.memoizedProps&&Ve===m.memoizedState||(y.flags|=1024),y.memoizedProps=M,y.memoizedState=En),U.props=M,U.state=En,U.context=It,M=Te):(typeof U.componentDidUpdate!="function"||tt===m.memoizedProps&&Ve===m.memoizedState||(y.flags|=4),typeof U.getSnapshotBeforeUpdate!="function"||tt===m.memoizedProps&&Ve===m.memoizedState||(y.flags|=1024),M=!1)}return U=M,kp(m,y),M=(y.flags&128)!==0,U||M?(U=y.stateNode,E=M&&typeof E.getDerivedStateFromError!="function"?null:U.render(),y.flags|=1,m!==null&&M?(y.child=Pu(y,m.child,null,$),y.child=Pu(y,null,E,$)):Tr(m,y,E,$),y.memoizedState=U.state,m=y.child):m=xc(m,y,$),m}function z_(m,y,E,M){return He(),y.flags|=256,Tr(m,y,E,M),y.child}function Jx(m){return{baseLanes:m,cachePool:G_()}}function tv(m,y,E){return m=m!==null?m.childLanes&~E:0,y&&(m|=Na),m}function U_(m,y,E){var M=y.pendingProps,$=!1,U=(y.flags&128)!==0,tt;if((tt=U)||(tt=m!==null&&m.memoizedState===null?!1:(Ui.current&2)!==0),tt&&($=!0,y.flags&=-129),tt=(y.flags&32)!==0,y.flags&=-33,m===null){if(is){if($?Io(y):Ro(),is){var mt=Ir,It;(It=mt)&&(mt=pw(mt,Lo),mt!==null?(y.memoizedState={dehydrated:mt,treeContext:hl!==null?{id:jl,overflow:$o}:null,retryLane:536870912},It=e(18,null,null,0),It.stateNode=mt,It.return=y,y.child=It,Hr=y,Ir=null,It=!0):It=!1),It||qt(y)}if(mt=y.memoizedState,mt!==null&&(mt=mt.dehydrated,mt!==null))return Jp(mt)?y.lanes=16:y.lanes=536870912,null;lr(y)}return mt=M.children,M=M.fallback,$?(Ro(),$=y.mode,mt=ev({mode:"hidden",children:mt},$),M=Cc(M,$,E,null),mt.return=y,M.return=y,mt.sibling=M,y.child=mt,$=y.child,$.memoizedState=Jx(E),$.childLanes=tv(m,tt,E),y.memoizedState=qr,M):(Io(y),Op(y,mt))}if(It=m.memoizedState,It!==null&&(mt=It.dehydrated,mt!==null)){if(U)y.flags&256?(Io(y),y.flags&=-257,y=nv(m,y,E)):y.memoizedState!==null?(Ro(),y.child=m.child,y.flags|=128,y=null):(Ro(),$=M.fallback,mt=y.mode,M=ev({mode:"visible",children:M.children},mt),$=Cc($,mt,E,null),$.flags|=2,M.return=y,$.return=y,M.sibling=$,y.child=M,Pu(y,m.child,null,E),M=y.child,M.memoizedState=Jx(E),M.childLanes=tv(m,tt,E),y.memoizedState=qr,y=$);else if(Io(y),Jp(mt))tt=ow(mt).digest,M=Error(i(419)),M.stack="",M.digest=tt,Ae({value:M,source:null,stack:null}),y=nv(m,y,E);else if(Ni||Dh(m,y,E,!1),tt=(E&m.childLanes)!==0,Ni||tt){if(tt=Gn,tt!==null){if(M=E&-E,(M&42)!==0)M=1;else switch(M){case 2:M=1;break;case 8:M=4;break;case 32:M=16;break;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:M=64;break;case 268435456:M=134217728;break;default:M=0}if(M=(M&(tt.suspendedLanes|E))!==0?0:M,M!==0&&M!==It.retryLane)throw It.retryLane=M,ce(m,M),Pr(tt,m,M),Mw}k0(mt)||Sa(),y=nv(m,y,E)}else k0(mt)?(y.flags|=128,y.child=m.child,y=Uh.bind(null,m),RN(mt,y),y=null):(m=It.treeContext,la&&(Ir=hw(mt),Hr=y,is=!0,ao=null,Lo=!1,m!==null&&(io[ro++]=jl,io[ro++]=$o,io[ro++]=hl,jl=m.id,$o=m.overflow,hl=y)),y=Op(y,M.children),y.flags|=4096);return y}return $?(Ro(),$=M.fallback,mt=y.mode,It=m.child,U=It.sibling,M=Vr(It,{mode:"hidden",children:M.children}),M.subtreeFlags=It.subtreeFlags&31457280,U!==null?$=Vr(U,$):($=Cc($,mt,E,null),$.flags|=2),$.return=y,M.return=y,M.sibling=$,y.child=M,M=$,$=y.child,mt=m.child.memoizedState,mt===null?mt=Jx(E):(It=mt.cachePool,It!==null?(U=Wl?_s._currentValue:_s._currentValue2,It=It.parent!==U?{parent:U,pool:U}:It):It=G_(),mt={baseLanes:mt.baseLanes|E,cachePool:It}),$.memoizedState=mt,$.childLanes=tv(m,tt,E),y.memoizedState=qr,M):(Io(y),E=m.child,m=E.sibling,E=Vr(E,{mode:"visible",children:M.children}),E.return=y,E.sibling=null,m!==null&&(tt=y.deletions,tt===null?(y.deletions=[m],y.flags|=16):tt.push(m)),y.child=E,y.memoizedState=null,E)}function Op(m,y){return y=ev({mode:"visible",children:y},m.mode),y.return=m,m.child=y}function ev(m,y){return _0(m,y,0,null)}function nv(m,y,E){return Pu(y,m.child,null,E),m=Op(y,y.pendingProps.children),m.flags|=2,y.memoizedState=null,m}function B_(m,y,E){m.lanes|=y;var M=m.alternate;M!==null&&(M.lanes|=y),iv(m.return,y,E)}function a0(m,y,E,M,$){var U=m.memoizedState;U===null?m.memoizedState={isBackwards:y,rendering:null,renderingStartTime:0,last:M,tail:E,tailMode:$}:(U.isBackwards=y,U.rendering=null,U.renderingStartTime=0,U.last=M,U.tail=E,U.tailMode=$)}function P_(m,y,E){var M=y.pendingProps,$=M.revealOrder,U=M.tail;if(Tr(m,y,M.children,E),M=Ui.current,(M&2)!==0)M=M&1|2,y.flags|=128;else{if(m!==null&&(m.flags&128)!==0)t:for(m=y.child;m!==null;){if(m.tag===13)m.memoizedState!==null&&B_(m,E,y);else if(m.tag===19)B_(m,E,y);else if(m.child!==null){m.child.return=m,m=m.child;continue}if(m===y)break t;for(;m.sibling===null;){if(m.return===null||m.return===y)break t;m=m.return}m.sibling.return=m.return,m=m.sibling}M&=1}switch(T(Ui,M),$){case"forwards":for(E=y.child,$=null;E!==null;)m=E.alternate,m!==null&&ia(m)===null&&($=E),E=E.sibling;E=$,E===null?($=y.child,y.child=null):($=E.sibling,E.sibling=null),a0(y,!1,$,E,U);break;case"backwards":for(E=null,$=y.child,y.child=null;$!==null;){if(m=$.alternate,m!==null&&ia(m)===null){y.child=$;break}m=$.sibling,$.sibling=E,E=$,$=m}a0(y,!0,E,null,U);break;case"together":a0(y,!1,null,null,void 0);break;default:y.memoizedState=null}return y.child}function xc(m,y,E){if(m!==null&&(y.dependencies=m.dependencies),ho|=y.lanes,(E&y.childLanes)===0)if(m!==null){if(Dh(m,y,E,!1),(E&y.childLanes)===0)return null}else return null;if(m!==null&&y.child!==m.child)throw Error(i(153));if(y.child!==null){for(m=y.child,E=Vr(m,m.pendingProps),y.child=E,E.return=y;m.sibling!==null;)m=m.sibling,E=E.sibling=Vr(m,m.pendingProps),E.return=y;E.sibling=null}return y.child}function sv(m,y){return(m.lanes&y)!==0?!0:(m=m.dependencies,!!(m!==null&&vu(m)))}function NN(m,y,E){switch(y.tag){case 3:yt(y,y.stateNode.containerInfo),xu(y,_s,m.memoizedState.cache),He();break;case 27:case 5:ft(y);break;case 4:yt(y,y.stateNode.containerInfo);break;case 10:xu(y,y.type,y.memoizedProps.value);break;case 13:var M=y.memoizedState;if(M!==null)return M.dehydrated!==null?(Io(y),y.flags|=128,null):(E&y.child.childLanes)!==0?U_(m,y,E):(Io(y),m=xc(m,y,E),m!==null?m.sibling:null);Io(y);break;case 19:var $=(m.flags&128)!==0;if(M=(E&y.childLanes)!==0,M||(Dh(m,y,E,!1),M=(E&y.childLanes)!==0),$){if(M)return P_(m,y,E);y.flags|=128}if($=y.memoizedState,$!==null&&($.rendering=null,$.tail=null,$.lastEffect=null),T(Ui,Ui.current),M)break;return null;case 22:case 23:return y.lanes=0,$_(m,y,E);case 24:xu(y,_s,m.memoizedState.cache)}return xc(m,y,E)}function V_(m,y,E){if(m!==null)if(m.memoizedProps!==y.pendingProps)Ni=!0;else{if(!sv(m,E)&&(y.flags&128)===0)return Ni=!1,NN(m,y,E);Ni=(m.flags&131072)!==0}else Ni=!1,is&&(y.flags&1048576)!==0&&X(y,rm,y.index);switch(y.lanes=0,y.tag){case 16:t:{m=y.pendingProps;var M=y.elementType,$=M._init;if(M=$(M._payload),y.type=M,typeof M=="function")Tc(M)?(m=al(M,m),y.tag=1,y=Qx(null,y,M,m,E)):(y.tag=0,y=Zx(null,y,M,m,E));else{if(M!=null){if($=M.$$typeof,$===td){y.tag=11,y=k_(null,y,M,m,E);break t}else if($===Wp){y.tag=14,y=O_(null,y,M,m,E);break t}}throw y=a(M)||M,Error(i(306,y,""))}}return y;case 0:return Zx(m,y,y.type,y.pendingProps,E);case 1:return M=y.type,$=al(M,y.pendingProps),Qx(m,y,M,$,E);case 3:t:{if(yt(y,y.stateNode.containerInfo),m===null)throw Error(i(387));var U=y.pendingProps;$=y.memoizedState,M=$.element,nn(m,y),Se(y,U,null,E);var tt=y.memoizedState;if(U=tt.cache,xu(y,_s,U),U!==$.cache&&rv(y,[_s],E,!0),kt(),U=tt.element,la&&$.isDehydrated)if($={element:U,isDehydrated:!1,cache:tt.cache},y.updateQueue.baseState=$,y.memoizedState=$,y.flags&256){y=z_(m,y,U,E);break t}else if(U!==M){M=st(Error(i(424)),y),Ae(M),y=z_(m,y,U,E);break t}else for(la&&(Ir=uw(y.stateNode.containerInfo),Hr=y,is=!0,ao=null,Lo=!0),E=rb(y,null,U,E),y.child=E;E;)E.flags=E.flags&-3|4096,E=E.sibling;else{if(He(),U===M){y=xc(m,y,E);break t}Tr(m,y,U,E)}y=y.child}return y;case 26:if(no)return kp(m,y),m===null?(E=z0(y.type,null,y.pendingProps,null))?y.memoizedState=E:is||(y.stateNode=kN(y.type,y.pendingProps,fl.current,y)):y.memoizedState=z0(y.type,m.memoizedProps,y.pendingProps,m.memoizedState),null;case 27:if(Nr)return ft(y),m===null&&Nr&&is&&(M=y.stateNode=eb(y.type,y.pendingProps,fl.current,mr.current,!1),Hr=y,Lo=!0,Ir=O0(M)),M=y.pendingProps.children,m!==null||is?Tr(m,y,M,E):y.child=Pu(y,null,M,E),kp(m,y),y.child;case 5:return m===null&&is&&(vw(y.type,y.pendingProps,mr.current),($=M=Ir)&&(M=fw(M,y.type,y.pendingProps,Lo),M!==null?(y.stateNode=M,Hr=y,Ir=O0(M),Lo=!1,$=!0):$=!1),$||qt(y)),ft(y),$=y.type,U=y.pendingProps,tt=m!==null?m.memoizedProps:null,M=U.children,Lu($,U)?M=null:tt!==null&&Lu($,tt)&&(y.flags|=32),y.memoizedState!==null&&($=Ka(m,y,Zg,null,null,E),Wl?xn._currentValue=$:xn._currentValue2=$),kp(m,y),Tr(m,y,M,E),y.child;case 6:return m===null&&is&&(bw(y.pendingProps,mr.current),(m=E=Ir)&&(E=dw(E,y.pendingProps,Lo),E!==null?(y.stateNode=E,Hr=y,Ir=null,m=!0):m=!1),m||qt(y)),null;case 13:return U_(m,y,E);case 4:return yt(y,y.stateNode.containerInfo),M=y.pendingProps,m===null?y.child=Pu(y,null,M,E):Tr(m,y,M,E),y.child;case 11:return k_(m,y,y.type,y.pendingProps,E);case 7:return Tr(m,y,y.pendingProps,E),y.child;case 8:return Tr(m,y,y.pendingProps.children,E),y.child;case 12:return Tr(m,y,y.pendingProps.children,E),y.child;case 10:return M=y.pendingProps,xu(y,y.type,M.value),Tr(m,y,M.children,E),y.child;case 9:return $=y.type._context,M=y.pendingProps.children,kh(y),$=Er($),M=M($),y.flags|=1,Tr(m,y,M,E),y.child;case 14:return O_(m,y,y.type,y.pendingProps,E);case 15:return r0(m,y,y.type,y.pendingProps,E);case 19:return P_(m,y,E);case 22:return $_(m,y,E);case 24:return kh(y),M=Er(_s),m===null?($=bu(),$===null&&($=Gn,U=o0(),$.pooledCache=U,U.refCount++,U!==null&&($.pooledCacheLanes|=E),$=U),y.memoizedState={parent:M,cache:$},ze(y),xu(y,_s,$)):((m.lanes&E)!==0&&(nn(m,y),Se(y,null,null,E),kt()),$=m.memoizedState,U=y.memoizedState,$.parent!==M?($={parent:M,cache:M},y.memoizedState=$,y.lanes===0&&(y.memoizedState=y.updateQueue.baseState=$),xu(y,_s,M)):(M=U.cache,xu(y,_s,M),M!==$.cache&&rv(y,[_s],E,!0))),Tr(m,y,y.pendingProps.children,E),y.child;case 29:throw y.pendingProps}throw Error(i(156,y.tag))}function xu(m,y,E){Wl?(T(Ca,y._currentValue),y._currentValue=E):(T(Ca,y._currentValue2),y._currentValue2=E)}function vc(m){var y=Ca.current;Wl?m._currentValue=y:m._currentValue2=y,b(Ca)}function iv(m,y,E){for(;m!==null;){var M=m.alternate;if((m.childLanes&y)!==y?(m.childLanes|=y,M!==null&&(M.childLanes|=y)):M!==null&&(M.childLanes&y)!==y&&(M.childLanes|=y),m===E)break;m=m.return}}function rv(m,y,E,M){var $=m.child;for($!==null&&($.return=m);$!==null;){var U=$.dependencies;if(U!==null){var tt=$.child;U=U.firstContext;t:for(;U!==null;){var mt=U;U=$;for(var It=0;It<y.length;It++)if(mt.context===y[It]){U.lanes|=E,mt=U.alternate,mt!==null&&(mt.lanes|=E),iv(U.return,E,m),M||(tt=null);break t}U=mt.next}}else if($.tag===18){if(tt=$.return,tt===null)throw Error(i(341));tt.lanes|=E,U=tt.alternate,U!==null&&(U.lanes|=E),iv(tt,E,m),tt=null}else tt=$.child;if(tt!==null)tt.return=$;else for(tt=$;tt!==null;){if(tt===m){tt=null;break}if($=tt.sibling,$!==null){$.return=tt.return,tt=$;break}tt=tt.return}$=tt}}function Dh(m,y,E,M){m=null;for(var $=y,U=!1;$!==null;){if(!U){if(($.flags&524288)!==0)U=!0;else if(($.flags&262144)!==0)break}if($.tag===10){var tt=$.alternate;if(tt===null)throw Error(i(387));if(tt=tt.memoizedProps,tt!==null){var mt=$.type;so($.pendingProps.value,tt.value)||(m!==null?m.push(mt):m=[mt])}}else if($===od.current){if(tt=$.alternate,tt===null)throw Error(i(387));tt.memoizedState.memoizedState!==$.memoizedState.memoizedState&&(m!==null?m.push(xn):m=[xn])}$=$.return}m!==null&&rv(y,m,E,M),y.flags|=262144}function vu(m){for(m=m.firstContext;m!==null;){var y=m.context;if(!so(Wl?y._currentValue:y._currentValue2,m.memoizedValue))return!0;m=m.next}return!1}function kh(m){Gu=m,vi=null,m=m.dependencies,m!==null&&(m.firstContext=null)}function Er(m){return av(Gu,m)}function $p(m,y){return Gu===null&&kh(m),av(m,y)}function av(m,y){var E=Wl?y._currentValue:y._currentValue2;if(y={context:y,memoizedValue:E,next:null},vi===null){if(m===null)throw Error(i(308));vi=y,m.dependencies={lanes:0,firstContext:y},m.flags|=524288}else vi=vi.next=y;return E}function o0(){return{controller:new Iw,data:new Map,refCount:0}}function Uf(m){m.refCount--,m.refCount===0&&Oc(Kh,function(){m.controller.abort()})}function bu(){var m=$c.current;return m!==null?m:Gn.pooledCache}function l0(m,y){y===null?T($c,$c.current):T($c,y.pool)}function G_(){var m=bu();return m===null?null:{parent:Wl?_s._currentValue:_s._currentValue2,pool:m}}function Za(m){m.flags|=4}function ov(m,y){if(m!==null&&m.child===y.child)return!1;if((y.flags&16)!==0)return!0;for(m=y.child;m!==null;){if((m.flags&13878)!==0||(m.subtreeFlags&13878)!==0)return!0;m=m.sibling}return!1}function c0(m,y,E,M){if(Ar)for(E=y.child;E!==null;){if(E.tag===5||E.tag===6)Hl(m,E.stateNode);else if(!(E.tag===4||Nr&&E.tag===27)&&E.child!==null){E.child.return=E,E=E.child;continue}if(E===y)break;for(;E.sibling===null;){if(E.return===null||E.return===y)return;E=E.return}E.sibling.return=E.return,E=E.sibling}else if(to)for(var $=y.child;$!==null;){if($.tag===5){var U=$.stateNode;E&&M&&(U=Vv(U,$.type,$.memoizedProps)),Hl(m,U)}else if($.tag===6)U=$.stateNode,E&&M&&(U=Gv(U,$.memoizedProps)),Hl(m,U);else if($.tag!==4){if($.tag===22&&$.memoizedState!==null)U=$.child,U!==null&&(U.return=$),c0(m,$,!0,!0);else if($.child!==null){$.child.return=$,$=$.child;continue}}if($===y)break;for(;$.sibling===null;){if($.return===null||$.return===y)return;$=$.return}$.sibling.return=$.return,$=$.sibling}}function Bf(m,y,E,M){if(to)for(var $=y.child;$!==null;){if($.tag===5){var U=$.stateNode;E&&M&&(U=Vv(U,$.type,$.memoizedProps)),Bv(m,U)}else if($.tag===6)U=$.stateNode,E&&M&&(U=Gv(U,$.memoizedProps)),Bv(m,U);else if($.tag!==4){if($.tag===22&&$.memoizedState!==null)U=$.child,U!==null&&(U.return=$),Bf(m,$,!($.memoizedProps!==null&&$.memoizedProps.mode==="manual"),!0);else if($.child!==null){$.child.return=$,$=$.child;continue}}if($===y)break;for(;$.sibling===null;){if($.return===null||$.return===y)return;$=$.return}$.sibling.return=$.return,$=$.sibling}}function Pf(m,y){if(to&&ov(m,y)){m=y.stateNode;var E=m.containerInfo,M=D0();Bf(M,y,!1,!1),m.pendingChildren=M,Za(y),aw(E,M)}}function lv(m,y,E,M){if(Ar)m.memoizedProps!==M&&Za(y);else if(to){var $=m.stateNode,U=m.memoizedProps;if((m=ov(m,y))||U!==M){var tt=mr.current;U=Uv($,E,U,M,!m,null),U===$?y.stateNode=$:(Nc(U,E,M,tt)&&Za(y),y.stateNode=U,m?c0(U,y,!1,!1):Za(y))}else y.stateNode=$}}function Vf(m,y,E){if(sw(y,E)){if(m.flags|=16777216,!Mc(y,E))if(Pp())m.flags|=8192;else throw jh=G0,ib}else m.flags&=-16777217}function cv(m,y){if(Sw(y)){if(m.flags|=16777216,!Jv(y))if(Pp())m.flags|=8192;else throw jh=G0,ib}else m.flags&=-16777217}function Lp(m,y){y!==null&&(m.flags|=4),m.flags&16384&&(y=m.tag!==22?k():536870912,m.lanes|=y,Fc|=y)}function Oh(m,y){if(!is)switch(m.tailMode){case"hidden":y=m.tail;for(var E=null;y!==null;)y.alternate!==null&&(E=y),y=y.sibling;E===null?m.tail=null:E.sibling=null;break;case"collapsed":E=m.tail;for(var M=null;E!==null;)E.alternate!==null&&(M=E),E=E.sibling;M===null?y||m.tail===null?m.tail=null:m.tail.sibling=null:M.sibling=null}}function Qs(m){var y=m.alternate!==null&&m.alternate.child===m.child,E=0,M=0;if(y)for(var $=m.child;$!==null;)E|=$.lanes|$.childLanes,M|=$.subtreeFlags&31457280,M|=$.flags&31457280,$.return=m,$=$.sibling;else for($=m.child;$!==null;)E|=$.lanes|$.childLanes,M|=$.subtreeFlags,M|=$.flags,$.return=m,$=$.sibling;return m.subtreeFlags|=M,m.childLanes=E,y}function H_(m,y,E){var M=y.pendingProps;switch(ct(y),y.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Qs(y),null;case 1:return Qs(y),null;case 3:return E=y.stateNode,M=null,m!==null&&(M=m.memoizedState.cache),y.memoizedState.cache!==M&&(y.flags|=2048),vc(_s),Rt(),E.pendingContext&&(E.context=E.pendingContext,E.pendingContext=null),(m===null||m.child===null)&&(Ee(y)?Za(y):m===null||m.memoizedState.isDehydrated&&(y.flags&256)===0||(y.flags|=1024,ao!==null&&(Sc(ao),ao=null))),Pf(m,y),Qs(y),null;case 26:if(no){E=y.type;var $=y.memoizedState;return m===null?(Za(y),$!==null?(Qs(y),cv(y,$)):(Qs(y),Vf(y,E,M))):$?$!==m.memoizedState?(Za(y),Qs(y),cv(y,$)):(Qs(y),y.flags&=-16777217):(Ar?m.memoizedProps!==M&&Za(y):lv(m,y,E,M),Qs(y),Vf(y,E,M)),null}case 27:if(Nr){if(_t(y),E=fl.current,$=y.type,m!==null&&y.stateNode!=null)Ar?m.memoizedProps!==M&&Za(y):lv(m,y,$,M);else{if(!M){if(y.stateNode===null)throw Error(i(166));return Qs(y),null}m=mr.current,Ee(y)?Qt(y,m):(m=eb($,M,E,m,!0),y.stateNode=m,Za(y))}return Qs(y),null}case 5:if(_t(y),E=y.type,m!==null&&y.stateNode!=null)lv(m,y,E,M);else{if(!M){if(y.stateNode===null)throw Error(i(166));return Qs(y),null}m=mr.current,Ee(y)?Qt(y,m):($=Nv(E,M,fl.current,m,y),c0($,y,!1,!1),y.stateNode=$,Nc($,E,M,m)&&Za(y))}return Qs(y),Vf(y,y.type,y.pendingProps),null;case 6:if(m&&y.stateNode!=null)E=m.memoizedProps,Ar?E!==M&&Za(y):to&&(E!==M?(y.stateNode=C0(M,fl.current,mr.current,y),Za(y)):y.stateNode=m.stateNode);else{if(typeof M!="string"&&y.stateNode===null)throw Error(i(166));if(m=fl.current,E=mr.current,Ee(y)){if(!la)throw Error(i(176));if(m=y.stateNode,E=y.memoizedProps,M=null,$=Hr,$!==null)switch($.tag){case 27:case 5:M=$.memoizedProps}mw(m,E,y,M)||qt(y)}else y.stateNode=C0(M,m,E,y)}return Qs(y),null;case 13:if(M=y.memoizedState,m===null||m.memoizedState!==null&&m.memoizedState.dehydrated!==null){if($=Ee(y),M!==null&&M.dehydrated!==null){if(m===null){if(!$)throw Error(i(318));if(!la)throw Error(i(344));if($=y.memoizedState,$=$!==null?$.dehydrated:null,!$)throw Error(i(317));nd($,y)}else He(),(y.flags&128)===0&&(y.memoizedState=null),y.flags|=4;Qs(y),$=!1}else ao!==null&&(Sc(ao),ao=null),$=!0;if(!$)return y.flags&256?(lr(y),y):(lr(y),null)}if(lr(y),(y.flags&128)!==0)return y.lanes=E,y;if(E=M!==null,m=m!==null&&m.memoizedState!==null,E){M=y.child,$=null,M.alternate!==null&&M.alternate.memoizedState!==null&&M.alternate.memoizedState.cachePool!==null&&($=M.alternate.memoizedState.cachePool.pool);var U=null;M.memoizedState!==null&&M.memoizedState.cachePool!==null&&(U=M.memoizedState.cachePool.pool),U!==$&&(M.flags|=2048)}return E!==m&&E&&(y.child.flags|=8192),Lp(y,y.updateQueue),Qs(y),null;case 4:return Rt(),Pf(m,y),m===null&&Rv(y.stateNode.containerInfo),Qs(y),null;case 10:return vc(y.type),Qs(y),null;case 19:if(b(Ui),$=y.memoizedState,$===null)return Qs(y),null;if(M=(y.flags&128)!==0,U=$.rendering,U===null)if(M)Oh($,!1);else{if(es!==0||m!==null&&(m.flags&128)!==0)for(m=y.child;m!==null;){if(U=ia(m),U!==null){for(y.flags|=128,Oh($,!1),m=U.updateQueue,y.updateQueue=m,Lp(y,m),y.subtreeFlags=0,m=E,E=y.child;E!==null;)Ec(E,m),E=E.sibling;return T(Ui,Ui.current&1|2),y.child}m=m.sibling}$.tail!==null&&Mr()>ui&&(y.flags|=128,M=!0,Oh($,!1),y.lanes=4194304)}else{if(!M)if(m=ia(U),m!==null){if(y.flags|=128,M=!0,m=m.updateQueue,y.updateQueue=m,Lp(y,m),Oh($,!0),$.tail===null&&$.tailMode==="hidden"&&!U.alternate&&!is)return Qs(y),null}else 2*Mr()-$.renderingStartTime>ui&&E!==536870912&&(y.flags|=128,M=!0,Oh($,!1),y.lanes=4194304);$.isBackwards?(U.sibling=y.child,y.child=U):(m=$.last,m!==null?m.sibling=U:y.child=U,$.last=U)}return $.tail!==null?(y=$.tail,$.rendering=y,$.tail=y.sibling,$.renderingStartTime=Mr(),y.sibling=null,m=Ui.current,T(Ui,M?m&1|2:m&1),y):(Qs(y),null);case 22:case 23:return lr(y),du(),M=y.memoizedState!==null,m!==null?m.memoizedState!==null!==M&&(y.flags|=8192):M&&(y.flags|=8192),M?(E&536870912)!==0&&(y.flags&128)===0&&(Qs(y),y.subtreeFlags&6&&(y.flags|=8192)):Qs(y),E=y.updateQueue,E!==null&&Lp(y,E.retryQueue),E=null,m!==null&&m.memoizedState!==null&&m.memoizedState.cachePool!==null&&(E=m.memoizedState.cachePool.pool),M=null,y.memoizedState!==null&&y.memoizedState.cachePool!==null&&(M=y.memoizedState.cachePool.pool),M!==E&&(y.flags|=2048),m!==null&&b($c),null;case 24:return E=null,m!==null&&(E=m.memoizedState.cache),y.memoizedState.cache!==E&&(y.flags|=2048),vc(_s),Qs(y),null;case 25:return null}throw Error(i(156,y.tag))}function W_(m,y){switch(ct(y),y.tag){case 1:return m=y.flags,m&65536?(y.flags=m&-65537|128,y):null;case 3:return vc(_s),Rt(),m=y.flags,(m&65536)!==0&&(m&128)===0?(y.flags=m&-65537|128,y):null;case 26:case 27:case 5:return _t(y),null;case 13:if(lr(y),m=y.memoizedState,m!==null&&m.dehydrated!==null){if(y.alternate===null)throw Error(i(340));He()}return m=y.flags,m&65536?(y.flags=m&-65537|128,y):null;case 19:return b(Ui),null;case 4:return Rt(),null;case 10:return vc(y.type),null;case 22:case 23:return lr(y),du(),m!==null&&b($c),m=y.flags,m&65536?(y.flags=m&-65537|128,y):null;case 24:return vc(_s),null;case 25:return null;default:return null}}function uv(m,y){switch(ct(y),y.tag){case 3:vc(_s),Rt();break;case 26:case 27:case 5:_t(y);break;case 4:Rt();break;case 13:lr(y);break;case 19:b(Ui);break;case 10:vc(y.type);break;case 22:case 23:lr(y),du(),m!==null&&b($c);break;case 24:vc(_s)}}function Fp(m,y){try{var E=y.updateQueue,M=E!==null?E.lastEffect:null;if(M!==null){var $=M.next;E=$;do{if((E.tag&m)===m){M=void 0;var U=E.create,tt=E.inst;M=U(),tt.destroy=M}E=E.next}while(E!==$)}}catch(mt){jn(y,y.return,mt)}}function Su(m,y,E){try{var M=y.updateQueue,$=M!==null?M.lastEffect:null;if($!==null){var U=$.next;M=U;do{if((M.tag&m)===m){var tt=M.inst,mt=tt.destroy;if(mt!==void 0){tt.destroy=void 0,$=y;var It=E;try{mt()}catch(ne){jn($,It,ne)}}}M=M.next}while(M!==U)}}catch(ne){jn(y,y.return,ne)}}function q_(m){var y=m.updateQueue;if(y!==null){var E=m.stateNode;try{ye(y,E)}catch(M){jn(m,m.return,M)}}}function X_(m,y,E){E.props=al(m.type,m.memoizedProps),E.state=m.memoizedState;try{E.componentWillUnmount()}catch(M){jn(m,y,M)}}function $h(m,y){try{var E=m.ref;if(E!==null){var M=m.stateNode;switch(m.tag){case 26:case 27:case 5:var $=ed(M);break;default:$=M}typeof E=="function"?m.refCleanup=E($):E.current=$}}catch(U){jn(m,y,U)}}function Js(m,y){var E=m.ref,M=m.refCleanup;if(E!==null)if(typeof M=="function")try{M()}catch($){jn(m,y,$)}finally{m.refCleanup=null,m=m.alternate,m!=null&&(m.refCleanup=null)}else if(typeof E=="function")try{E(null)}catch($){jn(m,y,$)}else E.current=null}function Gf(m){var y=m.type,E=m.memoizedProps,M=m.stateNode;try{IN(M,y,E,m)}catch($){jn(m,m.return,$)}}function hv(m,y,E){try{$v(m.stateNode,m.type,E,y,m)}catch(M){jn(m,m.return,M)}}function fv(m){return m.tag===5||m.tag===3||(no?m.tag===26:!1)||(Nr?m.tag===27:!1)||m.tag===4}function u0(m){t:for(;;){for(;m.sibling===null;){if(m.return===null||fv(m.return))return null;m=m.return}for(m.sibling.return=m.return,m=m.sibling;m.tag!==5&&m.tag!==6&&(!Nr||m.tag!==27)&&m.tag!==18;){if(m.flags&2||m.child===null||m.tag===4)continue t;m.child.return=m,m=m.child}if(!(m.flags&2))return m.stateNode}}function h0(m,y,E){var M=m.tag;if(M===5||M===6)m=m.stateNode,y?Fv(E,m,y):iw(E,m);else if(!(M===4||Nr&&M===27)&&(m=m.child,m!==null))for(h0(m,y,E),m=m.sibling;m!==null;)h0(m,y,E),m=m.sibling}function Hf(m,y,E){var M=m.tag;if(M===5||M===6)m=m.stateNode,y?Lv(E,m,y):Ov(E,m);else if(!(M===4||Nr&&M===27)&&(m=m.child,m!==null))for(Hf(m,y,E),m=m.sibling;m!==null;)Hf(m,y,E),m=m.sibling}function j_(m,y,E){m=m.containerInfo;try{Pv(m,E)}catch(M){jn(y,y.return,M)}}function Wf(m,y){for($u(m.containerInfo),bi=y;bi!==null;)if(m=bi,y=m.child,(m.subtreeFlags&1028)!==0&&y!==null)y.return=m,bi=y;else for(;bi!==null;){m=bi;var E=m.alternate;switch(y=m.flags,m.tag){case 0:break;case 11:case 15:break;case 1:if((y&1024)!==0&&E!==null){y=void 0;var M=m,$=E.memoizedProps;E=E.memoizedState;var U=M.stateNode;try{var tt=al(M.type,$,M.elementType===M.type);y=U.getSnapshotBeforeUpdate(tt,E),U.__reactInternalSnapshotBeforeUpdate=y}catch(mt){jn(M,M.return,mt)}}break;case 3:(y&1024)!==0&&Ar&&R0(m.stateNode.containerInfo);break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((y&1024)!==0)throw Error(i(163))}if(y=m.sibling,y!==null){y.return=m.return,bi=y;break}bi=m.return}return tt=Yh,Yh=!1,tt}function f0(m,y,E){var M=E.flags;switch(E.tag){case 0:case 11:case 15:zl(m,E),M&4&&Fp(5,E);break;case 1:if(zl(m,E),M&4)if(m=E.stateNode,y===null)try{m.componentDidMount()}catch(mt){jn(E,E.return,mt)}else{var $=al(E.type,y.memoizedProps);y=y.memoizedState;try{m.componentDidUpdate($,y,m.__reactInternalSnapshotBeforeUpdate)}catch(mt){jn(E,E.return,mt)}}M&64&&q_(E),M&512&&$h(E,E.return);break;case 3:if(zl(m,E),M&64&&(M=E.updateQueue,M!==null)){if(m=null,E.child!==null)switch(E.child.tag){case 27:case 5:m=ed(E.child.stateNode);break;case 1:m=E.child.stateNode}try{ye(M,m)}catch(mt){jn(E,E.return,mt)}}break;case 26:if(no){zl(m,E),M&512&&$h(E,E.return);break}case 27:case 5:zl(m,E),y===null&&M&4&&Gf(E),M&512&&$h(E,E.return);break;case 12:zl(m,E);break;case 13:zl(m,E),M&4&&_u(m,E);break;case 22:if($=E.memoizedState!==null||Ji,!$){y=y!==null&&y.memoizedState!==null||ci;var U=Ji,tt=ci;Ji=$,(ci=y)&&!tt?Tu(m,E,(E.subtreeFlags&8772)!==0):zl(m,E),Ji=U,ci=tt}M&512&&(E.memoizedProps.mode==="manual"?$h(E,E.return):Js(E,E.return));break;default:zl(m,E)}}function qf(m){var y=m.alternate;y!==null&&(m.alternate=null,qf(y)),m.child=null,m.deletions=null,m.sibling=null,m.tag===5&&(y=m.stateNode,y!==null&&Dv(y)),m.stateNode=null,m.return=null,m.dependencies=null,m.memoizedProps=null,m.memoizedState=null,m.pendingProps=null,m.stateNode=null,m.updateQueue=null}function Qa(m,y,E){for(E=E.child;E!==null;)d0(m,y,E),E=E.sibling}function d0(m,y,E){if(Ta&&typeof Ta.onCommitFiberUnmount=="function")try{Ta.onCommitFiberUnmount(ad,E)}catch{}switch(E.tag){case 26:if(no){ci||Js(E,y),Qa(m,y,E),E.memoizedState?jv(E.memoizedState):E.stateNode&&Zv(E.stateNode);break}case 27:if(Nr){ci||Js(E,y);var M=Mi,$=Aa;Mi=E.stateNode,Qa(m,y,E),_w(E.stateNode),Mi=M,Aa=$;break}case 5:ci||Js(E,y);case 6:if(Ar){if(M=Mi,$=Aa,Mi=null,Qa(m,y,E),Mi=M,Aa=$,Mi!==null)if(Aa)try{Ci(Mi,E.stateNode)}catch(U){jn(E,y,U)}else try{ca(Mi,E.stateNode)}catch(U){jn(E,y,U)}}else Qa(m,y,E);break;case 18:Ar&&Mi!==null&&(Aa?Wv(Mi,E.stateNode):yw(Mi,E.stateNode));break;case 4:Ar?(M=Mi,$=Aa,Mi=E.stateNode.containerInfo,Aa=!0,Qa(m,y,E),Mi=M,Aa=$):(to&&j_(E.stateNode,E,D0()),Qa(m,y,E));break;case 0:case 11:case 14:case 15:ci||Su(2,E,y),ci||Su(4,E,y),Qa(m,y,E);break;case 1:ci||(Js(E,y),M=E.stateNode,typeof M.componentWillUnmount=="function"&&X_(E,y,M)),Qa(m,y,E);break;case 21:Qa(m,y,E);break;case 22:ci||Js(E,y),ci=(M=ci)||E.memoizedState!==null,Qa(m,y,E),ci=M;break;default:Qa(m,y,E)}}function _u(m,y){if(la&&y.memoizedState===null&&(m=y.alternate,m!==null&&(m=m.memoizedState,m!==null&&(m=m.dehydrated,m!==null))))try{L0(m)}catch(E){jn(y,y.return,E)}}function Xf(m){switch(m.tag){case 13:case 19:var y=m.stateNode;return y===null&&(y=m.stateNode=new fd),y;case 22:return m=m.stateNode,y=m._retryCache,y===null&&(y=m._retryCache=new fd),y;default:throw Error(i(435,m.tag))}}function zp(m,y){var E=Xf(m);y.forEach(function(M){var $=yv.bind(null,m,M);E.has(M)||(E.add(M),M.then($,$))})}function ra(m,y){var E=y.deletions;if(E!==null)for(var M=0;M<E.length;M++){var $=E[M],U=m,tt=y;if(Ar){var mt=tt;t:for(;mt!==null;){switch(mt.tag){case 27:case 5:Mi=mt.stateNode,Aa=!1;break t;case 3:Mi=mt.stateNode.containerInfo,Aa=!0;break t;case 4:Mi=mt.stateNode.containerInfo,Aa=!0;break t}mt=mt.return}if(Mi===null)throw Error(i(160));d0(U,tt,$),Mi=null,Aa=!1}else d0(U,tt,$);U=$.alternate,U!==null&&(U.return=null),$.return=null}if(y.subtreeFlags&13878)for(y=y.child;y!==null;)wu(y,m),y=y.sibling}function wu(m,y){var E=m.alternate,M=m.flags;switch(m.tag){case 0:case 11:case 14:case 15:ra(y,m),va(m),M&4&&(Su(3,m,m.return),Fp(3,m),Su(5,m,m.return));break;case 1:ra(y,m),va(m),M&512&&(ci||E===null||Js(E,E.return)),M&64&&Ji&&(m=m.updateQueue,m!==null&&(M=m.callbacks,M!==null&&(E=m.shared.hiddenCallbacks,m.shared.hiddenCallbacks=E===null?M:E.concat(M))));break;case 26:if(no){var $=ua;ra(y,m),va(m),M&512&&(ci||E===null||Js(E,E.return)),M&4&&(M=E!==null?E.memoizedState:null,y=m.memoizedState,E===null?y===null?m.stateNode===null?m.stateNode=Kv($,m.type,m.memoizedProps,m):Yv($,m.type,m.stateNode):m.stateNode=Xv($,y,m.memoizedProps):M!==y?(M===null?E.stateNode!==null&&Zv(E.stateNode):jv(M),y===null?Yv($,m.type,m.stateNode):Xv($,y,m.memoizedProps)):y===null&&m.stateNode!==null&&hv(m,m.memoizedProps,E.memoizedProps));break}case 27:if(Nr&&M&4&&m.alternate===null){$=m.stateNode;var U=m.memoizedProps;try{ON($),$N(m.type,U,$,m)}catch(Te){jn(m,m.return,Te)}}case 5:if(ra(y,m),va(m),M&512&&(ci||E===null||Js(E,E.return)),Ar){if(m.flags&32){y=m.stateNode;try{Zp(y)}catch(Te){jn(m,m.return,Te)}}M&4&&m.stateNode!=null&&(y=m.memoizedProps,hv(m,y,E!==null?E.memoizedProps:y)),M&1024&&(Hu=!0)}break;case 6:if(ra(y,m),va(m),M&4&&Ar){if(m.stateNode===null)throw Error(i(162));M=m.memoizedProps,E=E!==null?E.memoizedProps:M,y=m.stateNode;try{rw(y,E,M)}catch(Te){jn(m,m.return,Te)}}break;case 3:if(no?(Qv(),$=ua,ua=F0(y.containerInfo),ra(y,m),ua=$):ra(y,m),va(m),M&4){if(Ar&&la&&E!==null&&E.memoizedState.isDehydrated)try{$0(y.containerInfo)}catch(Te){jn(m,m.return,Te)}if(to){M=y.containerInfo,E=y.pendingChildren;try{Pv(M,E)}catch(Te){jn(m,m.return,Te)}}}Hu&&(Hu=!1,dv(m));break;case 4:no?(E=ua,ua=F0(m.stateNode.containerInfo),ra(y,m),va(m),ua=E):(ra(y,m),va(m)),M&4&&to&&j_(m.stateNode,m,m.stateNode.pendingChildren);break;case 12:ra(y,m),va(m);break;case 13:ra(y,m),va(m),m.child.flags&8192&&m.memoizedState!==null!=(E!==null&&E.memoizedState!==null)&&(Ql=Mr()),M&4&&(M=m.updateQueue,M!==null&&(m.updateQueue=null,zp(m,M)));break;case 22:M&512&&(ci||E===null||Js(E,E.return)),$=m.memoizedState!==null;var tt=E!==null&&E.memoizedState!==null,mt=Ji,It=ci;if(Ji=mt||$,ci=It||tt,ra(y,m),ci=It,Ji=mt,va(m),y=m.stateNode,y._current=m,y._visibility&=-3,y._visibility|=y._pendingVisibility&2,M&8192&&(y._visibility=$?y._visibility&-2:y._visibility|1,$&&(y=Ji||ci,E===null||tt||y||jf(m)),Ar&&(m.memoizedProps===null||m.memoizedProps.mode!=="manual"))){t:if(E=null,Ar)for(y=m;;){if(y.tag===5||no&&y.tag===26||Nr&&y.tag===27){if(E===null){tt=E=y;try{U=tt.stateNode,$?Qp(U):zv(tt.stateNode,tt.memoizedProps)}catch(Te){jn(tt,tt.return,Te)}}}else if(y.tag===6){if(E===null){tt=y;try{var ne=tt.stateNode;$?I0(ne):Ic(ne,tt.memoizedProps)}catch(Te){jn(tt,tt.return,Te)}}}else if((y.tag!==22&&y.tag!==23||y.memoizedState===null||y===m)&&y.child!==null){y.child.return=y,y=y.child;continue}if(y===m)break t;for(;y.sibling===null;){if(y.return===null||y.return===m)break t;E===y&&(E=null),y=y.return}E===y&&(E=null),y.sibling.return=y.return,y=y.sibling}}M&4&&(M=m.updateQueue,M!==null&&(E=M.retryQueue,E!==null&&(M.retryQueue=null,zp(m,E))));break;case 19:ra(y,m),va(m),M&4&&(M=m.updateQueue,M!==null&&(m.updateQueue=null,zp(m,M)));break;case 21:break;default:ra(y,m),va(m)}}function va(m){var y=m.flags;if(y&2){try{if(Ar&&(!Nr||m.tag!==27)){t:{for(var E=m.return;E!==null;){if(fv(E)){var M=E;break t}E=E.return}throw Error(i(160))}switch(M.tag){case 27:if(Nr){var $=M.stateNode,U=u0(m);Hf(m,U,$);break}case 5:var tt=M.stateNode;M.flags&32&&(Zp(tt),M.flags&=-33);var mt=u0(m);Hf(m,mt,tt);break;case 3:case 4:var It=M.stateNode.containerInfo,ne=u0(m);h0(m,ne,It);break;default:throw Error(i(161))}}}catch(Te){jn(m,m.return,Te)}m.flags&=-3}y&4096&&(m.flags&=-4097)}function dv(m){if(m.subtreeFlags&1024)for(m=m.child;m!==null;){var y=m;dv(y),y.tag===5&&y.flags&1024&&Os(y.stateNode),m=m.sibling}}function zl(m,y){if(y.subtreeFlags&8772)for(y=y.child;y!==null;)f0(m,y.alternate,y),y=y.sibling}function jf(m){for(m=m.child;m!==null;){var y=m;switch(y.tag){case 0:case 11:case 14:case 15:Su(4,y,y.return),jf(y);break;case 1:Js(y,y.return);var E=y.stateNode;typeof E.componentWillUnmount=="function"&&X_(y,y.return,E),jf(y);break;case 26:case 27:case 5:Js(y,y.return),jf(y);break;case 22:Js(y,y.return),y.memoizedState===null&&jf(y);break;default:jf(y)}m=m.sibling}}function Tu(m,y,E){for(E=E&&(y.subtreeFlags&8772)!==0,y=y.child;y!==null;){var M=y.alternate,$=m,U=y,tt=U.flags;switch(U.tag){case 0:case 11:case 15:Tu($,U,E),Fp(4,U);break;case 1:if(Tu($,U,E),M=U,$=M.stateNode,typeof $.componentDidMount=="function")try{$.componentDidMount()}catch(ne){jn(M,M.return,ne)}if(M=U,$=M.updateQueue,$!==null){var mt=M.stateNode;try{var It=$.shared.hiddenCallbacks;if(It!==null)for($.shared.hiddenCallbacks=null,$=0;$<It.length;$++)dt(It[$],mt)}catch(ne){jn(M,M.return,ne)}}E&&tt&64&&q_(U),$h(U,U.return);break;case 26:case 27:case 5:Tu($,U,E),E&&M===null&&tt&4&&Gf(U),$h(U,U.return);break;case 12:Tu($,U,E);break;case 13:Tu($,U,E),E&&tt&4&&_u($,U);break;case 22:U.memoizedState===null&&Tu($,U,E),$h(U,U.return);break;default:Tu($,U,E)}y=y.sibling}}function pv(m,y){var E=null;m!==null&&m.memoizedState!==null&&m.memoizedState.cachePool!==null&&(E=m.memoizedState.cachePool.pool),m=null,y.memoizedState!==null&&y.memoizedState.cachePool!==null&&(m=y.memoizedState.cachePool.pool),m!==E&&(m!=null&&m.refCount++,E!=null&&Uf(E))}function p0(m,y){m=null,y.alternate!==null&&(m=y.alternate.memoizedState.cache),y=y.memoizedState.cache,y!==m&&(y.refCount++,m!=null&&Uf(m))}function bc(m,y,E,M){if(y.subtreeFlags&10256)for(y=y.child;y!==null;)m0(m,y,E,M),y=y.sibling}function m0(m,y,E,M){var $=y.flags;switch(y.tag){case 0:case 11:case 15:bc(m,y,E,M),$&2048&&Fp(9,y);break;case 3:bc(m,y,E,M),$&2048&&(m=null,y.alternate!==null&&(m=y.alternate.memoizedState.cache),y=y.memoizedState.cache,y!==m&&(y.refCount++,m!=null&&Uf(m)));break;case 12:if($&2048){bc(m,y,E,M),m=y.stateNode;try{var U=y.memoizedProps,tt=U.id,mt=U.onPostCommit;typeof mt=="function"&&mt(tt,y.alternate===null?"mount":"update",m.passiveEffectDuration,-0)}catch(It){jn(y,y.return,It)}}else bc(m,y,E,M);break;case 23:break;case 22:U=y.stateNode,y.memoizedState!==null?U._visibility&4?bc(m,y,E,M):Eu(m,y):U._visibility&4?bc(m,y,E,M):(U._visibility|=4,Br(m,y,E,M,(y.subtreeFlags&10256)!==0)),$&2048&&pv(y.alternate,y);break;case 24:bc(m,y,E,M),$&2048&&p0(y.alternate,y);break;default:bc(m,y,E,M)}}function Br(m,y,E,M,$){for($=$&&(y.subtreeFlags&10256)!==0,y=y.child;y!==null;){var U=m,tt=y,mt=E,It=M,ne=tt.flags;switch(tt.tag){case 0:case 11:case 15:Br(U,tt,mt,It,$),Fp(8,tt);break;case 23:break;case 22:var Te=tt.stateNode;tt.memoizedState!==null?Te._visibility&4?Br(U,tt,mt,It,$):Eu(U,tt):(Te._visibility|=4,Br(U,tt,mt,It,$)),$&&ne&2048&&pv(tt.alternate,tt);break;case 24:Br(U,tt,mt,It,$),$&&ne&2048&&p0(tt.alternate,tt);break;default:Br(U,tt,mt,It,$)}y=y.sibling}}function Eu(m,y){if(y.subtreeFlags&10256)for(y=y.child;y!==null;){var E=m,M=y,$=M.flags;switch(M.tag){case 22:Eu(E,M),$&2048&&pv(M.alternate,M);break;case 24:Eu(E,M),$&2048&&p0(M.alternate,M);break;default:Eu(E,M)}y=y.sibling}}function hr(m){if(m.subtreeFlags&Zh)for(m=m.child;m!==null;)Lh(m),m=m.sibling}function Lh(m){switch(m.tag){case 26:hr(m),m.flags&Zh&&(m.memoizedState!==null?tb(ua,m.memoizedState,m.memoizedProps):mi(m.type,m.memoizedProps));break;case 5:hr(m),m.flags&Zh&&mi(m.type,m.memoizedProps);break;case 3:case 4:if(no){var y=ua;ua=F0(m.stateNode.containerInfo),hr(m),ua=y}else hr(m);break;case 22:m.memoizedState===null&&(y=m.alternate,y!==null&&y.memoizedState!==null?(y=Zh,Zh=16777216,hr(m),Zh=y):hr(m));break;default:hr(m)}}function g0(m){var y=m.alternate;if(y!==null&&(m=y.child,m!==null)){y.child=null;do y=m.sibling,m.sibling=null,m=y;while(m!==null)}}function Cu(m){var y=m.deletions;if((m.flags&16)!==0){if(y!==null)for(var E=0;E<y.length;E++){var M=y[E];bi=M,Au(M,m)}g0(m)}if(m.subtreeFlags&10256)for(m=m.child;m!==null;)Up(m),m=m.sibling}function Up(m){switch(m.tag){case 0:case 11:case 15:Cu(m),m.flags&2048&&Su(9,m,m.return);break;case 3:Cu(m);break;case 12:Cu(m);break;case 22:var y=m.stateNode;m.memoizedState!==null&&y._visibility&4&&(m.return===null||m.return.tag!==13)?(y._visibility&=-5,Kf(m)):Cu(m);break;default:Cu(m)}}function Kf(m){var y=m.deletions;if((m.flags&16)!==0){if(y!==null)for(var E=0;E<y.length;E++){var M=y[E];bi=M,Au(M,m)}g0(m)}for(m=m.child;m!==null;){switch(y=m,y.tag){case 0:case 11:case 15:Su(8,y,y.return),Kf(y);break;case 22:E=y.stateNode,E._visibility&4&&(E._visibility&=-5,Kf(y));break;default:Kf(y)}m=m.sibling}}function Au(m,y){for(;bi!==null;){var E=bi;switch(E.tag){case 0:case 11:case 15:Su(8,E,y);break;case 23:case 22:if(E.memoizedState!==null&&E.memoizedState.cachePool!==null){var M=E.memoizedState.cachePool.pool;M!=null&&M.refCount++}break;case 24:Uf(E.memoizedState.cache)}if(M=E.child,M!==null)M.return=E,bi=M;else t:for(E=m;bi!==null;){M=bi;var $=M.sibling,U=M.return;if(qf(M),M===E){bi=null;break t}if($!==null){$.return=U,bi=$;break t}bi=U}}}function y0(m){var y=Iv(m);if(y!=null){if(typeof y.memoizedProps["data-testname"]!="string")throw Error(i(364));return y}if(m=Wh(m),m===null)throw Error(i(362));return m.stateNode.current}function Yf(m,y){var E=m.tag;switch(y.$$typeof){case dm:if(m.type===y.value)return!0;break;case j0:t:{for(y=y.value,m=[m,0],E=0;E<m.length;){var M=m[E++],$=M.tag,U=m[E++],tt=y[U];if($!==5&&$!==26&&$!==27||!Xl(M)){for(;tt!=null&&Yf(M,tt);)U++,tt=y[U];if(U===y.length){y=!0;break t}else for(M=M.child;M!==null;)m.push(M,U),M=M.sibling}}y=!1}return y;case K0:if((E===5||E===26||E===27)&&MN(m.stateNode,y.value))return!0;break;case ws:if((E===5||E===6||E===26||E===27)&&(m=Yp(m),m!==null&&0<=m.indexOf(y.value)))return!0;break;case ts:if((E===5||E===26||E===27)&&(m=m.memoizedProps["data-testname"],typeof m=="string"&&m.toLowerCase()===y.value.toLowerCase()))return!0;break;default:throw Error(i(365))}return!1}function Nu(m){switch(m.$$typeof){case dm:return"<"+(a(m.value)||"Unknown")+">";case j0:return":has("+(Nu(m)||"")+")";case K0:return'[role="'+m.value+'"]';case ws:return'"'+m.value+'"';case ts:return'[data-testname="'+m.value+'"]';default:throw Error(i(365))}}function K_(m,y){var E=[];m=[m,0];for(var M=0;M<m.length;){var $=m[M++],U=$.tag,tt=m[M++],mt=y[tt];if(U!==5&&U!==26&&U!==27||!Xl($)){for(;mt!=null&&Yf($,mt);)tt++,mt=y[tt];if(tt===y.length)E.push($);else for($=$.child;$!==null;)m.push($,tt),$=$.sibling}}return E}function aa(m,y){if(!ql)throw Error(i(363));m=y0(m),m=K_(m,y),y=[],m=Array.from(m);for(var E=0;E<m.length;){var M=m[E++],$=M.tag;if($===5||$===26||$===27)Xl(M)||y.push(M.stateNode);else for(M=M.child;M!==null;)m.push(M),M=M.sibling}return y}function oa(){if((an&2)!==0&&Un!==0)return Un&-Un;if(dn.T!==null){var m=Ea;return m!==0?m:te()}return Oo()}function Ul(){Na===0&&(Na=(Un&536870912)===0||is?z():536870912);var m=co.current;return m!==null&&(m.flags|=32),Na}function Pr(m,y,E){(m===Gn&&$s===2||m.cancelPendingCommit!==null)&&(ll(m,0),ol(m,Un,Na,!1)),L(m,E),((an&2)===0||m!==Gn)&&(m===Gn&&((an&2)===0&&(ml|=E),es===4&&ol(m,Un,Na,!1)),he(m))}function Bp(m,y,E){if((an&6)!==0)throw Error(i(327));var M=!E&&(y&60)===0&&(y&m.expiredLanes)===0||D(m,y),$=M?Vl(m,y):Bl(m,y,!0),U=M;do{if($===0){uo&&!M&&ol(m,y,0,!1);break}else if($===6)ol(m,y,0,!Ts);else{if(E=m.current.alternate,U&&!Y_(E)){$=Bl(m,y,!1),U=!1;continue}if($===2){if(U=y,m.errorRecoveryDisabledLanes&U)var tt=0;else tt=m.pendingLanes&-536870913,tt=tt!==0?tt:tt&536870912?536870912:0;if(tt!==0){y=tt;t:{var mt=m;$=dd;var It=la&&mt.current.memoizedState.isDehydrated;if(It&&(ll(mt,tt).flags|=256),tt=Bl(mt,tt,!1),tt!==2){if(Lc&&!It){mt.errorRecoveryDisabledLanes|=U,ml|=U,$=4;break t}U=fo,fo=$,U!==null&&Sc(U)}$=tt}if(U=!1,$!==2)continue}}if($===1){ll(m,0),ol(m,y,0,!0);break}t:{switch(M=m,$){case 0:case 1:throw Error(i(345));case 4:if((y&4194176)===y){ol(M,y,Na,!Ts);break t}break;case 2:fo=null;break;case 3:case 5:break;default:throw Error(i(329))}if(M.finishedWork=E,M.finishedLanes=y,(y&62914560)===y&&(U=Ql+300-Mr(),10<U)){if(ol(M,y,Na,!Ts),I(M,0)!==0)break t;M.timeoutHandle=Mv(x0.bind(null,M,E,fo,gl,pd,y,Na,ml,Fc,Ts,2,-0,0),U);break t}x0(M,E,fo,gl,pd,y,Na,ml,Fc,Ts,0,-0,0)}}break}while(!0);he(m)}function Sc(m){fo===null?fo=m:fo.push.apply(fo,m)}function x0(m,y,E,M,$,U,tt,mt,It,ne,Te,$e,Ve){var En=y.subtreeFlags;if((En&8192||(En&16785408)===16785408)&&(eo(),Lh(y),y=A0(),y!==null)){m.cancelPendingCommit=y(qs.bind(null,m,E,M,$,tt,mt,It,1,$e,Ve)),ol(m,U,tt,!ne);return}qs(m,E,M,$,tt,mt,It,Te,$e,Ve)}function Y_(m){for(var y=m;;){var E=y.tag;if((E===0||E===11||E===15)&&y.flags&16384&&(E=y.updateQueue,E!==null&&(E=E.stores,E!==null)))for(var M=0;M<E.length;M++){var $=E[M],U=$.getSnapshot;$=$.value;try{if(!so(U(),$))return!1}catch{return!1}}if(E=y.child,y.subtreeFlags&16384&&E!==null)E.return=y,y=E;else{if(y===m)break;for(;y.sibling===null;){if(y.return===null||y.return===m)return!0;y=y.return}y.sibling.return=y.return,y=y.sibling}}return!0}function ol(m,y,E,M){y&=~Xr,y&=~ml,m.suspendedLanes|=y,m.pingedLanes&=~y,M&&(m.warmLanes|=y),M=m.expirationTimes;for(var $=y;0<$;){var U=31-wa($),tt=1<<U;M[U]=-1,$&=~tt}E!==0&&q(m,E,y)}function mv(){return(an&6)===0?(Pe(0),!1):!0}function ba(){if(Cn!==null){if($s===0)var m=Cn.return;else m=Cn,vi=Gu=null,Ah(m),Kl=null,Fo=0,m=Cn;for(;m!==null;)uv(m.alternate,m),m=m.return;Cn=null}}function ll(m,y){m.finishedWork=null,m.finishedLanes=0;var E=m.timeoutHandle;E!==Hh&&(m.timeoutHandle=Hh,Kp(E)),E=m.cancelPendingCommit,E!==null&&(m.cancelPendingCommit=null,E()),ba(),Gn=m,Cn=E=Vr(m.current,null),Un=y,$s=0,Ii=null,Ts=!1,uo=D(m,y),Lc=!1,Fc=Na=Xr=ml=ho=es=0,fo=dd=null,pd=!1,(y&8)!==0&&(y|=y&32);var M=m.entangledLanes;if(M!==0)for(m=m.entanglements,M&=y;0<M;){var $=31-wa(M),U=1<<$;y|=m[$],M&=~U}return pl=y,Ht(),E}function Fh(m,y){Dn=null,dn.H=rs,y===Rs?(y=ve(),$s=3):y===ib?(y=ve(),$s=4):$s=y===Mw?8:y!==null&&typeof y=="object"&&typeof y.then=="function"?6:1,Ii=y,Cn===null&&(es=1,s0(m,st(y,m.current)))}function Pp(){var m=co.current;return m===null?!0:(Un&4194176)===Un?zo===null:(Un&62914560)===Un||(Un&536870912)!==0?m===zo:!1}function Zf(){var m=dn.H;return dn.H=rs,m===null?rs:m}function Ja(){var m=dn.A;return dn.A=X0,m}function Sa(){es=4,Ts||(Un&4194176)!==Un&&co.current!==null||(uo=!0),(ho&134217727)===0&&(ml&134217727)===0||Gn===null||ol(Gn,Un,Na,!1)}function Bl(m,y,E){var M=an;an|=2;var $=Zf(),U=Ja();(Gn!==m||Un!==y)&&(gl=null,ll(m,y)),y=!1;var tt=es;t:do try{if($s!==0&&Cn!==null){var mt=Cn,It=Ii;switch($s){case 8:ba(),tt=6;break t;case 3:case 2:case 6:co.current===null&&(y=!0);var ne=$s;if($s=0,Ii=null,Mu(m,mt,It,ne),E&&uo){tt=0;break t}break;default:ne=$s,$s=0,Ii=null,Mu(m,mt,It,ne)}}Pl(),tt=es;break}catch(Te){Fh(m,Te)}while(!0);return y&&m.shellSuspendCounter++,vi=Gu=null,an=M,dn.H=$,dn.A=U,Cn===null&&(Gn=null,Un=0,Ht()),tt}function Pl(){for(;Cn!==null;)gv(Cn)}function Vl(m,y){var E=an;an|=2;var M=Zf(),$=Ja();Gn!==m||Un!==y?(gl=null,ui=Mr()+500,ll(m,y)):uo=D(m,y);t:do try{if($s!==0&&Cn!==null){y=Cn;var U=Ii;e:switch($s){case 1:$s=0,Ii=null,Mu(m,y,U,1);break;case 2:if(Ce(U)){$s=0,Ii=null,v0(y);break}y=function(){$s===2&&Gn===m&&($s=7),he(m)},U.then(y,y);break t;case 3:$s=7;break t;case 4:$s=5;break t;case 7:Ce(U)?($s=0,Ii=null,v0(y)):($s=0,Ii=null,Mu(m,y,U,7));break;case 5:var tt=null;switch(Cn.tag){case 26:tt=Cn.memoizedState;case 5:case 27:var mt=Cn,It=mt.type,ne=mt.pendingProps;if(tt?Jv(tt):Mc(It,ne)){$s=0,Ii=null;var Te=mt.sibling;if(Te!==null)Cn=Te;else{var $e=mt.return;$e!==null?(Cn=$e,Vp($e)):Cn=null}break e}}$s=0,Ii=null,Mu(m,y,U,5);break;case 6:$s=0,Ii=null,Mu(m,y,U,6);break;case 8:ba(),es=6;break t;default:throw Error(i(462))}}_c();break}catch(Ve){Fh(m,Ve)}while(!0);return vi=Gu=null,dn.H=M,dn.A=$,an=E,Cn!==null?0:(Gn=null,Un=0,Ht(),es)}function _c(){for(;Cn!==null&&!Tw();)gv(Cn)}function gv(m){var y=V_(m.alternate,m,pl);m.memoizedProps=m.pendingProps,y===null?Vp(m):Cn=y}function v0(m){var y=m,E=y.alternate;switch(y.tag){case 15:case 0:y=F_(E,y,y.pendingProps,y.type,void 0,Un);break;case 11:y=F_(E,y,y.pendingProps,y.type.render,y.ref,Un);break;case 5:Ah(y);default:uv(E,y),y=Cn=Ec(y,pl),y=V_(E,y,pl)}m.memoizedProps=m.pendingProps,y===null?Vp(m):Cn=y}function Mu(m,y,E,M){vi=Gu=null,Ah(y),Kl=null,Fo=0;var $=y.return;try{if(D_(m,$,y,E,Un)){es=1,s0(m,st(E,m.current)),Cn=null;return}}catch(U){if($!==null)throw Cn=$,U;es=1,s0(m,st(E,m.current)),Cn=null;return}y.flags&32768?(is||M===1?m=!0:uo||(Un&536870912)!==0?m=!1:(Ts=m=!0,(M===2||M===3||M===6)&&(M=co.current,M!==null&&M.tag===13&&(M.flags|=16384))),fr(y,m)):Vp(y)}function Vp(m){var y=m;do{if((y.flags&32768)!==0){fr(y,Ts);return}m=y.return;var E=H_(y.alternate,y,pl);if(E!==null){Cn=E;return}if(y=y.sibling,y!==null){Cn=y;return}Cn=y=m}while(y!==null);es===0&&(es=5)}function fr(m,y){do{var E=W_(m.alternate,m);if(E!==null){E.flags&=32767,Cn=E;return}if(E=m.return,E!==null&&(E.flags|=32768,E.subtreeFlags=0,E.deletions=null),!y&&(m=m.sibling,m!==null)){Cn=m;return}Cn=m=E}while(m!==null);es=6,Cn=null}function qs(m,y,E,M,$,U,tt,mt,It,ne){var Te=dn.T,$e=Qi();try{Gr(2),dn.T=null,Yn(m,y,E,M,$e,$,U,tt,mt,It,ne)}finally{dn.T=Te,Gr($e)}}function Yn(m,y,E,M,$,U,tt,mt){do dr();while(zc!==null);if((an&6)!==0)throw Error(i(327));var It=m.finishedWork;if(M=m.finishedLanes,It===null)return null;if(m.finishedWork=null,m.finishedLanes=0,It===m.current)throw Error(i(177));m.callbackNode=null,m.callbackPriority=0,m.cancelPendingCommit=null;var ne=It.lanes|It.childLanes;if(ne|=ld,H(m,M,ne,U,tt,mt),m===Gn&&(Cn=Gn=null,Un=0),(It.subtreeFlags&10256)===0&&(It.flags&10256)===0||Bo||(Bo=!0,Y0=ne,Jh=E,Gp(U0,function(){return dr(),null})),E=(It.flags&15990)!==0,(It.subtreeFlags&15990)!==0||E?(E=dn.T,dn.T=null,U=Qi(),Gr(2),tt=an,an|=4,Wf(m,It),wu(It,m),Av(m.containerInfo),m.current=It,f0(m,It.alternate,It),Ew(),an=tt,Gr(U),dn.T=E):m.current=It,Bo?(Bo=!1,zc=m,Qh=M):wc(m,ne),ne=m.pendingLanes,ne===0&&(po=null),P(It.stateNode),he(m),y!==null)for($=m.onRecoverableError,It=0;It<y.length;It++)ne=y[It],$(ne.value,{componentStack:ne.stack});return(Qh&3)!==0&&dr(),ne=m.pendingLanes,(M&4194218)!==0&&(ne&42)!==0?m===ha?tf++:(tf=0,ha=m):tf=0,Pe(0),null}function wc(m,y){(m.pooledCacheLanes&=y)===0&&(y=m.pooledCache,y!=null&&(m.pooledCache=null,Uf(y)))}function dr(){if(zc!==null){var m=zc,y=Y0;Y0=0;var E=Y(Qh),M=32>E?32:E;E=dn.T;var $=Qi();try{if(Gr(M),dn.T=null,zc===null)var U=!1;else{M=Jh,Jh=null;var tt=zc,mt=Qh;if(zc=null,Qh=0,(an&6)!==0)throw Error(i(331));var It=an;if(an|=4,Up(tt.current),m0(tt,tt.current,mt,M),an=It,Pe(0,!1),Ta&&typeof Ta.onPostCommitFiberRoot=="function")try{Ta.onPostCommitFiberRoot(ad,tt)}catch{}U=!0}return U}finally{Gr($),dn.T=E,wc(m,y)}}return!1}function b0(m,y,E){y=st(E,y),y=Rp(m.stateNode,y,2),m=de(m,y,2),m!==null&&(L(m,2),he(m))}function jn(m,y,E){if(m.tag===3)b0(m,m,E);else for(;y!==null;){if(y.tag===3){b0(y,m,E);break}else if(y.tag===1){var M=y.stateNode;if(typeof y.type.getDerivedStateFromError=="function"||typeof M.componentDidCatch=="function"&&(po===null||!po.has(M))){m=st(E,m),E=zf(2),M=de(y,E,2),M!==null&&(Dp(E,M,y,m),L(M,2),he(M));break}}y=y.return}}function S0(m,y,E){var M=m.pingCache;if(M===null){M=m.pingCache=new Kn;var $=new Set;M.set(y,$)}else $=M.get(y),$===void 0&&($=new Set,M.set(y,$));$.has(E)||(Lc=!0,$.add(E),m=Z_.bind(null,m,y,E),y.then(m,m))}function Z_(m,y,E){var M=m.pingCache;M!==null&&M.delete(y),m.pingedLanes|=m.suspendedLanes&E,m.warmLanes&=~E,Gn===m&&(Un&E)===E&&(es===4||es===3&&(Un&62914560)===Un&&300>Mr()-Ql?(an&2)===0&&ll(m,0):Xr|=E,Fc===Un&&(Fc=0)),he(m)}function zh(m,y){y===0&&(y=k()),m=ce(m,y),m!==null&&(L(m,y),he(m))}function Uh(m){var y=m.memoizedState,E=0;y!==null&&(E=y.retryLane),zh(m,E)}function yv(m,y){var E=0;switch(m.tag){case 13:var M=m.stateNode,$=m.memoizedState;$!==null&&(E=$.retryLane);break;case 19:M=m.stateNode;break;case 22:M=m.stateNode._retryCache;break;default:throw Error(i(314))}M!==null&&M.delete(y),zh(m,E)}function Gp(m,y){return rd(m,y)}function xv(m,y,E,M){this.tag=m,this.key=E,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=y,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=M,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Tc(m){return m=m.prototype,!(!m||!m.isReactComponent)}function Vr(m,y){var E=m.alternate;return E===null?(E=e(m.tag,y,m.key,m.mode),E.elementType=m.elementType,E.type=m.type,E.stateNode=m.stateNode,E.alternate=m,m.alternate=E):(E.pendingProps=y,E.type=m.type,E.flags=0,E.subtreeFlags=0,E.deletions=null),E.flags=m.flags&31457280,E.childLanes=m.childLanes,E.lanes=m.lanes,E.child=m.child,E.memoizedProps=m.memoizedProps,E.memoizedState=m.memoizedState,E.updateQueue=m.updateQueue,y=m.dependencies,E.dependencies=y===null?null:{lanes:y.lanes,firstContext:y.firstContext},E.sibling=m.sibling,E.index=m.index,E.ref=m.ref,E.refCleanup=m.refCleanup,E}function Ec(m,y){m.flags&=31457282;var E=m.alternate;return E===null?(m.childLanes=0,m.lanes=y,m.child=null,m.subtreeFlags=0,m.memoizedProps=null,m.memoizedState=null,m.updateQueue=null,m.dependencies=null,m.stateNode=null):(m.childLanes=E.childLanes,m.lanes=E.lanes,m.child=E.child,m.subtreeFlags=0,m.deletions=null,m.memoizedProps=E.memoizedProps,m.memoizedState=E.memoizedState,m.updateQueue=E.updateQueue,m.type=E.type,y=E.dependencies,m.dependencies=y===null?null:{lanes:y.lanes,firstContext:y.firstContext}),m}function ko(m,y,E,M,$,U){var tt=0;if(M=m,typeof m=="function")Tc(m)&&(tt=1);else if(typeof m=="string")tt=no&&Nr?qv(m,E,mr.current)?26:sd(m)?27:5:no?qv(m,E,mr.current)?26:5:Nr&&sd(m)?27:5;else t:switch(m){case Jf:return Cc(E.children,$,U,y);case wv:tt=8,$|=24;break;case Tv:return m=e(12,E,y,$|2),m.elementType=Tv,m.lanes=U,m;case w0:return m=e(13,E,y,$),m.elementType=w0,m.lanes=U,m;case Du:return m=e(19,E,y,$),m.elementType=Du,m.lanes=U,m;case qp:return _0(E,$,U,y);default:if(typeof m=="object"&&m!==null)switch(m.$$typeof){case tw:case Gl:tt=10;break t;case Ru:tt=9;break t;case td:tt=11;break t;case Wp:tt=14;break t;case ul:tt=16,M=null;break t}tt=29,E=Error(i(130,m===null?"null":typeof m,"")),M=null}return y=e(tt,E,y,$),y.elementType=m,y.type=M,y.lanes=U,y}function Cc(m,y,E,M){return m=e(7,m,M,y),m.lanes=E,m}function _0(m,y,E,M){m=e(22,m,M,y),m.elementType=qp,m.lanes=E;var $={_visibility:1,_pendingVisibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null,_current:null,detach:function(){var U=$._current;if(U===null)throw Error(i(456));if(($._pendingVisibility&2)===0){var tt=ce(U,2);tt!==null&&($._pendingVisibility|=2,Pr(tt,U,2))}},attach:function(){var U=$._current;if(U===null)throw Error(i(456));if(($._pendingVisibility&2)!==0){var tt=ce(U,2);tt!==null&&($._pendingVisibility&=-3,Pr(tt,U,2))}}};return m.stateNode=$,m}function Iu(m,y,E){return m=e(6,m,null,y),m.lanes=E,m}function Qf(m,y,E){return y=e(4,m.children!==null?m.children:[],m.key,y),y.lanes=E,y.stateNode={containerInfo:m.containerInfo,pendingChildren:null,implementation:m.implementation},y}function Bh(m,y,E,M,$,U,tt,mt){this.tag=1,this.containerInfo=m,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=Hh,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=O(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.finishedLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=O(0),this.hiddenUpdates=O(null),this.identifierPrefix=M,this.onUncaughtError=$,this.onCaughtError=U,this.onRecoverableError=tt,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=mt,this.incompleteTransitions=new Map}function pr(m,y,E,M,$,U,tt,mt,It,ne,Te,$e){return m=new Bh(m,y,E,tt,mt,It,ne,$e),y=1,U===!0&&(y|=24),U=e(3,null,null,y),m.current=U,U.stateNode=m,y=o0(),y.refCount++,m.pooledCache=y,y.refCount++,U.memoizedState={element:M,isDehydrated:E,cache:y},ze(U),m}function Hp(m){return m?(m=qh,m):qh}function vv(m){var y=m._reactInternals;if(y===void 0)throw typeof m.render=="function"?Error(i(188)):(m=Object.keys(m).join(","),Error(i(268,m)));return m=g(y),m=m!==null?v(m):null,m===null?null:ed(m.stateNode)}function Q_(m,y,E,M,$,U){$=Hp($),M.context===null?M.context=$:M.pendingContext=$,M=ae(y),M.payload={element:E},U=U===void 0?null:U,U!==null&&(M.callback=U),E=de(m,M,y),E!==null&&(Pr(E,m,y),Ne(E,m,y))}function J_(m,y){if(m=m.memoizedState,m!==null&&m.dehydrated!==null){var E=m.retryLane;m.retryLane=E!==0&&E<y?E:y}}function bv(m,y){J_(m,y),(m=m.alternate)&&J_(m,y)}var rn={},Sv=Dg(),Cr=fV(),Ph=Object.assign,_v=Symbol.for("react.element"),Ac=Symbol.for("react.transitional.element"),cl=Symbol.for("react.portal"),Jf=Symbol.for("react.fragment"),wv=Symbol.for("react.strict_mode"),Tv=Symbol.for("react.profiler"),tw=Symbol.for("react.provider"),Ru=Symbol.for("react.consumer"),Gl=Symbol.for("react.context"),td=Symbol.for("react.forward_ref"),w0=Symbol.for("react.suspense"),Du=Symbol.for("react.suspense_list"),Wp=Symbol.for("react.memo"),ul=Symbol.for("react.lazy"),qp=Symbol.for("react.offscreen"),ew=Symbol.for("react.memo_cache_sentinel"),Ev=Symbol.iterator,Vh=Symbol.for("react.client.reference"),dn=Sv.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,T0,Cv,ku=!1,Ou=Array.isArray,E0=t.rendererVersion,Xp=t.rendererPackageName,jp=t.extraDevToolsConfig,ed=t.getPublicInstance,Gh=t.getRootHostContext,nw=t.getChildHostContext,$u=t.prepareForCommit,Av=t.resetAfterCommit,Nv=t.createInstance,Hl=t.appendInitialChild,Nc=t.finalizeInitialChildren,Lu=t.shouldSetTextContent,C0=t.createTextInstance,Mv=t.scheduleTimeout,Kp=t.cancelTimeout,Hh=t.noTimeout,Wl=t.isPrimaryRenderer;t.warnsIfNotActing;var Ar=t.supportsMutation,to=t.supportsPersistence,la=t.supportsHydration,Iv=t.getInstanceFromNode;t.beforeActiveInstanceBlur,t.afterActiveInstanceBlur;var Rv=t.preparePortalMount;t.prepareScopeUpdate,t.getInstanceFromScope;var Gr=t.setCurrentUpdatePriority,Qi=t.getCurrentUpdatePriority,Oo=t.resolveUpdatePriority;t.resolveEventType,t.resolveEventTimeStamp;var Fu=t.shouldAttemptEagerTransition,Dv=t.detachDeletedInstance;t.requestPostPaintCallback;var sw=t.maySuspendCommit,Mc=t.preloadInstance,eo=t.startSuspendingCommit,mi=t.suspendInstance,A0=t.waitForCommitToBeReady,_a=t.NotPendingTransition,xn=t.HostTransitionContext,Os=t.resetFormInstance;t.bindToConsole;var zi=t.supportsMicrotasks,N0=t.scheduleMicrotask,ql=t.supportsTestSelectors,Wh=t.findFiberRoot,M0=t.getBoundingRect,Yp=t.getTextContent,Xl=t.isHiddenSubtree,MN=t.matchAccessibilityRole,gi=t.setFocusIfFocusable,kv=t.setupIntersectionObserver,Ov=t.appendChild,iw=t.appendChildToContainer,rw=t.commitTextUpdate,IN=t.commitMount,$v=t.commitUpdate,Lv=t.insertBefore,Fv=t.insertInContainerBefore,ca=t.removeChild,Ci=t.removeChildFromContainer,Zp=t.resetTextContent,Qp=t.hideInstance,I0=t.hideTextInstance,zv=t.unhideInstance,Ic=t.unhideTextInstance,R0=t.clearContainer,Uv=t.cloneInstance,D0=t.createContainerChildSet,Bv=t.appendChildToContainerChildSet,aw=t.finalizeContainerChildren,Pv=t.replaceContainerChildren,Vv=t.cloneHiddenInstance,Gv=t.cloneHiddenTextInstance,k0=t.isSuspenseInstancePending,Jp=t.isSuspenseInstanceFallback,ow=t.getSuspenseInstanceFallbackErrorDetails,RN=t.registerSuspenseInstanceRetry,lw=t.canHydrateFormStateMarker,cw=t.isFormStateMarkerMatching,Hv=t.getNextHydratableSibling,O0=t.getFirstHydratableChild,uw=t.getFirstHydratableChildWithinContainer,hw=t.getFirstHydratableChildWithinSuspenseInstance,fw=t.canHydrateInstance,dw=t.canHydrateTextInstance,pw=t.canHydrateSuspenseInstance,DN=t.hydrateInstance,mw=t.hydrateTextInstance,nd=t.hydrateSuspenseInstance,gw=t.getNextHydratableInstanceAfterSuspenseInstance,$0=t.commitHydratedContainer,L0=t.commitHydratedSuspenseInstance,yw=t.clearSuspenseBoundary,Wv=t.clearSuspenseBoundaryFromContainer,xw=t.shouldDeleteUnhydratedTailInstances;t.diffHydratedPropsForDevWarnings,t.diffHydratedTextForDevWarnings,t.describeHydratableInstanceForDevWarnings;var vw=t.validateHydratableInstance,bw=t.validateHydratableTextInstance,no=t.supportsResources,qv=t.isHostHoistableType,F0=t.getHoistableRoot,z0=t.getResource,Xv=t.acquireResource,jv=t.releaseResource,Kv=t.hydrateHoistable,Yv=t.mountHoistable,Zv=t.unmountHoistable,kN=t.createHoistableInstance,Qv=t.prepareToCommitHoistables,Sw=t.mayResourceSuspendCommit,Jv=t.preloadResource,tb=t.suspendResource,Nr=t.supportsSingletons,eb=t.resolveSingletonInstance,ON=t.clearSingleton,$N=t.acquireSingletonInstance,_w=t.releaseSingletonInstance,sd=t.isHostSingletonType,tm=[],Rc=-1,qh={},wa=Math.clz32?Math.clz32:C,em=Math.log,ww=Math.LN2,id=128,nm=4194304,rd=Cr.unstable_scheduleCallback,sm=Cr.unstable_cancelCallback,Tw=Cr.unstable_shouldYield,Ew=Cr.unstable_requestPaint,Mr=Cr.unstable_now,nb=Cr.unstable_ImmediatePriority,Cw=Cr.unstable_UserBlockingPriority,U0=Cr.unstable_NormalPriority,B0=Cr.unstable_IdlePriority,Aw=Cr.log,sb=Cr.unstable_setDisableYieldValue,ad=null,Ta=null,so=typeof Object.is=="function"?Object.is:j,P0=new WeakMap,ti=[],yi=0,im=null,rm=0,io=[],ro=0,hl=null,jl=1,$o="",mr=S(null),am=S(null),fl=S(null),od=S(null),Hr=null,Ir=null,is=!1,ao=null,Lo=!1,om=Error(i(519)),oo=[],zu=0,ld=0,cd=null,Xh=null,lm=!1,cm=!1,dl=!1,Uu=0,um=null,V0=0,Ea=0,Bu=null,Dc=!1,ud=!1,hm=Object.prototype.hasOwnProperty,Rs=Error(i(460)),ib=Error(i(474)),G0={then:function(){}},jh=null,Kl=null,Fo=0,Pu=wr(!0),rb=wr(!1),Yl=S(null),lo=S(0),co=S(null),zo=null,Ui=S(0),Zl=0,Dn=null,xs=null,Ai=null,Uo=!1,ei=!1,kc=!1,fm=0,xi=0,hd=null,Nw=0,H0=function(){return{lastEffect:null,events:null,stores:null,memoCache:null}},rs={readContext:Er,use:rl,useCallback:$n,useContext:$n,useEffect:$n,useImperativeHandle:$n,useLayoutEffect:$n,useInsertionEffect:$n,useMemo:$n,useReducer:$n,useRef:$n,useState:$n,useDebugValue:$n,useDeferredValue:$n,useTransition:$n,useSyncExternalStore:$n,useId:$n};rs.useCacheRefresh=$n,rs.useMemoCache=$n,rs.useHostTransitionStatus=$n,rs.useFormState=$n,rs.useActionState=$n,rs.useOptimistic=$n;var Bi={readContext:Er,use:rl,useCallback:function(m,y){return Ei().memoizedState=[m,y===void 0?null:y],m},useContext:Er,useEffect:Nh,useImperativeHandle:function(m,y,E){E=E!=null?E.concat([m]):null,Li(4194308,4,Cp.bind(null,y,m),E)},useLayoutEffect:function(m,y){return Li(4194308,4,m,y)},useInsertionEffect:function(m,y){Li(4,2,m,y)},useMemo:function(m,y){var E=Ei();y=y===void 0?null:y;var M=m();if(kc){W(!0);try{m()}finally{W(!1)}}return E.memoizedState=[M,y],M},useReducer:function(m,y,E){var M=Ei();if(E!==void 0){var $=E(y);if(kc){W(!0);try{E(y)}finally{W(!1)}}}else $=y;return M.memoizedState=M.baseState=$,m={pending:null,lanes:0,dispatch:null,lastRenderedReducer:m,lastRenderedState:$},M.queue=m,m=m.dispatch=mu.bind(null,Dn,m),[M.memoizedState,m]},useRef:function(m){var y=Ei();return m={current:m},y.memoizedState=m},useState:function(m){m=Xe(m);var y=m.queue,E=e0.bind(null,Dn,y);return y.dispatch=E,[m.memoizedState,E]},useDebugValue:Ap,useDeferredValue:function(m,y){var E=Ei();return pu(E,m,y)},useTransition:function(){var m=Xe(!1);return m=Jg.bind(null,Dn,m.queue,!0,!1),Ei().memoizedState=m,[!1,m]},useSyncExternalStore:function(m,y,E){var M=Dn,$=Ei();if(is){if(E===void 0)throw Error(i(407));E=E()}else{if(E=y(),Gn===null)throw Error(i(349));(Un&60)!==0||We(M,y,E)}$.memoizedState=E;var U={value:E,getSnapshot:y};return $.queue=U,Nh(qe.bind(null,M,U,m),[m]),M.flags|=2048,pi(9,De.bind(null,M,U,E,y),{destroy:void 0},null),E},useId:function(){var m=Ei(),y=Gn.identifierPrefix;if(is){var E=$o,M=jl;E=(M&~(1<<32-wa(M)-1)).toString(32)+E,y=":"+y+"R"+E,E=fm++,0<E&&(y+="H"+E.toString(32)),y+=":"}else E=Nw++,y=":"+y+"r"+E.toString(32)+":";return m.memoizedState=y},useCacheRefresh:function(){return Ei().memoizedState=Np.bind(null,Dn)}};Bi.useMemoCache=Z,Bi.useHostTransitionStatus=Ih,Bi.useFormState=cr,Bi.useActionState=cr,Bi.useOptimistic=function(m){var y=Ei();y.memoizedState=y.baseState=m;var E={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return y.queue=E,y=n0.bind(null,Dn,!0,E),E.dispatch=y,[m,y]};var Wr={readContext:Er,use:rl,useCallback:Qg,useContext:Er,useEffect:Ya,useImperativeHandle:Ll,useInsertionEffect:I_,useLayoutEffect:R_,useMemo:Mh,useReducer:Gt,useRef:$i,useState:function(){return Gt(Et)},useDebugValue:Ap,useDeferredValue:function(m,y){var E=Us();return jx(E,xs.memoizedState,m,y)},useTransition:function(){var m=Gt(Et)[0],y=Us().memoizedState;return[typeof m=="boolean"?m:il(m),y]},useSyncExternalStore:Me,useId:Fl};Wr.useCacheRefresh=t0,Wr.useMemoCache=Z,Wr.useHostTransitionStatus=Ih,Wr.useFormState=$l,Wr.useActionState=$l,Wr.useOptimistic=function(m,y){var E=Us();return fn(E,xs,m,y)};var Vu={readContext:Er,use:rl,useCallback:Qg,useContext:Er,useEffect:Ya,useImperativeHandle:Ll,useInsertionEffect:I_,useLayoutEffect:R_,useMemo:Mh,useReducer:Dt,useRef:$i,useState:function(){return Dt(Et)},useDebugValue:Ap,useDeferredValue:function(m,y){var E=Us();return xs===null?pu(E,m,y):jx(E,xs.memoizedState,m,y)},useTransition:function(){var m=Dt(Et)[0],y=Us().memoizedState;return[typeof m=="boolean"?m:il(m),y]},useSyncExternalStore:Me,useId:Fl};Vu.useCacheRefresh=t0,Vu.useMemoCache=Z,Vu.useHostTransitionStatus=Ih,Vu.useFormState=Ss,Vu.useActionState=Ss,Vu.useOptimistic=function(m,y){var E=Us();return xs!==null?fn(E,xs,m,y):(E.baseState=m,[m,E.queue.dispatch])};var W0={isMounted:function(m){return(m=m._reactInternals)?f(m)===m:!1},enqueueSetState:function(m,y,E){m=m._reactInternals;var M=oa(),$=ae(M);$.payload=y,E!=null&&($.callback=E),y=de(m,$,M),y!==null&&(Pr(y,m,M),Ne(y,m,M))},enqueueReplaceState:function(m,y,E){m=m._reactInternals;var M=oa(),$=ae(M);$.tag=1,$.payload=y,E!=null&&($.callback=E),y=de(m,$,M),y!==null&&(Pr(y,m,M),Ne(y,m,M))},enqueueForceUpdate:function(m,y){m=m._reactInternals;var E=oa(),M=ae(E);M.tag=2,y!=null&&(M.callback=y),y=de(m,M,E),y!==null&&(Pr(y,m,E),Ne(y,m,E))}},ab=typeof reportError=="function"?reportError:function(m){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var y=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof m=="object"&&m!==null&&typeof m.message=="string"?String(m.message):String(m),error:m});if(!window.dispatchEvent(y))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",m);return}console.error(m)},Mw=Error(i(461)),Ni=!1,qr={dehydrated:null,treeContext:null,retryLane:0},Ca=S(null),Gu=null,vi=null,Iw=typeof AbortController<"u"?AbortController:function(){var m=[],y=this.signal={aborted:!1,addEventListener:function(E,M){m.push(M)}};this.abort=function(){y.aborted=!0,m.forEach(function(E){return E()})}},Oc=Cr.unstable_scheduleCallback,Kh=Cr.unstable_NormalPriority,_s={$$typeof:Gl,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0},q0=dn.S;dn.S=function(m,y){typeof y=="object"&&y!==null&&typeof y.then=="function"&&Pt(m,y),q0!==null&&q0(m,y)};var $c=S(null),Ji=!1,ci=!1,Hu=!1,fd=typeof WeakSet=="function"?WeakSet:Set,bi=null,Yh=!1,Mi=null,Aa=!1,ua=null,Zh=8192,X0={getCacheForType:function(m){var y=Er(_s),E=y.data.get(m);return E===void 0&&(E=m(),y.data.set(m,E)),E}},dm=0,j0=1,K0=2,ts=3,ws=4;if(typeof Symbol=="function"&&Symbol.for){var kn=Symbol.for;dm=kn("selector.component"),j0=kn("selector.has_pseudo_class"),K0=kn("selector.role"),ts=kn("selector.test_id"),ws=kn("selector.text")}var Kn=typeof WeakMap=="function"?WeakMap:Map,an=0,Gn=null,Cn=null,Un=0,$s=0,Ii=null,Ts=!1,uo=!1,Lc=!1,pl=0,es=0,ho=0,ml=0,Xr=0,Na=0,Fc=0,dd=null,fo=null,pd=!1,Ql=0,ui=1/0,gl=null,po=null,Bo=!1,zc=null,Qh=0,Y0=0,Jh=null,tf=0,ha=null;return rn.attemptContinuousHydration=function(m){if(m.tag===13){var y=ce(m,67108864);y!==null&&Pr(y,m,67108864),bv(m,67108864)}},rn.attemptHydrationAtCurrentPriority=function(m){if(m.tag===13){var y=oa(),E=ce(m,y);E!==null&&Pr(E,m,y),bv(m,y)}},rn.attemptSynchronousHydration=function(m){switch(m.tag){case 3:if(m=m.stateNode,m.current.memoizedState.isDehydrated){var y=A(m.pendingLanes);if(y!==0){for(m.pendingLanes|=2,m.entangledLanes|=2;y;){var E=1<<31-wa(y);m.entanglements[1]|=E,y&=~E}he(m),(an&6)===0&&(ui=Mr()+500,Pe(0))}}break;case 13:y=ce(m,2),y!==null&&Pr(y,m,2),mv(),bv(m,2)}},rn.batchedUpdates=function(m,y){return m(y)},rn.createComponentSelector=function(m){return{$$typeof:dm,value:m}},rn.createContainer=function(m,y,E,M,$,U,tt,mt,It,ne){return pr(m,y,!1,null,E,M,U,tt,mt,It,ne,null)},rn.createHasPseudoClassSelector=function(m){return{$$typeof:j0,value:m}},rn.createHydrationContainer=function(m,y,E,M,$,U,tt,mt,It,ne,Te,$e,Ve){return m=pr(E,M,!0,m,$,U,mt,It,ne,Te,$e,Ve),m.context=Hp(null),E=m.current,M=oa(),$=ae(M),$.callback=y??null,de(E,$,M),m.current.lanes=M,L(m,M),he(m),m},rn.createPortal=function(m,y,E){var M=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:cl,key:M==null?null:""+M,children:m,containerInfo:y,implementation:E}},rn.createRoleSelector=function(m){return{$$typeof:K0,value:m}},rn.createTestNameSelector=function(m){return{$$typeof:ts,value:m}},rn.createTextSelector=function(m){return{$$typeof:ws,value:m}},rn.defaultOnCaughtError=function(m){console.error(m)},rn.defaultOnRecoverableError=function(m){ab(m)},rn.defaultOnUncaughtError=function(m){ab(m)},rn.deferredUpdates=function(m){var y=dn.T,E=Qi();try{return Gr(32),dn.T=null,m()}finally{Gr(E),dn.T=y}},rn.discreteUpdates=function(m,y,E,M,$){var U=dn.T,tt=Qi();try{return Gr(2),dn.T=null,m(y,E,M,$)}finally{Gr(tt),dn.T=U,an===0&&(ui=Mr()+500)}},rn.findAllNodes=aa,rn.findBoundingRects=function(m,y){if(!ql)throw Error(i(363));y=aa(m,y),m=[];for(var E=0;E<y.length;E++)m.push(M0(y[E]));for(y=m.length-1;0<y;y--){E=m[y];for(var M=E.x,$=M+E.width,U=E.y,tt=U+E.height,mt=y-1;0<=mt;mt--)if(y!==mt){var It=m[mt],ne=It.x,Te=ne+It.width,$e=It.y,Ve=$e+It.height;if(M>=ne&&U>=$e&&$<=Te&&tt<=Ve){m.splice(y,1);break}else if(M!==ne||E.width!==It.width||Ve<U||$e>tt){if(!(U!==$e||E.height!==It.height||Te<M||ne>$)){ne>M&&(It.width+=ne-M,It.x=M),Te<$&&(It.width=$-ne),m.splice(y,1);break}}else{$e>U&&(It.height+=$e-U,It.y=U),Ve<tt&&(It.height=tt-$e),m.splice(y,1);break}}}return m},rn.findHostInstance=vv,rn.findHostInstanceWithNoPortals=function(m){return m=g(m),m=m!==null?_(m):null,m===null?null:ed(m.stateNode)},rn.findHostInstanceWithWarning=function(m){return vv(m)},rn.flushPassiveEffects=dr,rn.flushSyncFromReconciler=function(m){var y=an;an|=1;var E=dn.T,M=Qi();try{if(Gr(2),dn.T=null,m)return m()}finally{Gr(M),dn.T=E,an=y,(an&6)===0&&Pe(0)}},rn.flushSyncWork=mv,rn.focusWithin=function(m,y){if(!ql)throw Error(i(363));for(m=y0(m),y=K_(m,y),y=Array.from(y),m=0;m<y.length;){var E=y[m++],M=E.tag;if(!Xl(E)){if((M===5||M===26||M===27)&&gi(E.stateNode))return!0;for(E=E.child;E!==null;)y.push(E),E=E.sibling}}return!1},rn.getFindAllNodesFailureDescription=function(m,y){if(!ql)throw Error(i(363));var E=0,M=[];m=[y0(m),0];for(var $=0;$<m.length;){var U=m[$++],tt=U.tag,mt=m[$++],It=y[mt];if((tt!==5&&tt!==26&&tt!==27||!Xl(U))&&(Yf(U,It)&&(M.push(Nu(It)),mt++,mt>E&&(E=mt)),mt<y.length))for(U=U.child;U!==null;)m.push(U,mt),U=U.sibling}if(E<y.length){for(m=[];E<y.length;E++)m.push(Nu(y[E]));return`findAllNodes was able to match part of the selector:
  `+(M.join(" > ")+`

No matching component was found for:
  `)+m.join(" > ")}return null},rn.getPublicRootInstance=function(m){if(m=m.current,!m.child)return null;switch(m.child.tag){case 27:case 5:return ed(m.child.stateNode);default:return m.child.stateNode}},rn.injectIntoDevTools=function(){var m={bundleType:0,version:E0,rendererPackageName:Xp,currentDispatcherRef:dn,findFiberByHostInstance:Iv,reconcilerVersion:"19.0.0"};if(jp!==null&&(m.rendererConfig=jp),typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")m=!1;else{var y=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(y.isDisabled||!y.supportsFiber)m=!0;else{try{ad=y.inject(m),Ta=y}catch{}m=!!y.checkDCE}}return m},rn.isAlreadyRendering=function(){return!1},rn.observeVisibleRects=function(m,y,E,M){if(!ql)throw Error(i(363));m=aa(m,y);var $=kv(m,E,M).disconnect;return{disconnect:function(){$()}}},rn.shouldError=function(){return null},rn.shouldSuspend=function(){return!1},rn.startHostTransition=function(m,y,E,M){if(m.tag!==5)throw Error(i(476));var $=Kx(m).queue;Jg(m,$,y,_a,E===null?s:function(){var U=Kx(m).next.queue;return gu(m,U,{},oa()),E(M)})},rn.updateContainer=function(m,y,E,M){var $=y.current,U=oa();return Q_($,U,m,y,E,M),U},rn.updateContainerSync=function(m,y,E,M){return y.tag===0&&dr(),Q_(y.current,2,m,y,E,M),2},rn},n.exports.default=n.exports,Object.defineProperty(n.exports,"__esModule",{value:!0})})(uI)),uI.exports}var Nz;function jet(){return Nz||(Nz=1,cI.exports=Xet()),cI.exports}var Ket=jet();const Yet=_x(Ket);var Mz=fV();function C3(n,t,e){if(!n)return;if(e(n)===!0)return n;let s=t?n.return:n.child;for(;s;){const i=C3(s,t,e);if(i)return i;s=t?null:s.sibling}}function dV(n){try{return Object.defineProperties(n,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return n}}const A3=dV(be.createContext(null));class pV extends be.Component{render(){return be.createElement(A3.Provider,{value:this._reactInternals},this.props.children)}}function mV(){const n=be.useContext(A3);if(n===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const t=be.useId();return be.useMemo(()=>{for(const e of[n,n==null?void 0:n.alternate]){if(!e)continue;const s=C3(e,!1,i=>{let r=i.memoizedState;for(;r;){if(r.memoizedState===t)return!0;r=r.next}});if(s)return s}},[n,t])}const Zet=Symbol.for("react.context"),Qet=n=>n!==null&&typeof n=="object"&&"$$typeof"in n&&n.$$typeof===Zet;function Jet(){const n=mV(),[t]=be.useState(()=>new Map);t.clear();let e=n;for(;e;){const s=e.type;Qet(s)&&s!==A3&&!t.has(s)&&t.set(s,be.use(dV(s))),e=e.return}return t}function tnt(){const n=Jet();return be.useMemo(()=>Array.from(n.keys()).reduce((t,e)=>s=>be.createElement(t,null,be.createElement(e.Provider,{...s,value:n.get(e)})),t=>be.createElement(pV,{...t})),[n])}function gV(n){let t=n.root;for(;t.getState().previousRoot;)t=t.getState().previousRoot;return t}const yV=n=>n&&n.isOrthographicCamera,ent=n=>n&&n.hasOwnProperty("current"),nnt=n=>n!=null&&(typeof n=="string"||typeof n=="number"||n.isColor),cS=((n,t)=>typeof window<"u"&&(((n=window.document)==null?void 0:n.createElement)||((t=window.navigator)==null?void 0:t.product)==="ReactNative"))()?be.useLayoutEffect:be.useEffect;function xV(n){const t=be.useRef(n);return cS(()=>void(t.current=n),[n]),t}function snt(){const n=mV(),t=tnt();return be.useMemo(()=>({children:e})=>{const i=!!C3(n,!0,r=>r.type===be.StrictMode)?be.StrictMode:be.Fragment;return ge.jsx(i,{children:ge.jsx(t,{children:e})})},[n,t])}function int({set:n}){return cS(()=>(n(new Promise(()=>null)),()=>n(!1)),[n]),null}const rnt=(n=>(n=class extends be.Component{constructor(...e){super(...e),this.state={error:!1}}componentDidCatch(e){this.props.set(e)}render(){return this.state.error?null:this.props.children}},n.getDerivedStateFromError=()=>({error:!0}),n))();function vV(n){var t;const e=typeof window<"u"?(t=window.devicePixelRatio)!=null?t:2:1;return Array.isArray(n)?Math.min(Math.max(n[0],e),n[1]):n}function Ty(n){var t;return(t=n.__r3f)==null?void 0:t.root.getState()}const Ri={obj:n=>n===Object(n)&&!Ri.arr(n)&&typeof n!="function",fun:n=>typeof n=="function",str:n=>typeof n=="string",num:n=>typeof n=="number",boo:n=>typeof n=="boolean",und:n=>n===void 0,nul:n=>n===null,arr:n=>Array.isArray(n),equ(n,t,{arrays:e="shallow",objects:s="reference",strict:i=!0}={}){if(typeof n!=typeof t||!!n!=!!t)return!1;if(Ri.str(n)||Ri.num(n)||Ri.boo(n))return n===t;const r=Ri.obj(n);if(r&&s==="reference")return n===t;const a=Ri.arr(n);if(a&&e==="reference")return n===t;if((a||r)&&n===t)return!0;let o;for(o in n)if(!(o in t))return!1;if(r&&e==="shallow"&&s==="shallow"){for(o in i?t:n)if(!Ri.equ(n[o],t[o],{strict:i,objects:"reference"}))return!1}else for(o in i?t:n)if(n[o]!==t[o])return!1;if(Ri.und(o)){if(a&&n.length===0&&t.length===0||r&&Object.keys(n).length===0&&Object.keys(t).length===0)return!0;if(n!==t)return!1}return!0}};function ant(n){n.type!=="Scene"&&(n.dispose==null||n.dispose());for(const t in n){const e=n[t];(e==null?void 0:e.type)!=="Scene"&&(e==null||e.dispose==null||e.dispose())}}const bV=["children","key","ref"];function ont(n){const t={};for(const e in n)bV.includes(e)||(t[e]=n[e]);return t}function m2(n,t,e,s){const i=n;let r=i==null?void 0:i.__r3f;return r||(r={root:t,type:e,parent:null,children:[],props:ont(s),object:i,eventCount:0,handlers:{},isHidden:!1},i&&(i.__r3f=r)),r}function I1(n,t){if(!t.includes("-"))return{root:n,key:t,target:n[t]};if(t in n)return{root:n,key:t,target:n[t]};let e=n;const s=t.split("-");for(const i of s){if(typeof e!="object"||e===null){if(e!==void 0){const r=s.slice(s.indexOf(i)).join("-");return{root:e,key:r,target:void 0}}return{root:n,key:t,target:void 0}}t=i,n=e,e=e[t]}return{root:n,key:t,target:e}}const Iz=/-\d+$/;function g2(n,t){if(Ri.str(t.props.attach)){if(Iz.test(t.props.attach)){const i=t.props.attach.replace(Iz,""),{root:r,key:a}=I1(n.object,i);Array.isArray(r[a])||(r[a]=[])}const{root:e,key:s}=I1(n.object,t.props.attach);t.previousAttach=e[s],e[s]=t.object}else Ri.fun(t.props.attach)&&(t.previousAttach=t.props.attach(n.object,t.object))}function y2(n,t){if(Ri.str(t.props.attach)){const{root:e,key:s}=I1(n.object,t.props.attach),i=t.previousAttach;i===void 0?delete e[s]:e[s]=i}else t.previousAttach==null||t.previousAttach(n.object,t.object);delete t.previousAttach}const fR=[...bV,"args","dispose","attach","object","onUpdate","dispose"],Rz=new Map;function lnt(n){let t=Rz.get(n.constructor);try{t||(t=new n.constructor,Rz.set(n.constructor,t))}catch{}return t}function cnt(n,t){const e={};for(const s in t)if(!fR.includes(s)&&!Ri.equ(t[s],n.props[s])){e[s]=t[s];for(const i in t)i.startsWith(`${s}-`)&&(e[i]=t[i])}for(const s in n.props){if(fR.includes(s)||t.hasOwnProperty(s))continue;const{root:i,key:r}=I1(n.object,s);if(i.constructor&&i.constructor.length===0){const a=lnt(i);Ri.und(a)||(e[r]=a[r])}else e[r]=0}return e}const unt=["map","emissiveMap","sheenColorMap","specularColorMap","envMap"],hnt=/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;function kd(n,t){var e;const s=n.__r3f,i=s&&gV(s).getState(),r=s==null?void 0:s.eventCount;for(const o in t){let l=t[o];if(fR.includes(o))continue;if(s&&hnt.test(o)){typeof l=="function"?s.handlers[o]=l:delete s.handlers[o],s.eventCount=Object.keys(s.handlers).length;continue}if(l===void 0)continue;let{root:c,key:h,target:f}=I1(n,o);if(f===void 0&&(typeof c!="object"||c===null))throw Error(`R3F: Cannot set "${o}". Ensure it is an object before setting "${h}".`);if(f instanceof nx&&l instanceof nx)f.mask=l.mask;else if(f instanceof ke&&nnt(l))f.set(l);else if(f!==null&&typeof f=="object"&&typeof f.set=="function"&&typeof f.copy=="function"&&l!=null&&l.constructor&&f.constructor===l.constructor)f.copy(l);else if(f!==null&&typeof f=="object"&&typeof f.set=="function"&&Array.isArray(l))typeof f.fromArray=="function"?f.fromArray(l):f.set(...l);else if(f!==null&&typeof f=="object"&&typeof f.set=="function"&&typeof l=="number")typeof f.setScalar=="function"?f.setScalar(l):f.set(l);else{var a;c[h]=l,i&&!i.linear&&unt.includes(h)&&(a=c[h])!=null&&a.isTexture&&c[h].format===Ba&&c[h].type===Gi&&(c[h].colorSpace=Ms)}}if(s!=null&&s.parent&&i!=null&&i.internal&&(e=s.object)!=null&&e.isObject3D&&r!==s.eventCount){const o=s.object,l=i.internal.interaction.indexOf(o);l>-1&&i.internal.interaction.splice(l,1),s.eventCount&&o.raycast!==null&&i.internal.interaction.push(o)}return s&&s.props.attach===void 0&&(s.object.isBufferGeometry?s.props.attach="geometry":s.object.isMaterial&&(s.props.attach="material")),s&&Ax(s),n}function Ax(n){var t;if(!n.parent)return;n.props.onUpdate==null||n.props.onUpdate(n.object);const e=(t=n.root)==null||t.getState==null?void 0:t.getState();e&&e.internal.frames===0&&e.invalidate()}function fnt(n,t){n.manual||(yV(n)?(n.left=t.width/-2,n.right=t.width/2,n.top=t.height/2,n.bottom=t.height/-2):n.aspect=t.width/t.height,n.updateProjectionMatrix())}const Xo=n=>n==null?void 0:n.isObject3D;function UT(n){return(n.eventObject||n.object).uuid+"/"+n.index+n.instanceId}function SV(n,t,e,s){const i=e.get(t);i&&(e.delete(t),e.size===0&&(n.delete(s),i.target.releasePointerCapture(s)))}function dnt(n,t){const{internal:e}=n.getState();e.interaction=e.interaction.filter(s=>s!==t),e.initialHits=e.initialHits.filter(s=>s!==t),e.hovered.forEach((s,i)=>{(s.eventObject===t||s.object===t)&&e.hovered.delete(i)}),e.capturedMap.forEach((s,i)=>{SV(e.capturedMap,t,s,i)})}function pnt(n){function t(l){const{internal:c}=n.getState(),h=l.offsetX-c.initialClick[0],f=l.offsetY-c.initialClick[1];return Math.round(Math.sqrt(h*h+f*f))}function e(l){return l.filter(c=>["Move","Over","Enter","Out","Leave"].some(h=>{var f;return(f=c.__r3f)==null?void 0:f.handlers["onPointer"+h]}))}function s(l,c){const h=n.getState(),f=new Set,p=[],g=c?c(h.internal.interaction):h.internal.interaction;for(let b=0;b<g.length;b++){const T=Ty(g[b]);T&&(T.raycaster.camera=void 0)}h.previousRoot||h.events.compute==null||h.events.compute(l,h);function v(b){const T=Ty(b);if(!T||!T.events.enabled||T.raycaster.camera===null)return[];if(T.raycaster.camera===void 0){var C;T.events.compute==null||T.events.compute(l,T,(C=T.previousRoot)==null?void 0:C.getState()),T.raycaster.camera===void 0&&(T.raycaster.camera=null)}return T.raycaster.camera?T.raycaster.intersectObject(b,!0):[]}let _=g.flatMap(v).sort((b,T)=>{const C=Ty(b.object),A=Ty(T.object);return!C||!A?b.distance-T.distance:A.events.priority-C.events.priority||b.distance-T.distance}).filter(b=>{const T=UT(b);return f.has(T)?!1:(f.add(T),!0)});h.events.filter&&(_=h.events.filter(_,h));for(const b of _){let T=b.object;for(;T;){var S;(S=T.__r3f)!=null&&S.eventCount&&p.push({...b,eventObject:T}),T=T.parent}}if("pointerId"in l&&h.internal.capturedMap.has(l.pointerId))for(let b of h.internal.capturedMap.get(l.pointerId).values())f.has(UT(b.intersection))||p.push(b.intersection);return p}function i(l,c,h,f){if(l.length){const p={stopped:!1};for(const g of l){let v=Ty(g.object);if(v||g.object.traverseAncestors(_=>{const S=Ty(_);if(S)return v=S,!1}),v){const{raycaster:_,pointer:S,camera:b,internal:T}=v,C=new at(S.x,S.y,0).unproject(b),A=k=>{var O,L;return(O=(L=T.capturedMap.get(k))==null?void 0:L.has(g.eventObject))!=null?O:!1},I=k=>{const O={intersection:g,target:c.target};T.capturedMap.has(k)?T.capturedMap.get(k).set(g.eventObject,O):T.capturedMap.set(k,new Map([[g.eventObject,O]])),c.target.setPointerCapture(k)},D=k=>{const O=T.capturedMap.get(k);O&&SV(T.capturedMap,g.eventObject,O,k)};let F={};for(let k in c){let O=c[k];typeof O!="function"&&(F[k]=O)}let z={...g,...F,pointer:S,intersections:l,stopped:p.stopped,delta:h,unprojectedPoint:C,ray:_.ray,camera:b,stopPropagation(){const k="pointerId"in c&&T.capturedMap.get(c.pointerId);if((!k||k.has(g.eventObject))&&(z.stopped=p.stopped=!0,T.hovered.size&&Array.from(T.hovered.values()).find(O=>O.eventObject===g.eventObject))){const O=l.slice(0,l.indexOf(g));r([...O,g])}},target:{hasPointerCapture:A,setPointerCapture:I,releasePointerCapture:D},currentTarget:{hasPointerCapture:A,setPointerCapture:I,releasePointerCapture:D},nativeEvent:c};if(f(z),p.stopped===!0)break}}}return l}function r(l){const{internal:c}=n.getState();for(const h of c.hovered.values())if(!l.length||!l.find(f=>f.object===h.object&&f.index===h.index&&f.instanceId===h.instanceId)){const p=h.eventObject.__r3f;if(c.hovered.delete(UT(h)),p!=null&&p.eventCount){const g=p.handlers,v={...h,intersections:l};g.onPointerOut==null||g.onPointerOut(v),g.onPointerLeave==null||g.onPointerLeave(v)}}}function a(l,c){for(let h=0;h<c.length;h++){const f=c[h].__r3f;f==null||f.handlers.onPointerMissed==null||f.handlers.onPointerMissed(l)}}function o(l){switch(l){case"onPointerLeave":case"onPointerCancel":return()=>r([]);case"onLostPointerCapture":return c=>{const{internal:h}=n.getState();"pointerId"in c&&h.capturedMap.has(c.pointerId)&&requestAnimationFrame(()=>{h.capturedMap.has(c.pointerId)&&(h.capturedMap.delete(c.pointerId),r([]))})}}return function(h){const{onPointerMissed:f,internal:p}=n.getState();p.lastEvent.current=h;const g=l==="onPointerMove",v=l==="onClick"||l==="onContextMenu"||l==="onDoubleClick",S=s(h,g?e:void 0),b=v?t(h):0;l==="onPointerDown"&&(p.initialClick=[h.offsetX,h.offsetY],p.initialHits=S.map(C=>C.eventObject)),v&&!S.length&&b<=2&&(a(h,p.interaction),f&&f(h)),g&&r(S);function T(C){const A=C.eventObject,I=A.__r3f;if(!(I!=null&&I.eventCount))return;const D=I.handlers;if(g){if(D.onPointerOver||D.onPointerEnter||D.onPointerOut||D.onPointerLeave){const F=UT(C),z=p.hovered.get(F);z?z.stopped&&C.stopPropagation():(p.hovered.set(F,C),D.onPointerOver==null||D.onPointerOver(C),D.onPointerEnter==null||D.onPointerEnter(C))}D.onPointerMove==null||D.onPointerMove(C)}else{const F=D[l];F?(!v||p.initialHits.includes(A))&&(a(h,p.interaction.filter(z=>!p.initialHits.includes(z))),F(C)):v&&p.initialHits.includes(A)&&a(h,p.interaction.filter(z=>!p.initialHits.includes(z)))}}i(S,h,b,T)}}return{handlePointer:o}}const Dz=n=>!!(n!=null&&n.render),_V=be.createContext(null),mnt=(n,t)=>{const e=Wet((o,l)=>{const c=new at,h=new at,f=new at;function p(b=l().camera,T=h,C=l().size){const{width:A,height:I,top:D,left:F}=C,z=A/I;T.isVector3?f.copy(T):f.set(...T);const k=b.getWorldPosition(c).distanceTo(f);if(yV(b))return{width:A/b.zoom,height:I/b.zoom,top:D,left:F,factor:1,distance:k,aspect:z};{const O=b.fov*Math.PI/180,L=2*Math.tan(O/2)*k,H=L*(A/I);return{width:H,height:L,top:D,left:F,factor:A/H,distance:k,aspect:z}}}let g;const v=b=>o(T=>({performance:{...T.performance,current:b}})),_=new Yt;return{set:o,get:l,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},scene:null,xr:null,invalidate:(b=1)=>n(l(),b),advance:(b,T)=>t(b,T,l()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new _3,pointer:_,mouse:_,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const b=l();g&&clearTimeout(g),b.performance.current!==b.performance.min&&v(b.performance.min),g=setTimeout(()=>v(l().performance.max),b.performance.debounce)}},size:{width:0,height:0,top:0,left:0},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:p},setEvents:b=>o(T=>({...T,events:{...T.events,...b}})),setSize:(b,T,C=0,A=0)=>{const I=l().camera,D={width:b,height:T,top:C,left:A};o(F=>({size:D,viewport:{...F.viewport,...p(I,h,D)}}))},setDpr:b=>o(T=>{const C=vV(b);return{viewport:{...T.viewport,dpr:C,initialDpr:T.viewport.initialDpr||C}}}),setFrameloop:(b="always")=>{const T=l().clock;T.stop(),T.elapsedTime=0,b!=="never"&&(T.start(),T.elapsedTime=0),o(()=>({frameloop:b}))},previousRoot:void 0,internal:{interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,lastEvent:be.createRef(),active:!1,frames:0,priority:0,subscribe:(b,T,C)=>{const A=l().internal;return A.priority=A.priority+(T>0?1:0),A.subscribers.push({ref:b,priority:T,store:C}),A.subscribers=A.subscribers.sort((I,D)=>I.priority-D.priority),()=>{const I=l().internal;I!=null&&I.subscribers&&(I.priority=I.priority-(T>0?1:0),I.subscribers=I.subscribers.filter(D=>D.ref!==b))}}}}}),s=e.getState();let i=s.size,r=s.viewport.dpr,a=s.camera;return e.subscribe(()=>{const{camera:o,size:l,viewport:c,gl:h,set:f}=e.getState();if(l.width!==i.width||l.height!==i.height||c.dpr!==r){i=l,r=c.dpr,fnt(o,l),c.dpr>0&&h.setPixelRatio(c.dpr);const p=typeof HTMLCanvasElement<"u"&&h.domElement instanceof HTMLCanvasElement;h.setSize(l.width,l.height,p)}o!==a&&(a=o,f(p=>({viewport:{...p.viewport,...p.viewport.getCurrentViewport(o)}})))}),e.subscribe(o=>n(o)),e};function wV(){const n=be.useContext(_V);if(!n)throw new Error("R3F: Hooks can only be used within the Canvas component!");return n}function Ku(n=e=>e,t){return wV()(n,t)}function fp(n,t=0){const e=wV(),s=e.getState().internal.subscribe,i=xV(n);return cS(()=>s(i,t,e),[t,s,e]),null}var gnt={version:"9.4.2"};function ynt(n){const t=Yet(n);return t.injectIntoDevTools(),t}const TV=0,ax={},xnt=/^three(?=[A-Z])/,VC=n=>`${n[0].toUpperCase()}${n.slice(1)}`;let vnt=0;const bnt=n=>typeof n=="function";function EV(n){if(bnt(n)){const t=`${vnt++}`;return ax[t]=n,t}else Object.assign(ax,n)}function CV(n,t){const e=VC(n),s=ax[e];if(n!=="primitive"&&!s)throw new Error(`R3F: ${e} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(n==="primitive"&&!t.object)throw new Error("R3F: Primitives without 'object' are invalid!");if(t.args!==void 0&&!Array.isArray(t.args))throw new Error("R3F: The args prop must be an array!")}function Snt(n,t,e){var s;return n=VC(n)in ax?n:n.replace(xnt,""),CV(n,t),n==="primitive"&&(s=t.object)!=null&&s.__r3f&&delete t.object.__r3f,m2(t.object,e,n,t)}function _nt(n){if(!n.isHidden){var t;n.props.attach&&(t=n.parent)!=null&&t.object?y2(n.parent,n):Xo(n.object)&&(n.object.visible=!1),n.isHidden=!0,Ax(n)}}function AV(n){if(n.isHidden){var t;n.props.attach&&(t=n.parent)!=null&&t.object?g2(n.parent,n):Xo(n.object)&&n.props.visible!==!1&&(n.object.visible=!0),n.isHidden=!1,Ax(n)}}function N3(n,t,e){const s=t.root.getState();if(!(!n.parent&&n.object!==s.scene)){if(!t.object){var i,r;const a=ax[VC(t.type)];t.object=(i=t.props.object)!=null?i:new a(...(r=t.props.args)!=null?r:[]),t.object.__r3f=t}if(kd(t.object,t.props),t.props.attach)g2(n,t);else if(Xo(t.object)&&Xo(n.object)){const a=n.object.children.indexOf(e==null?void 0:e.object);if(e&&a!==-1){const o=n.object.children.indexOf(t.object);if(o!==-1){n.object.children.splice(o,1);const l=o<a?a-1:a;n.object.children.splice(l,0,t.object)}else t.object.parent=n.object,n.object.children.splice(a,0,t.object),t.object.dispatchEvent({type:"added"}),n.object.dispatchEvent({type:"childadded",child:t.object})}else n.object.add(t.object)}for(const a of t.children)N3(t,a);Ax(t)}}function dI(n,t){t&&(t.parent=n,n.children.push(t),N3(n,t))}function kz(n,t,e){if(!t||!e)return;t.parent=n;const s=n.children.indexOf(e);s!==-1?n.children.splice(s,0,t):n.children.push(t),N3(n,t,e)}function NV(n){if(typeof n.dispose=="function"){const t=()=>{try{n.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT<"u"?t():Mz.unstable_scheduleCallback(Mz.unstable_IdlePriority,t)}}function dR(n,t,e){if(!t)return;t.parent=null;const s=n.children.indexOf(t);s!==-1&&n.children.splice(s,1),t.props.attach?y2(n,t):Xo(t.object)&&Xo(n.object)&&(n.object.remove(t.object),dnt(gV(t),t.object));const i=t.props.dispose!==null&&e!==!1;for(let r=t.children.length-1;r>=0;r--){const a=t.children[r];dR(t,a,i)}t.children.length=0,delete t.object.__r3f,i&&t.type!=="primitive"&&t.object.type!=="Scene"&&NV(t.object),e===void 0&&Ax(t)}function wnt(n,t){for(const e of[n,n.alternate])if(e!==null)if(typeof e.ref=="function"){e.refCleanup==null||e.refCleanup();const s=e.ref(t);typeof s=="function"&&(e.refCleanup=s)}else e.ref&&(e.ref.current=t)}const oE=[];function Tnt(){for(const[e]of oE){const s=e.parent;if(s){e.props.attach?y2(s,e):Xo(e.object)&&Xo(s.object)&&s.object.remove(e.object);for(const i of e.children)i.props.attach?y2(e,i):Xo(i.object)&&Xo(e.object)&&e.object.remove(i.object)}e.isHidden&&AV(e),e.object.__r3f&&delete e.object.__r3f,e.type!=="primitive"&&NV(e.object)}for(const[e,s,i]of oE){e.props=s;const r=e.parent;if(r){var n,t;const a=ax[VC(e.type)];e.object=(n=e.props.object)!=null?n:new a(...(t=e.props.args)!=null?t:[]),e.object.__r3f=e,wnt(i,e.object),kd(e.object,e.props),e.props.attach?g2(r,e):Xo(e.object)&&Xo(r.object)&&r.object.add(e.object);for(const o of e.children)o.props.attach?g2(e,o):Xo(o.object)&&Xo(e.object)&&e.object.add(o.object);Ax(e)}}oE.length=0}const pI=()=>{},Oz={};let BT=TV;const Ent=0,Cnt=4,pR=ynt({isPrimaryRenderer:!1,warnsIfNotActing:!1,supportsMutation:!0,supportsPersistence:!1,supportsHydration:!1,createInstance:Snt,removeChild:dR,appendChild:dI,appendInitialChild:dI,insertBefore:kz,appendChildToContainer(n,t){const e=n.getState().scene.__r3f;!t||!e||dI(e,t)},removeChildFromContainer(n,t){const e=n.getState().scene.__r3f;!t||!e||dR(e,t)},insertInContainerBefore(n,t,e){const s=n.getState().scene.__r3f;!t||!e||!s||kz(s,t,e)},getRootHostContext:()=>Oz,getChildHostContext:()=>Oz,commitUpdate(n,t,e,s,i){var r,a,o;CV(t,s);let l=!1;if((n.type==="primitive"&&e.object!==s.object||((r=s.args)==null?void 0:r.length)!==((a=e.args)==null?void 0:a.length)||(o=s.args)!=null&&o.some((h,f)=>{var p;return h!==((p=e.args)==null?void 0:p[f])}))&&(l=!0),l)oE.push([n,{...s},i]);else{const h=cnt(n,s);Object.keys(h).length&&(Object.assign(n.props,h),kd(n.object,h))}(i.sibling===null||(i.flags&Cnt)===Ent)&&Tnt()},finalizeInitialChildren:()=>!1,commitMount(){},getPublicInstance:n=>n==null?void 0:n.object,prepareForCommit:()=>null,preparePortalMount:n=>m2(n.getState().scene,n,"",{}),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance:_nt,unhideInstance:AV,createTextInstance:pI,hideTextInstance:pI,unhideTextInstance:pI,scheduleTimeout:typeof setTimeout=="function"?setTimeout:void 0,cancelTimeout:typeof clearTimeout=="function"?clearTimeout:void 0,noTimeout:-1,getInstanceFromNode:()=>null,beforeActiveInstanceBlur(){},afterActiveInstanceBlur(){},detachDeletedInstance(){},prepareScopeUpdate(){},getInstanceFromScope:()=>null,shouldAttemptEagerTransition:()=>!1,trackSchedulerEvent:()=>{},resolveEventType:()=>null,resolveEventTimeStamp:()=>-1.1,requestPostPaintCallback(){},maySuspendCommit:()=>!1,preloadInstance:()=>!0,startSuspendingCommit(){},suspendInstance(){},waitForCommitToBeReady:()=>null,NotPendingTransition:null,HostTransitionContext:be.createContext(null),setCurrentUpdatePriority(n){BT=n},getCurrentUpdatePriority(){return BT},resolveUpdatePriority(){var n;if(BT!==TV)return BT;switch(typeof window<"u"&&((n=window.event)==null?void 0:n.type)){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return sE.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return sE.ContinuousEventPriority;default:return sE.DefaultEventPriority}},resetFormInstance(){},rendererPackageName:"@react-three/fiber",rendererVersion:gnt.version}),ug=new Map,Ey={objects:"shallow",strict:!1};function Ant(n,t){if(!t&&typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement&&n.parentElement){const{width:e,height:s,top:i,left:r}=n.parentElement.getBoundingClientRect();return{width:e,height:s,top:i,left:r}}else if(!t&&typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas)return{width:n.width,height:n.height,top:0,left:0};return{width:0,height:0,top:0,left:0,...t}}function Nnt(n){const t=ug.get(n),e=t==null?void 0:t.fiber,s=t==null?void 0:t.store;t&&console.warn("R3F.createRoot should only be called once!");const i=typeof reportError=="function"?reportError:console.error,r=s||mnt(yR,Lz),a=e||pR.createContainer(r,sE.ConcurrentRoot,null,!1,null,"",i,i,i,null);t||ug.set(n,{fiber:a,store:r});let o,l,c=!1,h=null;return{async configure(f={}){let p;h=new Promise(X=>p=X);let{gl:g,size:v,scene:_,events:S,onCreated:b,shadows:T=!1,linear:C=!1,flat:A=!1,legacy:I=!1,orthographic:D=!1,frameloop:F="always",dpr:z=[1,2],performance:k,raycaster:O,camera:L,onPointerMissed:H}=f,q=r.getState(),K=q.gl;if(!q.gl){const X={canvas:n,powerPreference:"high-performance",antialias:!0,alpha:!0},it=typeof g=="function"?await g(X):g;Dz(it)?K=it:K=new hV({...X,...g}),q.set({gl:K})}let Y=q.raycaster;Y||q.set({raycaster:Y=new sV});const{params:P,...W}=O||{};if(Ri.equ(W,Y,Ey)||kd(Y,{...W}),Ri.equ(P,Y.params,Ey)||kd(Y,{params:{...Y.params,...P}}),!q.camera||q.camera===l&&!Ri.equ(l,L,Ey)){l=L;const X=L==null?void 0:L.isCamera,it=X?L:D?new rh(0,0,0,0,.1,1e3):new Vi(75,0,.1,1e3);X||(it.position.z=5,L&&(kd(it,L),it.manual||("aspect"in L||"left"in L||"right"in L||"bottom"in L||"top"in L)&&(it.manual=!0,it.updateProjectionMatrix())),!q.camera&&!(L!=null&&L.rotation)&&it.lookAt(0,0,0)),q.set({camera:it}),Y.camera=it}if(!q.scene){let X;_!=null&&_.isScene?(X=_,m2(X,r,"",{})):(X=new _1,m2(X,r,"",{}),_&&kd(X,_)),q.set({scene:X})}S&&!q.events.handlers&&q.set({events:S(r)});const j=Ant(n,v);if(Ri.equ(j,q.size,Ey)||q.setSize(j.width,j.height,j.top,j.left),z&&q.viewport.dpr!==vV(z)&&q.setDpr(z),q.frameloop!==F&&q.setFrameloop(F),q.onPointerMissed||q.set({onPointerMissed:H}),k&&!Ri.equ(k,q.performance,Ey)&&q.set(X=>({performance:{...X.performance,...k}})),!q.xr){var st;const X=(yt,Rt)=>{const ft=r.getState();ft.frameloop!=="never"&&Lz(yt,!0,ft,Rt)},it=()=>{const yt=r.getState();yt.gl.xr.enabled=yt.gl.xr.isPresenting,yt.gl.xr.setAnimationLoop(yt.gl.xr.isPresenting?X:null),yt.gl.xr.isPresenting||yR(yt)},ct={connect(){const yt=r.getState().gl;yt.xr.addEventListener("sessionstart",it),yt.xr.addEventListener("sessionend",it)},disconnect(){const yt=r.getState().gl;yt.xr.removeEventListener("sessionstart",it),yt.xr.removeEventListener("sessionend",it)}};typeof((st=K.xr)==null?void 0:st.addEventListener)=="function"&&ct.connect(),q.set({xr:ct})}if(K.shadowMap){const X=K.shadowMap.enabled,it=K.shadowMap.type;if(K.shadowMap.enabled=!!T,Ri.boo(T))K.shadowMap.type=Zb;else if(Ri.str(T)){var ot;const ct={basic:_P,percentage:Py,soft:Zb,variance:Vm};K.shadowMap.type=(ot=ct[T])!=null?ot:Zb}else Ri.obj(T)&&Object.assign(K.shadowMap,T);(X!==K.shadowMap.enabled||it!==K.shadowMap.type)&&(K.shadowMap.needsUpdate=!0)}return ss.enabled=!I,c||(K.outputColorSpace=C?gh:Ms,K.toneMapping=A?Tl:aC),q.legacy!==I&&q.set(()=>({legacy:I})),q.linear!==C&&q.set(()=>({linear:C})),q.flat!==A&&q.set(()=>({flat:A})),g&&!Ri.fun(g)&&!Dz(g)&&!Ri.equ(g,K,Ey)&&kd(K,g),o=b,c=!0,p(),this},render(f){return!c&&!h&&this.configure(),h.then(()=>{pR.updateContainer(ge.jsx(Mnt,{store:r,children:f,onCreated:o,rootElement:n}),a,null,()=>{})}),r},unmount(){MV(n)}}}function Mnt({store:n,children:t,onCreated:e,rootElement:s}){return cS(()=>{const i=n.getState();i.set(r=>({internal:{...r.internal,active:!0}})),e&&e(i),n.getState().events.connected||i.events.connect==null||i.events.connect(s)},[]),ge.jsx(_V.Provider,{value:n,children:t})}function MV(n,t){const e=ug.get(n),s=e==null?void 0:e.fiber;if(s){const i=e==null?void 0:e.store.getState();i&&(i.internal.active=!1),pR.updateContainer(null,s,null,()=>{i&&setTimeout(()=>{try{var r,a,o,l;i.events.disconnect==null||i.events.disconnect(),(r=i.gl)==null||(a=r.renderLists)==null||a.dispose==null||a.dispose(),(o=i.gl)==null||o.forceContextLoss==null||o.forceContextLoss(),(l=i.gl)!=null&&l.xr&&i.xr.disconnect(),ant(i.scene),ug.delete(n)}catch{}},500)})}}const Int=new Set,Rnt=new Set,Dnt=new Set;function mI(n,t){if(n.size)for(const{callback:e}of n.values())e(t)}function a1(n,t){switch(n){case"before":return mI(Int,t);case"after":return mI(Rnt,t);case"tail":return mI(Dnt,t)}}let gI,yI;function mR(n,t,e){let s=t.clock.getDelta();t.frameloop==="never"&&typeof n=="number"&&(s=n-t.clock.elapsedTime,t.clock.oldTime=t.clock.elapsedTime,t.clock.elapsedTime=n),gI=t.internal.subscribers;for(let i=0;i<gI.length;i++)yI=gI[i],yI.ref.current(yI.store.getState(),s,e);return!t.internal.priority&&t.gl.render&&t.gl.render(t.scene,t.camera),t.internal.frames=Math.max(0,t.internal.frames-1),t.frameloop==="always"?1:t.internal.frames}let x2=!1,gR=!1,xI,$z,Cy;function IV(n){$z=requestAnimationFrame(IV),x2=!0,xI=0,a1("before",n),gR=!0;for(const e of ug.values()){var t;Cy=e.store.getState(),Cy.internal.active&&(Cy.frameloop==="always"||Cy.internal.frames>0)&&!((t=Cy.gl.xr)!=null&&t.isPresenting)&&(xI+=mR(n,Cy))}if(gR=!1,a1("after",n),xI===0)return a1("tail",n),x2=!1,cancelAnimationFrame($z)}function yR(n,t=1){var e;if(!n)return ug.forEach(s=>yR(s.store.getState(),t));(e=n.gl.xr)!=null&&e.isPresenting||!n.internal.active||n.frameloop==="never"||(t>1?n.internal.frames=Math.min(60,n.internal.frames+t):gR?n.internal.frames=2:n.internal.frames=1,x2||(x2=!0,requestAnimationFrame(IV)))}function Lz(n,t=!0,e,s){if(t&&a1("before",n),e)mR(n,e,s);else for(const i of ug.values())mR(n,i.store.getState());t&&a1("after",n)}const vI={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function knt(n){const{handlePointer:t}=pnt(n);return{priority:1,enabled:!0,compute(e,s,i){s.pointer.set(e.offsetX/s.size.width*2-1,-(e.offsetY/s.size.height)*2+1),s.raycaster.setFromCamera(s.pointer,s.camera)},connected:void 0,handlers:Object.keys(vI).reduce((e,s)=>({...e,[s]:t(s)}),{}),update:()=>{var e;const{events:s,internal:i}=n.getState();(e=i.lastEvent)!=null&&e.current&&s.handlers&&s.handlers.onPointerMove(i.lastEvent.current)},connect:e=>{const{set:s,events:i}=n.getState();if(i.disconnect==null||i.disconnect(),s(r=>({events:{...r.events,connected:e}})),i.handlers)for(const r in i.handlers){const a=i.handlers[r],[o,l]=vI[r];e.addEventListener(o,a,{passive:l})}},disconnect:()=>{const{set:e,events:s}=n.getState();if(s.connected){if(s.handlers)for(const i in s.handlers){const r=s.handlers[i],[a]=vI[i];s.connected.removeEventListener(a,r)}e(i=>({events:{...i.events,connected:void 0}}))}}}}function Fz(n,t){let e;return(...s)=>{window.clearTimeout(e),e=window.setTimeout(()=>n(...s),t)}}function Ont({debounce:n,scroll:t,polyfill:e,offsetSize:s}={debounce:0,scroll:!1,offsetSize:!1}){const i=e||(typeof window>"u"?class{}:window.ResizeObserver);if(!i)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[r,a]=be.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),o=be.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:r,orientationHandler:null}),l=n?typeof n=="number"?n:n.scroll:null,c=n?typeof n=="number"?n:n.resize:null,h=be.useRef(!1);be.useEffect(()=>(h.current=!0,()=>void(h.current=!1)));const[f,p,g]=be.useMemo(()=>{const b=()=>{if(!o.current.element)return;const{left:T,top:C,width:A,height:I,bottom:D,right:F,x:z,y:k}=o.current.element.getBoundingClientRect(),O={left:T,top:C,width:A,height:I,bottom:D,right:F,x:z,y:k};o.current.element instanceof HTMLElement&&s&&(O.height=o.current.element.offsetHeight,O.width=o.current.element.offsetWidth),Object.freeze(O),h.current&&!znt(o.current.lastBounds,O)&&a(o.current.lastBounds=O)};return[b,c?Fz(b,c):b,l?Fz(b,l):b]},[a,s,l,c]);function v(){o.current.scrollContainers&&(o.current.scrollContainers.forEach(b=>b.removeEventListener("scroll",g,!0)),o.current.scrollContainers=null),o.current.resizeObserver&&(o.current.resizeObserver.disconnect(),o.current.resizeObserver=null),o.current.orientationHandler&&("orientation"in screen&&"removeEventListener"in screen.orientation?screen.orientation.removeEventListener("change",o.current.orientationHandler):"onorientationchange"in window&&window.removeEventListener("orientationchange",o.current.orientationHandler))}function _(){o.current.element&&(o.current.resizeObserver=new i(g),o.current.resizeObserver.observe(o.current.element),t&&o.current.scrollContainers&&o.current.scrollContainers.forEach(b=>b.addEventListener("scroll",g,{capture:!0,passive:!0})),o.current.orientationHandler=()=>{g()},"orientation"in screen&&"addEventListener"in screen.orientation?screen.orientation.addEventListener("change",o.current.orientationHandler):"onorientationchange"in window&&window.addEventListener("orientationchange",o.current.orientationHandler))}const S=b=>{!b||b===o.current.element||(v(),o.current.element=b,o.current.scrollContainers=RV(b),_())};return Lnt(g,!!t),$nt(p),be.useEffect(()=>{v(),_()},[t,g,p]),be.useEffect(()=>v,[]),[S,r,f]}function $nt(n){be.useEffect(()=>{const t=n;return window.addEventListener("resize",t),()=>void window.removeEventListener("resize",t)},[n])}function Lnt(n,t){be.useEffect(()=>{if(t){const e=n;return window.addEventListener("scroll",e,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",e,!0)}},[n,t])}function RV(n){const t=[];if(!n||n===document.body)return t;const{overflow:e,overflowX:s,overflowY:i}=window.getComputedStyle(n);return[e,s,i].some(r=>r==="auto"||r==="scroll")&&t.push(n),[...t,...RV(n.parentElement)]}const Fnt=["x","y","top","bottom","left","right","width","height"],znt=(n,t)=>Fnt.every(e=>n[e]===t[e]);function Unt({ref:n,children:t,fallback:e,resize:s,style:i,gl:r,events:a=knt,eventSource:o,eventPrefix:l,shadows:c,linear:h,flat:f,legacy:p,orthographic:g,frameloop:v,dpr:_,performance:S,raycaster:b,camera:T,scene:C,onPointerMissed:A,onCreated:I,...D}){be.useMemo(()=>EV(Oet),[]);const F=snt(),[z,k]=Ont({scroll:!0,debounce:{scroll:50,resize:0},...s}),O=be.useRef(null),L=be.useRef(null);be.useImperativeHandle(n,()=>O.current);const H=xV(A),[q,K]=be.useState(!1),[Y,P]=be.useState(!1);if(q)throw q;if(Y)throw Y;const W=be.useRef(null);cS(()=>{const st=O.current;if(k.width>0&&k.height>0&&st){W.current||(W.current=Nnt(st));async function ot(){await W.current.configure({gl:r,scene:C,events:a,shadows:c,linear:h,flat:f,legacy:p,orthographic:g,frameloop:v,dpr:_,performance:S,raycaster:b,camera:T,size:k,onPointerMissed:(...X)=>H.current==null?void 0:H.current(...X),onCreated:X=>{X.events.connect==null||X.events.connect(o?ent(o)?o.current:o:L.current),l&&X.setEvents({compute:(it,ct)=>{const yt=it[l+"X"],Rt=it[l+"Y"];ct.pointer.set(yt/ct.size.width*2-1,-(Rt/ct.size.height)*2+1),ct.raycaster.setFromCamera(ct.pointer,ct.camera)}}),I==null||I(X)}}),W.current.render(ge.jsx(F,{children:ge.jsx(rnt,{set:P,children:ge.jsx(be.Suspense,{fallback:ge.jsx(int,{set:K}),children:t??null})})}))}ot()}}),be.useEffect(()=>{const st=O.current;if(st)return()=>MV(st)},[]);const j=o?"none":"auto";return ge.jsx("div",{ref:L,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:j,...i},...D,children:ge.jsx("div",{ref:z,style:{width:"100%",height:"100%"},children:ge.jsx("canvas",{ref:O,style:{display:"block"},children:e})})})}function Bnt(n){return ge.jsx(pV,{children:ge.jsx(Unt,{...n})})}/**
 * postprocessing v6.38.0 build Sat Nov 08 2025
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2025 Raoul van Rschen
 * @license Zlib
 */var bI=1/1e3,Pnt=1e3,Vnt=class{constructor(){this.startTime=performance.now(),this.previousTime=0,this.currentTime=0,this._delta=0,this._elapsed=0,this._fixedDelta=1e3/60,this.timescale=1,this.useFixedDelta=!1,this._autoReset=!1}get autoReset(){return this._autoReset}set autoReset(n){typeof document<"u"&&document.hidden!==void 0&&(n?document.addEventListener("visibilitychange",this):document.removeEventListener("visibilitychange",this),this._autoReset=n)}get delta(){return this._delta*bI}get fixedDelta(){return this._fixedDelta*bI}set fixedDelta(n){this._fixedDelta=n*Pnt}get elapsed(){return this._elapsed*bI}update(n){this.useFixedDelta?this._delta=this.fixedDelta:(this.previousTime=this.currentTime,this.currentTime=(n!==void 0?n:performance.now())-this.startTime,this._delta=this.currentTime-this.previousTime),this._delta*=this.timescale,this._elapsed+=this._delta}reset(){this._delta=0,this._elapsed=0,this.currentTime=performance.now()-this.startTime}getDelta(){return this.delta}getElapsed(){return this.elapsed}handleEvent(n){document.hidden||(this.currentTime=performance.now()-this.startTime)}dispose(){this.autoReset=!1}},Gnt=(()=>{const n=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t=new Float32Array([0,0,2,0,0,2]),e=new Nn;return e.setAttribute("position",new Fs(n,3)),e.setAttribute("uv",new Fs(t,2)),e})(),sl=class xR{static get fullscreenGeometry(){return Gnt}constructor(t="Pass",e=new _1,s=new rh){this.name=t,this.renderer=null,this.scene=e,this.camera=s,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(t){if(this.rtt===t){const e=this.fullscreenMaterial;e!==null&&(e.needsUpdate=!0),this.rtt=!t}}set mainScene(t){}set mainCamera(t){}setRenderer(t){this.renderer=t}isEnabled(){return this.enabled}setEnabled(t){this.enabled=t}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(t){let e=this.screen;e!==null?e.material=t:(e=new rr(xR.fullscreenGeometry,t),e.frustumCulled=!1,this.scene===null&&(this.scene=new _1),this.scene.add(e),this.screen=e)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(t){this.fullscreenMaterial=t}getDepthTexture(){return null}setDepthTexture(t,e=op){}render(t,e,s,i,r){throw new Error("Render method not implemented!")}setSize(t,e){}initialize(t,e,s){}dispose(){for(const t of Object.keys(this)){const e=this[t];(e instanceof ki||e instanceof Jr||e instanceof wi||e instanceof xR)&&this[t].dispose()}this.fullscreenMaterial!==null&&this.fullscreenMaterial.dispose()}},Hnt=class extends sl{constructor(){super("ClearMaskPass",null,null),this.needsSwap=!1}render(n,t,e,s,i){const r=n.state.buffers.stencil;r.setLocked(!1),r.setTest(!1)}},Wnt=`#ifdef COLOR_WRITE
#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#endif
#ifdef DEPTH_WRITE
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}
#endif
#ifdef USE_WEIGHTS
uniform vec4 channelWeights;
#endif
uniform float opacity;varying vec2 vUv;void main(){
#ifdef COLOR_WRITE
vec4 texel=texture2D(inputBuffer,vUv);
#ifdef USE_WEIGHTS
texel*=channelWeights;
#endif
gl_FragColor=opacity*texel;
#ifdef COLOR_SPACE_CONVERSION
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
#else
gl_FragColor=vec4(0.0);
#endif
#ifdef DEPTH_WRITE
gl_FragDepth=readDepth(vUv);
#endif
}`,DV="varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",kV=class extends ar{constructor(){super({name:"CopyMaterial",defines:{DEPTH_PACKING:"0",COLOR_WRITE:"1"},uniforms:{inputBuffer:new Qn(null),depthBuffer:new Qn(null),channelWeights:new Qn(null),opacity:new Qn(1)},blending:da,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Wnt,vertexShader:DV}),this.depthFunc=h1}get inputBuffer(){return this.uniforms.inputBuffer.value}set inputBuffer(n){const t=n!==null;this.colorWrite!==t&&(t?this.defines.COLOR_WRITE=!0:delete this.defines.COLOR_WRITE,this.colorWrite=t,this.needsUpdate=!0),this.uniforms.inputBuffer.value=n}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(n){const t=n!==null;this.depthWrite!==t&&(t?this.defines.DEPTH_WRITE=!0:delete this.defines.DEPTH_WRITE,this.depthTest=t,this.depthWrite=t,this.needsUpdate=!0),this.uniforms.depthBuffer.value=n}set depthPacking(n){this.defines.DEPTH_PACKING=n.toFixed(0),this.needsUpdate=!0}get channelWeights(){return this.uniforms.channelWeights.value}set channelWeights(n){n!==null?(this.defines.USE_WEIGHTS="1",this.uniforms.channelWeights.value=n):delete this.defines.USE_WEIGHTS,this.needsUpdate=!0}setInputBuffer(n){this.uniforms.inputBuffer.value=n}getOpacity(n){return this.uniforms.opacity.value}setOpacity(n){this.uniforms.opacity.value=n}},qnt=class extends sl{constructor(n,t=!0){super("CopyPass"),this.fullscreenMaterial=new kV,this.needsSwap=!1,this.renderTarget=n,n===void 0&&(this.renderTarget=new ki(1,1,{minFilter:Hs,magFilter:Hs,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="CopyPass.Target"),this.autoResize=t}get resize(){return this.autoResize}set resize(n){this.autoResize=n}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}setAutoResizeEnabled(n){this.autoResize=n}render(n,t,e,s,i){this.fullscreenMaterial.inputBuffer=t.texture,n.setRenderTarget(this.renderToScreen?null:this.renderTarget),n.render(this.scene,this.camera)}setSize(n,t){this.autoResize&&this.renderTarget.setSize(n,t)}initialize(n,t,e){e!==void 0&&(this.renderTarget.texture.type=e,e!==Gi?this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1":n!==null&&n.outputColorSpace===Ms&&(this.renderTarget.texture.colorSpace=Ms))}},zz=new ke,OV=class extends sl{constructor(n=!0,t=!0,e=!1){super("ClearPass",null,null),this.needsSwap=!1,this.color=n,this.depth=t,this.stencil=e,this.overrideClearColor=null,this.overrideClearAlpha=-1}setClearFlags(n,t,e){this.color=n,this.depth=t,this.stencil=e}getOverrideClearColor(){return this.overrideClearColor}setOverrideClearColor(n){this.overrideClearColor=n}getOverrideClearAlpha(){return this.overrideClearAlpha}setOverrideClearAlpha(n){this.overrideClearAlpha=n}render(n,t,e,s,i){const r=this.overrideClearColor,a=this.overrideClearAlpha,o=n.getClearAlpha(),l=r!==null,c=a>=0;l?(n.getClearColor(zz),n.setClearColor(r,c?a:o)):c&&n.setClearAlpha(a),n.setRenderTarget(this.renderToScreen?null:t),n.clear(this.color,this.depth,this.stencil),l?n.setClearColor(zz,o):c&&n.setClearAlpha(o)}},Xnt=class extends sl{constructor(n,t){super("MaskPass",n,t),this.needsSwap=!1,this.clearPass=new OV(!1,!1,!0),this.inverse=!1}set mainScene(n){this.scene=n}set mainCamera(n){this.camera=n}get inverted(){return this.inverse}set inverted(n){this.inverse=n}get clear(){return this.clearPass.enabled}set clear(n){this.clearPass.enabled=n}getClearPass(){return this.clearPass}isInverted(){return this.inverted}setInverted(n){this.inverted=n}render(n,t,e,s,i){const r=n.getContext(),a=n.state.buffers,o=this.scene,l=this.camera,c=this.clearPass,h=this.inverted?0:1,f=1-h;a.color.setMask(!1),a.depth.setMask(!1),a.color.setLocked(!0),a.depth.setLocked(!0),a.stencil.setTest(!0),a.stencil.setOp(r.REPLACE,r.REPLACE,r.REPLACE),a.stencil.setFunc(r.ALWAYS,h,4294967295),a.stencil.setClear(f),a.stencil.setLocked(!0),this.clearPass.enabled&&(this.renderToScreen?c.render(n,null):(c.render(n,t),c.render(n,e))),this.renderToScreen?(n.setRenderTarget(null),n.render(o,l)):(n.setRenderTarget(t),n.render(o,l),n.setRenderTarget(e),n.render(o,l)),a.color.setLocked(!1),a.depth.setLocked(!1),a.stencil.setLocked(!1),a.stencil.setFunc(r.EQUAL,1,4294967295),a.stencil.setOp(r.KEEP,r.KEEP,r.KEEP),a.stencil.setLocked(!0)}},jnt=class{constructor(n=null,{depthBuffer:t=!0,stencilBuffer:e=!1,multisampling:s=0,frameBufferType:i}={}){this.renderer=null,this.inputBuffer=this.createBuffer(t,e,i,s),this.outputBuffer=this.inputBuffer.clone(),this.copyPass=new qnt,this.depthTexture=null,this.passes=[],this.timer=new Vnt,this.autoRenderToScreen=!0,this.setRenderer(n)}get multisampling(){return this.inputBuffer.samples||0}set multisampling(n){const t=this.inputBuffer,e=this.multisampling;e>0&&n>0?(this.inputBuffer.samples=n,this.outputBuffer.samples=n,this.inputBuffer.dispose(),this.outputBuffer.dispose()):e!==n&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(t.depthBuffer,t.stencilBuffer,t.texture.type,n),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}getTimer(){return this.timer}getRenderer(){return this.renderer}setRenderer(n){if(this.renderer=n,n!==null){const t=n.getSize(new Yt),e=n.getContext().getContextAttributes().alpha,s=this.inputBuffer.texture.type;s===Gi&&n.outputColorSpace===Ms&&(this.inputBuffer.texture.colorSpace=Ms,this.outputBuffer.texture.colorSpace=Ms,this.inputBuffer.dispose(),this.outputBuffer.dispose()),n.autoClear=!1,this.setSize(t.width,t.height);for(const i of this.passes)i.initialize(n,e,s)}}replaceRenderer(n,t=!0){const e=this.renderer,s=e.domElement.parentNode;return this.setRenderer(n),t&&s!==null&&(s.removeChild(e.domElement),s.appendChild(n.domElement)),e}createDepthTexture(){const n=this.depthTexture=new lg;return this.inputBuffer.depthTexture=n,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(n.format=vf,n.type=rg):n.type=Nl,n}deleteDepthTexture(){if(this.depthTexture!==null){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();for(const n of this.passes)n.setDepthTexture(null)}}createBuffer(n,t,e,s){const i=this.renderer,r=i===null?new Yt:i.getDrawingBufferSize(new Yt),a={minFilter:Hs,magFilter:Hs,stencilBuffer:t,depthBuffer:n,type:e},o=new ki(r.width,r.height,a);return s>0&&(o.samples=s),e===Gi&&i!==null&&i.outputColorSpace===Ms&&(o.texture.colorSpace=Ms),o.texture.name="EffectComposer.Buffer",o.texture.generateMipmaps=!1,o}setMainScene(n){for(const t of this.passes)t.mainScene=n}setMainCamera(n){for(const t of this.passes)t.mainCamera=n}addPass(n,t){const e=this.passes,s=this.renderer,i=s.getDrawingBufferSize(new Yt),r=s.getContext().getContextAttributes().alpha,a=this.inputBuffer.texture.type;if(n.setRenderer(s),n.setSize(i.width,i.height),n.initialize(s,r,a),this.autoRenderToScreen&&(e.length>0&&(e[e.length-1].renderToScreen=!1),n.renderToScreen&&(this.autoRenderToScreen=!1)),t!==void 0?e.splice(t,0,n):e.push(n),this.autoRenderToScreen&&(e[e.length-1].renderToScreen=!0),n.needsDepthTexture||this.depthTexture!==null)if(this.depthTexture===null){const o=this.createDepthTexture();for(n of e)n.setDepthTexture(o)}else n.setDepthTexture(this.depthTexture)}removePass(n){const t=this.passes,e=t.indexOf(n);if(e!==-1&&t.splice(e,1).length>0){if(this.depthTexture!==null){const r=(o,l)=>o||l.needsDepthTexture;t.reduce(r,!1)||(n.getDepthTexture()===this.depthTexture&&n.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&e===t.length&&(n.renderToScreen=!1,t.length>0&&(t[t.length-1].renderToScreen=!0))}}removeAllPasses(){const n=this.passes;this.deleteDepthTexture(),n.length>0&&(this.autoRenderToScreen&&(n[n.length-1].renderToScreen=!1),this.passes=[])}render(n){const t=this.renderer,e=this.copyPass;let s=this.inputBuffer,i=this.outputBuffer,r=!1,a,o,l;n===void 0&&(this.timer.update(),n=this.timer.getDelta());for(const c of this.passes)c.enabled&&(c.render(t,s,i,n,r),c.needsSwap&&(r&&(e.renderToScreen=c.renderToScreen,a=t.getContext(),o=t.state.buffers.stencil,o.setFunc(a.NOTEQUAL,1,4294967295),e.render(t,s,i,n,r),o.setFunc(a.EQUAL,1,4294967295)),l=s,s=i,i=l),c instanceof Xnt?r=!0:c instanceof Hnt&&(r=!1))}setSize(n,t,e){const s=this.renderer,i=s.getSize(new Yt);(n===void 0||t===void 0)&&(n=i.width,t=i.height),(i.width!==n||i.height!==t)&&s.setSize(n,t,e);const r=s.getDrawingBufferSize(new Yt);this.inputBuffer.setSize(r.width,r.height),this.outputBuffer.setSize(r.width,r.height);for(const a of this.passes)a.setSize(r.width,r.height)}reset(){this.dispose(),this.autoRenderToScreen=!0}dispose(){for(const n of this.passes)n.dispose();this.passes=[],this.inputBuffer!==null&&this.inputBuffer.dispose(),this.outputBuffer!==null&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose(),this.timer.dispose(),sl.fullscreenGeometry.dispose()}},Jm={NONE:0,DEPTH:1,CONVOLUTION:2},As={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},Knt=class{constructor(){this.shaderParts=new Map([[As.FRAGMENT_HEAD,null],[As.FRAGMENT_MAIN_UV,null],[As.FRAGMENT_MAIN_IMAGE,null],[As.VERTEX_HEAD,null],[As.VERTEX_MAIN_SUPPORT,null]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.extensions=new Set,this.attributes=Jm.NONE,this.varyings=new Set,this.uvTransformation=!1,this.readDepth=!1,this.colorSpace=gh}},SI=!1,Uz=class{constructor(n=null){this.originalMaterials=new Map,this.material=null,this.materials=null,this.materialsBackSide=null,this.materialsDoubleSide=null,this.materialsFlatShaded=null,this.materialsFlatShadedBackSide=null,this.materialsFlatShadedDoubleSide=null,this.setMaterial(n),this.meshCount=0,this.replaceMaterial=t=>{if(t.isMesh){let e;if(t.material.flatShading)switch(t.material.side){case Fa:e=this.materialsFlatShadedDoubleSide;break;case kr:e=this.materialsFlatShadedBackSide;break;default:e=this.materialsFlatShaded;break}else switch(t.material.side){case Fa:e=this.materialsDoubleSide;break;case kr:e=this.materialsBackSide;break;default:e=this.materials;break}this.originalMaterials.set(t,t.material),t.isSkinnedMesh?t.material=e[2]:t.isInstancedMesh?t.material=e[1]:t.material=e[0],++this.meshCount}}}cloneMaterial(n){if(!(n instanceof ar))return n.clone();const t=n.uniforms,e=new Map;for(const i in t){const r=t[i].value;r.isRenderTargetTexture&&(t[i].value=null,e.set(i,r))}const s=n.clone();for(const i of e)t[i[0]].value=i[1],s.uniforms[i[0]].value=i[1];return s}setMaterial(n){if(this.disposeMaterials(),this.material=n,n!==null){const t=this.materials=[this.cloneMaterial(n),this.cloneMaterial(n),this.cloneMaterial(n)];for(const e of t)e.uniforms=Object.assign({},n.uniforms),e.side=dh;t[2].skinning=!0,this.materialsBackSide=t.map(e=>{const s=this.cloneMaterial(e);return s.uniforms=Object.assign({},n.uniforms),s.side=kr,s}),this.materialsDoubleSide=t.map(e=>{const s=this.cloneMaterial(e);return s.uniforms=Object.assign({},n.uniforms),s.side=Fa,s}),this.materialsFlatShaded=t.map(e=>{const s=this.cloneMaterial(e);return s.uniforms=Object.assign({},n.uniforms),s.flatShading=!0,s}),this.materialsFlatShadedBackSide=t.map(e=>{const s=this.cloneMaterial(e);return s.uniforms=Object.assign({},n.uniforms),s.flatShading=!0,s.side=kr,s}),this.materialsFlatShadedDoubleSide=t.map(e=>{const s=this.cloneMaterial(e);return s.uniforms=Object.assign({},n.uniforms),s.flatShading=!0,s.side=Fa,s})}}render(n,t,e){const s=n.shadowMap.enabled;if(n.shadowMap.enabled=!1,SI){const i=this.originalMaterials;this.meshCount=0,t.traverse(this.replaceMaterial),n.render(t,e);for(const r of i)r[0].material=r[1];this.meshCount!==i.size&&i.clear()}else{const i=t.overrideMaterial;t.overrideMaterial=this.material,n.render(t,e),t.overrideMaterial=i}n.shadowMap.enabled=s}disposeMaterials(){if(this.material!==null){const n=this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);for(const t of n)t.dispose()}}dispose(){this.originalMaterials.clear(),this.disposeMaterials()}static get workaroundEnabled(){return SI}static set workaroundEnabled(n){SI=n}},Md=-1,Pa=class extends Rl{constructor(n,t=Md,e=Md,s=1){super(),this.resizable=n,this.baseSize=new Yt(1,1),this.preferredSize=new Yt(t,e),this.target=this.preferredSize,this.s=s,this.effectiveSize=new Yt,this.addEventListener("change",()=>this.updateEffectiveSize()),this.updateEffectiveSize()}updateEffectiveSize(){const n=this.baseSize,t=this.preferredSize,e=this.effectiveSize,s=this.scale;t.width!==Md?e.width=t.width:t.height!==Md?e.width=Math.round(t.height*(n.width/Math.max(n.height,1))):e.width=Math.round(n.width*s),t.height!==Md?e.height=t.height:t.width!==Md?e.height=Math.round(t.width/Math.max(n.width/Math.max(n.height,1),1)):e.height=Math.round(n.height*s)}get width(){return this.effectiveSize.width}set width(n){this.preferredWidth=n}get height(){return this.effectiveSize.height}set height(n){this.preferredHeight=n}getWidth(){return this.width}getHeight(){return this.height}get scale(){return this.s}set scale(n){this.s!==n&&(this.s=n,this.preferredSize.setScalar(Md),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getScale(){return this.scale}setScale(n){this.scale=n}get baseWidth(){return this.baseSize.width}set baseWidth(n){this.baseSize.width!==n&&(this.baseSize.width=n,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseWidth(){return this.baseWidth}setBaseWidth(n){this.baseWidth=n}get baseHeight(){return this.baseSize.height}set baseHeight(n){this.baseSize.height!==n&&(this.baseSize.height=n,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseHeight(){return this.baseHeight}setBaseHeight(n){this.baseHeight=n}setBaseSize(n,t){(this.baseSize.width!==n||this.baseSize.height!==t)&&(this.baseSize.set(n,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}get preferredWidth(){return this.preferredSize.width}set preferredWidth(n){this.preferredSize.width!==n&&(this.preferredSize.width=n,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredWidth(){return this.preferredWidth}setPreferredWidth(n){this.preferredWidth=n}get preferredHeight(){return this.preferredSize.height}set preferredHeight(n){this.preferredSize.height!==n&&(this.preferredSize.height=n,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredHeight(){return this.preferredHeight}setPreferredHeight(n){this.preferredHeight=n}setPreferredSize(n,t){(this.preferredSize.width!==n||this.preferredSize.height!==t)&&(this.preferredSize.set(n,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}copy(n){this.s=n.scale,this.baseSize.set(n.baseWidth,n.baseHeight),this.preferredSize.set(n.preferredWidth,n.preferredHeight),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height)}static get AUTO_SIZE(){return Md}},ls={ADD:0,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},Ynt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb,y.a),y.a*opacity);}",Znt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb)*0.5,y.a),y.a*opacity);}",Qnt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.xy,xHSL.z));return mix(x,vec4(z,y.a),y.a*opacity);}",Jnt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/b)),vec3(1.0),step(1.0,a));return mix(x,vec4(z,y.a),y.a*opacity);}",tst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(x,vec4(z,y.a),y.a*opacity);}",est="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb,y.rgb),y.a),y.a*opacity);}",nst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(abs(x.rgb-y.rgb),y.a),y.a*opacity);}",sst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb/max(y.rgb,1e-12),y.a),y.a*opacity);}",ist="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb-2.0*x.rgb*y.rgb),y.a),y.a*opacity);}",rst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=min(x.rgb,1.0);vec3 b=min(y.rgb,1.0);vec3 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(x,vec4(z,y.a),y.a*opacity);}",ast="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(step(1.0,x.rgb+y.rgb),y.a),y.a*opacity);}",ost="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.x,xHSL.yz));return mix(x,vec4(z,y.a),y.a*opacity);}",lst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-y.rgb,y.a),y.a*opacity);}",cst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(y.rgb*(1.0-x.rgb),y.a),y.a*opacity);}",ust="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb,y.rgb),y.a),y.a*opacity);}",hst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(y.rgb+x.rgb-1.0,0.0,1.0),y.a),y.a*opacity);}",fst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb+y.rgb,1.0),y.a),y.a*opacity);}",dst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(2.0*y.rgb+x.rgb-1.0,0.0,1.0),y.a),y.a*opacity);}",pst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.xy,yHSL.z));return mix(x,vec4(z,y.a),y.a*opacity);}",mst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb*y.rgb,y.a),y.a*opacity);}",gst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-abs(1.0-x.rgb-y.rgb),y.a),y.a*opacity);}",yst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,y.a*opacity);}",xst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(2.0*y.rgb*x.rgb,1.0-2.0*(1.0-y.rgb)*(1.0-x.rgb),step(0.5,x.rgb));return mix(x,vec4(z,y.a),y.a*opacity);}",vst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 y2=2.0*y.rgb;vec3 z=mix(mix(y2,x.rgb,step(0.5*x.rgb,y.rgb)),max(y2-1.0,vec3(0.0)),step(x.rgb,y2-1.0));return mix(x,vec4(z,y.a),y.a*opacity);}",bst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(min(x.rgb*x.rgb/max(1.0-y.rgb,1e-12),1.0),y.rgb,step(1.0,y.rgb));return mix(x,vec4(z,y.a),y.a*opacity);}",Sst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.x,yHSL.y,xHSL.z));return mix(x,vec4(z,y.a),y.a*opacity);}",_st="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb-min(x.rgb*y.rgb,1.0),y.a),y.a*opacity);}",wst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb;vec3 b=y.rgb;vec3 y2=2.0*b;vec3 w=step(0.5,b);vec3 c=a-(1.0-y2)*a*(1.0-a);vec3 d=mix(a+(y2-1.0)*(sqrt(a)-a),a+(y2-1.0)*a*((16.0*a-12.0)*a+3.0),w*(1.0-step(0.25,a)));vec3 z=mix(c,d,w);return mix(x,vec4(z,y.a),y.a*opacity);}",Tst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",Est="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb+y.rgb-1.0,0.0),y.a),y.a*opacity);}",Cst="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(max(1.0-min((1.0-x.rgb)/(2.0*y.rgb),1.0),0.0),min(x.rgb/(2.0*(1.0-y.rgb)),1.0),step(0.5,y.rgb));return mix(x,vec4(z,y.a),y.a*opacity);}",Ast=new Map([[ls.ADD,Ynt],[ls.AVERAGE,Znt],[ls.COLOR,Qnt],[ls.COLOR_BURN,Jnt],[ls.COLOR_DODGE,tst],[ls.DARKEN,est],[ls.DIFFERENCE,nst],[ls.DIVIDE,sst],[ls.DST,null],[ls.EXCLUSION,ist],[ls.HARD_LIGHT,rst],[ls.HARD_MIX,ast],[ls.HUE,ost],[ls.INVERT,lst],[ls.INVERT_RGB,cst],[ls.LIGHTEN,ust],[ls.LINEAR_BURN,hst],[ls.LINEAR_DODGE,fst],[ls.LINEAR_LIGHT,dst],[ls.LUMINOSITY,pst],[ls.MULTIPLY,mst],[ls.NEGATION,gst],[ls.NORMAL,yst],[ls.OVERLAY,xst],[ls.PIN_LIGHT,vst],[ls.REFLECT,bst],[ls.SATURATION,Sst],[ls.SCREEN,_st],[ls.SOFT_LIGHT,wst],[ls.SRC,Tst],[ls.SUBTRACT,Est],[ls.VIVID_LIGHT,Cst]]),Nst=class extends Rl{constructor(n,t=1){super(),this._blendFunction=n,this.opacity=new Qn(t)}getOpacity(){return this.opacity.value}setOpacity(n){this.opacity.value=n}get blendFunction(){return this._blendFunction}set blendFunction(n){this._blendFunction=n,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(n){this.blendFunction=n}getShaderCode(){return Ast.get(this.blendFunction)}},v2=class extends Rl{constructor(n,t,{attributes:e=Jm.NONE,blendFunction:s=ls.NORMAL,defines:i=new Map,uniforms:r=new Map,extensions:a=null,vertexShader:o=null}={}){super(),this.name=n,this.renderer=null,this.attributes=e,this.fragmentShader=t,this.vertexShader=o,this.defines=i,this.uniforms=r,this.extensions=a,this.blendMode=new Nst(s),this.blendMode.addEventListener("change",l=>this.setChanged()),this._inputColorSpace=gh,this._outputColorSpace=Yc}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(n){this._inputColorSpace=n,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(n){this._outputColorSpace=n,this.setChanged()}set mainScene(n){}set mainCamera(n){}getName(){return this.name}setRenderer(n){this.renderer=n}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(n){this.attributes=n,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(n){this.fragmentShader=n,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(n){this.vertexShader=n,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(n,t=op){}update(n,t,e){}setSize(n,t){}initialize(n,t,e){}dispose(){for(const n of Object.keys(this)){const t=this[n];(t instanceof ki||t instanceof Jr||t instanceof wi||t instanceof sl)&&this[n].dispose()}}},M3={MEDIUM:2,LARGE:3},Mst=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`,Ist="uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",Rst=[new Float32Array([0,0]),new Float32Array([0,1,1]),new Float32Array([0,1,1,2]),new Float32Array([0,1,2,2,3]),new Float32Array([0,1,2,3,4,4,5]),new Float32Array([0,1,2,3,4,5,7,8,9,10])],Dst=class extends ar{constructor(n=new Gs){super({name:"KawaseBlurMaterial",uniforms:{inputBuffer:new Qn(null),texelSize:new Qn(new Gs),scale:new Qn(1),kernel:new Qn(0)},blending:da,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Mst,vertexShader:Ist}),this.setTexelSize(n.x,n.y),this.kernelSize=M3.MEDIUM}set inputBuffer(n){this.uniforms.inputBuffer.value=n}setInputBuffer(n){this.inputBuffer=n}get kernelSequence(){return Rst[this.kernelSize]}get scale(){return this.uniforms.scale.value}set scale(n){this.uniforms.scale.value=n}getScale(){return this.uniforms.scale.value}setScale(n){this.uniforms.scale.value=n}getKernel(){return null}get kernel(){return this.uniforms.kernel.value}set kernel(n){this.uniforms.kernel.value=n}setKernel(n){this.kernel=n}setTexelSize(n,t){this.uniforms.texelSize.value.set(n,t,n*.5,t*.5)}setSize(n,t){const e=1/n,s=1/t;this.uniforms.texelSize.value.set(e,s,e*.5,s*.5)}},kst=class extends sl{constructor({kernelSize:n=M3.MEDIUM,resolutionScale:t=.5,width:e=Pa.AUTO_SIZE,height:s=Pa.AUTO_SIZE,resolutionX:i=e,resolutionY:r=s}={}){super("KawaseBlurPass"),this.renderTargetA=new ki(1,1,{depthBuffer:!1}),this.renderTargetA.texture.name="Blur.Target.A",this.renderTargetB=this.renderTargetA.clone(),this.renderTargetB.texture.name="Blur.Target.B";const a=this.resolution=new Pa(this,i,r,t);a.addEventListener("change",o=>this.setSize(a.baseWidth,a.baseHeight)),this._blurMaterial=new Dst,this._blurMaterial.kernelSize=n,this.copyMaterial=new kV}getResolution(){return this.resolution}get blurMaterial(){return this._blurMaterial}set blurMaterial(n){this._blurMaterial=n}get dithering(){return this.copyMaterial.dithering}set dithering(n){this.copyMaterial.dithering=n}get kernelSize(){return this.blurMaterial.kernelSize}set kernelSize(n){this.blurMaterial.kernelSize=n}get width(){return this.resolution.width}set width(n){this.resolution.preferredWidth=n}get height(){return this.resolution.height}set height(n){this.resolution.preferredHeight=n}get scale(){return this.blurMaterial.scale}set scale(n){this.blurMaterial.scale=n}getScale(){return this.blurMaterial.scale}setScale(n){this.blurMaterial.scale=n}getKernelSize(){return this.kernelSize}setKernelSize(n){this.kernelSize=n}getResolutionScale(){return this.resolution.scale}setResolutionScale(n){this.resolution.scale=n}render(n,t,e,s,i){const r=this.scene,a=this.camera,o=this.renderTargetA,l=this.renderTargetB,c=this.blurMaterial,h=c.kernelSequence;let f=t;this.fullscreenMaterial=c;for(let p=0,g=h.length;p<g;++p){const v=(p&1)===0?o:l;c.kernel=h[p],c.inputBuffer=f.texture,n.setRenderTarget(v),n.render(r,a),f=v}this.fullscreenMaterial=this.copyMaterial,this.copyMaterial.inputBuffer=f.texture,n.setRenderTarget(this.renderToScreen?null:e),n.render(r,a)}setSize(n,t){const e=this.resolution;e.setBaseSize(n,t);const s=e.width,i=e.height;this.renderTargetA.setSize(s,i),this.renderTargetB.setSize(s,i),this.blurMaterial.setSize(n,t)}initialize(n,t,e){e!==void 0&&(this.renderTargetA.texture.type=e,this.renderTargetB.texture.type=e,e!==Gi?(this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1"):n!==null&&n.outputColorSpace===Ms&&(this.renderTargetA.texture.colorSpace=Ms,this.renderTargetB.texture.colorSpace=Ms))}static get AUTO_SIZE(){return Pa.AUTO_SIZE}},Ost=`#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);float mask=1.0;
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);mask=low*high;
#elif defined(THRESHOLD)
mask=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=texel*mask;
#else
gl_FragColor=vec4(l*mask);
#endif
}`,$st=class extends ar{constructor(n=!1,t=null){super({name:"LuminanceMaterial",defines:{THREE_REVISION:kg.replace(/\D+/g,"")},uniforms:{inputBuffer:new Qn(null),threshold:new Qn(0),smoothing:new Qn(1),range:new Qn(null)},blending:da,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Ost,vertexShader:DV}),this.colorOutput=n,this.luminanceRange=t}set inputBuffer(n){this.uniforms.inputBuffer.value=n}setInputBuffer(n){this.uniforms.inputBuffer.value=n}get threshold(){return this.uniforms.threshold.value}set threshold(n){this.smoothing>0||n>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.threshold.value=n}getThreshold(){return this.threshold}setThreshold(n){this.threshold=n}get smoothing(){return this.uniforms.smoothing.value}set smoothing(n){this.threshold>0||n>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.smoothing.value=n}getSmoothingFactor(){return this.smoothing}setSmoothingFactor(n){this.smoothing=n}get useThreshold(){return this.threshold>0||this.smoothing>0}set useThreshold(n){}get colorOutput(){return this.defines.COLOR!==void 0}set colorOutput(n){n?this.defines.COLOR="1":delete this.defines.COLOR,this.needsUpdate=!0}isColorOutputEnabled(n){return this.colorOutput}setColorOutputEnabled(n){this.colorOutput=n}get useRange(){return this.luminanceRange!==null}set useRange(n){this.luminanceRange=null}get luminanceRange(){return this.uniforms.range.value}set luminanceRange(n){n!==null?this.defines.RANGE="1":delete this.defines.RANGE,this.uniforms.range.value=n,this.needsUpdate=!0}getLuminanceRange(){return this.luminanceRange}setLuminanceRange(n){this.luminanceRange=n}},Lst=class extends sl{constructor({renderTarget:n,luminanceRange:t,colorOutput:e,resolutionScale:s=1,width:i=Pa.AUTO_SIZE,height:r=Pa.AUTO_SIZE,resolutionX:a=i,resolutionY:o=r}={}){super("LuminancePass"),this.fullscreenMaterial=new $st(e,t),this.needsSwap=!1,this.renderTarget=n,this.renderTarget===void 0&&(this.renderTarget=new ki(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="LuminancePass.Target");const l=this.resolution=new Pa(this,a,o,s);l.addEventListener("change",c=>this.setSize(l.baseWidth,l.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}render(n,t,e,s,i){const r=this.fullscreenMaterial;r.inputBuffer=t.texture,n.setRenderTarget(this.renderToScreen?null:this.renderTarget),n.render(this.scene,this.camera)}setSize(n,t){const e=this.resolution;e.setBaseSize(n,t),this.renderTarget.setSize(e.width,e.height)}initialize(n,t,e){e!==void 0&&e!==Gi&&(this.renderTarget.texture.type=e,this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},Fst=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <colorspace_fragment>
}`,zst="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}",Ust=class extends ar{constructor(){super({name:"DownsamplingMaterial",uniforms:{inputBuffer:new Qn(null),texelSize:new Qn(new Yt)},blending:da,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Fst,vertexShader:zst})}set inputBuffer(n){this.uniforms.inputBuffer.value=n}setSize(n,t){this.uniforms.texelSize.value.set(1/n,1/t)}},Bst=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <colorspace_fragment>
}`,Pst="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}",Vst=class extends ar{constructor(){super({name:"UpsamplingMaterial",uniforms:{inputBuffer:new Qn(null),supportBuffer:new Qn(null),texelSize:new Qn(new Yt),radius:new Qn(.85)},blending:da,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Bst,vertexShader:Pst})}set inputBuffer(n){this.uniforms.inputBuffer.value=n}set supportBuffer(n){this.uniforms.supportBuffer.value=n}get radius(){return this.uniforms.radius.value}set radius(n){this.uniforms.radius.value=n}setSize(n,t){this.uniforms.texelSize.value.set(1/n,1/t)}},Gst=class extends sl{constructor(){super("MipmapBlurPass"),this.needsSwap=!1,this.renderTarget=new ki(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Upsampling.Mipmap0",this.downsamplingMipmaps=[],this.upsamplingMipmaps=[],this.downsamplingMaterial=new Ust,this.upsamplingMaterial=new Vst,this.resolution=new Yt}get texture(){return this.renderTarget.texture}get levels(){return this.downsamplingMipmaps.length}set levels(n){if(this.levels!==n){const t=this.renderTarget;this.dispose(),this.downsamplingMipmaps=[],this.upsamplingMipmaps=[];for(let e=0;e<n;++e){const s=t.clone();s.texture.name="Downsampling.Mipmap"+e,this.downsamplingMipmaps.push(s)}this.upsamplingMipmaps.push(t);for(let e=1,s=n-1;e<s;++e){const i=t.clone();i.texture.name="Upsampling.Mipmap"+e,this.upsamplingMipmaps.push(i)}this.setSize(this.resolution.x,this.resolution.y)}}get radius(){return this.upsamplingMaterial.radius}set radius(n){this.upsamplingMaterial.radius=n}render(n,t,e,s,i){const{scene:r,camera:a}=this,{downsamplingMaterial:o,upsamplingMaterial:l}=this,{downsamplingMipmaps:c,upsamplingMipmaps:h}=this;let f=t;this.fullscreenMaterial=o;for(let p=0,g=c.length;p<g;++p){const v=c[p];o.setSize(f.width,f.height),o.inputBuffer=f.texture,n.setRenderTarget(v),n.render(r,a),f=v}this.fullscreenMaterial=l;for(let p=h.length-1;p>=0;--p){const g=h[p];l.setSize(f.width,f.height),l.inputBuffer=f.texture,l.supportBuffer=c[p].texture,n.setRenderTarget(g),n.render(r,a),f=g}}setSize(n,t){const e=this.resolution;e.set(n,t);let s=e.width,i=e.height;for(let r=0,a=this.downsamplingMipmaps.length;r<a;++r)s=Math.round(s*.5),i=Math.round(i*.5),this.downsamplingMipmaps[r].setSize(s,i),r<this.upsamplingMipmaps.length&&this.upsamplingMipmaps[r].setSize(s,i)}initialize(n,t,e){if(e!==void 0){const s=this.downsamplingMipmaps.concat(this.upsamplingMipmaps);for(const i of s)i.texture.type=e;if(e!==Gi)this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1";else if(n!==null&&n.outputColorSpace===Ms)for(const i of s)i.texture.colorSpace=Ms}}dispose(){super.dispose();for(const n of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))n.dispose()}},Hst=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,max(inputColor.a,texel.a));}`,Wst=class extends v2{constructor({blendFunction:n=ls.SCREEN,luminanceThreshold:t=1,luminanceSmoothing:e=.03,mipmapBlur:s=!0,intensity:i=1,radius:r=.85,levels:a=8,kernelSize:o=M3.LARGE,resolutionScale:l=.5,width:c=Pa.AUTO_SIZE,height:h=Pa.AUTO_SIZE,resolutionX:f=c,resolutionY:p=h}={}){super("BloomEffect",Hst,{blendFunction:n,uniforms:new Map([["map",new Qn(null)],["intensity",new Qn(i)]])}),this.renderTarget=new ki(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Bloom.Target",this.blurPass=new kst({kernelSize:o}),this.luminancePass=new Lst({colorOutput:!0}),this.luminanceMaterial.threshold=t,this.luminanceMaterial.smoothing=e,this.mipmapBlurPass=new Gst,this.mipmapBlurPass.enabled=s,this.mipmapBlurPass.radius=r,this.mipmapBlurPass.levels=a,this.uniforms.get("map").value=s?this.mipmapBlurPass.texture:this.renderTarget.texture;const g=this.resolution=new Pa(this,f,p,l);g.addEventListener("change",v=>this.setSize(g.baseWidth,g.baseHeight))}get texture(){return this.mipmapBlurPass.enabled?this.mipmapBlurPass.texture:this.renderTarget.texture}getTexture(){return this.texture}getResolution(){return this.resolution}getBlurPass(){return this.blurPass}getLuminancePass(){return this.luminancePass}get luminanceMaterial(){return this.luminancePass.fullscreenMaterial}getLuminanceMaterial(){return this.luminancePass.fullscreenMaterial}get width(){return this.resolution.width}set width(n){this.resolution.preferredWidth=n}get height(){return this.resolution.height}set height(n){this.resolution.preferredHeight=n}get dithering(){return this.blurPass.dithering}set dithering(n){this.blurPass.dithering=n}get kernelSize(){return this.blurPass.kernelSize}set kernelSize(n){this.blurPass.kernelSize=n}get distinction(){return console.warn(this.name,"distinction was removed"),1}set distinction(n){console.warn(this.name,"distinction was removed")}get intensity(){return this.uniforms.get("intensity").value}set intensity(n){this.uniforms.get("intensity").value=n}getIntensity(){return this.intensity}setIntensity(n){this.intensity=n}getResolutionScale(){return this.resolution.scale}setResolutionScale(n){this.resolution.scale=n}update(n,t,e){const s=this.renderTarget,i=this.luminancePass;i.enabled?(i.render(n,t),this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(n,i.renderTarget):this.blurPass.render(n,i.renderTarget,s)):this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(n,t):this.blurPass.render(n,t,s)}setSize(n,t){const e=this.resolution;e.setBaseSize(n,t),this.renderTarget.setSize(e.width,e.height),this.blurPass.resolution.copy(e),this.luminancePass.setSize(n,t),this.mipmapBlurPass.setSize(n,t)}initialize(n,t,e){this.blurPass.initialize(n,t,e),this.luminancePass.initialize(n,t,e),this.mipmapBlurPass.initialize(n,t,e),e!==void 0&&(this.renderTarget.texture.type=e,n!==null&&n.outputColorSpace===Ms&&(this.renderTarget.texture.colorSpace=Ms))}},$V=class extends sl{constructor(n,t,e=null){super("RenderPass",n,t),this.needsSwap=!1,this.clearPass=new OV,this.overrideMaterialManager=e===null?null:new Uz(e),this.ignoreBackground=!1,this.skipShadowMapUpdate=!1,this.selection=null}set mainScene(n){this.scene=n}set mainCamera(n){this.camera=n}get renderToScreen(){return super.renderToScreen}set renderToScreen(n){super.renderToScreen=n,this.clearPass.renderToScreen=n}get overrideMaterial(){const n=this.overrideMaterialManager;return n!==null?n.material:null}set overrideMaterial(n){const t=this.overrideMaterialManager;n!==null?t!==null?t.setMaterial(n):this.overrideMaterialManager=new Uz(n):t!==null&&(t.dispose(),this.overrideMaterialManager=null)}getOverrideMaterial(){return this.overrideMaterial}setOverrideMaterial(n){this.overrideMaterial=n}get clear(){return this.clearPass.enabled}set clear(n){this.clearPass.enabled=n}getSelection(){return this.selection}setSelection(n){this.selection=n}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(n){this.ignoreBackground=n}isShadowMapDisabled(){return this.skipShadowMapUpdate}setShadowMapDisabled(n){this.skipShadowMapUpdate=n}getClearPass(){return this.clearPass}render(n,t,e,s,i){const r=this.scene,a=this.camera,o=this.selection,l=a.layers.mask,c=r.background,h=n.shadowMap.autoUpdate,f=this.renderToScreen?null:t;o!==null&&a.layers.set(o.getLayer()),this.skipShadowMapUpdate&&(n.shadowMap.autoUpdate=!1),(this.ignoreBackground||this.clearPass.overrideClearColor!==null)&&(r.background=null),this.clearPass.enabled&&this.clearPass.render(n,t),n.setRenderTarget(f),this.overrideMaterialManager!==null?this.overrideMaterialManager.render(n,r,a):n.render(r,a),a.layers.mask=l,r.background=c,n.shadowMap.autoUpdate=h}},Db={DEFAULT:0,ESKIL:1},qst=`#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
gl_FragColor=vec4(n[index],d[index]);}`,Xst="uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",jst=class extends ar{constructor(){super({name:"DepthDownsamplingMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new Qn(null),normalBuffer:new Qn(null),texelSize:new Qn(new Yt)},blending:da,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:qst,vertexShader:Xst})}set depthBuffer(n){this.uniforms.depthBuffer.value=n}set depthPacking(n){this.defines.DEPTH_PACKING=n.toFixed(0),this.needsUpdate=!0}setDepthBuffer(n,t=op){this.depthBuffer=n,this.depthPacking=t}set normalBuffer(n){this.uniforms.normalBuffer.value=n,n!==null?this.defines.DOWNSAMPLE_NORMALS="1":delete this.defines.DOWNSAMPLE_NORMALS,this.needsUpdate=!0}setNormalBuffer(n){this.normalBuffer=n}setTexelSize(n,t){this.uniforms.texelSize.value.set(n,t)}setSize(n,t){this.uniforms.texelSize.value.set(1/n,1/t)}},Kst=class extends sl{constructor({normalBuffer:n=null,resolutionScale:t=.5,width:e=Pa.AUTO_SIZE,height:s=Pa.AUTO_SIZE,resolutionX:i=e,resolutionY:r=s}={}){super("DepthDownsamplingPass");const a=new jst;a.normalBuffer=n,this.fullscreenMaterial=a,this.needsDepthTexture=!0,this.needsSwap=!1,this.renderTarget=new ki(1,1,{minFilter:hi,magFilter:hi,depthBuffer:!1,type:Ua}),this.renderTarget.texture.name="DepthDownsamplingPass.Target",this.renderTarget.texture.generateMipmaps=!1;const o=this.resolution=new Pa(this,i,r,t);o.addEventListener("change",l=>this.setSize(o.baseWidth,o.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}setDepthTexture(n,t=op){this.fullscreenMaterial.depthBuffer=n,this.fullscreenMaterial.depthPacking=t}render(n,t,e,s,i){n.setRenderTarget(this.renderToScreen?null:this.renderTarget),n.render(this.scene,this.camera)}setSize(n,t){const e=this.resolution;e.setBaseSize(n,t),this.renderTarget.setSize(e.width,e.height),this.fullscreenMaterial.setSize(n,t)}initialize(n,t,e){const s=n.getContext();if(!(s.getExtension("EXT_color_buffer_float")||s.getExtension("EXT_color_buffer_half_float")))throw new Error("Rendering to float texture is not supported.")}},Yst=`uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`,Zst=class extends v2{constructor({blendFunction:n,eskil:t=!1,technique:e=t?Db.ESKIL:Db.DEFAULT,offset:s=.5,darkness:i=.5}={}){super("VignetteEffect",Yst,{blendFunction:n,defines:new Map([["VIGNETTE_TECHNIQUE",e.toFixed(0)]]),uniforms:new Map([["offset",new Qn(s)],["darkness",new Qn(i)]])})}get technique(){return Number(this.defines.get("VIGNETTE_TECHNIQUE"))}set technique(n){this.technique!==n&&(this.defines.set("VIGNETTE_TECHNIQUE",n.toFixed(0)),this.setChanged())}get eskil(){return this.technique===Db.ESKIL}set eskil(n){this.technique=n?Db.ESKIL:Db.DEFAULT}getTechnique(){return this.technique}setTechnique(n){this.technique=n}get offset(){return this.uniforms.get("offset").value}set offset(n){this.uniforms.get("offset").value=n}getOffset(){return this.offset}setOffset(n){this.offset=n}get darkness(){return this.uniforms.get("darkness").value}set darkness(n){this.uniforms.get("darkness").value=n}getDarkness(){return this.darkness}setDarkness(n){this.darkness=n}},Qst=`#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
float depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
float depth=texture2D(depthBuffer,uv).r;
#endif
#if defined(USE_LOGARITHMIC_DEPTH_BUFFER) || defined(LOG_DEPTH)
float d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;
#elif defined(USE_REVERSED_DEPTH_BUFFER)
depth=1.0-depth;
#endif
return depth;}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,Jst="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",tit=class extends ar{constructor(n,t,e,s,i=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:kg.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new Qn(null),depthBuffer:new Qn(null),resolution:new Qn(new Yt),texelSize:new Qn(new Yt),cameraNear:new Qn(.3),cameraFar:new Qn(1e3),aspect:new Qn(1),time:new Qn(0)},blending:da,toneMapped:!1,depthWrite:!1,depthTest:!1,dithering:i}),n&&this.setShaderParts(n),t&&this.setDefines(t),e&&this.setUniforms(e),this.copyCameraSettings(s)}set inputBuffer(n){this.uniforms.inputBuffer.value=n}setInputBuffer(n){this.uniforms.inputBuffer.value=n}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(n){this.uniforms.depthBuffer.value=n}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(n){this.defines.DEPTH_PACKING=n.toFixed(0),this.needsUpdate=!0}setDepthBuffer(n,t=op){this.depthBuffer=n,this.depthPacking=t}setShaderData(n){this.setShaderParts(n.shaderParts),this.setDefines(n.defines),this.setUniforms(n.uniforms),this.setExtensions(n.extensions)}setShaderParts(n){return this.fragmentShader=Qst.replace(As.FRAGMENT_HEAD,n.get(As.FRAGMENT_HEAD)||"").replace(As.FRAGMENT_MAIN_UV,n.get(As.FRAGMENT_MAIN_UV)||"").replace(As.FRAGMENT_MAIN_IMAGE,n.get(As.FRAGMENT_MAIN_IMAGE)||""),this.vertexShader=Jst.replace(As.VERTEX_HEAD,n.get(As.VERTEX_HEAD)||"").replace(As.VERTEX_MAIN_SUPPORT,n.get(As.VERTEX_MAIN_SUPPORT)||""),this.needsUpdate=!0,this}setDefines(n){for(const t of n.entries())this.defines[t[0]]=t[1];return this.needsUpdate=!0,this}setUniforms(n){for(const t of n.entries())this.uniforms[t[0]]=t[1];return this}setExtensions(n){this.extensions={};for(const t of n)this.extensions[t]=!0;return this}get encodeOutput(){return this.defines.ENCODE_OUTPUT!==void 0}set encodeOutput(n){this.encodeOutput!==n&&(n?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(n){return this.encodeOutput}setOutputEncodingEnabled(n){this.encodeOutput=n}get time(){return this.uniforms.time.value}set time(n){this.uniforms.time.value=n}setDeltaTime(n){this.uniforms.time.value+=n}adoptCameraSettings(n){this.copyCameraSettings(n)}copyCameraSettings(n){n&&(this.uniforms.cameraNear.value=n.near,this.uniforms.cameraFar.value=n.far,n instanceof Vi?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(n,t){const e=this.uniforms;e.resolution.value.set(n,t),e.texelSize.value.set(1/n,1/t),e.aspect.value=n/t}static get Section(){return As}};function Bz(n,t,e){for(const s of t){const i="$1"+n+s.charAt(0).toUpperCase()+s.slice(1),r=new RegExp("([^\\.])(\\b"+s+"\\b)","g");for(const a of e.entries())a[1]!==null&&e.set(a[0],a[1].replace(r,i))}}function eit(n,t,e){let s=t.getFragmentShader(),i=t.getVertexShader();const r=s!==void 0&&/mainImage/.test(s),a=s!==void 0&&/mainUv/.test(s);if(e.attributes|=t.getAttributes(),s===void 0)throw new Error(`Missing fragment shader (${t.name})`);if(a&&(e.attributes&Jm.CONVOLUTION)!==0)throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);if(!r&&!a)throw new Error(`Could not find mainImage or mainUv function (${t.name})`);{const o=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,l=e.shaderParts;let c=l.get(As.FRAGMENT_HEAD)||"",h=l.get(As.FRAGMENT_MAIN_UV)||"",f=l.get(As.FRAGMENT_MAIN_IMAGE)||"",p=l.get(As.VERTEX_HEAD)||"",g=l.get(As.VERTEX_MAIN_SUPPORT)||"";const v=new Set,_=new Set;if(a&&(h+=`	${n}MainUv(UV);
`,e.uvTransformation=!0),i!==null&&/mainSupport/.test(i)){const T=/mainSupport *\([\w\s]*?uv\s*?\)/.test(i);g+=`	${n}MainSupport(`,g+=T?`vUv);
`:`);
`;for(const C of i.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))for(const A of C[1].split(/\s*,\s*/))e.varyings.add(A),v.add(A),_.add(A);for(const C of i.matchAll(o))_.add(C[1])}for(const T of s.matchAll(o))_.add(T[1]);for(const T of t.defines.keys())_.add(T.replace(/\([\w\s,]*\)/g,""));for(const T of t.uniforms.keys())_.add(T);_.delete("while"),_.delete("for"),_.delete("if"),t.uniforms.forEach((T,C)=>e.uniforms.set(n+C.charAt(0).toUpperCase()+C.slice(1),T)),t.defines.forEach((T,C)=>e.defines.set(n+C.charAt(0).toUpperCase()+C.slice(1),T));const S=new Map([["fragment",s],["vertex",i]]);Bz(n,_,e.defines),Bz(n,_,S),s=S.get("fragment"),i=S.get("vertex");const b=t.blendMode;if(e.blendModes.set(b.blendFunction,b),r){t.inputColorSpace!==null&&t.inputColorSpace!==e.colorSpace&&(f+=t.inputColorSpace===Ms?`color0 = sRGBTransferOETF(color0);
	`:`color0 = sRGBToLinear(color0);
	`),t.outputColorSpace!==Yc?e.colorSpace=t.outputColorSpace:t.inputColorSpace!==null&&(e.colorSpace=t.inputColorSpace);const T=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;f+=`${n}MainImage(color0, UV, `,(e.attributes&Jm.DEPTH)!==0&&T.test(s)&&(f+="depth, ",e.readDepth=!0),f+=`color1);
	`;const C=n+"BlendOpacity";e.uniforms.set(C,b.opacity),f+=`color0 = blend${b.blendFunction}(color0, color1, ${C});

	`,c+=`uniform float ${C};

`}if(c+=s+`
`,i!==null&&(p+=i+`
`),l.set(As.FRAGMENT_HEAD,c),l.set(As.FRAGMENT_MAIN_UV,h),l.set(As.FRAGMENT_MAIN_IMAGE,f),l.set(As.VERTEX_HEAD,p),l.set(As.VERTEX_MAIN_SUPPORT,g),t.extensions!==null)for(const T of t.extensions)e.extensions.add(T)}}var nit=class extends sl{constructor(n,...t){super("EffectPass"),this.fullscreenMaterial=new tit(null,null,null,n),this.listener=e=>this.handleEvent(e),this.effects=[],this.setEffects(t),this.skipRendering=!1,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY,this.timeScale=1}set mainScene(n){for(const t of this.effects)t.mainScene=n}set mainCamera(n){this.fullscreenMaterial.copyCameraSettings(n);for(const t of this.effects)t.mainCamera=n}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(n){this.fullscreenMaterial.encodeOutput=n}get dithering(){return this.fullscreenMaterial.dithering}set dithering(n){const t=this.fullscreenMaterial;t.dithering=n,t.needsUpdate=!0}setEffects(n){for(const t of this.effects)t.removeEventListener("change",this.listener);this.effects=n.sort((t,e)=>e.attributes-t.attributes);for(const t of this.effects)t.addEventListener("change",this.listener)}updateMaterial(){const n=new Knt;let t=0;for(const a of this.effects)if(a.blendMode.blendFunction===ls.DST)n.attributes|=a.getAttributes()&Jm.DEPTH;else{if((n.attributes&a.getAttributes()&Jm.CONVOLUTION)!==0)throw new Error(`Convolution effects cannot be merged (${a.name})`);eit("e"+t++,a,n)}let e=n.shaderParts.get(As.FRAGMENT_HEAD),s=n.shaderParts.get(As.FRAGMENT_MAIN_IMAGE),i=n.shaderParts.get(As.FRAGMENT_MAIN_UV);const r=/\bblend\b/g;for(const a of n.blendModes.values())e+=a.getShaderCode().replace(r,`blend${a.blendFunction}`)+`
`;(n.attributes&Jm.DEPTH)!==0?(n.readDepth&&(s=`float depth = readDepth(UV);

	`+s),this.needsDepthTexture=this.getDepthTexture()===null):this.needsDepthTexture=!1,n.colorSpace===Ms&&(s+=`color0 = sRGBToLinear(color0);
	`),n.uvTransformation?(i=`vec2 transformedUv = vUv;
`+i,n.defines.set("UV","transformedUv")):n.defines.set("UV","vUv"),n.shaderParts.set(As.FRAGMENT_HEAD,e),n.shaderParts.set(As.FRAGMENT_MAIN_IMAGE,s),n.shaderParts.set(As.FRAGMENT_MAIN_UV,i);for(const[a,o]of n.shaderParts)o!==null&&n.shaderParts.set(a,o.trim().replace(/^#/,`
#`));this.skipRendering=t===0,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderData(n)}recompile(){this.updateMaterial()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(n,t=op){this.fullscreenMaterial.depthBuffer=n,this.fullscreenMaterial.depthPacking=t;for(const e of this.effects)e.setDepthTexture(n,t)}render(n,t,e,s,i){for(const r of this.effects)r.update(n,t,s);if(!this.skipRendering||this.renderToScreen){const r=this.fullscreenMaterial;r.inputBuffer=t.texture,r.time+=s*this.timeScale,n.setRenderTarget(this.renderToScreen?null:e),n.render(this.scene,this.camera)}}setSize(n,t){this.fullscreenMaterial.setSize(n,t);for(const e of this.effects)e.setSize(n,t)}initialize(n,t,e){this.renderer=n;for(const s of this.effects)s.initialize(n,t,e);this.updateMaterial(),e!==void 0&&e!==Gi&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(const n of this.effects)n.removeEventListener("change",this.listener),n.dispose()}handleEvent(n){switch(n.type){case"change":this.recompile();break}}},sit=class extends sl{constructor(n,t,{renderTarget:e,resolutionScale:s=1,width:i=Pa.AUTO_SIZE,height:r=Pa.AUTO_SIZE,resolutionX:a=i,resolutionY:o=r}={}){super("NormalPass"),this.needsSwap=!1,this.renderPass=new $V(n,t,new f3);const l=this.renderPass;l.ignoreBackground=!0,l.skipShadowMapUpdate=!0;const c=l.getClearPass();c.overrideClearColor=new ke(7829503),c.overrideClearAlpha=1,this.renderTarget=e,this.renderTarget===void 0&&(this.renderTarget=new ki(1,1,{minFilter:hi,magFilter:hi}),this.renderTarget.texture.name="NormalPass.Target");const h=this.resolution=new Pa(this,a,o,s);h.addEventListener("change",f=>this.setSize(h.baseWidth,h.baseHeight))}set mainScene(n){this.renderPass.mainScene=n}set mainCamera(n){this.renderPass.mainCamera=n}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(n){this.resolution.scale=n}render(n,t,e,s,i){const r=this.renderToScreen?null:this.renderTarget;this.renderPass.render(n,r,r)}setSize(n,t){const e=this.resolution;e.setBaseSize(n,t),this.renderTarget.setSize(e.width,e.height)}};function o1(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}new Yt;new Yt;function LV(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}var nc=function n(t,e,s){var i=this;LV(this,n),o1(this,"dot2",function(r,a){return i.x*r+i.y*a}),o1(this,"dot3",function(r,a,o){return i.x*r+i.y*a+i.z*o}),this.x=t,this.y=e,this.z=s},iit=[new nc(1,1,0),new nc(-1,1,0),new nc(1,-1,0),new nc(-1,-1,0),new nc(1,0,1),new nc(-1,0,1),new nc(1,0,-1),new nc(-1,0,-1),new nc(0,1,1),new nc(0,-1,1),new nc(0,1,-1),new nc(0,-1,-1)],Pz=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],Vz=new Array(512),Gz=new Array(512),rit=function(t){t>0&&t<1&&(t*=65536),t=Math.floor(t),t<256&&(t|=t<<8);for(var e=0;e<256;e++){var s;e&1?s=Pz[e]^t&255:s=Pz[e]^t>>8&255,Vz[e]=Vz[e+256]=s,Gz[e]=Gz[e+256]=iit[s%12]}};rit(0);function ait(n){if(typeof n=="number")n=Math.abs(n);else if(typeof n=="string"){var t=n;n=0;for(var e=0;e<t.length;e++)n=(n+(e+1)*(t.charCodeAt(e)%96))%2147483647}return n===0&&(n=311),n}function Hz(n){var t=ait(n);return function(){var e=t*48271%2147483647;return t=e,e/2147483647}}var oit=function n(t){var e=this;LV(this,n),o1(this,"seed",0),o1(this,"init",function(s){e.seed=s,e.value=Hz(s)}),o1(this,"value",Hz(this.seed)),this.init(t)};new oit(Math.random());const lit=be.createContext(null),Wz=n=>(n.getAttributes()&2)===2,cit=be.memo(be.forwardRef(({children:n,camera:t,scene:e,resolutionScale:s,enabled:i=!0,renderPriority:r=1,autoClear:a=!0,depthBuffer:o,enableNormalPass:l,stencilBuffer:c,multisampling:h=8,frameBufferType:f=ru},p)=>{const{gl:g,scene:v,camera:_,size:S}=Ku(),b=e||v,T=t||_,[C,A,I]=be.useMemo(()=>{const z=new jnt(g,{depthBuffer:o,stencilBuffer:c,multisampling:h,frameBufferType:f});z.addPass(new $V(b,T));let k=null,O=null;return l&&(O=new sit(b,T),O.enabled=!1,z.addPass(O),s!==void 0&&(k=new Kst({normalBuffer:O.texture,resolutionScale:s}),k.enabled=!1,z.addPass(k))),[z,O,k]},[T,g,o,c,h,f,b,l,s]);be.useEffect(()=>C==null?void 0:C.setSize(S.width,S.height),[C,S]),fp((z,k)=>{if(i){const O=g.autoClear;g.autoClear=a,c&&!a&&g.clearStencil(),C.render(k),g.autoClear=O}},i?r:0);const D=be.useRef(null);be.useLayoutEffect(()=>{var O;const z=[],k=D.current.__r3f;if(k&&C){const L=k.children;for(let H=0;H<L.length;H++){const q=L[H].object;if(q instanceof v2){const K=[q];if(!Wz(q)){let P=null;for(;(P=(O=L[H+1])==null?void 0:O.object)instanceof v2&&!Wz(P);)K.push(P),H++}const Y=new nit(T,...K);z.push(Y)}else q instanceof sl&&z.push(q)}for(const H of z)C==null||C.addPass(H);A&&(A.enabled=!0),I&&(I.enabled=!0)}return()=>{for(const L of z)C==null||C.removePass(L);A&&(A.enabled=!1),I&&(I.enabled=!1)}},[C,n,T,A,I]),be.useEffect(()=>{const z=g.toneMapping;return g.toneMapping=Tl,()=>{g.toneMapping=z}},[g]);const F=be.useMemo(()=>({composer:C,normalPass:A,downSamplingPass:I,resolutionScale:s,camera:T,scene:b}),[C,A,I,s,T,b]);return be.useImperativeHandle(p,()=>C,[C]),ge.jsx(lit.Provider,{value:F,children:ge.jsx("group",{ref:D,children:n})})}));let uit=0;const qz=new WeakMap,FV=(n,t)=>function({blendFunction:e=t==null?void 0:t.blendFunction,opacity:s=t==null?void 0:t.opacity,...i}){let r=qz.get(n);if(!r){const l=`@react-three/postprocessing/${n.name}-${uit++}`;EV({[l]:n}),qz.set(n,r=l)}const a=Ku(l=>l.camera),o=OD.useMemo(()=>[...(t==null?void 0:t.args)??[],...i.args??[{...t,...i}]],[JSON.stringify(i)]);return ge.jsx(r,{camera:a,"blendMode-blendFunction":e,"blendMode-opacity-value":s,...i,args:o})},hit=FV(Wst,{blendFunction:0}),fit=FV(Zst);function vR(){return vR=Object.assign?Object.assign.bind():function(n){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var s in e)({}).hasOwnProperty.call(e,s)&&(n[s]=e[s])}return n},vR.apply(null,arguments)}var dit=Object.defineProperty,pit=(n,t,e)=>t in n?dit(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,mit=(n,t,e)=>(pit(n,t+"",e),e);class git{constructor(){mit(this,"_listeners")}addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[t]===void 0&&(s[t]=[]),s[t].indexOf(e)===-1&&s[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const s=this._listeners;return s[t]!==void 0&&s[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const i=this._listeners[t];if(i!==void 0){const r=i.indexOf(e);r!==-1&&i.splice(r,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const s=this._listeners[t.type];if(s!==void 0){t.target=this;const i=s.slice(0);for(let r=0,a=i.length;r<a;r++)i[r].call(this,t);t.target=null}}}var yit=Object.defineProperty,xit=(n,t,e)=>t in n?yit(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,mn=(n,t,e)=>(xit(n,typeof t!="symbol"?t+"":t,e),e);const PT=new Og,Xz=new hf,vit=Math.cos(70*(Math.PI/180)),jz=(n,t)=>(n%t+t)%t;let bit=class extends git{constructor(t,e){super(),mn(this,"object"),mn(this,"domElement"),mn(this,"enabled",!0),mn(this,"target",new at),mn(this,"minDistance",0),mn(this,"maxDistance",1/0),mn(this,"minZoom",0),mn(this,"maxZoom",1/0),mn(this,"minPolarAngle",0),mn(this,"maxPolarAngle",Math.PI),mn(this,"minAzimuthAngle",-1/0),mn(this,"maxAzimuthAngle",1/0),mn(this,"enableDamping",!1),mn(this,"dampingFactor",.05),mn(this,"enableZoom",!0),mn(this,"zoomSpeed",1),mn(this,"enableRotate",!0),mn(this,"rotateSpeed",1),mn(this,"enablePan",!0),mn(this,"panSpeed",1),mn(this,"screenSpacePanning",!0),mn(this,"keyPanSpeed",7),mn(this,"zoomToCursor",!1),mn(this,"autoRotate",!1),mn(this,"autoRotateSpeed",2),mn(this,"reverseOrbit",!1),mn(this,"reverseHorizontalOrbit",!1),mn(this,"reverseVerticalOrbit",!1),mn(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),mn(this,"mouseButtons",{LEFT:Dm.ROTATE,MIDDLE:Dm.DOLLY,RIGHT:Dm.PAN}),mn(this,"touches",{ONE:km.ROTATE,TWO:km.DOLLY_PAN}),mn(this,"target0"),mn(this,"position0"),mn(this,"zoom0"),mn(this,"_domElementKeyEvents",null),mn(this,"getPolarAngle"),mn(this,"getAzimuthalAngle"),mn(this,"setPolarAngle"),mn(this,"setAzimuthalAngle"),mn(this,"getDistance"),mn(this,"getZoomScale"),mn(this,"listenToKeyEvents"),mn(this,"stopListenToKeyEvents"),mn(this,"saveState"),mn(this,"reset"),mn(this,"update"),mn(this,"connect"),mn(this,"dispose"),mn(this,"dollyIn"),mn(this,"dollyOut"),mn(this,"getScale"),mn(this,"setScale"),this.object=t,this.domElement=e,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>h.phi,this.getAzimuthalAngle=()=>h.theta,this.setPolarAngle=ut=>{let kt=jz(ut,2*Math.PI),Se=h.phi;Se<0&&(Se+=2*Math.PI),kt<0&&(kt+=2*Math.PI);let dt=Math.abs(kt-Se);2*Math.PI-dt<dt&&(kt<Se?kt+=2*Math.PI:Se+=2*Math.PI),f.phi=kt-Se,s.update()},this.setAzimuthalAngle=ut=>{let kt=jz(ut,2*Math.PI),Se=h.theta;Se<0&&(Se+=2*Math.PI),kt<0&&(kt+=2*Math.PI);let dt=Math.abs(kt-Se);2*Math.PI-dt<dt&&(kt<Se?kt+=2*Math.PI:Se+=2*Math.PI),f.theta=kt-Se,s.update()},this.getDistance=()=>s.object.position.distanceTo(s.target),this.listenToKeyEvents=ut=>{ut.addEventListener("keydown",Pt),this._domElementKeyEvents=ut},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",Pt),this._domElementKeyEvents=null},this.saveState=()=>{s.target0.copy(s.target),s.position0.copy(s.object.position),s.zoom0=s.object.zoom},this.reset=()=>{s.target.copy(s.target0),s.object.position.copy(s.position0),s.object.zoom=s.zoom0,s.object.updateProjectionMatrix(),s.dispatchEvent(i),s.update(),l=o.NONE},this.update=(()=>{const ut=new at,kt=new at(0,1,0),Se=new Va().setFromUnitVectors(t.up,kt),dt=Se.clone().invert(),ye=new at,fe=new Va,Ce=2*Math.PI;return function(){const ie=s.object.position;Se.setFromUnitVectors(t.up,kt),dt.copy(Se).invert(),ut.copy(ie).sub(s.target),ut.applyQuaternion(Se),h.setFromVector3(ut),s.autoRotate&&l===o.NONE&&K(H()),s.enableDamping?(h.theta+=f.theta*s.dampingFactor,h.phi+=f.phi*s.dampingFactor):(h.theta+=f.theta,h.phi+=f.phi);let ve=s.minAzimuthAngle,Je=s.maxAzimuthAngle;isFinite(ve)&&isFinite(Je)&&(ve<-Math.PI?ve+=Ce:ve>Math.PI&&(ve-=Ce),Je<-Math.PI?Je+=Ce:Je>Math.PI&&(Je-=Ce),ve<=Je?h.theta=Math.max(ve,Math.min(Je,h.theta)):h.theta=h.theta>(ve+Je)/2?Math.max(ve,h.theta):Math.min(Je,h.theta)),h.phi=Math.max(s.minPolarAngle,Math.min(s.maxPolarAngle,h.phi)),h.makeSafe(),s.enableDamping===!0?s.target.addScaledVector(g,s.dampingFactor):s.target.add(g),s.zoomToCursor&&k||s.object.isOrthographicCamera?h.radius=ct(h.radius):h.radius=ct(h.radius*p),ut.setFromSpherical(h),ut.applyQuaternion(dt),ie.copy(s.target).add(ut),s.object.matrixAutoUpdate||s.object.updateMatrix(),s.object.lookAt(s.target),s.enableDamping===!0?(f.theta*=1-s.dampingFactor,f.phi*=1-s.dampingFactor,g.multiplyScalar(1-s.dampingFactor)):(f.set(0,0,0),g.set(0,0,0));let zn=!1;if(s.zoomToCursor&&k){let Mn=null;if(s.object instanceof Vi&&s.object.isPerspectiveCamera){const li=ut.length();Mn=ct(li*p);const wr=li-Mn;s.object.position.addScaledVector(F,wr),s.object.updateMatrixWorld()}else if(s.object.isOrthographicCamera){const li=new at(z.x,z.y,0);li.unproject(s.object),s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/p)),s.object.updateProjectionMatrix(),zn=!0;const wr=new at(z.x,z.y,0);wr.unproject(s.object),s.object.position.sub(wr).add(li),s.object.updateMatrixWorld(),Mn=ut.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),s.zoomToCursor=!1;Mn!==null&&(s.screenSpacePanning?s.target.set(0,0,-1).transformDirection(s.object.matrix).multiplyScalar(Mn).add(s.object.position):(PT.origin.copy(s.object.position),PT.direction.set(0,0,-1).transformDirection(s.object.matrix),Math.abs(s.object.up.dot(PT.direction))<vit?t.lookAt(s.target):(Xz.setFromNormalAndCoplanarPoint(s.object.up,s.target),PT.intersectPlane(Xz,s.target))))}else s.object instanceof rh&&s.object.isOrthographicCamera&&(zn=p!==1,zn&&(s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/p)),s.object.updateProjectionMatrix()));return p=1,k=!1,zn||ye.distanceToSquared(s.object.position)>c||8*(1-fe.dot(s.object.quaternion))>c?(s.dispatchEvent(i),ye.copy(s.object.position),fe.copy(s.object.quaternion),zn=!1,!0):!1}})(),this.connect=ut=>{s.domElement=ut,s.domElement.style.touchAction="none",s.domElement.addEventListener("contextmenu",ze),s.domElement.addEventListener("pointerdown",pe),s.domElement.addEventListener("pointercancel",G),s.domElement.addEventListener("wheel",te)},this.dispose=()=>{var ut,kt,Se,dt,ye,fe;s.domElement&&(s.domElement.style.touchAction="auto"),(ut=s.domElement)==null||ut.removeEventListener("contextmenu",ze),(kt=s.domElement)==null||kt.removeEventListener("pointerdown",pe),(Se=s.domElement)==null||Se.removeEventListener("pointercancel",G),(dt=s.domElement)==null||dt.removeEventListener("wheel",te),(ye=s.domElement)==null||ye.ownerDocument.removeEventListener("pointermove",nt),(fe=s.domElement)==null||fe.ownerDocument.removeEventListener("pointerup",G),s._domElementKeyEvents!==null&&s._domElementKeyEvents.removeEventListener("keydown",Pt)};const s=this,i={type:"change"},r={type:"start"},a={type:"end"},o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let l=o.NONE;const c=1e-6,h=new p2,f=new p2;let p=1;const g=new at,v=new Yt,_=new Yt,S=new Yt,b=new Yt,T=new Yt,C=new Yt,A=new Yt,I=new Yt,D=new Yt,F=new at,z=new Yt;let k=!1;const O=[],L={};function H(){return 2*Math.PI/60/60*s.autoRotateSpeed}function q(){return Math.pow(.95,s.zoomSpeed)}function K(ut){s.reverseOrbit||s.reverseHorizontalOrbit?f.theta+=ut:f.theta-=ut}function Y(ut){s.reverseOrbit||s.reverseVerticalOrbit?f.phi+=ut:f.phi-=ut}const P=(()=>{const ut=new at;return function(Se,dt){ut.setFromMatrixColumn(dt,0),ut.multiplyScalar(-Se),g.add(ut)}})(),W=(()=>{const ut=new at;return function(Se,dt){s.screenSpacePanning===!0?ut.setFromMatrixColumn(dt,1):(ut.setFromMatrixColumn(dt,0),ut.crossVectors(s.object.up,ut)),ut.multiplyScalar(Se),g.add(ut)}})(),j=(()=>{const ut=new at;return function(Se,dt){const ye=s.domElement;if(ye&&s.object instanceof Vi&&s.object.isPerspectiveCamera){const fe=s.object.position;ut.copy(fe).sub(s.target);let Ce=ut.length();Ce*=Math.tan(s.object.fov/2*Math.PI/180),P(2*Se*Ce/ye.clientHeight,s.object.matrix),W(2*dt*Ce/ye.clientHeight,s.object.matrix)}else ye&&s.object instanceof rh&&s.object.isOrthographicCamera?(P(Se*(s.object.right-s.object.left)/s.object.zoom/ye.clientWidth,s.object.matrix),W(dt*(s.object.top-s.object.bottom)/s.object.zoom/ye.clientHeight,s.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),s.enablePan=!1)}})();function st(ut){s.object instanceof Vi&&s.object.isPerspectiveCamera||s.object instanceof rh&&s.object.isOrthographicCamera?p=ut:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function ot(ut){st(p/ut)}function X(ut){st(p*ut)}function it(ut){if(!s.zoomToCursor||!s.domElement)return;k=!0;const kt=s.domElement.getBoundingClientRect(),Se=ut.clientX-kt.left,dt=ut.clientY-kt.top,ye=kt.width,fe=kt.height;z.x=Se/ye*2-1,z.y=-(dt/fe)*2+1,F.set(z.x,z.y,1).unproject(s.object).sub(s.object.position).normalize()}function ct(ut){return Math.max(s.minDistance,Math.min(s.maxDistance,ut))}function yt(ut){v.set(ut.clientX,ut.clientY)}function Rt(ut){it(ut),A.set(ut.clientX,ut.clientY)}function ft(ut){b.set(ut.clientX,ut.clientY)}function _t(ut){_.set(ut.clientX,ut.clientY),S.subVectors(_,v).multiplyScalar(s.rotateSpeed);const kt=s.domElement;kt&&(K(2*Math.PI*S.x/kt.clientHeight),Y(2*Math.PI*S.y/kt.clientHeight)),v.copy(_),s.update()}function qt(ut){I.set(ut.clientX,ut.clientY),D.subVectors(I,A),D.y>0?ot(q()):D.y<0&&X(q()),A.copy(I),s.update()}function Qt(ut){T.set(ut.clientX,ut.clientY),C.subVectors(T,b).multiplyScalar(s.panSpeed),j(C.x,C.y),b.copy(T),s.update()}function se(ut){it(ut),ut.deltaY<0?X(q()):ut.deltaY>0&&ot(q()),s.update()}function Ee(ut){let kt=!1;switch(ut.code){case s.keys.UP:j(0,s.keyPanSpeed),kt=!0;break;case s.keys.BOTTOM:j(0,-s.keyPanSpeed),kt=!0;break;case s.keys.LEFT:j(s.keyPanSpeed,0),kt=!0;break;case s.keys.RIGHT:j(-s.keyPanSpeed,0),kt=!0;break}kt&&(ut.preventDefault(),s.update())}function He(){if(O.length==1)v.set(O[0].pageX,O[0].pageY);else{const ut=.5*(O[0].pageX+O[1].pageX),kt=.5*(O[0].pageY+O[1].pageY);v.set(ut,kt)}}function Ae(){if(O.length==1)b.set(O[0].pageX,O[0].pageY);else{const ut=.5*(O[0].pageX+O[1].pageX),kt=.5*(O[0].pageY+O[1].pageY);b.set(ut,kt)}}function Ht(){const ut=O[0].pageX-O[1].pageX,kt=O[0].pageY-O[1].pageY,Se=Math.sqrt(ut*ut+kt*kt);A.set(0,Se)}function Jt(){s.enableZoom&&Ht(),s.enablePan&&Ae()}function Xt(){s.enableZoom&&Ht(),s.enableRotate&&He()}function ce(ut){if(O.length==1)_.set(ut.pageX,ut.pageY);else{const Se=Ne(ut),dt=.5*(ut.pageX+Se.x),ye=.5*(ut.pageY+Se.y);_.set(dt,ye)}S.subVectors(_,v).multiplyScalar(s.rotateSpeed);const kt=s.domElement;kt&&(K(2*Math.PI*S.x/kt.clientHeight),Y(2*Math.PI*S.y/kt.clientHeight)),v.copy(_)}function rt(ut){if(O.length==1)T.set(ut.pageX,ut.pageY);else{const kt=Ne(ut),Se=.5*(ut.pageX+kt.x),dt=.5*(ut.pageY+kt.y);T.set(Se,dt)}C.subVectors(T,b).multiplyScalar(s.panSpeed),j(C.x,C.y),b.copy(T)}function Fe(ut){const kt=Ne(ut),Se=ut.pageX-kt.x,dt=ut.pageY-kt.y,ye=Math.sqrt(Se*Se+dt*dt);I.set(0,ye),D.set(0,Math.pow(I.y/A.y,s.zoomSpeed)),ot(D.y),A.copy(I)}function he(ut){s.enableZoom&&Fe(ut),s.enablePan&&rt(ut)}function Pe(ut){s.enableZoom&&Fe(ut),s.enableRotate&&ce(ut)}function pe(ut){var kt,Se;s.enabled!==!1&&(O.length===0&&((kt=s.domElement)==null||kt.ownerDocument.addEventListener("pointermove",nt),(Se=s.domElement)==null||Se.ownerDocument.addEventListener("pointerup",G)),nn(ut),ut.pointerType==="touch"?Ue(ut):vt(ut))}function nt(ut){s.enabled!==!1&&(ut.pointerType==="touch"?we(ut):Vt(ut))}function G(ut){var kt,Se,dt;ae(ut),O.length===0&&((kt=s.domElement)==null||kt.releasePointerCapture(ut.pointerId),(Se=s.domElement)==null||Se.ownerDocument.removeEventListener("pointermove",nt),(dt=s.domElement)==null||dt.ownerDocument.removeEventListener("pointerup",G)),s.dispatchEvent(a),l=o.NONE}function vt(ut){let kt;switch(ut.button){case 0:kt=s.mouseButtons.LEFT;break;case 1:kt=s.mouseButtons.MIDDLE;break;case 2:kt=s.mouseButtons.RIGHT;break;default:kt=-1}switch(kt){case Dm.DOLLY:if(s.enableZoom===!1)return;Rt(ut),l=o.DOLLY;break;case Dm.ROTATE:if(ut.ctrlKey||ut.metaKey||ut.shiftKey){if(s.enablePan===!1)return;ft(ut),l=o.PAN}else{if(s.enableRotate===!1)return;yt(ut),l=o.ROTATE}break;case Dm.PAN:if(ut.ctrlKey||ut.metaKey||ut.shiftKey){if(s.enableRotate===!1)return;yt(ut),l=o.ROTATE}else{if(s.enablePan===!1)return;ft(ut),l=o.PAN}break;default:l=o.NONE}l!==o.NONE&&s.dispatchEvent(r)}function Vt(ut){if(s.enabled!==!1)switch(l){case o.ROTATE:if(s.enableRotate===!1)return;_t(ut);break;case o.DOLLY:if(s.enableZoom===!1)return;qt(ut);break;case o.PAN:if(s.enablePan===!1)return;Qt(ut);break}}function te(ut){s.enabled===!1||s.enableZoom===!1||l!==o.NONE&&l!==o.ROTATE||(ut.preventDefault(),s.dispatchEvent(r),se(ut),s.dispatchEvent(a))}function Pt(ut){s.enabled===!1||s.enablePan===!1||Ee(ut)}function Ue(ut){switch(de(ut),O.length){case 1:switch(s.touches.ONE){case km.ROTATE:if(s.enableRotate===!1)return;He(),l=o.TOUCH_ROTATE;break;case km.PAN:if(s.enablePan===!1)return;Ae(),l=o.TOUCH_PAN;break;default:l=o.NONE}break;case 2:switch(s.touches.TWO){case km.DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;Jt(),l=o.TOUCH_DOLLY_PAN;break;case km.DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;Xt(),l=o.TOUCH_DOLLY_ROTATE;break;default:l=o.NONE}break;default:l=o.NONE}l!==o.NONE&&s.dispatchEvent(r)}function we(ut){switch(de(ut),l){case o.TOUCH_ROTATE:if(s.enableRotate===!1)return;ce(ut),s.update();break;case o.TOUCH_PAN:if(s.enablePan===!1)return;rt(ut),s.update();break;case o.TOUCH_DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;he(ut),s.update();break;case o.TOUCH_DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;Pe(ut),s.update();break;default:l=o.NONE}}function ze(ut){s.enabled!==!1&&ut.preventDefault()}function nn(ut){O.push(ut)}function ae(ut){delete L[ut.pointerId];for(let kt=0;kt<O.length;kt++)if(O[kt].pointerId==ut.pointerId){O.splice(kt,1);return}}function de(ut){let kt=L[ut.pointerId];kt===void 0&&(kt=new Yt,L[ut.pointerId]=kt),kt.set(ut.pageX,ut.pageY)}function Ne(ut){const kt=ut.pointerId===O[0].pointerId?O[1]:O[0];return L[kt.pointerId]}this.dollyIn=(ut=q())=>{X(ut),s.update()},this.dollyOut=(ut=q())=>{ot(ut),s.update()},this.getScale=()=>p,this.setScale=ut=>{st(ut),s.update()},this.getZoomScale=()=>q(),e!==void 0&&this.connect(e),this.update()}};const Sit=()=>parseInt(kg.replace(/\D+/g,"")),_it=Sit(),wit=be.forwardRef(({makeDefault:n,camera:t,regress:e,domElement:s,enableDamping:i=!0,keyEvents:r=!1,onChange:a,onStart:o,onEnd:l,...c},h)=>{const f=Ku(D=>D.invalidate),p=Ku(D=>D.camera),g=Ku(D=>D.gl),v=Ku(D=>D.events),_=Ku(D=>D.setEvents),S=Ku(D=>D.set),b=Ku(D=>D.get),T=Ku(D=>D.performance),C=t||p,A=s||v.connected||g.domElement,I=be.useMemo(()=>new bit(C),[C]);return fp(()=>{I.enabled&&I.update()},-1),be.useEffect(()=>(r&&I.connect(r===!0?A:r),I.connect(A),()=>void I.dispose()),[r,A,e,I,f]),be.useEffect(()=>{const D=k=>{f(),e&&T.regress(),a&&a(k)},F=k=>{o&&o(k)},z=k=>{l&&l(k)};return I.addEventListener("change",D),I.addEventListener("start",F),I.addEventListener("end",z),()=>{I.removeEventListener("start",F),I.removeEventListener("end",z),I.removeEventListener("change",D)}},[a,o,l,I,f,_]),be.useEffect(()=>{if(n){const D=b().controls;return S({controls:I}),()=>S({controls:D})}},[n,I]),be.createElement("primitive",vR({ref:h,object:I,enableDamping:i},c))});class Tit extends ar{constructor(){super({uniforms:{time:{value:0},fade:{value:1}},vertexShader:`
      uniform float time;
      attribute float size;
      varying vec3 vColor;
      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
        gl_Position = projectionMatrix * mvPosition;
      }`,fragmentShader:`
      uniform sampler2D pointTexture;
      uniform float fade;
      varying vec3 vColor;
      void main() {
        float opacity = 1.0;
        if (fade == 1.0) {
          float d = distance(gl_PointCoord, vec2(0.5, 0.5));
          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
        }
        gl_FragColor = vec4(vColor, opacity);

        #include <tonemapping_fragment>
	      #include <${_it>=154?"colorspace_fragment":"encodings_fragment"}>
      }`})}}const Eit=n=>new at().setFromSpherical(new p2(n,Math.acos(1-Math.random()*2),Math.random()*2*Math.PI)),Cit=be.forwardRef(({radius:n=100,depth:t=50,count:e=5e3,saturation:s=0,factor:i=4,fade:r=!1,speed:a=1},o)=>{const l=be.useRef(null),[c,h,f]=be.useMemo(()=>{const g=[],v=[],_=Array.from({length:e},()=>(.5+.5*Math.random())*i),S=new ke;let b=n+t;const T=t/e;for(let C=0;C<e;C++)b-=T*Math.random(),g.push(...Eit(b).toArray()),S.setHSL(C/e,s,.9),v.push(S.r,S.g,S.b);return[new Float32Array(g),new Float32Array(v),new Float32Array(_)]},[e,t,i,n,s]);fp(g=>l.current&&(l.current.uniforms.time.value=g.clock.elapsedTime*a));const[p]=be.useState(()=>new Tit);return be.createElement("points",{ref:o},be.createElement("bufferGeometry",null,be.createElement("bufferAttribute",{attach:"attributes-position",args:[c,3]}),be.createElement("bufferAttribute",{attach:"attributes-color",args:[h,3]}),be.createElement("bufferAttribute",{attach:"attributes-size",args:[f,1]})),be.createElement("primitive",{ref:l,object:p,attach:"material",blending:Zy,"uniforms-fade-value":r,depthWrite:!1,transparent:!0,vertexColors:!0}))}),ox={EMERALD_DEEP:new ke("#004028"),EMERALD_LIGHT:new ke("#00FF88"),GOLD_HIGHLIGHT:new ke("#FFD700"),GOLD_DARK:new ke("#FFA500"),SILVER:new ke("#C0C0C0"),RED_VELVET:new ke("#800020")},_l={NEEDLE_COUNT:12e3,ORNAMENT_COUNT:3e3,TREE_HEIGHT:11,TREE_RADIUS:4,CHAOS_RADIUS:35,CAMERA_POS:[0,0,32]};var tu=(n=>(n.FORMED="FORMED",n.CHAOS="CHAOS",n))(tu||{});const I3=n=>{const t=Math.random(),e=Math.random(),s=2*Math.PI*t,i=Math.acos(2*e-1),r=Math.cbrt(Math.random())*n,a=r*Math.sin(i)*Math.cos(s),o=r*Math.sin(i)*Math.sin(s),l=r*Math.cos(i);return new at(a,o,l)},zV=()=>be.useMemo(()=>{const n=document.createElement("canvas");n.width=32,n.height=32;const t=n.getContext("2d"),e=t.createRadialGradient(16,16,0,16,16,16);return e.addColorStop(0,"rgba(255, 255, 255, 1)"),e.addColorStop(.4,"rgba(255, 255, 255, 0.2)"),e.addColorStop(1,"rgba(0, 0, 0, 0)"),t.fillStyle=e,t.fillRect(0,0,32,32),new x4(n)},[]),Ait=({state:n})=>{const t=be.useRef(null),e=be.useMemo(()=>{const s=new Bd,i=.8,r=.35,a=5;for(let o=0;o<a*2;o++){const l=o*Math.PI/a-Math.PI/2,c=o%2===0?i:r,h=Math.cos(l)*c,f=Math.sin(l)*c;o===0?s.moveTo(h,f):s.lineTo(h,f)}return s.closePath(),s},[]);return fp(s=>{if(!t.current)return;const i=s.clock.getElapsedTime();t.current.rotation.y=i*.5,t.current.position.y=_l.TREE_HEIGHT/2+.5+Math.sin(i*2)*.1;const r=n===tu.FORMED?1:.1;t.current.scale.lerp(new at(r,r,r),.05)}),ge.jsxs("group",{ref:t,children:[ge.jsxs("mesh",{children:[ge.jsx("extrudeGeometry",{args:[e,{depth:.2,bevelEnabled:!0,bevelThickness:.1,bevelSize:.05,bevelSegments:2}]}),ge.jsx("meshStandardMaterial",{color:ox.GOLD_HIGHLIGHT,emissive:ox.GOLD_HIGHLIGHT,emissiveIntensity:3,roughness:.1,metalness:1})]}),ge.jsx("pointLight",{distance:10,intensity:2,color:"#ffaa00"})]})},Nit=({state:n})=>{const t=be.useRef(null),e=_l.ORNAMENT_COUNT,s=zV(),[i,r,a,o,l]=be.useMemo(()=>{const c=new Float32Array(e*3),h=new Float32Array(e*3),f=new Float32Array(e*3),p=new Float32Array(e*3),g=new Float32Array(e),v=5.5,_=_l.TREE_HEIGHT,S=_l.TREE_RADIUS+.5;for(let b=0;b<e;b++){const T=b/e,C=T*_-_/2,A=(1-T)*S,I=T*(Math.PI*2*v),D=.6,F=(Math.random()-.5)*D,z=(Math.random()-.5)*D,k=(Math.random()-.5)*D,O=A*Math.cos(I)+F,L=C+k,H=A*Math.sin(I)+z;h[b*3]=O,h[b*3+1]=L,h[b*3+2]=H;const q=I3(_l.CHAOS_RADIUS);f[b*3]=q.x,f[b*3+1]=q.y,f[b*3+2]=q.z,c[b*3]=q.x,c[b*3+1]=q.y,c[b*3+2]=q.z;const K=Math.random()>.5?ox.GOLD_HIGHLIGHT:ox.GOLD_DARK;p[b*3]=K.r,p[b*3+1]=K.g,p[b*3+2]=K.b,g[b]=Math.random()*.5+.3}return[c,h,f,p,g]},[]);return fp(c=>{if(!t.current)return;const h=n===tu.FORMED,f=t.current.geometry.attributes.position.array;for(let p=0;p<e;p++){const g=p*3,v=p*3+1,_=p*3+2,S=h?r[g]:a[g],b=h?r[v]:a[v],T=h?r[_]:a[_];f[g]+=(S-f[g])*.05,f[v]+=(b-f[v])*.05,f[_]+=(T-f[_])*.05}t.current.geometry.attributes.position.needsUpdate=!0}),ge.jsxs("points",{ref:t,children:[ge.jsxs("bufferGeometry",{children:[ge.jsx("bufferAttribute",{attach:"attributes-position",count:e,array:i,itemSize:3}),ge.jsx("bufferAttribute",{attach:"attributes-color",count:e,array:o,itemSize:3}),ge.jsx("bufferAttribute",{attach:"attributes-size",count:e,array:l,itemSize:1})]}),ge.jsx("pointsMaterial",{map:s,size:.6,vertexColors:!0,transparent:!0,opacity:1,blending:Zy,depthWrite:!1,sizeAttenuation:!0})]})},Mit=({state:n})=>{const t=be.useRef(null),e=_l.NEEDLE_COUNT,s=zV(),[i,r,a,o,l]=be.useMemo(()=>{const c=new Float32Array(e*3),h=new Float32Array(e*3),f=new Float32Array(e*3),p=new Float32Array(e*3),g=new Float32Array(e),v=_l.TREE_HEIGHT,_=_l.TREE_RADIUS;for(let S=0;S<e;S++){const b=Math.random(),T=b*v-v/2,C=(1-b)*_,A=Math.sqrt(Math.random())*C,I=Math.random()*Math.PI*2,D=b*Math.PI,F=A*Math.cos(I+D),z=A*Math.sin(I+D);h[S*3]=F,h[S*3+1]=T,h[S*3+2]=z;const k=I3(_l.CHAOS_RADIUS*1.2);f[S*3]=k.x,f[S*3+1]=k.y,f[S*3+2]=k.z,c[S*3]=k.x,c[S*3+1]=k.y,c[S*3+2]=k.z;const L=Math.random()>.7?ox.EMERALD_LIGHT:ox.EMERALD_DEEP;p[S*3]=L.r,p[S*3+1]=L.g,p[S*3+2]=L.b,g[S]=Math.random()*.4+.1}return[c,h,f,p,g]},[]);return fp(c=>{if(!t.current)return;const h=n===tu.FORMED,f=t.current.geometry.attributes.position.array;for(let p=0;p<e;p++){const g=p*3,v=p*3+1,_=p*3+2,S=h?r[g]:a[g],b=h?r[v]:a[v],T=h?r[_]:a[_];f[g]+=(S-f[g])*.04,f[v]+=(b-f[v])*.04,f[_]+=(T-f[_])*.04}t.current.geometry.attributes.position.needsUpdate=!0}),ge.jsxs("points",{ref:t,children:[ge.jsxs("bufferGeometry",{children:[ge.jsx("bufferAttribute",{attach:"attributes-position",count:e,array:i,itemSize:3}),ge.jsx("bufferAttribute",{attach:"attributes-color",count:e,array:o,itemSize:3}),ge.jsx("bufferAttribute",{attach:"attributes-size",count:e,array:l,itemSize:1})]}),ge.jsx("pointsMaterial",{map:s,size:.4,vertexColors:!0,transparent:!0,opacity:.8,blending:Zy,depthWrite:!1,sizeAttenuation:!0})]})},Iit=({photo:n,state:t,index:e,totalCount:s})=>{const i=be.useRef(null),r=be.useMemo(()=>new G4().load(n.url),[n.url]),{targetPos:a,chaosPos:o,targetRotationQ:l}=be.useMemo(()=>{const c=_l.TREE_HEIGHT,h=_l.TREE_RADIUS,f=-c/2+1.5,p=c/2-2,g=p-f;let v=0;if(s<=1)v=(f+p)/2;else{const F=e/(s-1);v=f+F*g}const b=(1-(v+c/2)/c)*h+1.5,T=e*2.39996,C=new at(Math.cos(T)*b,v,Math.sin(T)*b),A=new ps;A.position.copy(C),A.lookAt(0,v,0),A.rotateY(Math.PI);const I=A.quaternion.clone(),D=I3(_l.CHAOS_RADIUS*.8);return{targetPos:C,chaosPos:D,targetRotationQ:I}},[e,s]);return fp((c,h)=>{if(!i.current)return;const f=t===tu.FORMED,p=f?a:o;i.current.position.lerp(p,.03),f?i.current.quaternion.slerp(l,.05):(i.current.rotation.x+=.02,i.current.rotation.z+=.02)}),ge.jsxs("group",{ref:i,children:[ge.jsxs("mesh",{position:[0,0,-.01],children:[ge.jsx("boxGeometry",{args:[1.5,1.8,.05]}),ge.jsx("meshStandardMaterial",{color:"#f8f8f8",roughness:.5,metalness:0})]}),ge.jsxs("mesh",{position:[0,.15,.02],children:[ge.jsx("planeGeometry",{args:[1.3,1.3]}),ge.jsx("meshStandardMaterial",{map:r,side:Fa,roughness:.4,metalness:0,emissive:"black"})]}),ge.jsxs("mesh",{position:[0,.15,-.04],rotation:[0,Math.PI,0],children:[ge.jsx("planeGeometry",{args:[1.3,1.3]}),ge.jsx("meshStandardMaterial",{map:r,side:Fa,roughness:.4,metalness:0,emissive:"black"})]})]})},Rit=({state:n,photos:t,mousePos:e})=>{const s=be.useRef(null);return fp(()=>{if(!s.current)return;const i=(e.x-.5)*Math.PI*2.5;s.current.rotation.y=s4.lerp(s.current.rotation.y,i,.05)}),ge.jsxs("group",{ref:s,children:[ge.jsx(Ait,{state:n}),ge.jsx(Nit,{state:n}),ge.jsx(Mit,{state:n}),t.map((i,r)=>ge.jsx(Iit,{photo:i,state:n,index:r,totalCount:t.length},i.id))]})};var lE={exports:{}},Dit=lE.exports,Kz;function kit(){return Kz||(Kz=1,(function(n,t){(function(s,i){n.exports=i(Dg())})(Dit,function(e){return(function(s){var i={};function r(a){if(i[a])return i[a].exports;var o=i[a]={i:a,l:!1,exports:{}};return s[a].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=s,r.c=i,r.d=function(a,o,l){r.o(a,o)||Object.defineProperty(a,o,{enumerable:!0,get:l})},r.r=function(a){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(a,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(a,"__esModule",{value:!0})},r.t=function(a,o){if(o&1&&(a=r(a)),o&8||o&4&&typeof a=="object"&&a&&a.__esModule)return a;var l=Object.create(null);if(r.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:a}),o&2&&typeof a!="string")for(var c in a)r.d(l,c,(function(h){return a[h]}).bind(null,c));return l},r.n=function(a){var o=a&&a.__esModule?function(){return a.default}:function(){return a};return r.d(o,"a",o),o},r.o=function(a,o){return Object.prototype.hasOwnProperty.call(a,o)},r.p="",r(r.s="./src/react-webcam.tsx")})({"./src/react-webcam.tsx":(function(s,i,r){r.r(i);var a=r("react"),o=(function(){var p=function(g,v){return p=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_,S){_.__proto__=S}||function(_,S){for(var b in S)S.hasOwnProperty(b)&&(_[b]=S[b])},p(g,v)};return function(g,v){p(g,v);function _(){this.constructor=g}g.prototype=v===null?Object.create(v):(_.prototype=v.prototype,new _)}})(),l=function(){return l=Object.assign||function(p){for(var g,v=1,_=arguments.length;v<_;v++){g=arguments[v];for(var S in g)Object.prototype.hasOwnProperty.call(g,S)&&(p[S]=g[S])}return p},l.apply(this,arguments)},c=function(p,g){var v={};for(var _ in p)Object.prototype.hasOwnProperty.call(p,_)&&g.indexOf(_)<0&&(v[_]=p[_]);if(p!=null&&typeof Object.getOwnPropertySymbols=="function")for(var S=0,_=Object.getOwnPropertySymbols(p);S<_.length;S++)g.indexOf(_[S])<0&&Object.prototype.propertyIsEnumerable.call(p,_[S])&&(v[_[S]]=p[_[S]]);return v};(function(){typeof window>"u"||(navigator.mediaDevices===void 0&&(navigator.mediaDevices={}),navigator.mediaDevices.getUserMedia===void 0&&(navigator.mediaDevices.getUserMedia=function(g){var v=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return v?new Promise(function(_,S){v.call(navigator,g,_,S)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}))})();function h(){return!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)}var f=(function(p){o(g,p);function g(v){var _=p.call(this,v)||this;return _.canvas=null,_.ctx=null,_.requestUserMediaId=0,_.unmounted=!1,_.state={hasUserMedia:!1},_}return g.prototype.componentDidMount=function(){var v=this,_=v.state,S=v.props;if(this.unmounted=!1,!h()){S.onUserMediaError("getUserMedia not supported");return}_.hasUserMedia||this.requestUserMedia(),S.children&&typeof S.children!="function"&&console.warn("children must be a function")},g.prototype.componentDidUpdate=function(v){var _=this.props;if(!h()){_.onUserMediaError("getUserMedia not supported");return}var S=JSON.stringify(v.audioConstraints)!==JSON.stringify(_.audioConstraints),b=JSON.stringify(v.videoConstraints)!==JSON.stringify(_.videoConstraints),T=v.minScreenshotWidth!==_.minScreenshotWidth,C=v.minScreenshotHeight!==_.minScreenshotHeight;(b||T||C)&&(this.canvas=null,this.ctx=null),(S||b)&&(this.stopAndCleanup(),this.requestUserMedia())},g.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},g.stopMediaStream=function(v){v&&(v.getVideoTracks&&v.getAudioTracks?(v.getVideoTracks().map(function(_){v.removeTrack(_),_.stop()}),v.getAudioTracks().map(function(_){v.removeTrack(_),_.stop()})):v.stop())},g.prototype.stopAndCleanup=function(){var v=this.state;v.hasUserMedia&&(g.stopMediaStream(this.stream),v.src&&window.URL.revokeObjectURL(v.src))},g.prototype.getScreenshot=function(v){var _=this,S=_.state,b=_.props;if(!S.hasUserMedia)return null;var T=this.getCanvas(v);return T&&T.toDataURL(b.screenshotFormat,b.screenshotQuality)},g.prototype.getCanvas=function(v){var _=this,S=_.state,b=_.props;if(!this.video||!S.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var T=this.video.videoWidth,C=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var A=T/C;T=b.minScreenshotWidth||this.video.clientWidth,C=T/A,b.minScreenshotHeight&&C<b.minScreenshotHeight&&(C=b.minScreenshotHeight,T=C*A)}this.canvas=document.createElement("canvas"),this.canvas.width=(v==null?void 0:v.width)||T,this.canvas.height=(v==null?void 0:v.height)||C,this.ctx=this.canvas.getContext("2d")}var I=this,D=I.ctx,F=I.canvas;return D&&F&&(F.width=(v==null?void 0:v.width)||F.width,F.height=(v==null?void 0:v.height)||F.height,b.mirrored&&(D.translate(F.width,0),D.scale(-1,1)),D.imageSmoothingEnabled=b.imageSmoothing,D.drawImage(this.video,0,0,(v==null?void 0:v.width)||F.width,(v==null?void 0:v.height)||F.height),b.mirrored&&(D.scale(-1,1),D.translate(-F.width,0))),F},g.prototype.requestUserMedia=function(){var v=this,_=this.props,S=function(C,A){var I={video:typeof A<"u"?A:!0};_.audio&&(I.audio=typeof C<"u"?C:!0),v.requestUserMediaId++;var D=v.requestUserMediaId;navigator.mediaDevices.getUserMedia(I).then(function(F){v.unmounted||D!==v.requestUserMediaId?g.stopMediaStream(F):v.handleUserMedia(null,F)}).catch(function(F){v.handleUserMedia(F)})};if("mediaDevices"in navigator)S(_.audioConstraints,_.videoConstraints);else{var b=function(C){return{optional:[{sourceId:C}]}},T=function(C){var A=C.deviceId;return typeof A=="string"?A:Array.isArray(A)&&A.length>0?A[0]:typeof A=="object"&&A.ideal?A.ideal:null};MediaStreamTrack.getSources(function(C){var A=null,I=null;C.forEach(function(z){z.kind==="audio"?A=z.id:z.kind==="video"&&(I=z.id)});var D=T(_.audioConstraints);D&&(A=D);var F=T(_.videoConstraints);F&&(I=F),S(b(A),b(I))})}},g.prototype.handleUserMedia=function(v,_){var S=this.props;if(v||!_){this.setState({hasUserMedia:!1}),S.onUserMediaError(v);return}this.stream=_;try{this.video&&(this.video.srcObject=_),this.setState({hasUserMedia:!0})}catch{this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(_)})}S.onUserMedia(_)},g.prototype.render=function(){var v=this,_=this,S=_.state,b=_.props,T=b.audio;b.forceScreenshotSourceSize;var C=b.disablePictureInPicture;b.onUserMedia,b.onUserMediaError,b.screenshotFormat,b.screenshotQuality,b.minScreenshotWidth,b.minScreenshotHeight,b.audioConstraints,b.videoConstraints,b.imageSmoothing;var A=b.mirrored,I=b.style,D=I===void 0?{}:I,F=b.children,z=c(b,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),k=A?l(l({},D),{transform:(D.transform||"")+" scaleX(-1)"}):D,O={getScreenshot:this.getScreenshot.bind(this)};return a.createElement(a.Fragment,null,a.createElement("video",l({autoPlay:!0,disablePictureInPicture:C,src:S.src,muted:!T,playsInline:!0,ref:function(L){v.video=L},style:k},z)),F&&F(O))},g.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},g})(a.Component);i.default=f}),react:(function(s,i){s.exports=e})}).default})})(lE)),lE.exports}var Oit=kit();const $it=_x(Oit);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lit=1e-7,Fit=1e-4;class UV{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}let R3=class{refCount(t){return Vo("refCount")}incRef(t){return Vo("incRef")}timerAvailable(){return!0}time(t){return Vo("time")}read(t){return Vo("read")}readSync(t){return Vo("readSync")}readToGPU(t,e){return Vo("readToGPU")}numDataIds(){return Vo("numDataIds")}disposeData(t,e){return Vo("disposeData")}write(t,e,s){return Vo("write")}move(t,e,s,i,r){return Vo("move")}createTensorFromGPUData(t,e,s){return Vo("createTensorFromGPUData")}memory(){return Vo("memory")}floatPrecision(){return Vo("floatPrecision")}epsilon(){return this.floatPrecision()===32?Lit:Fit}dispose(){return Vo("dispose")}};function Vo(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zit(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Ry(n,t,e)}function hg(n,t,e){return Math.max(n,Math.min(t,e))}function D3(n){return n%2===0?n:n+1}function Ry(n,t,e){const s=n[t];n[t]=n[e],n[e]=s}function Uit(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}function et(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function k3(n,t,e=""){et(Is(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function BV(n){et(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Zt(n){if(n.length===0)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function Is(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function lx(n){return n%1===0}function bR(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function Gy(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function Yz(n,t=i=>0,e,s){return new Promise((i,r)=>{let a=0;const o=()=>{if(n()){i();return}a++;const l=t(a);if(e!=null&&a>=e){r();return}s!=null?s(o,l):setTimeout(o,l)};o()})}function PV(n,t){let e=1,s=-1;for(let r=0;r<n.length;++r)if(n[r]>=0)e*=n[r];else if(n[r]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${r}`);s=r}else if(n[r]<0)throw Error(`Shapes can not be < 0. Found ${n[r]} at dim ${r}`);if(s===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(e===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const i=n.slice();return i[s]=t/e,i}function Wn(n,t){const e=t.length;return n=n==null?t.map((s,i)=>i):[].concat(n),et(n.every(s=>s>=-e&&s<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),et(n.every(s=>lx(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?e+s:s)}function dp(n,t){const e=[],s=[],i=t!=null&&Array.isArray(t)&&t.length===0,r=t==null||i?null:Wn(t,n).sort();let a=0;for(let o=0;o<n.length;++o){if(r!=null){if(r[a]===o&&n[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);(r[a]==null||r[a]>o)&&n[o]===1&&(e.push(n[o]),s.push(o)),r[a]<=o&&a++}n[o]!==1&&(e.push(n[o]),s.push(o))}return{newShape:e,keptDims:s}}function ma(n,t){return Hi(n,t)}function Hi(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else if(n==="string")e=new Array(t);else throw new Error(`Unknown data type ${n}`);return e}function Bit(n,t){for(let e=0;e<n.length;e++){const s=n[e];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function Pit(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function VV(n,t){return!(t==="complex64"||t==="float32"&&n!=="complex64"||t==="int32"&&n!=="float32"&&n!=="complex64"||t==="bool"&&n==="bool")}function b2(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function Vit(n){if(n==null)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function uS(n){return typeof n=="string"||n instanceof String}function Git(n){return typeof n=="boolean"}function SR(n){return typeof n=="number"}function Nx(n){return Array.isArray(n)?Nx(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":SR(n)?"float32":uS(n)?"string":Git(n)?"bool":"float32"}function _R(n){return!!(n&&n.constructor&&n.call&&n.apply)}function wR(n,t){for(let e=t;e<n;++e)if(n%e===0)return e;return n}function ln(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let s=t-3;s>=0;--s)e[s]=e[s+1]*n[s+1];return e}function GV(n,t,e,s=!1){const i=new Array;if(t.length===1){const r=t[0]*(s?2:1);for(let a=0;a<r;a++)i[a]=e[n+a]}else{const r=t[0],a=t.slice(1),o=a.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<r;l++)i[l]=GV(n+l*o,a,e,s)}return i}function eu(n,t,e=!1){if(n.length===0)return t[0];const s=n.reduce((i,r)=>i*r)*(e?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return GV(0,n,t,e)}function Hit(n,t){if(Array.isArray(n))return n;if(t==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(t==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}function O3(n,t){const e=ga(n,t);for(let s=0;s<e.length;s++)e[s]=1;return e}function ga(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function HV(n,t){const e=n.reduce((s,i)=>s*i,1);if(t==null||t==="float32")return eu(n,new Float32Array(e));if(t==="int32")return eu(n,new Int32Array(e));if(t==="bool")return eu(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function kf(n){n.forEach(t=>{et(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function ah(n,t,e){if(t===0)return 0;if(t===1)return n[0];let s=n[n.length-1];for(let i=0;i<n.length-1;++i)s+=e[i]*n[i];return s}function Mx(n,t,e){if(t===0)return[];if(t===1)return[n];const s=new Array(t);for(let i=0;i<s.length-1;++i)s[i]=Math.floor(n/e[i]),n-=s[i]*e[i];return s[s.length-1]=n,s}function $3(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zz="tfjsflags";let Wit=class{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=qit,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(Bt().getBool("IS_TEST")||Bt().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,s){if(this.flagRegistry[t]={evaluationFn:e,setHook:s},this.urlFlags[t]!=null){const i=this.urlFlags[t];Bt().getBool("IS_TEST")||Bt().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${i}.`),this.set(t,i)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if($3(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);Zz in t&&t[Zz].split(",").forEach(s=>{const[i,r]=s.split(":");this.urlFlags[i]=jit(i,r)})}};function qit(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...s)=>(Xit(t,s[0],s[1]),s.join("="))),t}function Xit(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function jit(n,t){const e=t.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:t}function Bt(){return WV}let WV=null;function Kit(n){WV=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _I;function qV(){if(_I==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");_I=n}return _I}function Yit(){const n=qV();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function L3(n,t){const e=Yit();if(e.has(n))return e.get(n);{const s=t();return e.set(n,s),e.get(n)}}const GC="Abs",hS="Acos",fS="Acosh",Ix="Add",F3="AddN",z3="All",U3="Any",HC="ArgMax",WC="ArgMin",dS="Asin",pS="Asinh",mS="Atan",gS="Atanh",yS="Atan2",qC="AvgPool",B3="AvgPoolGrad",XC="AvgPool3D",P3="AvgPool3DGrad",jC="BatchMatMul",KC="BatchToSpaceND",V3="Bincount",G3="BitwiseAnd",Zit="BroadcastTo",XV="BroadcastArgs",xS="Cast",vS="Ceil",bS="ClipByValue",H3="Complex",YC="ComplexAbs",ZC="Concat",QC="Conv2D",W3="Conv2DBackpropFilter",JC="Conv2DBackpropInput",tA="Conv3D",q3="Conv3DBackpropFilterV2",X3="Conv3DBackpropInputV2",SS="Cos",_S="Cosh",j3="Cumprod",eA="Cumsum",K3="CropAndResize",Y3="DenseBincount",Z3="DepthToSpace",nA="DepthwiseConv2dNative",Q3="DepthwiseConv2dNativeBackpropFilter",J3="DepthwiseConv2dNativeBackpropInput",jV="Diag",sA="Dilation2D",TR="Dilation2DBackpropInput",ER="Dilation2DBackpropFilter",Qit="Draw",wS="RealDiv",tk="Einsum",TS="Elu",ek="EluGrad",ES="Erf",iA="Equal",CS="Exp",rA="ExpandDims",AS="Expm1",nk="FFT",sk="Fill",ik="FlipLeftRight",NS="Floor",MS="FloorDiv",aA="FusedBatchNorm",oA="GatherV2",KV="GatherNd",lA="Greater",IS="GreaterEqual",RS="Identity",rk="IFFT",ak="Imag",DS="IsFinite",kS="IsInf",OS="IsNan",cA="LeakyRelu",uA="Less",hA="LessEqual",YV="LinSpace",$S="Log",LS="Log1p",fA="LogicalAnd",dA="LogicalNot",pA="LogicalOr",Jit="LogSoftmax",mA="LRN",ok="LRNGrad",gA="Max",FS="Maximum",yA="MaxPool",lk="MaxPoolGrad",xA="MaxPool3D",ck="MaxPool3DGrad",ZV="MaxPoolWithArgmax",vA="Mean",bA="Min",zS="Minimum",SA="MirrorPad",US="Mod",QV="Multinomial",BS="Multiply",_A="Neg",wA="NotEqual",uk="NonMaxSuppressionV3",hk="NonMaxSuppressionV4",fk="NonMaxSuppressionV5",TA="OnesLike",EA="OneHot",CA="Pack",AA="PadV2",PS="Pow",NA="Prelu",MA="Prod",JV="RaggedGather",tG="RaggedRange",eG="RaggedTensorToTensor",dk="Range",pk="Real",VS="Reciprocal",GS="Relu",IA="Reshape",RA="ResizeNearestNeighbor",mk="ResizeNearestNeighborGrad",DA="ResizeBilinear",gk="ResizeBilinearGrad",HS="Relu6",kA="Reverse",WS="Round",qS="Rsqrt",nG="ScatterNd",sG="TensorScatterUpdate",iG="SearchSorted",OA="Select",XS="Selu",$A="Slice",jS="Sin",KS="Sinh",YS="Sign",ZS="Sigmoid",QS="Softplus",JS="Sqrt",LA="Sum",FA="SpaceToBatchND",zA="SplitV",UA="Softmax",rG="SparseFillEmptyRows",aG="SparseReshape",oG="SparseSegmentMean",lG="SparseSegmentSum",cG="SparseToDense",t_="SquaredDifference",yk="Square",xk="StaticRegexReplace",vk="StridedSlice",uG="StringNGrams",hG="StringSplit",fG="StringToHashBucketFast",e_="Sub",n_="Tan",s_="Tanh",i_="Tile",bk="TopK",Sk="Transform",Hy="Transpose",_k="Unique",BA="Unpack",PA="UnsortedSegmentSum",VA="ZerosLike",r_="Step",trt="FromPixels",wk="RotateWithOffset",S2="_FusedMatMul",_2="FusedConv2D",dG="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bl(...n){Bt().getBool("IS_TEST")||Bt().getBool("PROD")||console.warn(...n)}function ert(...n){Bt().getBool("IS_TEST")||Bt().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w2=L3("kernelRegistry",()=>new Map),CR=L3("gradRegistry",()=>new Map);function Qz(n,t){const e=mG(n,t);return w2.get(e)}function Jz(n){return CR.get(n)}function tU(n){const t=w2.entries(),e=[];for(;;){const{done:s,value:i}=t.next();if(s)break;const[r,a]=i,[o]=r.split("_");o===n&&e.push(a)}return e}function pG(n){const{kernelName:t,backendName:e}=n,s=mG(t,e);w2.has(s)&&bl(`The kernel '${t}' for backend '${e}' is already registered`),w2.set(s,n)}function nrt(n){const{kernelName:t}=n;CR.has(t)&&Bt().getBool("DEBUG")&&bl(`Overriding the gradient for '${t}'`),CR.set(t,n)}function mG(n,t){return`${t}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gG(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var wI,eU;function srt(){if(eU)return wI;eU=1,wI=t;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(O,L,H){this.low=O|0,this.high=L|0,this.unsigned=!!H}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function e(O){return(O&&O.__isLong__)===!0}t.isLong=e;var s={},i={};function r(O,L){var H,q,K;return L?(O>>>=0,(K=0<=O&&O<256)&&(q=i[O],q)?q:(H=o(O,(O|0)<0?-1:0,!0),K&&(i[O]=H),H)):(O|=0,(K=-128<=O&&O<128)&&(q=s[O],q)?q:(H=o(O,O<0?-1:0,!1),K&&(s[O]=H),H))}t.fromInt=r;function a(O,L){if(isNaN(O))return L?T:b;if(L){if(O<0)return T;if(O>=v)return F}else{if(O<=-_)return z;if(O+1>=_)return D}return O<0?a(-O,L).neg():o(O%g|0,O/g|0,L)}t.fromNumber=a;function o(O,L,H){return new t(O,L,H)}t.fromBits=o;var l=Math.pow;function c(O,L,H){if(O.length===0)throw Error("empty string");if(O==="NaN"||O==="Infinity"||O==="+Infinity"||O==="-Infinity")return b;if(typeof L=="number"?(H=L,L=!1):L=!!L,H=H||10,H<2||36<H)throw RangeError("radix");var q;if((q=O.indexOf("-"))>0)throw Error("interior hyphen");if(q===0)return c(O.substring(1),L,H).neg();for(var K=a(l(H,8)),Y=b,P=0;P<O.length;P+=8){var W=Math.min(8,O.length-P),j=parseInt(O.substring(P,P+W),H);if(W<8){var st=a(l(H,W));Y=Y.mul(st).add(a(j))}else Y=Y.mul(K),Y=Y.add(a(j))}return Y.unsigned=L,Y}t.fromString=c;function h(O,L){return typeof O=="number"?a(O,L):typeof O=="string"?c(O,L):o(O.low,O.high,typeof L=="boolean"?L:O.unsigned)}t.fromValue=h;var f=65536,p=1<<24,g=f*f,v=g*g,_=v/2,S=r(p),b=r(0);t.ZERO=b;var T=r(0,!0);t.UZERO=T;var C=r(1);t.ONE=C;var A=r(1,!0);t.UONE=A;var I=r(-1);t.NEG_ONE=I;var D=o(-1,2147483647,!1);t.MAX_VALUE=D;var F=o(-1,-1,!0);t.MAX_UNSIGNED_VALUE=F;var z=o(0,-2147483648,!1);t.MIN_VALUE=z;var k=t.prototype;return k.toInt=function(){return this.unsigned?this.low>>>0:this.low},k.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},k.toString=function(L){if(L=L||10,L<2||36<L)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(z)){var H=a(L),q=this.div(H),K=q.mul(H).sub(this);return q.toString(L)+K.toInt().toString(L)}else return"-"+this.neg().toString(L);for(var Y=a(l(L,6),this.unsigned),P=this,W="";;){var j=P.div(Y),st=P.sub(j.mul(Y)).toInt()>>>0,ot=st.toString(L);if(P=j,P.isZero())return ot+W;for(;ot.length<6;)ot="0"+ot;W=""+ot+W}},k.getHighBits=function(){return this.high},k.getHighBitsUnsigned=function(){return this.high>>>0},k.getLowBits=function(){return this.low},k.getLowBitsUnsigned=function(){return this.low>>>0},k.getNumBitsAbs=function(){if(this.isNegative())return this.eq(z)?64:this.neg().getNumBitsAbs();for(var L=this.high!=0?this.high:this.low,H=31;H>0&&(L&1<<H)==0;H--);return this.high!=0?H+33:H+1},k.isZero=function(){return this.high===0&&this.low===0},k.eqz=k.isZero,k.isNegative=function(){return!this.unsigned&&this.high<0},k.isPositive=function(){return this.unsigned||this.high>=0},k.isOdd=function(){return(this.low&1)===1},k.isEven=function(){return(this.low&1)===0},k.equals=function(L){return e(L)||(L=h(L)),this.unsigned!==L.unsigned&&this.high>>>31===1&&L.high>>>31===1?!1:this.high===L.high&&this.low===L.low},k.eq=k.equals,k.notEquals=function(L){return!this.eq(L)},k.neq=k.notEquals,k.ne=k.notEquals,k.lessThan=function(L){return this.comp(L)<0},k.lt=k.lessThan,k.lessThanOrEqual=function(L){return this.comp(L)<=0},k.lte=k.lessThanOrEqual,k.le=k.lessThanOrEqual,k.greaterThan=function(L){return this.comp(L)>0},k.gt=k.greaterThan,k.greaterThanOrEqual=function(L){return this.comp(L)>=0},k.gte=k.greaterThanOrEqual,k.ge=k.greaterThanOrEqual,k.compare=function(L){if(e(L)||(L=h(L)),this.eq(L))return 0;var H=this.isNegative(),q=L.isNegative();return H&&!q?-1:!H&&q?1:this.unsigned?L.high>>>0>this.high>>>0||L.high===this.high&&L.low>>>0>this.low>>>0?-1:1:this.sub(L).isNegative()?-1:1},k.comp=k.compare,k.negate=function(){return!this.unsigned&&this.eq(z)?z:this.not().add(C)},k.neg=k.negate,k.add=function(L){e(L)||(L=h(L));var H=this.high>>>16,q=this.high&65535,K=this.low>>>16,Y=this.low&65535,P=L.high>>>16,W=L.high&65535,j=L.low>>>16,st=L.low&65535,ot=0,X=0,it=0,ct=0;return ct+=Y+st,it+=ct>>>16,ct&=65535,it+=K+j,X+=it>>>16,it&=65535,X+=q+W,ot+=X>>>16,X&=65535,ot+=H+P,ot&=65535,o(it<<16|ct,ot<<16|X,this.unsigned)},k.subtract=function(L){return e(L)||(L=h(L)),this.add(L.neg())},k.sub=k.subtract,k.multiply=function(L){if(this.isZero())return b;if(e(L)||(L=h(L)),n){var H=n.mul(this.low,this.high,L.low,L.high);return o(H,n.get_high(),this.unsigned)}if(L.isZero())return b;if(this.eq(z))return L.isOdd()?z:b;if(L.eq(z))return this.isOdd()?z:b;if(this.isNegative())return L.isNegative()?this.neg().mul(L.neg()):this.neg().mul(L).neg();if(L.isNegative())return this.mul(L.neg()).neg();if(this.lt(S)&&L.lt(S))return a(this.toNumber()*L.toNumber(),this.unsigned);var q=this.high>>>16,K=this.high&65535,Y=this.low>>>16,P=this.low&65535,W=L.high>>>16,j=L.high&65535,st=L.low>>>16,ot=L.low&65535,X=0,it=0,ct=0,yt=0;return yt+=P*ot,ct+=yt>>>16,yt&=65535,ct+=Y*ot,it+=ct>>>16,ct&=65535,ct+=P*st,it+=ct>>>16,ct&=65535,it+=K*ot,X+=it>>>16,it&=65535,it+=Y*st,X+=it>>>16,it&=65535,it+=P*j,X+=it>>>16,it&=65535,X+=q*ot+K*st+Y*j+P*W,X&=65535,o(ct<<16|yt,X<<16|it,this.unsigned)},k.mul=k.multiply,k.divide=function(L){if(e(L)||(L=h(L)),L.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&L.low===-1&&L.high===-1)return this;var H=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,L.low,L.high);return o(H,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?T:b;var q,K,Y;if(this.unsigned){if(L.unsigned||(L=L.toUnsigned()),L.gt(this))return T;if(L.gt(this.shru(1)))return A;Y=T}else{if(this.eq(z)){if(L.eq(C)||L.eq(I))return z;if(L.eq(z))return C;var P=this.shr(1);return q=P.div(L).shl(1),q.eq(b)?L.isNegative()?C:I:(K=this.sub(L.mul(q)),Y=q.add(K.div(L)),Y)}else if(L.eq(z))return this.unsigned?T:b;if(this.isNegative())return L.isNegative()?this.neg().div(L.neg()):this.neg().div(L).neg();if(L.isNegative())return this.div(L.neg()).neg();Y=b}for(K=this;K.gte(L);){q=Math.max(1,Math.floor(K.toNumber()/L.toNumber()));for(var W=Math.ceil(Math.log(q)/Math.LN2),j=W<=48?1:l(2,W-48),st=a(q),ot=st.mul(L);ot.isNegative()||ot.gt(K);)q-=j,st=a(q,this.unsigned),ot=st.mul(L);st.isZero()&&(st=C),Y=Y.add(st),K=K.sub(ot)}return Y},k.div=k.divide,k.modulo=function(L){if(e(L)||(L=h(L)),n){var H=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,L.low,L.high);return o(H,n.get_high(),this.unsigned)}return this.sub(this.div(L).mul(L))},k.mod=k.modulo,k.rem=k.modulo,k.not=function(){return o(~this.low,~this.high,this.unsigned)},k.and=function(L){return e(L)||(L=h(L)),o(this.low&L.low,this.high&L.high,this.unsigned)},k.or=function(L){return e(L)||(L=h(L)),o(this.low|L.low,this.high|L.high,this.unsigned)},k.xor=function(L){return e(L)||(L=h(L)),o(this.low^L.low,this.high^L.high,this.unsigned)},k.shiftLeft=function(L){return e(L)&&(L=L.toInt()),(L&=63)===0?this:L<32?o(this.low<<L,this.high<<L|this.low>>>32-L,this.unsigned):o(0,this.low<<L-32,this.unsigned)},k.shl=k.shiftLeft,k.shiftRight=function(L){return e(L)&&(L=L.toInt()),(L&=63)===0?this:L<32?o(this.low>>>L|this.high<<32-L,this.high>>L,this.unsigned):o(this.high>>L-32,this.high>=0?0:-1,this.unsigned)},k.shr=k.shiftRight,k.shiftRightUnsigned=function(L){if(e(L)&&(L=L.toInt()),L&=63,L===0)return this;var H=this.high;if(L<32){var q=this.low;return o(q>>>L|H<<32-L,H>>>L,this.unsigned)}else return L===32?o(H,0,this.unsigned):o(H>>>L-32,0,this.unsigned)},k.shru=k.shiftRightUnsigned,k.shr_u=k.shiftRightUnsigned,k.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},k.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},k.toBytes=function(L){return L?this.toBytesLE():this.toBytesBE()},k.toBytesLE=function(){var L=this.high,H=this.low;return[H&255,H>>>8&255,H>>>16&255,H>>>24,L&255,L>>>8&255,L>>>16&255,L>>>24]},k.toBytesBE=function(){var L=this.high,H=this.low;return[L>>>24,L>>>16&255,L>>>8&255,L&255,H>>>24,H>>>16&255,H>>>8&255,H&255]},t.fromBytes=function(L,H,q){return q?t.fromBytesLE(L,H):t.fromBytesBE(L,H)},t.fromBytesLE=function(L,H){return new t(L[0]|L[1]<<8|L[2]<<16|L[3]<<24,L[4]|L[5]<<8|L[6]<<16|L[7]<<24,H)},t.fromBytesBE=function(L,H){return new t(L[4]<<24|L[5]<<16|L[6]<<8|L[7],L[0]<<24|L[1]<<16|L[2]<<8|L[3],H)},wI}var yG=srt();const xG=_x(yG),irt=zj({__proto__:null,default:xG},[yG]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fm=xG||irt;function GA(n){return Fm.fromString(n,!0,16)}const vG=GA("c3a5c85c97cb3127"),$m=GA("b492b66fbe98f273"),La=GA("9ae16a3b2f90404f");function AR(n){return n.xor(n.shru(47))}function bG(n,t,e){const s=n.slice(t,t+e);return Fm.fromBytes(Array.from(s),!0,!0)}function ni(n,t){return bG(n,t,8)}function nU(n,t){return bG(n,t,4)}function Rr(n,t){return t===0?n:n.shru(t).or(n.shl(64-t))}function Pd(n,t,e=GA("9ddfea08eb382d69")){let s=n.xor(t).mul(e);s=s.xor(s.shru(47));let i=t.xor(s).mul(e);return i=i.xor(i.shru(47)),i=i.mul(e),i}function rrt(n,t,e,s,i,r){i=i.add(n),r=Rr(r.add(i).add(s),21);const a=i;return i=i.add(t),i=i.add(e),r=r.add(Rr(i,44)),[i.add(s),r.add(a)]}function VT(n,t,e,s){return rrt(ni(n,t),ni(n,t+8),ni(n,t+16),ni(n,t+24),e,s)}function art(n,t=n.length){if(t>=8){const e=La.add(t*2),s=ni(n,0).add(La),i=ni(n,t-8),r=Rr(i,37).mul(e).add(s),a=Rr(s,25).add(i).mul(e);return Pd(r,a,e)}if(t>=4){const e=La.add(t*2),s=nU(n,0);return Pd(s.shl(3).add(t),nU(n,t-4),e)}if(t>0){const e=n[0],s=n[t>>1],i=n[t-1],r=e+(s<<8),a=t+(i<<2);return AR(La.mul(r).xor(vG.mul(a))).mul(La)}return La}function ort(n,t=n.length){const e=La.add(t*2),s=ni(n,0).mul($m),i=ni(n,8),r=ni(n,t-8).mul(e),a=ni(n,t-16).mul(La);return Pd(Rr(s.add(i),43).add(Rr(r,30)).add(a),s.add(Rr(i.add(La),18)).add(r),e)}function lrt(n,t=n.length){const e=La.add(t*2),s=ni(n,0).mul(La),i=ni(n,8),r=ni(n,t-8).mul(e),a=ni(n,t-16).mul(La),o=Rr(s.add(i),43).add(Rr(r,30)).add(a),l=Pd(o,s.add(Rr(i.add(La),18)).add(r),e),c=ni(n,16).mul(e),h=ni(n,24),f=o.add(ni(n,t-32)).mul(e),p=l.add(ni(n,t-24)).mul(e);return Pd(Rr(c.add(h),43).add(Rr(f,30)).add(p),c.add(Rr(h.add(s),18)).add(f),e)}function crt(n,t=n.length){const e=Fm.fromNumber(81,!0);if(t<=32)return t<=16?art(n,t):ort(n,t);if(t<=64)return lrt(n,t);let s=e,i=e.mul($m).add(113),r=AR(i.mul(La).add(113)).mul(La),a=[Fm.UZERO,Fm.UZERO],o=[Fm.UZERO,Fm.UZERO];s=s.mul(La).add(ni(n,0));let l=0;const c=(t-1>>6)*64,h=c+(t-1&63)-63;do s=Rr(s.add(i).add(a[0]).add(ni(n,l+8)),37).mul($m),i=Rr(i.add(a[1]).add(ni(n,l+48)),42).mul($m),s=s.xor(o[1]),i=i.add(a[0]).add(ni(n,l+40)),r=Rr(r.add(o[0]),33).mul($m),a=VT(n,l,a[1].mul($m),s.add(o[0])),o=VT(n,l+32,r.add(o[1]),i.add(ni(n,l+16))),[r,s]=[s,r],l+=64;while(l!==c);const f=$m.add(r.and(255).shl(1));return l=h,o[0]=o[0].add(t-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),s=Rr(s.add(i).add(a[0]).add(ni(n,l+8)),37).mul(f),i=Rr(i.add(a[1]).add(ni(n,l+48)),42).mul(f),s=s.xor(o[1].mul(9)),i=i.add(a[0].mul(9).add(ni(n,l+40))),r=Rr(r.add(o[0]),33).mul(f),a=VT(n,l,a[1].mul(f),s.add(o[0])),o=VT(n,l+32,r.add(o[1]),i.add(ni(n,l+16))),[r,s]=[s,r],Pd(Pd(a[0],o[0],f).add(AR(i).mul(vG)).add(r),Pd(a[1],o[1],f).add(s),f)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pp(n,t){return t==="string"?Vd(n):zg([n],t)}function urt(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function zg(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=fg(n)),Bt().getBool("DEBUG")&&Bit(n,t),urt(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){const e=new Uint8Array(n.length);for(let s=0;s<e.length;++s)Math.round(n[s])!==0&&(e[s]=1);return e}else throw new Error(`Unknown data type ${t}`)}function yo(){return Bt().platform.now()}function Vd(n,t="utf-8"){return t=t||"utf-8",Bt().platform.encode(n,t)}function Yd(n,t="utf-8"){return t=t||"utf-8",Bt().platform.decode(n,t)}function cc(n){return Bt().platform.isTypedArray!=null?Bt().platform.isTypedArray(n):gG(n)}function fg(n,t=[],e=!1){if(t==null&&(t=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||$3(n)||n==null||cc(n)&&e)t.push(n);else if(Array.isArray(n)||cc(n))for(let s=0;s<n.length;++s)fg(n[s],t,e);else{let s=-1;for(const i of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(i)&&(s=Math.max(s,Number(i)));for(let i=0;i<=s;i++)fg(n[i],t,e)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hrt=class{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new drt)}profileKernel(t,e,s){let i;const r=()=>{i=s()};let a;const o=yo();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(r);else{r();for(const c of i)c.dataSync();a=Promise.resolve({kernelMs:yo()-o})}if(Bt().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<i.length;c++){const h=i[c];h.data().then(f=>{frt(f,h.dtype,t)})}return{kernelName:t,outputs:i,inputs:e,timeMs:a.then(c=>c.kernelMs),extraInfo:a.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:s,timeMs:i,inputs:r,extraInfo:a}=t;s.forEach(o=>{Promise.all([o.data(),i,a]).then(l=>{this.logger.logKernelProfile(e,o,l[0],l[1],r,l[2])})})}};function frt(n,t,e){if(t!=="float32")return!1;for(let s=0;s<n.length;s++){const i=n[s];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${e}'`),!0}return!1}let drt=class{logKernelProfile(t,e,s,i,r,a){const o=typeof i=="number"?Gy(`${i}ms`,9):i.error,l=Gy(t,25),c=e.rank,h=e.size,f=Gy(e.shape.toString(),14);let p="";for(const g in r){const v=r[g];if(v!=null){const _=v.shape||e.shape,S=_.length;p+=`${g}: ${S}D ${S>0?_:""} `}}console.log(`%c${l}	%c${o}	%c${c}D ${f}	%c${h}	%c${p}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function prt(n,t,e){const s={},i={};for(let l=0;l<t.length;l++)s[t[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],h=c.inputs;for(const f in h){const p=h[f];let g=!1;for(let v=0;v<t.length;v++)if(s[p.id]){c.outputs.forEach(_=>s[_.id]=!0),g=!0,i[c.id]=!0;break}if(g)break}}const r={};r[e.id]=!0;const a={};for(let l=n.length-1;l>=0;l--){const c=n[l],h=c.inputs;for(let f=0;f<c.outputs.length;f++)if(r[c.outputs[f].id]){for(const p in h)r[h[p].id]=!0,a[c.id]=!0;break}}const o=[];for(let l=0;l<n.length;l++){const c=n[l];if(i[c.id]&&a[c.id]){const h={};for(const p in c.inputs){const g=c.inputs[p];s[g.id]&&(h[p]=g)}const f=Object.assign({},c);f.inputs=h,f.outputs=c.outputs,o.push(f)}}return o}function mrt(n,t,e,s){for(let i=t.length-1;i>=0;i--){const r=t[i],a=[];if(r.outputs.forEach(l=>{const c=n[l.id];c!=null?a.push(c):a.push(null)}),r.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${r.kernelName}.`);const o=r.gradient(a);for(const l in r.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const c=e(()=>o[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const h=r.inputs[l];if(!Is(c.shape,h.shape))throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${h.shape}'`);if(n[h.id]==null)n[h.id]=c;else{const f=n[h.id];n[h.id]=s(f,c),f.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sU=20,kb=3,TI=7;function grt(n,t,e,s){const i=ln(t),r=yrt(n,t,e,i),a=t.length,o=cE(n,t,e,i,r),l=["Tensor"];return s&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${a}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(c=>"    "+c).join(`
`)),l.join(`
`)}function yrt(n,t,e,s){const i=Zt(t),r=s[s.length-1],a=new Array(r).fill(0),o=t.length,l=e==="complex64"?Hb(n):n;if(o>1)for(let c=0;c<i/r;c++){const h=c*r;for(let f=0;f<r;f++)a[f]=Math.max(a[f],Gb(l[h+f],0,e).length)}return a}function Gb(n,t,e){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(TI))} + ${parseFloat(n[1].toFixed(TI))}j`:uS(n)?s=`'${n}'`:e==="bool"?s=SG(n):s=parseFloat(n.toFixed(TI)).toString(),Gy(s,t)}function SG(n){return n===0?"false":"true"}function cE(n,t,e,s,i,r=!0){const a=e==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(e==="complex64"){const _=Hb(n);return[Gb(_[0],0,e)]}return e==="bool"?[SG(n[0])]:[n[0].toString()]}if(l===1){if(o>sU){const S=kb*a;let b=Array.from(n.slice(0,S)),T=Array.from(n.slice((o-kb)*a,o*a));return e==="complex64"&&(b=Hb(b),T=Hb(T)),["["+b.map((C,A)=>Gb(C,i[A],e)).join(", ")+", ..., "+T.map((C,A)=>Gb(C,i[o-kb+A],e)).join(", ")+"]"]}return["["+(e==="complex64"?Hb(n):Array.from(n)).map((S,b)=>Gb(S,i[b],e)).join(", ")+"]"]}const c=t.slice(1),h=s.slice(1),f=s[0]*a,p=[];if(o>sU){for(let _=0;_<kb;_++){const S=_*f,b=S+f;p.push(...cE(n.slice(S,b),c,e,h,i,!1))}p.push("...");for(let _=o-kb;_<o;_++){const S=_*f,b=S+f;p.push(...cE(n.slice(S,b),c,e,h,i,_===o-1))}}else for(let _=0;_<o;_++){const S=_*f,b=S+f;p.push(...cE(n.slice(S,b),c,e,h,i,_===o-1))}const g=l===2?",":"";p[0]="["+(o>0?p[0]+g:"");for(let _=1;_<p.length-1;_++)p[_]=" "+p[_]+g;let v=`,
`;for(let _=2;_<l;_++)v+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(r?"":v),p}function Hb(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qr=class{constructor(t,e,s){if(this.dtype=e,this.shape=t.slice(),this.size=Zt(t),s!=null){const i=s.length;et(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Hi(e,this.size),this.strides=ln(t)}set(t,...e){e.length===0&&(e=[0]),et(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const s=this.locToIndex(e);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(const i of t){if(i<0||i>=this.shape[e]){const r=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(r)}e++}let s=t[t.length-1];for(let i=0;i<t.length-1;++i)s+=this.strides[i]*t[i];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let s=0;s<t.length-1;++s)e+=this.strides[s]*t[s];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const e=new Array(this.shape.length);for(let s=0;s<e.length-1;++s)e[s]=Math.floor(t/this.strides[s]),t-=e[s]*this.strides[s];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Xc().makeTensor(this.values,this.shape,this.dtype)}},Xc=null,Dy=null;function xrt(n){Xc=n}function vrt(n){Dy=n}let nr=class{constructor(t,e,s,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Zt(t),this.strides=ln(t),this.dataId=s,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Dy.buffer(this.shape,this.dtype,t)}bufferSync(){return Dy.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return eu(this.shape,t,this.dtype==="complex64")}arraySync(){return eu(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Xc().read(this.dataId);if(this.dtype==="string"){const e=await t;try{return e.map(s=>Yd(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Xc().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Xc().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>Yd(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Xc().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Xc().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Dy.print(this,t)}clone(){return this.throwIfDisposed(),Dy.clone(this)}toString(t=!1){const e=this.dataSync();return grt(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Dy.cast(this,t)}variable(t=!0,e,s){return this.throwIfDisposed(),Xc().makeVariable(this,t,e,s)}};Object.defineProperty(nr,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Kt(){return L3("Tensor",()=>nr)}Kt();let T2=class extends nr{constructor(t,e,s,i){super(t.shape,t.dtype,t.dataId,i),this.trainable=e,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Is(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Xc().disposeTensor(this),this.dataId=t.dataId,Xc().incRef(this,null)}dispose(){Xc().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(T2,Symbol.hasInstance,{value:n=>n instanceof nr&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var iU;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(iU||(iU={}));var NR;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(NR||(NR={}));var MR;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(MR||(MR={}));var IR;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(IR||(IR={}));var RR;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(RR||(RR={}));const brt={float32:IR,int32:NR,bool:MR,complex64:RR};function Jo(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return brt[n][t]}function Tk(n){return Jo(n,"int32")}function _G(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function wG(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xi(n,t){if(n.dtype===t.dtype)return[n,t];const e=Jo(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function TG(n){const t=[];return EG(n,t,new Set),t}function EG(n,t,e){if(n==null)return;if(n instanceof nr){t.push(n);return}if(!Srt(n))return;const s=n;for(const i in s){const r=s[i];e.has(r)||(e.add(r),EG(r,t,e))}}function Srt(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(n){return n.kernelName!=null}let rU=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}},Ek=class DR{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new rU}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,s=1){return t in this.registryFactory?(bl(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:e,asyncInit:s}=this.initializeBackend(t);if(!(s?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new hrt(this.backendInstance),!0}setupRegisteredKernels(){tU(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){tU(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=e.factory();if(s&&!(s instanceof R3)&&typeof s.then=="function"){const i=++this.pendingBackendInitId,r=s.then(a=>i<this.pendingBackendInitId?!1:(this.registry[t]=a,this.pendingBackendInit=null,!0)).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,bl(`Initialization of backend ${t} failed`),bl(a.stack||a.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return bl(`Initialization of backend ${t} failed`),bl(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e],{success:i,asyncInit:r}=this.initializeBackend(s);if(r||i)return{name:s,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const s=this.state.tensorInfo.get(e),i=s.backend,r=this.readSync(e),a=i.refCount(e);i.disposeData(e,!0),s.backend=t,t.move(e,r,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let s=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let i;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=e(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(t,e,s){t();try{const i=s();return e(),i}catch(i){throw e(),i}}nextTensorId(){return DR.nextTensorId++}nextVariableId(){return DR.nextVariableId++}clone(t){const e=wt.runKernel(RS,{x:t}),s={x:t},i=a=>({x:()=>{const o="float32",l={x:a},c={dtype:o};return wt.runKernel(xS,l,c)}}),r=[];return this.addTapeNode(this.state.activeScope.name,s,[e],i,r,{}),e}runKernel(t,e,s){if(this.backendName==null&&this.backend,!(Qz(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,s){const i=this.backend.numDataIds();let r=0;s.forEach(l=>{r+=l.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=i-e-r-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let e,s=[];const i=this.isTapeOn(),r=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const c=EI(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(EI(t)){const{kernelName:v,inputs:_,attrs:S}=t;this.backendName==null&&this.backend;const b=Qz(v,this.backendName);et(b!=null,()=>`Cannot find registered kernel '${v}' for backend '${this.backendName}'`),o=()=>{const T=this.backend.numDataIds();l=b.kernelFunc({inputs:_,attrs:S,backend:this.backend});const C=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(v,T,C);const A=C.map(I=>I.rank!=null?I:this.makeTensorFromTensorInfo(I));if(i){const I=this.getTensorsForGradient(v,_,A);s=this.saveTensorsForBackwardMode(I)}return A}}else{const{forwardFunc:v}=t,_=S=>{i&&(s=S.map(b=>this.keep(this.clone(b))))};o=()=>{const S=this.backend.numDataIds();l=this.tidy(()=>v(this.backend,_));const b=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,S,b),b}}const{inputs:h,attrs:f}=t,p=EI(t)?null:t.backwardsFunc;let g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=o():(g=this.profiler.profileKernel(c,h,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),e=g.outputs)}),i&&this.addTapeNode(c,h,e,p,s,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(v=>h[v]!=null?h[v].shape:null),outputShapes:e.map(v=>v.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(l)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,e,s){const i=Jz(t);if(i!=null){const r=i.inputsToSave||[],a=i.outputsToSave||[];let o;i.saveAllInputs?(et(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(e).map(c=>e[c])):o=r.map(c=>e[c]);const l=s.filter((c,h)=>a[h]);return o.concat(l)}return[]}makeTensor(t,e,s,i){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",i=i||this.backend;let r=t;s==="string"&&uS(t[0])&&(r=t.map(l=>Vd(l)));const a=i.write(r,e,s),o=new nr(e,s,a,this.nextTensorId());if(this.trackTensor(o,i),s==="string"){const l=this.state.tensorInfo.get(a),c=Vit(r);this.state.numBytes+=c-l.bytes,l.bytes=c}return o}makeTensorFromDataId(t,e,s,i){s=s||"float32";const r={dataId:t,shape:e,dtype:s};return this.makeTensorFromTensorInfo(r,i)}makeTensorFromTensorInfo(t,e){const{dataId:s,shape:i,dtype:r}=t,a=new nr(i,r,s,this.nextTensorId());return this.trackTensor(a,e),a}makeVariable(t,e=!0,s,i){s=s||this.nextVariableId().toString(),i!=null&&i!==t.dtype&&(t=t.cast(i));const r=new T2(t,e,s,this.nextTensorId());if(this.state.registeredVariables[r.name]!=null)throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*b2(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof T2||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*b2(t.dtype);this.state.numBytes-=s}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,s,i,r,a){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:s,saved:r},l=Jz(t);l!=null&&(i=l.gradFunc),i!=null&&(o.gradient=c=>(c=c.map((h,f)=>{if(h==null){const p=s[f],g=ga(p.size,p.dtype);return this.makeTensor(g,p.shape,p.dtype)}return h}),i(c.length>1?c:c[0],r,a))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=TG(t),s=new Set(e.map(r=>r.id));for(let r=0;r<this.state.activeScope.track.length;r++){const a=this.state.activeScope.track[r];!a.kept&&!s.has(a.id)&&a.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(r=>{!r.kept&&r.scopeId===i.id&&this.track(r)})}gradients(t,e,s,i=!1){if(et(e.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));et(r instanceof nr,()=>"The result y returned by f() must be a tensor.");const a=prt(this.state.activeTape,e,r);if(!i&&a.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[r.id]=s??_rt(r.shape),mrt(o,a,c=>this.tidy(c),wrt);const l=e.map(c=>o[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const h of c.saved)h.dispose()}),this.state.activeTape=null),{value:r,grads:l}})}customGrad(t){return et(_R(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{et(e.every(o=>o instanceof nr),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const i={};e.forEach((o,l)=>{i[l]=o});const r=(o,l)=>(s=t(...e,l),et(s.value instanceof nr,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),et(_R(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(o,l)=>{const c=s.gradFunc(o,l),h=Array.isArray(c)?c:[c];et(h.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),et(h.every(p=>p instanceof nr),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};return h.forEach((p,g)=>{f[g]=()=>p}),f};return this.runKernelFunc({forwardFunc:r,backwardsFunc:a,inputs:i})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=yo(),s=await this.backend.time(t);return s.wallMs=yo()-e,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new rU;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Ek.nextTensorId=0;Ek.nextVariableId=0;function _rt(n){const t=O3(Zt(n),"float32");return wt.makeTensor(t,n,"float32")}function CG(){const n=qV();if(n._tfengine==null){const t=new Wit(n);n._tfengine=new Ek(t)}return Kit(n._tfengine.ENV),xrt(()=>n._tfengine),n._tfengine}const wt=CG();function wrt(n,t){const e={a:n,b:t};return wt.runKernel(Ix,e)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Trt(){return typeof navigator<"u"&&navigator!=null}function AG(n){if(n||Trt()){if(n||(n=navigator),n.product==="ReactNative")return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function NG(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const To=Bt();To.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});To.registerFlag("IS_BROWSER",()=>NG());To.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");To.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));To.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));To.registerFlag("PROD",()=>!1);To.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>To.getBool("DEBUG"));To.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);To.registerFlag("IS_TEST",()=>!1);To.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>To.getBool("DEBUG"));To.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);To.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);To.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HA(n,t){let e=n;if(cc(n))return t==="string"?[]:[n.length];if(_G(n)){const i=n.channels||"RGBA";return[n.height,n.width*i.length]}else if(wG(n))return[n.buffer.size/(t==null?4:b2(t))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(e)||cc(e)&&t!=="string";)s.push(e.length),e=e[0];return Array.isArray(n)&&Bt().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&MG(n,s,[]),s}function MG(n,t,e){if(e=e||[],!Array.isArray(n)&&!cc(n)){et(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}et(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),et(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const s=t.slice(1);for(let i=0;i<n.length;++i)MG(n[i],s,e.concat(i))}function aU(n,t,e,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`)}}function ht(n,t,e,s="numeric"){if(n instanceof nr)return aU(s,n.dtype,t,e),n;let i=Nx(n);if(i!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(i=s),aU(s,i,t,e),n==null||!cc(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${l}'`)}const r=HA(n,i);!cc(n)&&!Array.isArray(n)&&(n=[n]);const o=i!=="string"?zg(n,i):fg(n,[],!0);return wt.makeTensor(o,r,i)}function IG(n,t,e,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((r,a)=>ht(r,`${t}[${a}]`,e,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ert="__op";function At(n){const t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const s=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+Ert;const i=(...r)=>{wt.startScope(e);try{const a=s(...r);return $3(a)&&console.error("Cannot return a Promise inside of tidy."),wt.endScope(a),a}catch(a){throw wt.endScope(null),a}};return Object.defineProperty(i,"name",{value:e,configurable:!0}),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Crt(n,t){const e=ht(n,"real","complex"),s=ht(t,"imag","complex");k3(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`);const i={real:e,imag:s};return wt.runKernel(H3,i)}const cx=At({complex_:Crt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WA(n,t,e,s){if(s==null)s=Nx(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(wG(n)||_G(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return wt.backend.createTensorFromGPUData(n,t||e,s)}if(!cc(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){kf(t);const i=Zt(t),r=Zt(e);et(i===r,()=>`Based on the provided shape, [${t}], the tensor should have ${i} values but has ${r}`);for(let a=0;a<e.length;++a){const o=e[a],l=a===e.length-1?o!==Zt(t.slice(a)):!0;et(e[a]===t[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!cc(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n=s!=="string"?zg(n,s):fg(n,[],!0),wt.makeTensor(n,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RG(n,t,e){const s=HA(n,e);return WA(n,t,s,e)}let qA=class DG{static join(t){return new DG(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(s=>cc(s)?s.buffer:s),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let s=0;s<t.length;s++){const i=t[s];s!==t.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=e+i.byteLength;this.shards.push({buffer:i,start:e,end:r}),e=r}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(s===-1)throw new Error(`Could not find start shard for byte ${t}`);const i=e-t,r=new ArrayBuffer(i),a=new Uint8Array(r);let o=0;for(let l=s;l<this.shards.length;l++){const c=this.shards[l],f=t+o-c.start,p=o,v=Math.min(e,c.end)-c.start,_=new Uint8Array(c.buffer,f,v-f);if(a.set(_,p),o+=_.length,e<c.end)break}return r}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(i){return t<i.start?-1:t>=i.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=Art(this.shards,e);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}};function Art(n,t){let e=0,s=n.length;for(;e<=s;){const i=Math.floor((s-e)/2)+e,r=t(n[i]);if(r===0)return i;r<0?s=i:e=i+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oU=4;async function lU(n,t){const e=[],s=[],i=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<i.length;++a){const o=i[a],l=Array.isArray(n)?n[a].tensor:n[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const c={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const h=new Promise(async f=>{const p=await l.bytes(),g=p.reduce((S,b)=>S+b.length,0)+oU*p.length,v=new Uint8Array(g);let _=0;for(let S=0;S<p.length;S++){const b=p[S],T=new Uint8Array(new Uint32Array([b.length]).buffer);v.set(T,_),_+=oU,v.set(b,_),_+=b.length}f(v)});s.push(h)}else s.push(l.data());t!=null&&(c.group=t),e.push(c)}const r=await Promise.all(s);return{data:Nrt(r),specs:e}}function Nrt(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(r=>{if(t+=r.byteLength,e.push(r.byteLength===r.buffer.byteLength?r:new r.constructor(r)),!(r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${r.constructor.name}`)});const s=new Uint8Array(t);let i=0;return e.forEach(r=>{s.set(new Uint8Array(r.buffer),i),i+=r.byteLength}),s.buffer}const Ck=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function cU(n){return Ck?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function Mrt(n){if(Ck)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let s=0,i=t.length;s<i;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function Irt(n){if(Ck){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let s=0;s<t.length;++s)e.set([t.charCodeAt(s)],s);return e.buffer}function Rrt(n){return qA.join(n)}function kG(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:cU(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:cU(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new qA(n.weightData).byteLength}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let a_=class Hc{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Hc.instance==null&&(Hc.instance=new Hc),Hc.instance}static registerSaveRouter(t){Hc.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Hc.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Hc.getHandlers(t,"save")}static getLoadHandlers(t,e){return Hc.getHandlers(t,"load",e)}static getHandlers(t,e,s){const i=[];return(e==="load"?Hc.getInstance().loadRouters:Hc.getInstance().saveRouters).forEach(a=>{const o=a(t,s);o!==null&&i.push(o)}),i}};const Drt=n=>a_.getSaveHandlers(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kR="tensorflowjs",OR=1,qm="models_store",Ld="model_info_store";function OG(){if(!Bt().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function $R(n){const t=n.result;t.createObjectStore(qm,{keyPath:"modelPath"}),t.createObjectStore(Ld,{keyPath:"modelPath"})}let dg=class{constructor(t){if(this.indexedDB=OG(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((s,i)=>{const r=this.indexedDB.open(kR,OR);r.onupgradeneeded=()=>$R(r),r.onsuccess=()=>{const a=r.result;if(e==null){const o=a.transaction(qm,"readonly"),c=o.objectStore(qm).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return a.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=h=>(a.close(),i(c.error)),o.oncomplete=()=>a.close()}else{e.weightData=qA.join(e.weightData);const o=kG(e),l=a.transaction(Ld,"readwrite");let c=l.objectStore(Ld),h;try{h=c.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(p){return i(p)}let f;h.onsuccess=()=>{f=a.transaction(qm,"readwrite");const p=f.objectStore(qm);let g;try{g=p.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:o})}catch(v){return i(v)}g.onsuccess=()=>s({modelArtifactsInfo:o}),g.onerror=v=>{c=l.objectStore(Ld);const _=c.delete(this.modelPath);_.onsuccess=()=>(a.close(),i(g.error)),_.onerror=S=>(a.close(),i(g.error))}},h.onerror=p=>(a.close(),i(h.error)),l.oncomplete=()=>{f==null?a.close():f.oncomplete=()=>a.close()}}},r.onerror=a=>i(r.error)})}};dg.URL_SCHEME="indexeddb://";const $G=n=>Bt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(dg.URL_SCHEME)?krt(n.slice(dg.URL_SCHEME.length)):null;a_.registerSaveRouter($G);a_.registerLoadRouter($G);function krt(n){return new dg(n)}function Ort(n){return n.startsWith(dg.URL_SCHEME)?n.slice(dg.URL_SCHEME.length):n}let $rt=class{constructor(){this.indexedDB=OG()}async listModels(){return new Promise((t,e)=>{const s=this.indexedDB.open(kR,OR);s.onupgradeneeded=()=>$R(s),s.onsuccess=()=>{const i=s.result,r=i.transaction(Ld,"readonly"),o=r.objectStore(Ld).getAll();o.onsuccess=()=>{const l={};for(const c of o.result)l[c.modelPath]=c.modelArtifactsInfo;t(l)},o.onerror=l=>(i.close(),e(o.error)),r.oncomplete=()=>i.close()},s.onerror=i=>e(s.error)})}async removeModel(t){return t=Ort(t),new Promise((e,s)=>{const i=this.indexedDB.open(kR,OR);i.onupgradeneeded=()=>$R(i),i.onsuccess=()=>{const r=i.result,a=r.transaction(Ld,"readwrite"),o=a.objectStore(Ld),l=o.get(t);let c;l.onsuccess=()=>{if(l.result==null)return r.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const h=o.delete(t),f=()=>{c=r.transaction(qm,"readwrite");const g=c.objectStore(qm).delete(t);g.onsuccess=()=>e(l.result.modelArtifactsInfo),g.onerror=v=>s(l.error)};h.onsuccess=f,h.onerror=p=>(f(),r.close(),s(l.error))}},l.onerror=h=>(r.close(),s(l.error)),a.oncomplete=()=>{c==null?r.close():c.oncomplete=()=>r.close()}},i.onerror=r=>s(i.error)})}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yf="/",ky="tensorflowjs_models",LG="info",Lrt="model_topology",Frt="weight_specs",zrt="weight_data",Urt="model_metadata";function FG(n){return{info:[ky,n,LG].join(yf),topology:[ky,n,Lrt].join(yf),weightSpecs:[ky,n,Frt].join(yf),weightData:[ky,n,zrt].join(yf),modelMetadata:[ky,n,Urt].join(yf)}}function zG(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function Brt(n){const t=n.split(yf);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(yf)}function Prt(n){return n.startsWith(pg.URL_SCHEME)?n.slice(pg.URL_SCHEME.length):n}let pg=class{constructor(t){if(!Bt().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=FG(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),i=kG(t),r=qA.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,Mrt(r));const a={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:i}}catch{throw zG(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=s;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=i;const r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){const o=JSON.parse(r);e.format=o.format,e.generatedBy=o.generatedBy,e.convertedBy=o.convertedBy,o.signature!=null&&(e.signature=o.signature),o.userDefinedMetadata!=null&&(e.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(e.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(e.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(e.trainingConfig=o.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=Irt(a),e}};pg.URL_SCHEME="localstorage://";const UG=n=>Bt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(pg.URL_SCHEME)?Vrt(n.slice(pg.URL_SCHEME.length)):null;a_.registerSaveRouter(UG);a_.registerLoadRouter(UG);function Vrt(n){return new pg(n)}let Grt=class{constructor(){et(Bt().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),et(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=ky+yf,s=yf+LG;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);if(r.startsWith(e)&&r.endsWith(s)){const a=Brt(r);t[a]=JSON.parse(this.LS.getItem(r))}}return t}async removeModel(t){t=Prt(t);const e=FG(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(e.info));return zG(e),s}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uU="://";let hU=class Id{constructor(){this.managers={}}static getInstance(){return Id.instance==null&&(Id.instance=new Id),Id.instance}static registerManager(t,e){et(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(uU)&&(t=t.slice(0,t.indexOf(uU))),et(t.length>0,()=>"scheme must not be an empty string.");const s=Id.getInstance();et(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=e}static getManager(t){const e=Id.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(Id.getInstance().managers)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Hrt=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window>"u"||!Bt().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const i=this.functionRefs[s.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return gG(t)}};if(Bt().get("IS_BROWSER")){Bt().setPlatform("browser",new Hrt);try{hU.registerManager(pg.URL_SCHEME,new Grt)}catch{}try{hU.registerManager(dg.URL_SCHEME,new $rt)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wrt={importFetch:()=>require("node-fetch")};let CI,qrt=class{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return Bt().global.fetch!=null?Bt().global.fetch(t,e):(CI==null&&(CI=Wrt.importFetch()),CI(t,e))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}};Bt().get("IS_NODE")&&!Bt().get("IS_BROWSER")&&Bt().setPlatform("node",new qrt);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hn(n,t="float32",e){return t=t||"float32",kf(n),new Qr(n,t,e)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xrt(n,t){const e=ht(n,"x","cast");if(!Pit(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:e},i={dtype:t};return wt.runKernel(xS,s,i)}const Ge=At({cast_:Xrt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jrt(n){const e={x:ht(n,"x","clone","string_or_numeric")};return wt.runKernel(RS,e)}const tg=At({clone_:jrt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Krt(n,t=!1){console.log(n.toString(t))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */CG();const Yrt={buffer:Hn,cast:Ge,clone:tg,print:Krt};vrt(Yrt);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yu(){return wt}function fU(){return wt.memory()}function Lt(n,t){return wt.tidy(n,t)}function Xn(n){TG(n).forEach(e=>e.dispose())}function oh(n){return wt.keep(n)}function Zrt(){return wt.ready()}function BG(n,t,e=1){return wt.registerBackend(n,t,e)}function Qrt(){return wt.backend}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jrt(n,t){let e=ht(n,"a","add"),s=ht(t,"b","add");[e,s]=Xi(e,s);const i={a:e,b:s};return wt.runKernel(Ix,i)}const _e=At({add_:Jrt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tat(n,t){let e=ht(n,"a","floorDiv"),s=ht(t,"b","floorDiv");[e,s]=Xi(e,s);const i={a:e,b:s};return wt.runKernel(MS,i)}const PG=At({floorDiv_:tat});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eat(n,t){let e=ht(n,"a","div"),s=ht(t,"b","div");if([e,s]=Xi(e,s),e.dtype==="int32"&&s.dtype==="int32")return PG(e,s);const i={a:e,b:s},r={};return wt.runKernel(wS,i,r)}const pn=At({div_:eat});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nat(n,t){let e=ht(n,"a","mul"),s=ht(t,"b","mul");[e,s]=Xi(e,s);const i={a:e,b:s};return wt.runKernel(BS,i)}const Tt=At({mul_:nat});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sat(n){const t=ht(n,"x","abs");if(t.dtype==="complex64"){const e={x:t};return wt.runKernel(YC,e)}else{const e={x:t};return wt.runKernel(GC,e)}}const Oa=At({abs_:sat});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iat(n){const e={x:ht(n,"x","acos")};return wt.runKernel(hS,e)}const rat=At({acos_:iat});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aat(n){const e={x:ht(n,"x","acosh")};return wt.runKernel(fS,e)}const oat=At({acosh_:aat});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lat(n,t=null,e=!1){const i={x:ht(n,"x","all","bool")},r={axis:t,keepDims:e};return wt.runKernel(z3,i,r)}const VG=At({all_:lat});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cat(n,t=null,e=!1){const i={x:ht(n,"x","any","bool")},r={axis:t,keepDims:e};return wt.runKernel(U3,i,r)}const LR=At({any_:cat});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uat(n,t=0){const s={x:ht(n,"x","argMax")},i={axis:t};return wt.runKernel(HC,s,i)}const R1=At({argMax_:uat});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hat(n,t=0){const s={x:ht(n,"x","argMin")},i={axis:t};return wt.runKernel(WC,s,i)}const fat=At({argMin_:hat});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dat(n){const e={x:ht(n,"x","asin")};return wt.runKernel(dS,e)}const pat=At({asin_:dat});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mat(n){const e={x:ht(n,"x","asinh")};return wt.runKernel(pS,e)}const gat=At({asinh_:mat});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yat(n){const e={x:ht(n,"x","atan")};return wt.runKernel(mS,e)}const xat=At({atan_:yat});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vat(n,t){let e=ht(n,"a","atan2"),s=ht(t,"b","atan2");[e,s]=Xi(e,s);const i={a:e,b:s};return wt.runKernel(yS,i)}const bat=At({atan2_:vat});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sat(n){const e={x:ht(n,"x","atanh")};return wt.runKernel(gS,e)}const _at=At({atanh_:Sat});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o_(n,t,e,s,i="NHWC",r){const a=n[3],o=[...t,a],l=$f(i);return ta(n,o,e,r,s,null,null,l)}function dc(n,t,e,s,i,r,a="channelsLast"){const[o,l]=D1(t);let c;if(a==="channelsLast")c=[o,l,n[3],n[3]];else if(a==="channelsFirst")c=[o,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return ta(n,c,e,s,i,r,!1,a)}function Of(n,t,e,s,i,r,a="NDHWC"){const[o,l,c]=FR(t);let h,f;if(a==="NDHWC")f="channelsLast",h=[o,l,c,n[4],n[4]];else if(a==="NCDHW")f="channelsFirst",h=[o,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return mp(n,h,e,s,i,!1,f,r)}function ta(n,t,e,s,i,r,a=!1,o="channelsLast"){let[l,c,h,f]=[-1,-1,-1,-1];if(o==="channelsLast")[l,c,h,f]=n;else if(o==="channelsFirst")[l,f,c,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[p,g,,v]=t,[_,S]=D1(e),[b,T]=D1(s),C=Wy(p,b),A=Wy(g,T),{padInfo:I,outHeight:D,outWidth:F}=Eat(i,c,h,_,S,C,A,r,o),z=a?v*f:v;let k;return o==="channelsFirst"?k=[l,z,D,F]:o==="channelsLast"&&(k=[l,D,F,z]),{batchSize:l,dataFormat:o,inHeight:c,inWidth:h,inChannels:f,outHeight:D,outWidth:F,outChannels:z,padInfo:I,strideHeight:_,strideWidth:S,filterHeight:p,filterWidth:g,effectiveFilterHeight:C,effectiveFilterWidth:A,dilationHeight:b,dilationWidth:T,inShape:n,outShape:k,filterShape:t}}function mp(n,t,e,s,i,r=!1,a="channelsLast",o){let[l,c,h,f,p]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,c,h,f,p]=n;else if(a==="channelsFirst")[l,p,c,h,f]=n;else throw new Error(`Unknown dataFormat ${a}`);const[g,v,_,,S]=t,[b,T,C]=FR(e),[A,I,D]=FR(s),F=Wy(g,A),z=Wy(v,I),k=Wy(_,D),{padInfo:O,outDepth:L,outHeight:H,outWidth:q}=Cat(i,c,h,f,b,T,C,F,z,k,o),K=r?S*p:S;let Y;return a==="channelsFirst"?Y=[l,K,L,H,q]:a==="channelsLast"&&(Y=[l,L,H,q,K]),{batchSize:l,dataFormat:a,inDepth:c,inHeight:h,inWidth:f,inChannels:p,outDepth:L,outHeight:H,outWidth:q,outChannels:K,padInfo:O,strideDepth:b,strideHeight:T,strideWidth:C,filterDepth:g,filterHeight:v,filterWidth:_,effectiveFilterDepth:F,effectiveFilterHeight:z,effectiveFilterWidth:k,dilationDepth:A,dilationHeight:I,dilationWidth:D,inShape:n,outShape:Y,filterShape:t}}function wat(n,t,e,s,i){s==null&&(s=Ak(n,t,e));const r=n[0],a=n[1],o=k1((r-t+2*s)/e+1,i),l=k1((a-t+2*s)/e+1,i);return[o,l]}function Tat(n,t,e,s,i,r){i==null&&(i=Ak(n,t[0],s[0]));const a=[0,0,0,e];for(let o=0;o<3;o++)n[o]+2*i>=t[o]&&(a[o]=k1((n[o]-t[o]+2*i)/s[o]+1,r));return a}function Ak(n,t,e,s=1){const i=Wy(t,s);return Math.floor((n[0]*(e-1)-e+i)/2)}function D1(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function FR(n){return typeof n=="number"?[n,n,n]:n}function Wy(n,t){return t<=1?n:n+(n-1)*(t-1)}function Eat(n,t,e,s,i,r,a,o,l){let c,h,f;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const g=wat([t,e],r,s,n,o);h=g[0],f=g[1]}else if(n==="same"){h=Math.ceil(t/s),f=Math.ceil(e/i);const p=Math.max(0,(h-1)*s+r-t),g=Math.max(0,(f-1)*i+a-e),v=Math.floor(p/2),_=p-v,S=Math.floor(g/2),b=g-S;c={top:v,bottom:_,left:S,right:b,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((t-r+1)/s),f=Math.ceil((e-a+1)/i);else if(typeof n=="object"){const p=l==="channelsLast"?n[1][0]:n[2][0],g=l==="channelsLast"?n[1][1]:n[2][1],v=l==="channelsLast"?n[2][0]:n[3][0],_=l==="channelsLast"?n[2][1]:n[3][1];c={top:p,bottom:g,left:v,right:_,type:p===0&&g===0&&v===0&&_===0?"VALID":"EXPLICIT"},h=k1((t-r+p+g)/s+1,o),f=k1((e-a+v+_)/i+1,o)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:h,outWidth:f}}function Cat(n,t,e,s,i,r,a,o,l,c,h){let f,p,g,v;if(n==="valid"&&(n=0),typeof n=="number"){f={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const S=Tat([t,e,s,1],[o,l,c],1,[i,r,a],n,h);p=S[0],g=S[1],v=S[2]}else if(n==="same"){p=Math.ceil(t/i),g=Math.ceil(e/r),v=Math.ceil(s/a);const _=(p-1)*i+o-t,S=(g-1)*r+l-e,b=(v-1)*a+c-s,T=Math.floor(_/2),C=_-T,A=Math.floor(S/2),I=S-A,D=Math.floor(b/2),F=b-D;f={top:A,bottom:I,left:D,right:F,front:T,back:C,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:f,outDepth:p,outHeight:g,outWidth:v}}function k1(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function mg(n){const[t,e,s]=D1(n);return t===1&&e===1&&s===1}function ya(n,t){return mg(n)||mg(t)}function gg(n){return D1(n).every(t=>t>0)}function $f(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function No(n,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")et(lx(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(i=>{et(lx(i),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${i}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${t}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aat(n,t){const s={x:ht(n,"x","reshape","string_or_numeric")},i={shape:t};return wt.runKernel(IA,s,i)}const Ct=At({reshape_:Aat});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nat(n,t,e,s,i){const r=ht(n,"x","avgPool","float32"),a=1;et(ya(e,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`);let o=r,l=!1;r.rank===3&&(l=!0,o=Ct(r,[1,r.shape[0],r.shape[1],r.shape[2]])),et(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),No("avgPool",s,i);const c={x:o},h={filterSize:t,strides:e,pad:s,dimRoundingMode:i};let f=wt.runKernel(qC,c,h);return f=Ge(f,r.dtype),l?Ct(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Nk=At({avgPool_:Nat});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mat(n,t,e,s,i,r="NDHWC"){const a=ht(n,"x","avgPool3d","float32");let o=a,l=!1;a.rank===4&&(l=!0,o=Ct(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),et(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),et(r==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),et(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),No("avgPool3d",s,i);const c={x:o},h={filterSize:t,strides:e,pad:s,dimRoundingMode:i,dataFormat:r};let f=wt.runKernel(XC,c,h);return f=Ge(f,o.dtype),l?Ct(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const Iat=At({avgPool3d_:Mat});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rat(n,t=0){et(n.length>=1,()=>"Pass at least one tensor to concat");const e=IG(n,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(r=>{if(r.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${r.dtype}. `)}),e.length===1)return tg(e[0]);const s=e,i={axis:t};return wt.runKernel(ZC,s,i)}const _o=At({concat_:Rat});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dat(n,t,e=!1,s=!1){let i=ht(n,"a","matMul"),r=ht(t,"b","matMul");[i,r]=Xi(i,r);const a={a:i,b:r},o={transposeA:e,transposeB:s};return wt.runKernel(jC,a,o)}const Ns=At({matMul_:Dat});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kat(n){const e={x:ht(n,"x","sigmoid","float32")};return wt.runKernel(ZS,e)}const Rx=At({sigmoid_:kat});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oat(n,t,e){const s=ht(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const i={x:s},r={begin:t,size:e};return wt.runKernel($A,i,r)}const si=At({slice_:Oat});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $at(n){const e={x:ht(n,"x","tanh","float32")};return wt.runKernel(s_,e)}const Mk=At({tanh_:$at});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lat(n,t,e){const s=ht(n,"x","batchToSpaceND"),i=t.reduce((o,l)=>o*l);et(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),et(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),et(s.shape[0]%i===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${i}`);const r={x:s},a={blockShape:t,crops:e};return wt.runKernel(KC,r,a)}const Ik=At({batchToSpaceND_:Lat});function Fat(n){let t;return n.rank===0||n.rank===1?t=Ct(n,[1,1,1,n.size]):n.rank===2?t=Ct(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?t=Ct(n,[1,n.shape[0],n.shape[1],n.shape[2]]):t=n,t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zat(n,t,e,s,i,r){r==null&&(r=.001);const a=ht(n,"x","batchNorm"),o=ht(t,"mean","batchNorm"),l=ht(e,"variance","batchNorm");let c;i!=null&&(c=ht(i,"scale","batchNorm"));let h;s!=null&&(h=ht(s,"offset","batchNorm")),et(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),et(h==null||o.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),et(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:Fat(a),scale:c,offset:h,mean:o,variance:l},g={varianceEpsilon:r},v=wt.runKernel(aA,p,g);return Ct(v,a.shape)}const XA=At({batchNorm_:zat});function Uat(n,t,e,s,i,r){const a=ht(n,"x","batchNorm"),o=ht(t,"mean","batchNorm"),l=ht(e,"variance","batchNorm");let c;i!=null&&(c=ht(i,"scale","batchNorm"));let h;return s!=null&&(h=ht(s,"offset","batchNorm")),et(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),et(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),et(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&et(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&et(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),XA(a,o,l,h,c,r)}const Bat=At({batchNorm2d_:Uat});function Pat(n,t,e,s,i,r){const a=ht(n,"x","batchNorm"),o=ht(t,"mean","batchNorm"),l=ht(e,"variance","batchNorm");let c;i!=null&&(c=ht(i,"scale","batchNorm"));let h;return s!=null&&(h=ht(s,"offset","batchNorm")),et(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),et(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),et(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&et(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&et(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),XA(a,o,l,h,c,r)}const Vat=At({batchNorm3d_:Pat});function Gat(n,t,e,s,i,r){const a=ht(n,"x","batchNorm"),o=ht(t,"mean","batchNorm"),l=ht(e,"variance","batchNorm");let c;i!=null&&(c=ht(i,"scale","batchNorm"));let h;return s!=null&&(h=ht(s,"offset","batchNorm")),et(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),et(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),et(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&et(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&et(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),XA(a,o,l,h,c,r)}const Hat=At({batchNorm4d_:Gat});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wat(n,t,e){const s=ht(n,"x","bincount"),i=ht(t,"weights","bincount");et(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),et(e>=0,()=>`size must be non-negative, but got ${e}.`),et(i.size===s.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);const r={x:s,weights:i},a={size:e};return wt.runKernel(V3,r,a)}const qat=At({bincount_:Wat});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xat(n,t){let e=ht(n,"broadcastTo","x");const s=e.shape;if(kf(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const c=e.shape.slice();for(;c.length<t.length;)c.unshift(1);e=Ct(e,c)}const i=e.shape,r=Array.from(t);for(let c=t.length-1;c>=0;c--)if(i[c]===t[c])r[c]=1;else if(e.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(r.map((c,h)=>c>1?h:-1).filter(c=>c>=0).length===0)return tg(e);const o={x:e},l={reps:r};return wt.runKernel(i_,o,l)}const l1=At({broadcastTo_:Xat});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jat(n){const e={x:ht(n,"x","ceil","float32")};return wt.runKernel(vS,e)}const Kat=At({ceil_:jat});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jA(n,t,e){kf(n),e=e||Nx(t);const s={shape:n,value:t,dtype:e};return wt.runKernel(sk,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yat(n,t,e){const s=ht(n,"x","clipByValue");if(et(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return jA(s.shape,t,s.dtype);const i={x:s},r={clipValueMin:t,clipValueMax:e};return wt.runKernel(bS,i,r)}const Il=At({clipByValue_:Yat});function Zat(n){return _o(n,0)}const Qat=At({concat1d_:Zat});function Jat(n,t){return _o(n,t)}const tot=At({concat2d_:Jat});function eot(n,t){return _o(n,t)}const not=At({concat3d_:eot});function sot(n,t){return _o(n,t)}const iot=At({concat4d_:sot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rot(n,t,e,s,i="NHWC",r=[1,1],a){const o=ht(n,"x","conv2d","float32"),l=ht(t,"filter","conv2d","float32");let c=o,h=!1;o.rank===3&&(h=!0,c=Ct(o,[1,o.shape[0],o.shape[1],o.shape[2]])),et(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),et(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),No("conv2d",s,a);const f=i==="NHWC"?c.shape[3]:c.shape[1];et(f===l.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${l.shape[2]}.`),et(ya(e,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`),et(gg(r),()=>"Error in conv2D: Dilated rates should be larger than 0."),et(gg(e),()=>"Error in conv2D: Strides should be larger than 0.");const p={x:c,filter:l},g={strides:e,pad:s,dataFormat:i,dilations:r,dimRoundingMode:a},v=wt.runKernel(QC,p,g);return h?Ct(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const yg=At({conv2d_:rot});function aot(n,t,e,s,i="NWC",r=1,a){const o=ht(n,"x","conv1d"),l=ht(t,"filter","conv1d");let c=o,h=!1;o.rank===2&&(h=!0,c=Ct(o,[1,o.shape[0],o.shape[1]])),et(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),et(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),No("conv1d",s,a),et(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),et(ya(e,r),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${r}'`),et(gg(r),()=>"Error in conv1D: Dilated rates should be larger than 0."),et(gg(e),()=>"Error in conv1D: Stride should be larger than 0."),et(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const f=Ct(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=Ct(c,[c.shape[0],1,c.shape[1],c.shape[2]]),S=yg(p,f,[1,e],s,"NHWC",[1,r],a);return h?Ct(S,[S.shape[2],S.shape[3]]):Ct(S,[S.shape[0],S.shape[2],S.shape[3]])}const GG=At({conv1d_:aot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oot(n,t,e,s,i,r="NHWC",a){et(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let o=n,l=t,c=!1;t.rank===3&&(c=!0,l=Ct(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,n[0],n[1],n[2]]),et(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),et(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),et(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const h=r==="NHWC"?o[3]:o[1],f=r==="NHWC"?l.shape[3]:l.shape[1];et(h===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${e.shape[2]}.`),et(f===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${e.shape[3]}.`),No("conv2dDerInput",i,a);const p={dy:l,filter:e},g={strides:s,pad:i,dataFormat:r,dimRoundingMode:a,inputShape:o},v=wt.runKernel(JC,p,g);return c?Ct(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const Rk=At({conv2DBackpropInput_:oot});function lot(n,t,e,s,i,r){const a=ht(n,"x","conv2dTranspose"),o=ht(t,"filter","conv2dTranspose");return Rk(e,a,o,s,i,"NHWC",r)}const HG=At({conv2dTranspose_:lot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cot(n,t,e,s,i="NDHWC",r=[1,1,1]){const a=ht(n,"x","conv3d"),o=ht(t,"filter","conv3d");let l=a,c=!1;a.rank===4&&(c=!0,l=Ct(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),et(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),et(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),et(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),et(ya(e,r),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`),et(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),et(gg(r),()=>"Error in conv3D: Dilated rates should be larger than 0."),et(gg(e),()=>"Error in conv3D: Strides should be larger than 0.");const h={x:l,filter:o},f={strides:e,pad:s,dataFormat:i,dilations:r},p=wt.runKernel(tA,h,f);return c?Ct(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const uot=At({conv3d_:cot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hot(n,t,e,s,i){et(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let r=n,a=t,o=!1;t.rank===4&&(o=!0,a=Ct(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),r=[1,n[0],n[1],n[2],n[3]]);const l=r[4],c=a.shape[4];et(r.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${r.length}.`),et(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),et(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),et(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),et(c===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);const h={dy:a,filter:e},f={pad:i,strides:s,inputShape:r},p=wt.runKernel(X3,h,f);return o?Ct(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const WG=At({conv3DBackpropInput_:hot});function fot(n,t,e,s,i){const r=ht(n,"x","conv3dTranspose"),a=ht(t,"filter","conv3dTranspose");return WG(e,r,a,s,i)}const dot=At({conv3dTranspose_:fot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pot(n){const e={x:ht(n,"x","cos","float32")};return wt.runKernel(SS,e)}const Dk=At({cos_:pot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mot(n){const e={x:ht(n,"x","cosh","float32")};return wt.runKernel(_S,e)}const qG=At({cosh_:mot});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function got(n,t=0,e=!1,s=!1){const r={x:ht(n,"x","cumprod")},a={axis:t,exclusive:e,reverse:s};return wt.runKernel(j3,r,a)}const zR=At({cumprod_:got});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yot(n,t=0,e=!1,s=!1){const r={x:ht(n,"x","cumsum")},a={axis:t,exclusive:e,reverse:s};return wt.runKernel(eA,r,a)}const XG=At({cumsum_:yot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xot(n,t,e,s=!1){const i=ht(n,"x","denseBincount"),r=ht(t,"weights","denseBincount");et(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),et(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),et(e>=0,()=>`size must be non-negative, but got ${e}.`),et(r.size===i.size||r.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${r.shape}.`);const a={x:i,weights:r},o={size:e,binaryOutput:s};return wt.runKernel(Y3,a,o)}const dU=At({denseBincount_:xot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vot(n,t,e="NHWC"){const s=ht(n,"x","depthToSpace","float32"),i=e==="NHWC"?s.shape[1]:s.shape[2],r=e==="NHWC"?s.shape[2]:s.shape[3],a=e==="NHWC"?s.shape[3]:s.shape[1];et(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),et(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t}  for depthToSpace with input shape
    ${s.shape}`),et(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t} for depthToSpace with input shape
        ${s.shape}`),et(a%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${a} for depthToSpace with input shape ${s.shape}`);const o={x:s},l={blockSize:t,dataFormat:e};return wt.runKernel(Z3,o,l)}const bot=At({depthToSpace_:vot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sot(n,t,e,s,i="NHWC",r=[1,1],a){const o=ht(n,"x","depthwiseConv2d","float32"),l=ht(t,"filter","depthwiseConv2d","float32");let c=o,h=!1;o.rank===3&&(h=!0,c=Ct(o,[1,o.shape[0],o.shape[1],o.shape[2]])),et(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),et(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const f=i==="NHWC"?c.shape[3]:c.shape[1];et(f===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${l.shape[2]}.`),No("depthwiseConv2d",s,a);const p={x:c,filter:l},g={strides:e,pad:s,dataFormat:i,dilations:r,dimRoundingMode:a},v=wt.runKernel(nA,p,g);return h?Ct(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const kk=At({depthwiseConv2d_:Sot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ot(n,t,e,s,i=[1,1],r="NHWC"){const a=ht(n,"x","dilation2d"),o=ht(t,"filter","dilation2d");et(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),et(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),et(r==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${r}`);let l=a,c=!1;a.rank===3&&(l=Ct(a,[1,a.shape[0],a.shape[1],a.shape[2]]),c=!0),et(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const h={x:l,filter:o},f={strides:e,pad:s,dilations:i},p=wt.runKernel(sA,h,f);return c?Ct(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const wot=At({dilation2d_:_ot});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ux(n,t){const e=n.length,s=[];for(let i=0;i<e;i++){const r=e-1-i,a=n[r]||1;(t[t.length-1-i]||1)>1&&a===1&&s.unshift(r)}return s}function Sr(n,t){const e=[];for(let s=0;s<t.length;s++){const i=n[n.length-s-1],r=t.length-s-1,a=t[r];(i==null||i===1&&a>1)&&e.unshift(r)}return e}function Rn(n,t){const e=Math.max(n.length,t.length),s=new Array(e);for(let i=0;i<e;i++){let r=n[n.length-i-1];r==null&&(r=1);let a=t[t.length-i-1];if(a==null&&(a=1),r===1)s[e-i-1]=a;else if(a===1)s[e-i-1]=r;else if(r!==a){const o=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(o)}else s[e-i-1]=r}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tot(n,t){let e=ht(n,"a","equal","string_or_numeric"),s=ht(t,"b","equal","string_or_numeric");[e,s]=Xi(e,s),Rn(e.shape,s.shape);const i={a:e,b:s};return wt.runKernel(iA,i)}const yh=At({equal_:Tot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eot(n,t,e){const s=ht(t,"a","where"),i=ht(e,"b","where"),r=ht(n,"condition","where","bool"),a=Rn(Rn(r.shape,s.shape),i.shape),o=l1(r,a),l=l1(s,a),c=l1(i,a),h={condition:o,t:l,e:c};return wt.runKernel(OA,h)}const Ha=At({where_:Eot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cot(n){const e={x:ht(n,"x","zerosLike")};return wt.runKernel(VA,e)}const us=At({zerosLike_:Cot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aot(n,t){let e=ht(n,"a","div"),s=ht(t,"b","div");[e,s]=Xi(e,s);const i=pn(e,s),r=us(i),a=yh(s,r);return Ha(a,r,i)}const Not=At({divNoNan_:Aot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mot(n,t){const e=ht(n,"t1","dot"),s=ht(t,"t2","dot");et((e.rank===1||e.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${s.rank}.`);const i=e.rank===1?e.size:e.shape[1],r=s.rank===1?s.size:s.shape[0];if(et(i===r,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${r}.`),e.rank===1&&s.rank===1){const a=Ct(e,[1,-1]),o=Ct(s,[-1,1]),l=Ns(a,o);return Ct(l,[])}else if(e.rank===1&&s.rank===2){const a=Ct(e,[1,-1]),o=Ct(s,[s.shape[0],s.shape[1]]),l=Ns(a,o);return Ct(l,[l.size])}else if(e.rank===2&&s.rank===1){const a=Ct(s,[-1,1]),o=Ns(e,a);return Ct(o,[o.size])}else{const a=Ct(s,[s.shape[0],s.shape[1]]);return Ns(e,a)}}const Iot=At({dot_:Mot});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rot(n,...t){const e=t.map((i,r)=>ht(i,`tensors${r}`,"einsum")),s={equation:n};return wt.runKernel(tk,e,s)}const Ob=At({einsum_:Rot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dot(n){const e={x:ht(n,"x","elu","float32")};return wt.runKernel(TS,e)}const KA=At({elu_:Dot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kot(n){let t=ht(n,"x","erf");et(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Ge(t,"float32"));const e={x:t};return wt.runKernel(ES,e)}const Oot=At({erf_:kot});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ok(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function jG(n,t,e){const s=n.length+t.length,i=[];let r=0,a=0;for(let o=0;o<s;o++)e.indexOf(o)===-1?i.push(n[r++]):i.push(t[a++]);return i}function zr(n,t){const e=[],s=n.length;for(let r=0;r<s;r++)t.indexOf(r)===-1&&e.push(n[r]);const i=t.map(r=>n[r]);return[e,i]}function or(n,t){const e=t.map(s=>1);return jG(n,e,t)}function ea(n,t,e){et(Ok(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function Ti(n,t){if(Ok(n,t))return null;const e=[];for(let s=0;s<t;++s)n.indexOf(s)===-1&&e.push(s);return n.forEach(s=>e.push(s)),e}function gp(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function ji(n,t){const e=[];for(let s=t-n;s<t;++s)e.push(s);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ot(n,t=null,e=!1){const i={x:ht(n,"x","max")},r={reductionIndices:t,keepDims:e};return wt.runKernel(gA,i,r)}const nu=At({max_:$ot});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lot(n,t=null,e=!1){const i={x:ht(n,"x","min")},r={axis:t,keepDims:e};return wt.runKernel(bA,i,r)}const E2=At({min_:Lot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fot(n,t){let e=ht(n,"base","pow"),s=ht(t,"exp","pow");[e,s]=Xi(e,s);const i={a:e,b:s};return wt.runKernel(PS,i)}const hx=At({pow_:Fot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ds(n,t){if((cc(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&cc(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return WA(n,[],[],t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zot(n){const e={x:ht(n,"x","sqrt","float32")};return wt.runKernel(JS,e)}const qa=At({sqrt_:zot});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uot(n){const t=ht(n,"x","square"),e={};return wt.runKernel("Square",{x:t},e)}const oi=At({square_:Uot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bot(n,t=null,e=!1){let s=ht(n,"x","sum");s.dtype==="bool"&&(s=Ge(s,"int32"));const i={x:s},r={axis:t,keepDims:e};return wt.runKernel(LA,i,r)}const un=At({sum_:Bot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pot(n,t="euclidean",e=null,s=!1){n=ht(n,"x","norm");const i=KG(n,t,e);let r=i.shape;if(s){const a=Wn(e,n.shape);r=or(i.shape,a)}return Ct(i,r)}function KG(n,t,e=null){if(n.rank===0)return Oa(n);if(n.rank!==1&&e===null)return KG(Ct(n,[-1]),t,e);if(n.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return un(Oa(n),e);if(t===1/0)return nu(Oa(n),e);if(t===-1/0)return E2(Oa(n),e);if(t==="euclidean"||t===2)return qa(un(hx(Oa(n),Ds(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return nu(un(Oa(n),e[0]),e[1]-1);if(t===1/0)return nu(un(Oa(n),e[1]),e[0]);if(t===-1/0)return E2(un(Oa(n),e[1]),e[0]);if(t==="fro"||t==="euclidean")return qa(un(oi(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const YA=At({norm_:Pot});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vot(n,t=null,e=!1){return YA(n,"euclidean",t,e)}const Got=At({euclideanNorm_:Vot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hot(n){const e={x:ht(n,"x","exp")};return wt.runKernel(CS,e)}const Tf=At({exp_:Hot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wot(n,t=0){const e=ht(n,"x","expandDims","string_or_numeric");et(t<=e.rank,()=>"Axis must be <= rank of the tensor");const s={input:e},i={dim:t};return wt.runKernel(rA,s,i)}const xo=At({expandDims_:Wot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qot(n){const e={x:ht(n,"x","expm1")};return wt.runKernel(AS,e)}const Xot=At({expm1_:qot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jot(n,t){const e=ht(n,"x","tile","string_or_numeric");et(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);const s={x:e},i={reps:t};return wt.runKernel(i_,s,i)}const Qc=At({tile_:jot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kot(n,t,e,s="float32"){t==null&&(t=n);const i=Hn([n,t],s),r=n<=t?n:t;for(let o=0;o<r;++o)i.set(1,o,o);const a=Ct(i.toTensor(),[n,t]);if(e==null)return a;if(e.length===1)return Qc(xo(a,0),[e[0],1,1]);if(e.length===2)return Qc(xo(xo(a,0),0),[e[0],e[1],1,1]);if(e.length===3)return Qc(xo(xo(xo(a,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}const YG=At({eye_:Kot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yot(n){const e={x:ht(n,"x","floor","float32")};return wt.runKernel(NS,e)}const ZA=At({floor_:Yot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zot(n,t,e=0,s=0){const i=ht(n,"x","gather"),r=ht(t,"indices","gather","int32"),a={x:i,indices:r},o={axis:e,batchDims:s};return wt.runKernel(oA,a,o)}const $k=At({gather_:Zot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qot(n,t){let e=ht(n,"a","greater","string_or_numeric"),s=ht(t,"b","greater","string_or_numeric");[e,s]=Xi(e,s),Rn(e.shape,s.shape);const i={a:e,b:s};return wt.runKernel(lA,i)}const Dl=At({greater_:Qot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jot(n,t){let e=ht(n,"a","greaterEqual","string_or_numeric"),s=ht(t,"b","greaterEqual","string_or_numeric");[e,s]=Xi(e,s),Rn(e.shape,s.shape);const i={a:e,b:s};return wt.runKernel(IS,i)}const Ug=At({greaterEqual_:Jot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tlt(n){const e={input:ht(n,"input","imag")};return wt.runKernel(ak,e)}const Lk=At({imag_:tlt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function elt(n){const e={x:ht(n,"x","isFinite")};return wt.runKernel(DS,e)}const nlt=At({isFinite_:elt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function slt(n){const e={x:ht(n,"x","isInf")};return wt.runKernel(kS,e)}const ilt=At({isInf_:slt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rlt(n){const e={x:ht(n,"x","isNaN")};return wt.runKernel(OS,e)}const alt=At({isNaN_:rlt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function olt(n,t=.2){const s={x:ht(n,"x","leakyRelu")},i={alpha:t};return wt.runKernel(cA,s,i)}const Fk=At({leakyRelu_:olt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function llt(n,t){let e=ht(n,"a","less","string_or_numeric"),s=ht(t,"b","less","string_or_numeric");[e,s]=Xi(e,s),Rn(e.shape,s.shape);const i={a:e,b:s};return wt.runKernel(uA,i)}const C2=At({less_:llt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function clt(n,t){let e=ht(n,"a","lessEqual","string_or_numeric"),s=ht(t,"b","lessEqual","string_or_numeric");[e,s]=Xi(e,s),Rn(e.shape,s.shape);const i={a:e,b:s};return wt.runKernel(hA,i)}const Dx=At({lessEqual_:clt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ult(n,t=5,e=1,s=1,i=.5){const r=ht(n,"x","localResponseNormalization");et(r.rank===4||r.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${r.rank}.`),et(lx(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let a=r,o=!1;r.rank===3&&(o=!0,a=Ct(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={x:a},c={depthRadius:t,bias:e,alpha:s,beta:i},h=wt.runKernel(mA,l,c);return o?Ct(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const hlt=At({localResponseNormalization_:ult});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function flt(n){const e={x:ht(n,"x","log","float32")};return wt.runKernel($S,e)}const xh=At({log_:flt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dlt(n){const e={x:ht(n,"x","log1p")};return wt.runKernel(LS,e)}const ZG=At({log1p_:dlt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function plt(n,t){et(_R(n),()=>"The f passed in variableGrads(f) must be a function"),et(t==null||Array.isArray(t)&&t.every(c=>c instanceof T2),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=t!=null;if(!e){t=[];for(const c in wt.registeredVariables)t.push(wt.registeredVariables[c])}const s=e?t.filter(c=>!c.trainable):null,i=t.length;t=t.filter(c=>c.trainable),et(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const r=!0,{value:a,grads:o}=wt.gradients(n,t,null,r);et(o.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),et(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const l={};return t.forEach((c,h)=>{o[h]!=null&&(l[c.name]=o[h])}),s!=null&&s.forEach(c=>l[c.name]=null),{value:a,grads:l}}function fx(n){return wt.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mlt(n){const e={x:ht(n,"x","neg")};return wt.runKernel(_A,e)}const Wi=At({neg_:mlt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function glt(n){const e={x:ht(n,"x","softplus")};return wt.runKernel(QS,e)}const l_=At({softplus_:glt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ylt(n){const t=ht(n,"x","logSigmoid");return fx(s=>({value:Wi(l_(Wi(s))),gradFunc:a=>Tt(a,Rx(Wi(s)))}))(t)}const xlt=At({logSigmoid_:ylt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vlt(n,t){let e=ht(n,"a","sub"),s=ht(t,"b","sub");[e,s]=Xi(e,s);const i={a:e,b:s};return wt.runKernel(e_,i)}const _n=At({sub_:vlt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function blt(n,t=-1){const e=ht(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return fx((i,r)=>{const o=nu(i,t,!0),l=_n(i,o),c=_n(Ge(l,"float32"),xh(un(Tf(l),t,!0)));return r([c]),{value:c,gradFunc:(f,p)=>{const[g]=p,v=!0,_=Tf(g);return _n(f,Tt(un(f,t,v),_))}}})(e)}const QG=At({logSoftmax_:blt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Slt(n,t=null,e=!1){const s=ht(n,"x","logSumExp"),i=Wn(t,s.shape),r=nu(s,i,!0),a=_n(s,r),o=Tf(a),l=un(o,i),c=xh(l),h=_e(Ct(r,c.shape),c);if(e){const f=or(h.shape,i);return Ct(h,f)}return h}const _lt=At({logSumExp_:Slt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wlt(n,t){const e=ht(n,"a","logicalAnd","bool"),s=ht(t,"b","logicalAnd","bool");Rn(e.shape,s.shape);const i={a:e,b:s};return wt.runKernel(fA,i)}const Ef=At({logicalAnd_:wlt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tlt(n){const e={x:ht(n,"x","logicalNot","bool")};return wt.runKernel(dA,e)}const zk=At({logicalNot_:Tlt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Elt(n,t){const e=ht(n,"a","logicalOr","bool"),s=ht(t,"b","logicalOr","bool");Rn(e.shape,s.shape);const i={a:e,b:s};return wt.runKernel(pA,i)}const JG=At({logicalOr_:Elt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Clt(n,t){const e=ht(n,"a","logicalXor","bool"),s=ht(t,"b","logicalXor","bool");return Rn(e.shape,s.shape),Ef(JG(n,t),zk(Ef(n,t)))}const Alt=At({logicalXor_:Clt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nlt(n,t,e,s,i){const r=ht(n,"x","maxPool"),a=1;let o=r,l=!1;r.rank===3&&(l=!0,o=Ct(r,[1,r.shape[0],r.shape[1],r.shape[2]])),et(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),et(ya(e,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`),No("maxPool",s,i);const c={x:o},h={filterSize:t,strides:e,pad:s,dimRoundingMode:i},f=wt.runKernel(yA,c,h);return l?Ct(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Uk=At({maxPool_:Nlt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mlt(n,t=[1,1,1],e,s,i,r="NDHWC"){const a=ht(n,"x","maxPool3d");let o=a,l=!1;a.rank===4&&(l=!0,o=Ct(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),et(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),et(r==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),No("maxPool3d",s,i);const c={x:o},h={filterSize:t,strides:e,pad:s,dimRoundingMode:i,dataFormat:r},f=wt.runKernel(xA,c,h);return l?Ct(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const Ilt=At({maxPool3d_:Mlt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rlt(n,t){let e=ht(n,"a","maximum"),s=ht(t,"b","maximum");[e,s]=Xi(e,s),e.dtype==="bool"&&(e=Ge(e,"int32"),s=Ge(s,"int32")),Rn(e.shape,s.shape);const i={a:e,b:s};return wt.runKernel(FS,i)}const yp=At({maximum_:Rlt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dlt(n,t=null,e=!1){const i={x:ht(n,"x","mean")},r={axis:t,keepDims:e};return wt.runKernel(vA,i,r)}const sr=At({mean_:Dlt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dr(n,t="float32"){if(kf(n),t==="complex64"){const s=Dr(n,"float32"),i=Dr(n,"float32");return cx(s,i)}const e=ga(Zt(n),t);return wt.makeTensor(e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bg(n,t="float32"){if(kf(n),t==="complex64"){const s=Bg(n,"float32"),i=Dr(n,"float32");return cx(s,i)}const e=O3(Zt(n),t);return wt.makeTensor(e,n,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function klt(n,t){let e=ht(n,"a","minimum"),s=ht(t,"b","minimum");[e,s]=Xi(e,s),e.dtype==="bool"&&(e=Ge(e,"int32"),s=Ge(s,"int32")),Rn(e.shape,s.shape);const i={a:e,b:s};return wt.runKernel(zS,i)}const O1=At({minimum_:klt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Olt(n,t,e){et(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const s=ht(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");et(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const i=e==="reflect"?1:0;for(let o=0;o<s.rank;o++)et(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),et(t[o][0]>=0&&t[o][0]<=s.shape[o]-i&&t[o][1]>=0&&t[o][1]<=s.shape[o]-i,()=>`Padding in dimension ${o} cannot be greater than or equal to ${s.shape[o]-i} or less than 0 for input of shape ${s.shape}`);const r={paddings:t,mode:e},a={x:s};return wt.runKernel(SA,a,r)}const $lt=At({mirrorPad_:Olt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Llt(n,t){let e=ht(n,"a","mod"),s=ht(t,"b","mod");[e,s]=Xi(e,s);const i={a:e,b:s};return wt.runKernel(US,i)}const Flt=At({mod_:Llt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zlt(n,t=null,e=!1){n=ht(n,"x","moments");const s=Wn(t,n.shape),i=sr(n,s,e);let r=i.shape;e||(r=or(i.shape,s));const a=oi(_n(Ge(n,"float32"),Ct(i,r))),o=sr(a,s,e);return{mean:i,variance:o}}const Bk=At({moments_:zlt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ult(n,t){let e=ht(n,"a","notEqual","string_or_numeric"),s=ht(t,"b","notEqual","string_or_numeric");[e,s]=Xi(e,s),Rn(e.shape,s.shape);const i={a:e,b:s};return wt.runKernel(wA,i)}const A2=At({notEqual_:Ult});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Blt(n,t,e=1,s=0,i="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:ht(n,"indices","oneHot","int32")},o={dtype:i,depth:t,onValue:e,offValue:s};return wt.runKernel(EA,a,o)}const tH=At({oneHot_:Blt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Plt(n){const e={x:ht(n,"x","onesLike")};return wt.runKernel(TA,e)}const uc=At({onesLike_:Plt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vlt(n,t,e=0){const s=ht(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:t,constantValue:e},r={x:s};return wt.runKernel(AA,r,i)}const Pk=At({pad_:Vlt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Glt(n,t,e){const s=ht(n,"x","spaceToBatchND");et(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),et(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),et(s.shape.reduce((a,o,l)=>l>0&&l<=t.length?a&&(o+e[l-1][0]+e[l-1][1])%t[l-1]===0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);const i={x:s},r={blockShape:t,paddings:e};return wt.runKernel(FA,i,r)}const Vk=At({spaceToBatchND_:Glt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hlt(n,t,e,s,i,r,a){i==null&&(i=[1,1]),r==null&&(r=1),s===0&&(s="valid");const o=ht(n,"x","maxPool");let l=o,c=!1;o.rank===3&&(c=!0,l=Ct(o,[1,o.shape[0],o.shape[1],o.shape[2]])),et(ya(r,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`);const h=dc(l.shape,t,r,i,s),f=[h.dilationHeight,h.dilationWidth];let p;s==="same"?p=qlt([h.filterHeight,h.filterWidth],f):p=[[0,0],[0,0]];const g=f[0]===1&&f[1]===1,[v,_]=Wlt([h.inHeight,h.inWidth],f,p),S=g?s:"valid",b=g?l:Vk(l,f,v),C=(e==="avg"?()=>Nk(b,t,r,S,a):()=>Uk(b,t,r,S,a))(),A=g?C:Ik(C,f,_);return c?Ct(A,[A.shape[1],A.shape[2],A.shape[3]]):A}function Wlt(n,t,e){const s=e.map(h=>h[0]),i=e.map(h=>h[1]),r=n.concat(s,i),a=t.map((h,f)=>(h-r[f]%h)%h),o=i.map((h,f)=>h+a[f]),l=t.map((h,f)=>[s[f],o[f]]),c=t.map((h,f)=>[0,a[f]]);return[l,c]}function qlt(n,t){const s=n.map((a,o)=>a+(a-1)*(t[o]-1)).map(a=>a-1),i=s.map(a=>Math.floor(a/2)),r=s.map((a,o)=>a-i[o]);return s.map((a,o)=>[i[o],r[o]])}const Xlt=At({pool_:Hlt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jlt(n,t){const e=ht(n,"x","prelu"),s=ht(t,"alpha","prelu"),i={x:e,alpha:s};return wt.runKernel(NA,i)}const Gk=At({prelu_:jlt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Klt(n,t=null,e=!1){let s=ht(n,"x","prod");s.dtype==="bool"&&(s=Ge(s,"int32"));const i={x:s},r={axis:t,keepDims:e};return wt.runKernel(MA,i,r)}const Ylt=At({prod_:Klt});var uE={exports:{}},Zlt=uE.exports,pU;function Qlt(){return pU||(pU=1,(function(n){(function(t,e,s){function i(l){var c=this,h=o();c.next=function(){var f=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=f-(c.c=f|0)},c.c=1,c.s0=h(" "),c.s1=h(" "),c.s2=h(" "),c.s0-=h(l),c.s0<0&&(c.s0+=1),c.s1-=h(l),c.s1<0&&(c.s1+=1),c.s2-=h(l),c.s2<0&&(c.s2+=1),h=null}function r(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function a(l,c){var h=new i(l),f=c&&c.state,p=h.next;return p.int32=function(){return h.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,f&&(typeof f=="object"&&r(f,h),p.state=function(){return r(h,{})}),p}function o(){var l=4022871197,c=function(h){h=String(h);for(var f=0;f<h.length;f++){l+=h.charCodeAt(f);var p=.02519603282416938*l;l=p>>>0,p-=l,p*=l,l=p>>>0,p-=l,l+=p*4294967296}return(l>>>0)*23283064365386963e-26};return c}e&&e.exports?e.exports=a:this.alea=a})(Zlt,n)})(uE)),uE.exports}var hE={exports:{}},Jlt=hE.exports,mU;function tct(){return mU||(mU=1,(function(n){(function(t,e,s){function i(o){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var f=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^f^f>>>8},o===(o|0)?l.x=o:c+=o;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,l.next()}function r(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l}function a(o,l){var c=new i(o),h=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,v=(p+g)/(1<<21);while(v===0);return v},f.int32=c.next,f.quick=f,h&&(typeof h=="object"&&r(h,c),f.state=function(){return r(c,{})}),f}e&&e.exports?e.exports=a:this.xor128=a})(Jlt,n)})(hE)),hE.exports}var fE={exports:{}},ect=fE.exports,gU;function nct(){return gU||(gU=1,(function(n){(function(t,e,s){function i(o){var l=this,c="";l.next=function(){var f=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(f^f<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,o===(o|0)?l.x=o:c+=o;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,h==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function r(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l.v=o.v,l.d=o.d,l}function a(o,l){var c=new i(o),h=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,v=(p+g)/(1<<21);while(v===0);return v},f.int32=c.next,f.quick=f,h&&(typeof h=="object"&&r(h,c),f.state=function(){return r(c,{})}),f}e&&e.exports?e.exports=a:this.xorwow=a})(ect,n)})(fE)),fE.exports}var dE={exports:{}},sct=dE.exports,yU;function ict(){return yU||(yU=1,(function(n){(function(t,e,s){function i(o){var l=this;l.next=function(){var h=l.x,f=l.i,p,g;return p=h[f],p^=p>>>7,g=p^p<<24,p=h[f+1&7],g^=p^p>>>10,p=h[f+3&7],g^=p^p>>>3,p=h[f+4&7],g^=p^p<<7,p=h[f+7&7],p=p^p<<13,g^=p^p<<9,h[f]=g,l.i=f+1&7,g};function c(h,f){var p,g=[];if(f===(f|0))g[0]=f;else for(f=""+f,p=0;p<f.length;++p)g[p&7]=g[p&7]<<15^f.charCodeAt(p)+g[p+1&7]<<13;for(;g.length<8;)g.push(0);for(p=0;p<8&&g[p]===0;++p);for(p==8?g[7]=-1:g[p],h.x=g,h.i=0,p=256;p>0;--p)h.next()}c(l,o)}function r(o,l){return l.x=o.x.slice(),l.i=o.i,l}function a(o,l){o==null&&(o=+new Date);var c=new i(o),h=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,v=(p+g)/(1<<21);while(v===0);return v},f.int32=c.next,f.quick=f,h&&(h.x&&r(h,c),f.state=function(){return r(c,{})}),f}e&&e.exports?e.exports=a:this.xorshift7=a})(sct,n)})(dE)),dE.exports}var pE={exports:{}},rct=pE.exports,xU;function act(){return xU||(xU=1,(function(n){(function(t,e,s){function i(o){var l=this;l.next=function(){var h=l.w,f=l.X,p=l.i,g,v;return l.w=h=h+1640531527|0,v=f[p+34&127],g=f[p=p+1&127],v^=v<<13,g^=g<<17,v^=v>>>15,g^=g>>>12,v=f[p]=v^g,l.i=p,v+(h^h>>>16)|0};function c(h,f){var p,g,v,_,S,b=[],T=128;for(f===(f|0)?(g=f,f=null):(f=f+"\0",g=0,T=Math.max(T,f.length)),v=0,_=-32;_<T;++_)f&&(g^=f.charCodeAt((_+32)%f.length)),_===0&&(S=g),g^=g<<10,g^=g>>>15,g^=g<<4,g^=g>>>13,_>=0&&(S=S+1640531527|0,p=b[_&127]^=g+S,v=p==0?v+1:0);for(v>=128&&(b[(f&&f.length||0)&127]=-1),v=127,_=512;_>0;--_)g=b[v+34&127],p=b[v=v+1&127],g^=g<<13,p^=p<<17,g^=g>>>15,p^=p>>>12,b[v]=g^p;h.w=S,h.X=b,h.i=v}c(l,o)}function r(o,l){return l.i=o.i,l.w=o.w,l.X=o.X.slice(),l}function a(o,l){o==null&&(o=+new Date);var c=new i(o),h=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,v=(p+g)/(1<<21);while(v===0);return v},f.int32=c.next,f.quick=f,h&&(h.X&&r(h,c),f.state=function(){return r(c,{})}),f}e&&e.exports?e.exports=a:this.xor4096=a})(rct,n)})(pE)),pE.exports}var mE={exports:{}},oct=mE.exports,vU;function lct(){return vU||(vU=1,(function(n){(function(t,e,s){function i(o){var l=this,c="";l.next=function(){var f=l.b,p=l.c,g=l.d,v=l.a;return f=f<<25^f>>>7^p,p=p-g|0,g=g<<24^g>>>8^v,v=v-f|0,l.b=f=f<<20^f>>>12^p,l.c=p=p-g|0,l.d=g<<16^p>>>16^v,l.a=v-f|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,o===Math.floor(o)?(l.a=o/4294967296|0,l.b=o|0):c+=o;for(var h=0;h<c.length+20;h++)l.b^=c.charCodeAt(h)|0,l.next()}function r(o,l){return l.a=o.a,l.b=o.b,l.c=o.c,l.d=o.d,l}function a(o,l){var c=new i(o),h=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,v=(p+g)/(1<<21);while(v===0);return v},f.int32=c.next,f.quick=f,h&&(typeof h=="object"&&r(h,c),f.state=function(){return r(c,{})}),f}e&&e.exports?e.exports=a:this.tychei=a})(oct,n)})(mE)),mE.exports}var gE={exports:{}};const cct={},uct=Object.freeze(Object.defineProperty({__proto__:null,default:cct},Symbol.toStringTag,{value:"Module"})),hct=Uj(uct);var fct=gE.exports,bU;function dct(){return bU||(bU=1,(function(n){(function(t,e,s){var i=256,r=6,a=52,o="random",l=s.pow(i,r),c=s.pow(2,a),h=c*2,f=i-1,p;function g(A,I,D){var F=[];I=I==!0?{entropy:!0}:I||{};var z=b(S(I.entropy?[A,C(e)]:A??T(),3),F),k=new v(F),O=function(){for(var L=k.g(r),H=l,q=0;L<c;)L=(L+q)*i,H*=i,q=k.g(1);for(;L>=h;)L/=2,H/=2,q>>>=1;return(L+q)/H};return O.int32=function(){return k.g(4)|0},O.quick=function(){return k.g(4)/4294967296},O.double=O,b(C(k.S),e),(I.pass||D||function(L,H,q,K){return K&&(K.S&&_(K,k),L.state=function(){return _(k,{})}),q?(s[o]=L,H):L})(O,z,"global"in I?I.global:this==s,I.state)}function v(A){var I,D=A.length,F=this,z=0,k=F.i=F.j=0,O=F.S=[];for(D||(A=[D++]);z<i;)O[z]=z++;for(z=0;z<i;z++)O[z]=O[k=f&k+A[z%D]+(I=O[z])],O[k]=I;(F.g=function(L){for(var H,q=0,K=F.i,Y=F.j,P=F.S;L--;)H=P[K=f&K+1],q=q*i+P[f&(P[K]=P[Y=f&Y+H])+(P[Y]=H)];return F.i=K,F.j=Y,q})(i)}function _(A,I){return I.i=A.i,I.j=A.j,I.S=A.S.slice(),I}function S(A,I){var D=[],F=typeof A,z;if(I&&F=="object")for(z in A)try{D.push(S(A[z],I-1))}catch{}return D.length?D:F=="string"?A:A+"\0"}function b(A,I){for(var D=A+"",F,z=0;z<D.length;)I[f&z]=f&(F^=I[f&z]*19)+D.charCodeAt(z++);return C(I)}function T(){try{var A;return p&&(A=p.randomBytes)?A=A(i):(A=new Uint8Array(i),(t.crypto||t.msCrypto).getRandomValues(A)),C(A)}catch{var I=t.navigator,D=I&&I.plugins;return[+new Date,t,D,t.screen,C(e)]}}function C(A){return String.fromCharCode.apply(0,A)}if(b(s.random(),e),n.exports){n.exports=g;try{p=hct}catch{}}else s["seed"+o]=g})(typeof self<"u"?self:fct,[],Math)})(gE)),gE.exports}var AI,SU;function pct(){if(SU)return AI;SU=1;var n=Qlt(),t=tct(),e=nct(),s=ict(),i=act(),r=lct(),a=dct();return a.alea=n,a.xor128=t,a.xorwow=e,a.xorshift7=s,a.xor4096=i,a.tychei=r,AI=a,AI}var kx=pct();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eH=class{constructor(t,e,s,i,r){this.mean=t,this.stdDev=e,this.dtype=s,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=r||Math.random();this.random=kx.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let t,e,s=!1;for(;!s;){let i,r,a;do i=2*this.random()-1,r=2*this.random()-1,a=i*i+r*r;while(a>=1||a===0);const o=Math.sqrt(-2*Math.log(a)/a);t=this.mean+this.stdDev*i*o,e=this.mean+this.stdDev*r*o,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}},mct=class{constructor(t=0,e=1,s,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=s,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=kx.alea(i)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gct(n,t=0,e=1,s,i){if(kf(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const r=new eH(t,e,s,!1,i),a=Hn(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=r.nextValue();return a.toTensor()}const yct=At({randomNormal_:gct});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xct(n,t=0,e=1,s="float32",i){kf(n);const r=Hn(n,s),a=new mct(t,e,null,i);for(let o=0;o<r.values.length;o++)r.values[o]=a.nextValue();return r.toTensor()}const c_=At({randomUniform_:xct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $1(n,t,e=1,s="float32"){if(e===0)throw new Error("Cannot have a step of zero");const i={start:n,stop:t,step:e,dtype:s};return wt.runKernel(dk,{},i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vct(n){const e={input:ht(n,"input","real")};return wt.runKernel(pk,e)}const N2=At({real_:vct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bct(n){const e={x:ht(n,"x","reciprocal")};return wt.runKernel(VS,e)}const Sct=At({reciprocal_:bct});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ct(n){const e={x:ht(n,"x","relu")};return wt.runKernel(GS,e)}const Pg=At({relu_:_ct});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wct(n){const e={x:ht(n,"x","relu6")};return wt.runKernel(HS,e)}const nH=At({relu6_:wct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tct(n,t){const s={x:ht(n,"x","reverse")},i={dims:t};return wt.runKernel(kA,s,i)}const xg=At({reverse_:Tct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ect(n){const e={x:ht(n,"x","round")};return wt.runKernel(WS,e)}const sH=At({round_:Ect});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cct(n){const e={x:ht(n,"x","rsqrt","float32")};return wt.runKernel(qS,e)}const iH=At({rsqrt_:Cct});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Act(n){const e={x:ht(n,"x","selu")};return wt.runKernel(XS,e)}const rH=At({selu_:Act});function Nct(n,t,e,s,i,r=[1,1],a="NHWC"){const o=ht(n,"x","separableConv2d"),l=ht(t,"depthwiseFilter","separableConv2d"),c=ht(e,"pointwiseFilter","separableConv2d");let h=o,f=!1;if(o.rank===3&&(f=!0,h=Ct(o,[1,o.shape[0],o.shape[1],o.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");et(h.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),et(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),et(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),et(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),et(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const p=l.shape[2],g=l.shape[3];et(c.shape[2]===p*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*g}, but got ${c.shape[2]}.`);const v=kk(h,l,s,i,a,r),S=yg(v,c,1,"valid",a);return f?Ct(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const aH=At({separableConv2d_:Nct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mct(n){const e={x:ht(n,"x","sign")};return wt.runKernel(YS,e)}const Ict=At({sign_:Mct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rct(n){const e={x:ht(n,"x","sin","float32")};return wt.runKernel(jS,e)}const oH=At({sin_:Rct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dct(n){const e={x:ht(n,"x","sinh")};return wt.runKernel(KS,e)}const lH=At({sinh_:Dct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kct(n,t,e){const s=ht(n,"x","slice1d");return et(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),si(s,[t],[e])}const Hk=At({slice1d_:kct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oct(n,t,e){const s=ht(n,"x","slice2d");return et(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),si(s,t,e)}const cH=At({slice2d_:Oct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ct(n,t,e){const s=ht(n,"x","slice3d");return et(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),si(s,t,e)}const Wk=At({slice3d_:$ct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lct(n,t,e){const s=ht(n,"x","slice4d");return et(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),si(s,t,e)}const M2=At({slice4d_:Lct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fct(n,t=-1){const e=ht(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);const s={logits:e},i={dim:t};return wt.runKernel(UA,s,i)}const qk=At({softmax_:Fct});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zct(n){et(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const t={input:n};return wt.runKernel(nk,t)}const uH=At({fft_:zct});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uct(n){et(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const t={input:n};return wt.runKernel(rk,t)}const UR=At({ifft_:Uct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bct(n){const t=n.shape[n.shape.length-1],e=n.size/t;let s;if(t<=2){const i=Ct(n,[e,t]);s=UR(i)}else{const i=[e,2*(t-1)],r=Ct(N2(n),[e,t]),a=Ct(Lk(n),[e,t]),o=xg(si(r,[0,1],[e,t-2]),1),l=Tt(xg(si(a,[0,1],[e,t-2]),1),Ds(-1)),c=_o([r,o],1),h=_o([a,l],1),f=Ct(cx(c,h),[i[0],i[1]]);s=UR(f)}if(s=N2(s),n.rank===3&&n.shape[0]!==0){const i=s,r=n.shape[0];s=Ct(s,[r,s.shape[0]/r,s.shape[1]]),i.dispose()}return s}const Pct=At({irfft_:Bct});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vct(n,t,e=0){const i={x:ht(n,"x","split")},r={numOrSizeSplits:t,axis:e};return wt.runKernel(zA,i,r)}const Cl=At({split_:Vct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gct(n,t){et(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const s=n.size/e;let i;if(t!=null&&t<e){const v=n.shape.map(S=>0),_=n.shape.map(S=>S);_[n.shape.length-1]=t,i=si(n,v,_),e=t}else if(t!=null&&t>e){const v=n.shape.map(_=>_);v[n.shape.length-1]=t-e,i=_o([n,Dr(v)],n.shape.length-1),e=t}else i=n;const r=us(i),a=Ct(cx(i,r),[s,e]),o=uH(a),l=Math.floor(e/2)+1,c=N2(o),h=Lk(o),f=Cl(c,[l,e-l],c.shape.length-1),p=Cl(h,[l,e-l],h.shape.length-1),g=i.shape.slice();return g[i.shape.length-1]=l,Ct(cx(f[0],p[0]),g)}const Hct=At({rfft_:Gct});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wct(n,t){let e=ht(n,"a","squaredDifference"),s=ht(t,"b","squaredDifference");[e,s]=Xi(e,s),Rn(e.shape,s.shape);const i={a:e,b:s},r={};return wt.runKernel(t_,i,r)}const qct=At({squaredDifference_:Wct});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xct(n,t){const e=ht(n,"x","squeeze","string_or_numeric");return Ct(e,dp(e.shape,t).newShape)}const u_=At({squeeze_:Xct});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jct(n,t=0){const e=IG(n,"tensors","stack","string_or_numeric");et(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&et(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");const s=e,i={axis:t};return wt.runKernel(CA,s,i)}const Zd=At({stack_:jct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kct(n,t=0){const s={x:ht(n,"x","step")},i={alpha:t};return wt.runKernel(r_,s,i)}const h_=At({step_:Kct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yct(n,t,e,s,i=0,r=0,a=0,o=0,l=0){const h={x:ht(n,"x","stridedSlice","string_or_numeric")},f={begin:t,end:e,strides:s,beginMask:i,endMask:r,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};return wt.runKernel(vk,h,f)}const Zct=At({stridedSlice_:Yct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qct(n){const e={x:ht(n,"x","tan","float32")};return wt.runKernel(n_,e)}const Jct=At({tan_:Qct});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zo(n,t){BV(n);const e=HA(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return WA(n,null,e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NI(n,t,e){if(BV(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=HA(n,e);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return WA(n,t,s,e)}function hH(n,t,e){const s=t.rank>1?t.shape[t.rank-1]:1,i=t.rank>1?t.rank-1:1,r=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${i}.`;if(e.rank<i)throw new Error(r+` update.rank < ${i}. `);if(n.length<s+(e.rank-i))throw new Error(r+` Output shape length < ${s+(e.rank-i)}`);if(e.rank!==i+n.length-s)throw new Error(r+` update.rank != ${i+n.length-s}`);for(let a=0;a<i;++a)if(e.shape[a]!==t.shape[a])throw new Error(r+` updates.shape[${a}] (${e.shape[a]}) != indices.shape[${a}] (${t.shape[a]}).`);for(let a=0;a<e.rank-i;++a)if(e.shape[a+i]!==n[a+s])throw new Error(r+` updates.shape[${a+i}] (${e.shape[a+i]}) != shape[${a+i}] (${n[a+i]})`)}function tut(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}hH(e,t,n)}function Vg(n,t,e){const s=t.shape.length,i=s>1?t.shape[s-1]:1,r=e.length;let a=1;for(let f=i;f<r;++f)a*=e[f];const o=i<1?1:i,l=Zt(t.shape)/o,c=[...ln(e.slice(0,i)),1],h=Zt(e);return{sliceRank:i,numUpdates:l,sliceSize:a,strides:c,outputSize:h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eut(n,t=1,e=!0){const s=ht(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${t}`);const r={x:s},a={k:t,sorted:e},[o,l]=wt.runKernel(bk,r,a);return{values:o,indices:l}}const nut=At({topk_:eut});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sut(n,t=0,e=1,s,i){if(kf(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const r=new eH(t,e,s,!0,i),a=Hn(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=r.nextValue();return a.toTensor()}const fH=At({truncatedNormal_:sut});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iut(n,t=0){const e=ht(n,"x","unique","string_or_numeric");et(e.rank>0,()=>"The input tensor must be at least 1D");const s={x:e},i={axis:t},[r,a]=wt.runKernel(_k,s,i);return{values:r,indices:a}}const rut=At({unique_:iut});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aut(n,t,e){const s=ht(n,"x","unsortedSegmentSum"),i=ht(t,"segmentIds","unsortedSegmentSum","int32");et(lx(e),()=>"numSegments must be of dtype int");const r={x:s,segmentIds:i},a={numSegments:e};return wt.runKernel(PA,r,a)}const dH=At({unsortedSegmentSum_:aut});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function out(n,t=0){const e=ht(n,"x","unstack","string_or_numeric");et(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);const s={value:e},i={axis:t};return wt.runKernel(BA,s,i)}const vg=At({unstack_:out});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lut(n,t=!0,e,s){return wt.makeVariable(n,t,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pH(n,t){const e=[];for(let r=0;r<t.length;r++)t[r]&&e.push(r);const s=Hn(n,"int32"),i=Hn([e.length,n.length],"int32");for(let r=0;r<e.length;r++){const a=s.indexToLoc(e[r]),o=r*n.length;i.values.set(a,o)}return i.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cut(n,t,e){const s=ht(n,"x","transpose");if(t==null&&(t=s.shape.map((a,o)=>o).reverse()),et(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(a=>{et(a>=0&&a<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const i={x:s},r={perm:t};return s.dtype==="complex64"?Lt(()=>{let a=N2(s),o=Lk(s);return a=wt.runKernel(Hy,{x:a},r),o=wt.runKernel(Hy,{x:o},r),e&&(o=Wi(o)),cx(a,o)}):wt.runKernel(Hy,i,r)}const cs=At({transpose_:cut});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uut(n,t){if(t==null)return n.shape.slice();if(Is(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let s=0;s<n.shape.length;s++)t[s]==null&&n.shape[s]!=null?e.push(n.shape[s]):e.push(t[s]);return e}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hut(n,t,e,s){const i=ht(n,"x","dropout");if(et(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),et(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return n instanceof nr?i.clone():i;const r=uut(i,e),a=1-t,o=pn(ZA(_e(c_(r,0,1,"float32",s),a)),a);return Tt(i,o)}const fut=At({dropout_:hut});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dut(n,t,e,s,i,r="NHWC",a){let o=n;n.rank===3&&(o=Ct(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;l.rank===3&&(l=Ct(t,[1,t.shape[0],t.shape[1],t.shape[2]])),et(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),et(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),et(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const c=r==="NHWC"?o.shape[3]:o.shape[1],h=r==="NHWC"?l.shape[3]:l.shape[1];et(c===e[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`),et(h===e[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${e[3]}).`),No("conv2dDerFilter",i,a);const f={x:o,dy:l},p={strides:s,pad:i,dataFormat:r,dimRoundingMode:a,filterShape:e};return wt.runKernel(W3,f,p)}const Xk=At({conv2DBackpropFilter_:dut});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jk(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return Tt(n,h_(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Kk(n,t){let e=t;const s=Sr(n.shape,t.shape);return s.length>0&&(e=un(e,s)),Ct(e,n.shape)}function Yk(n,t,e,s){if(t==="linear")return n;if(t==="relu")return Pg(n);if(t==="elu")return KA(n);if(t==="relu6")return nH(n);if(t==="prelu")return Gk(n,e);if(t==="leakyrelu")return Fk(n,s);if(t==="sigmoid")return Rx(n);throw new Error(`Unknown fused activation ${t}.`)}const Zk=(n,t)=>!(n>0)||t==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function put({x:n,filter:t,strides:e,pad:s,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(l=l||"linear",Zk(wt.state.gradientDepth,l)===!1){et(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let D=yg(n,t,e,s,i,r,a);return o!=null&&(D=_e(D,o)),Yk(D,l,c,h)}const f=ht(n,"x","conv2d","float32"),p=ht(t,"filter","conv2d","float32");let g=f,v=!1;f.rank===3&&(v=!0,g=Ct(f,[1,f.shape[0],f.shape[1],f.shape[2]])),et(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),et(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),No("fused conv2d",s,a);const _=i==="NHWC"?g.shape[3]:g.shape[1];et(p.shape[2]===_,()=>`Error in conv2d: depth of input (${_}) must match input depth for filter ${p.shape[2]}.`),et(ya(e,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`);const S=ta(g.shape,p.shape,e,r,s,a);let b;o!=null&&(b=ht(o,"bias","fused conv2d"),[b]=Xi(b,f),i==="NHWC"?Rn(S.outShape,b.shape):(et(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),et(b.shape.length===0||b.shape[0]===S.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${S.outChannels})`)));let T;if(c!=null){const D=c.shape;if(et(D.length<=1||D.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${D.length}.`),D.length===1)et(D[0]===1||D[0]===S.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${D}) is not compatible with the number of output channels (${S.outChannels}).`);else if(D.length===3)try{Rn(D,S.outShape)}catch{const z=`Error in fused conv2d: PReLU activation weights (${D}) is not compatible with the output shape of the conv2d (${S.outShape}).`;throw Error(z)}T=ht(c,"prelu weights","fused conv2d")}const C=(D,F)=>{et(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[z,k,O,L]=F,H=jk(D,O,l);et(mg(r),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const q=Rk(k.shape,H,z,e,s),K=Xk(k,H,z.shape,e,s),Y=[q,K];if(L!=null){const P=Kk(L,H);Y.push(P)}return Y},A={x:g,filter:p,bias:b,preluActivationWeights:T},I={strides:e,pad:s,dataFormat:i,dilations:r,dimRoundingMode:a,activation:l,leakyreluAlpha:h};return o==null?fx((F,z,k)=>{let O=wt.runKernel(_2,A,I);return k([z,F,O]),v&&(O=Ct(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:C}})(g,p):fx((F,z,k,O)=>{let L=wt.runKernel(_2,A,I);return O([z,F,L,k]),v&&(L=Ct(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:C}})(g,p,b)}const mut=At({fusedConv2d_:put});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gut(n,t,e,s,i,r=[1,1],a){let o=n;n.rank===3&&(o=Ct(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;l.rank===3&&(l=Ct(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={x:o,dy:l},h={strides:s,pad:i,dimRoundingMode:a,dilations:r,filterShape:e};return wt.runKernel(Q3,c,h)}const yut=At({depthwiseConv2dNativeBackpropFilter_:gut});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xut(n,t,e,s,i,r=[1,1],a){let o=t,l=!1;t.rank===3&&(l=!0,o=Ct(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={dy:o,filter:e},h={strides:s,pad:i,dimRoundingMode:a,dilations:r,inputShape:n},f=wt.runKernel(J3,c,h);return l?Ct(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const vut=At({depthwiseConv2dNativeBackpropInput_:xut});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function but({a:n,b:t,transposeA:e=!1,transposeB:s=!1,bias:i,activation:r="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if(Zk(wt.state.gradientDepth,r)===!1){let L=Ns(n,t,e,s);return i!=null&&(L=_e(L,i)),Yk(L,r,a,o)}let l=ht(n,"a","fused matMul"),c=ht(t,"b","fused matMul");[l,c]=Xi(l,c);const h=e?l.shape[l.rank-2]:l.shape[l.rank-1],f=s?c.shape[c.rank-1]:c.shape[c.rank-2],p=e?l.shape[l.rank-1]:l.shape[l.rank-2],g=s?c.shape[c.rank-2]:c.shape[c.rank-1],v=l.shape.slice(0,-2),_=c.shape.slice(0,-2),S=Zt(v),b=Zt(_);et(h===f,()=>`Error in fused matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${e} and transposeB=${s} must match.`);const C=Rn(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,g]),A=e?Ct(l,[S,h,p]):Ct(l,[S,p,h]),I=s?Ct(c,[b,g,f]):Ct(c,[b,f,g]);let D;i!=null&&(D=ht(i,"bias","fused matMul"),[D]=Xi(D,l),Rn(C,D.shape));let F;a!=null&&(F=ht(a,"prelu weights","fused matMul"));const z=(L,H)=>{const[q,K,Y,P]=H,W=jk(Ct(L,Y.shape),Y,r);let j,st;if(!e&&!s?(j=Ns(W,K,!1,!0),st=Ns(q,W,!0,!1)):!e&&s?(j=Ns(W,K,!1,!1),st=Ns(W,q,!0,!1)):e&&!s?(j=Ns(K,W,!1,!0),st=Ns(q,W,!1,!1)):(j=Ns(K,W,!0,!0),st=Ns(W,q,!0,!0)),i!=null){const ot=Kk(P,W);return[j,st,ot]}else return[j,st]},k={a:A,b:I,bias:D,preluActivationWeights:F},O={transposeA:e,transposeB:s,activation:r,leakyreluAlpha:o};return i==null?fx((H,q,K)=>{const Y=wt.runKernel(S2,k,O);return K([H,q,Y]),{value:Ct(Y,C),gradFunc:z}})(A,I):fx((H,q,K,Y)=>{const P=wt.runKernel(S2,k,O);return Y([H,q,P,K]),{value:Ct(P,C),gradFunc:z}})(A,I,D)}const _U=At({fusedMatMul_:but});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sut(n,t,e,s,i="bilinear",r=0){const a=ht(n,"image","cropAndResize"),o=ht(t,"boxes","cropAndResize","float32"),l=ht(e,"boxInd","cropAndResize","int32"),c=o.shape[0];et(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),et(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${o.shape}.`),et(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${o.shape}.`),et(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),et(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),et(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const h={image:a,boxes:o,boxInd:l},f={method:i,extrapolationValue:r,cropSize:s};return wt.runKernel(K3,h,f)}const _ut=At({cropAndResize_:Sut});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wut(n){const t=ht(n,"image","flipLeftRight","float32");et(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const e={image:t};return wt.runKernel(ik,e,{})}const Tut=At({flipLeftRight_:wut});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eut(n){const t=ht(n,"image","grayscaleToRGB"),e=t.rank-1,s=t.shape[e];et(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),et(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const i=new Array(t.rank);return i.fill(1,0,e),i[e]=3,Qc(t,i)}const Cut=At({grayscaleToRGB_:Eut});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aut(n){const t=ht(n,"image","RGBToGrayscale"),e=t.rank-1,s=t.shape[e];et(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),et(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const i=t.dtype,r=Ge(t,"float32"),a=Zo([.2989,.587,.114]);let o;switch(t.rank){case 2:o=Ob("ij,j->i",r,a);break;case 3:o=Ob("ijk,k->ij",r,a);break;case 4:o=Ob("ijkl,l->ijk",r,a);break;case 5:o=Ob("ijklm,m->ijkl",r,a);break;case 6:o=Ob("ijklmn,n->ijklm",r,a);break;default:throw new Error("Not a valid tensor rank.")}return o=xo(o,-1),Ge(o,i)}const Nut=At({rgbToGrayscale_:Aut});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mut(n,t,e=0,s=.5){const i=ht(n,"image","rotateWithOffset","float32");et(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const r={image:i},a={radians:t,fillValue:e,center:s};return wt.runKernel(wk,r,a)}const Iut=At({rotateWithOffset_:Mut});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ox(n,t,e,s,i,r){s==null&&(s=.5),i==null&&(i=Number.NEGATIVE_INFINITY),r==null&&(r=0);const a=n.shape[0];return e=Math.min(e,a),et(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),et(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),et(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),et(t.rank===1,()=>"scores must be a 1D tensor"),et(t.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${t.shape[0]}`),et(0<=r&&r<=1,()=>`softNmsSigma must be in [0, 1], but was '${r}'`),{maxOutputSize:e,iouThreshold:s,scoreThreshold:i,softNmsSigma:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rut(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY){const r=ht(n,"boxes","nonMaxSuppression","float32"),a=ht(t,"scores","nonMaxSuppression","float32"),o=Ox(r,a,e,s,i);e=o.maxOutputSize,s=o.iouThreshold,i=o.scoreThreshold;const l={maxOutputSize:e,iouThreshold:s,scoreThreshold:i};return wt.runKernel(uk,{boxes:r,scores:a},l)}const Dut=At({nonMaxSuppression_:Rut});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kut(n,t,e){const s=Out(n,t,e),i=s<0?-(s+1):s;n.splice(i,0,t)}function Out(n,t,e){return Lut(n,t,e||$ut)}function $ut(n,t){return n>t?1:n<t?-1:0}function Lut(n,t,e){let s=0,i=n.length,r=0,a=!1;for(;s<i;){r=s+(i-s>>>1);const o=e(t,n[r]);o>0?s=r+1:(i=r,a=!o)}return a?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qk(n,t,e,s,i){return eO(n,t,e,s,i,0)}function Jk(n,t,e,s,i,r){return eO(n,t,e,s,i,0,!1,r,!0)}function tO(n,t,e,s,i,r){return eO(n,t,e,s,i,r,!0)}function eO(n,t,e,s,i,r,a=!1,o=!1,l=!1){const c=[];for(let S=0;S<t.length;S++)t[S]>i&&c.push({score:t[S],boxIndex:S,suppressBeginIndex:0});c.sort(wU);const h=r>0?-.5/r:0,f=[],p=[];for(;f.length<e&&c.length>0;){const S=c.pop(),{score:b,boxIndex:T,suppressBeginIndex:C}=S;if(b<i)break;let A=!1;for(let I=f.length-1;I>=C;--I){const D=Fut(n,T,f[I]);if(D>=s){A=!0;break}if(S.score=S.score*zut(s,h,D),S.score<=i)break}S.suppressBeginIndex=f.length,A||(S.score===b?(f.push(T),p.push(S.score)):S.score>i&&kut(c,S,wU))}const g=f.length,v=e-g;o&&v>0&&(f.push(...new Array(v).fill(0)),p.push(...new Array(v).fill(0)));const _={selectedIndices:f};return a&&(_.selectedScores=p),l&&(_.validOutputs=g),_}function Fut(n,t,e){const s=n.subarray(t*4,t*4+4),i=n.subarray(e*4,e*4+4),r=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(i[0],i[2]),h=Math.min(i[1],i[3]),f=Math.max(i[0],i[2]),p=Math.max(i[1],i[3]),g=(o-r)*(l-a),v=(f-c)*(p-h);if(g<=0||v<=0)return 0;const _=Math.max(r,c),S=Math.max(a,h),b=Math.min(o,f),T=Math.min(l,p),C=Math.max(b-_,0)*Math.max(T-S,0);return C/(g+v-C)}function zut(n,t,e){const s=Math.exp(t*e*e);return e<=n?s:0}function wU(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Uut(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY){const r=ht(n,"boxes","nonMaxSuppressionAsync"),a=ht(t,"scores","nonMaxSuppressionAsync"),o=Ox(r,a,e,s,i);e=o.maxOutputSize,s=o.iouThreshold,i=o.scoreThreshold;const l=await Promise.all([r.data(),a.data()]),c=l[0],h=l[1],{selectedIndices:f}=Qk(c,h,e,s,i);return r!==n&&r.dispose(),a!==t&&a.dispose(),Zo(f,"int32")}const But=Uut;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Put(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const a=ht(n,"boxes","nonMaxSuppression"),o=ht(t,"scores","nonMaxSuppression"),l=Ox(a,o,e,s,i,r);e=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c={boxes:a,scores:o},h={maxOutputSize:e,iouThreshold:s,scoreThreshold:i,softNmsSigma:r},f=wt.runKernel(fk,c,h);return{selectedIndices:f[0],selectedScores:f[1]}}const Vut=At({nonMaxSuppressionWithScore_:Put});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Gut(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const a=ht(n,"boxes","nonMaxSuppressionAsync"),o=ht(t,"scores","nonMaxSuppressionAsync"),l=Ox(a,o,e,s,i,r);e=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c=await Promise.all([a.data(),o.data()]),h=c[0],f=c[1],{selectedIndices:p,selectedScores:g}=tO(h,f,e,s,i,r);return a!==n&&a.dispose(),o!==t&&o.dispose(),{selectedIndices:Zo(p,"int32"),selectedScores:Zo(g)}}const Hut=Gut;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wut(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const a=ht(n,"boxes","nonMaxSuppression"),o=ht(t,"scores","nonMaxSuppression"),l=Ox(a,o,e,s,i,null),c=l.maxOutputSize,h=l.iouThreshold,f=l.scoreThreshold,p={boxes:a,scores:o},g={maxOutputSize:c,iouThreshold:h,scoreThreshold:f,padToMaxOutputSize:r},v=wt.runKernel(hk,p,g);return{selectedIndices:v[0],validOutputs:v[1]}}const qut=At({nonMaxSuppressionPadded_:Wut});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Xut(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const a=ht(n,"boxes","nonMaxSuppressionAsync"),o=ht(t,"scores","nonMaxSuppressionAsync"),l=Ox(a,o,e,s,i,null),c=l.maxOutputSize,h=l.iouThreshold,f=l.scoreThreshold,[p,g]=await Promise.all([a.data(),o.data()]),{selectedIndices:v,validOutputs:_}=Jk(p,g,c,h,f,r);return a!==n&&a.dispose(),o!==t&&o.dispose(),{selectedIndices:Zo(v,"int32"),validOutputs:Ds(_,"int32")}}const jut=Xut;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kut(n,t,e=!1,s=!1){const i=ht(n,"images","resizeBilinear");et(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),et(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),et(s===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let r=i,a=!1;i.rank===3&&(a=!0,r=Ct(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:r},l={alignCorners:e,halfPixelCenters:s,size:t},c=wt.runKernel(DA,o,l);return a?Ct(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const mH=At({resizeBilinear_:Kut});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yut(n,t,e=!1,s=!1){const i=ht(n,"images","resizeNearestNeighbor");et(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),et(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),et(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),et(s===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let r=i,a=!1;i.rank===3&&(a=!0,r=Ct(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:r},l={alignCorners:e,halfPixelCenters:s,size:t},c=wt.runKernel(RA,o,l);return a?Ct(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const gH=At({resizeNearestNeighbor_:Yut});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zut(n,t="binary",e=!1,s=.5){const i=ht(n,"image","threshold"),r=.2989,a=.587,o=.114,l=i.shape[0]*i.shape[1];let c=Tt(Zo([s]),255),h,f,p,g;if(et(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),et(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),et(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),et(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),i.shape[2]===3){[h,f,p]=Cl(i,[1,1,1],-1);const S=Tt(h,r),b=Tt(f,a),T=Tt(p,o);g=_e(_e(S,b),T)}else g=n;if(t==="otsu"){const S=qat(Ge(sH(g),"int32"),RG([]),256);c=Qut(S,l)}const v=e?Dx(g,c):Dl(g,c);return Ge(Tt(v,255),"int32")}function Qut(n,t){let e=Zo([-1]),s=Zo([0]),i=Zo([0]),r,a,o,l,c,h;for(let f=0;f<n.size-1;f++){r=si(n,0,f+1),a=si(n,f+1),c=pn(un(r),t),h=pn(un(a),t);const p=un(Tt(r,$1(0,r.size)));o=pn(p,un(r));const g=jA(a.shape,r.size),v=_e($1(0,a.size),g),_=Tt(a,v);l=pn(un(_),un(a));const S=_n(o,l),b=_n(o,l),T=Tt(c,h);i=Tt(Tt(T,S),b);const C=Dl(i,s);s=Ha(C,i,s),e=Ha(C,Zo([f]),e)}return e}const Jut=At({threshold_:Zut});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tht(n,t,e="nearest",s="constant",i=0,r){const a=ht(n,"image","transform","float32"),o=ht(t,"transforms","transform","float32");et(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),et(o.rank===2&&(o.shape[0]===a.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),et(r==null||r.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${r}.`);const l={image:a,transforms:o},c={interpolation:e,fillMode:s,fillValue:i,outputShape:r};return wt.runKernel(Sk,l,c)}const eht=At({transform_:tht});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nht(n,t,e){const s=ht(n,"a","bandPart");et(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const i=s.shape,[r,a]=s.shape.slice(-2);let o,l;typeof t=="number"?(et(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),et(t<=r,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${r}).`),o=ht(t<0?r:t,"numLower","bandPart")):(et(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Ha(C2(t,0),r,O1(t,r))),typeof e=="number"?(et(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),et(e<=a,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${a}).`),l=ht(e<0?a:e,"numUpper","bandPart")):(et(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Ha(C2(e,0),a,O1(e,a)));const c=Ct($1(0,r,1,"int32"),[-1,1]),h=$1(0,a,1,"int32"),f=_n(c,h),p=Ef(Dx(f,o),Ug(f,Wi(l))),g=Dr([r,a],s.dtype);return Ct(Zd(vg(Ct(s,[-1,r,a])).map(v=>Ha(p,v,g))),i)}const sht=At({bandPart_:nht});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iht(n){let t;if(Array.isArray(n)){t=!1,et(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=n[0].shape[0];for(let r=1;r<n.length;++r)et(n[r].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[r].shape[0]} vs. ${i})`)}else t=!0,n=Cl(n,n.shape[0],0).map(i=>u_(i,[0]));et(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],s=n;for(let i=0;i<n.length;++i)e.push(wt.tidy(()=>{let r=s[i];if(i>0)for(let a=0;a<i;++a){const o=Tt(un(Tt(e[a],r)),e[a]);r=_n(r,o)}return pn(r,YA(r,"euclidean"))}));return t?Zd(e,0):e}const rht=At({gramSchmidt_:iht});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aht(n,t=!1){if(et(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return TU(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),s=vg(Ct(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),i=[],r=[];s.forEach(l=>{const[c,h]=TU(l,t);i.push(c),r.push(h)});const a=Ct(Zd(i,0),n.shape),o=Ct(Zd(r,0),n.shape);return[a,o]}}function TU(n,t=!1){return wt.tidy(()=>{et(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],s=n.shape[1];let i=YG(e),r=tg(n);const a=NI([[1]],[1,1]);let o=tg(a);const l=e>=s?s:e;for(let c=0;c<l;++c){const h=r,f=o,p=i;[o,r,i]=wt.tidy(()=>{const g=si(r,[c,c],[e-c,1]),v=YA(g),_=si(r,[c,c],[1,1]),S=Ha(Dl(_,0),NI([[-1]]),NI([[1]])),b=_n(_,Tt(S,v)),T=pn(g,b);T.shape[0]===1?o=tg(a):o=_o([a,si(T,[1,0],[T.shape[0]-1,T.shape[1]])],0);const C=Wi(pn(Ns(S,b),v)),A=si(r,[c,0],[e-c,s]),I=Tt(C,o),D=cs(o);if(c===0)r=_n(A,Ns(I,Ns(D,A)));else{const k=_n(A,Ns(I,Ns(D,A)));r=_o([si(r,[0,0],[c,s]),k],0)}const F=cs(I),z=si(i,[0,c],[e,i.shape[1]-c]);if(c===0)i=_n(z,Ns(Ns(z,o),F));else{const k=_n(z,Ns(Ns(z,o),F));i=_o([si(i,[0,0],[e,c]),k],1)}return[o,r,i]}),Xn([h,f,p])}return!t&&e>s&&(i=si(i,[0,0],[e,s]),r=si(r,[0,0],[s,s])),[i,r]})}const oht=At({qr_:aht});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bf={flipLeftRight:Tut,grayscaleToRGB:Cut,resizeNearestNeighbor:gH,resizeBilinear:mH,rgbToGrayscale:Nut,rotateWithOffset:Iut,cropAndResize:_ut,nonMaxSuppression:Dut,nonMaxSuppressionAsync:But,nonMaxSuppressionWithScore:Vut,nonMaxSuppressionWithScoreAsync:Hut,nonMaxSuppressionPadded:qut,nonMaxSuppressionPaddedAsync:jut,threshold:Jut,transform:eht},lht={bandPart:sht,gramSchmidt:rht,qr:oht};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cht=new Map,uht=new Map;let $x=class{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}},Lx=class Oy{constructor(){this.classNameMap={}}static getMap(){return Oy.instance==null&&(Oy.instance=new Oy),Oy.instance}static register(t){Oy.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function me(n,t,e){et(n.className!=null,()=>"Class being registered does not have the static className property defined."),et(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),et(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof e>"u"&&(e=n.className);const s=e,i=t+">"+s;return Lx.register(n),cht.set(i,n),uht.set(n,i),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xp=class extends $x{minimize(t,e=!1,s){const{value:i,grads:r}=this.computeGradients(t,s);if(s!=null){const a=s.map(o=>({name:o.name,tensor:r[o.name]}));this.applyGradients(a)}else this.applyGradients(r);return Xn(r),e?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return plt(t,e)}dispose(){this.iterations_!=null&&Xn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Ds(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}};Object.defineProperty(xp,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yH=class extends xp{static get className(){return"Adadelta"}constructor(t,e,s=null){super(),this.learningRate=t,this.rho=e,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=wt.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=wt.registeredVariables[s],a=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accum_grad`,variable:Lt(()=>us(r).variable(a))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${s}/accum_var`,variable:Lt(()=>us(r).variable(a))});const o=Array.isArray(t)?t[i].tensor:t[s];if(o==null)return;const l=this.accumulatedGrads[i].variable,c=this.accumulatedUpdates[i].variable;Lt(()=>{const h=_e(Tt(l,this.rho),Tt(oi(o),1-this.rho)),f=Tt(pn(qa(_e(c,this.epsilon)),qa(_e(l,this.epsilon))),o),p=_e(Tt(c,this.rho),Tt(oi(f),1-this.rho));l.assign(h),c.assign(p);const g=_e(Tt(f,-this.learningRate),r);r.assign(g)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Xn(this.accumulatedGrads.map(t=>t.variable)),Xn(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,e).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedUpdates=t.slice(e,e*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xH=class extends xp{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=wt.registeredVariables[s];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accumulator`,variable:Lt(()=>jA(r.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(t)?t[i].tensor:t[s];if(a==null)return;const o=this.accumulatedGrads[i].variable;Lt(()=>{const l=_e(o,oi(a));o.assign(l);const c=_e(Tt(pn(a,qa(_e(l,wt.backend.epsilon()))),-this.learningRate),r);r.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Xn(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vH=class extends xp{static get className(){return"Adam"}constructor(t,e,s,i=null){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Lt(()=>{this.accBeta1=Ds(e).variable(),this.accBeta2=Ds(s).variable()}),i==null&&(this.epsilon=wt.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);Lt(()=>{const s=_n(1,this.accBeta1),i=_n(1,this.accBeta2);e.forEach((r,a)=>{const o=wt.registeredVariables[r],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${r}/m`,variable:Lt(()=>us(o).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${r}/v`,variable:Lt(()=>us(o).variable(l))});const c=Array.isArray(t)?t[a].tensor:t[r];if(c==null)return;const h=this.accumulatedFirstMoment[a].variable,f=this.accumulatedSecondMoment[a].variable,p=_e(Tt(h,this.beta1),Tt(c,1-this.beta1)),g=_e(Tt(f,this.beta2),Tt(oi(c),1-this.beta2)),v=pn(p,s),_=pn(g,i);h.assign(p),f.assign(g);const S=_e(Tt(pn(v,_e(qa(_),this.epsilon)),-this.learningRate),o);o.assign(S)}),this.accBeta1.assign(Tt(this.accBeta1,this.beta1)),this.accBeta2.assign(Tt(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Xn(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Xn(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),Lt(()=>{this.accBeta1.assign(hx(this.beta1,this.iterations_+1)),this.accBeta2.assign(hx(this.beta2,this.iterations_+1))});const e=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,e).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let bH=class extends xp{static get className(){return"Adamax"}constructor(t,e,s,i=null,r=0){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=i,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Lt(()=>{this.iteration=Ds(0).variable(),this.accBeta1=Ds(e).variable()}),i==null&&(this.epsilon=wt.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);Lt(()=>{const s=_n(1,this.accBeta1),i=pn(-this.learningRate,_e(Tt(this.iteration,this.decay),1));e.forEach((r,a)=>{const o=wt.registeredVariables[r],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${r}/m`,variable:us(o).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${r}/v`,variable:us(o).variable(l)});const c=Array.isArray(t)?t[a].tensor:t[r];if(c==null)return;const h=this.accumulatedFirstMoment[a].variable,f=this.accumulatedWeightedInfNorm[a].variable,p=_e(Tt(h,this.beta1),Tt(c,1-this.beta1)),g=Tt(f,this.beta2),v=Oa(c),_=yp(g,v);h.assign(p),f.assign(_);const S=_e(Tt(pn(i,s),pn(p,_e(_,this.epsilon))),o);o.assign(S)}),this.iteration.assign(_e(this.iteration,1)),this.accBeta1.assign(Tt(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Xn(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Xn(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nO=class extends xp{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=Array.isArray(t)?t[i].tensor:t[s];if(r==null)return;const a=wt.registeredVariables[s];Lt(()=>{const o=_e(Tt(this.c,r),a);a.assign(o)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=oh(Ds(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SH=class extends nO{static get className(){return"Momentum"}constructor(t,e,s=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=s,this.accumulations=[],this.m=Ds(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=wt.registeredVariables[s];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${s}/momentum`,variable:Lt(()=>us(r).variable(!1))});const a=this.accumulations[i].variable,o=Array.isArray(t)?t[i].tensor:t[s];o!=null&&Lt(()=>{let l;const c=_e(Tt(this.m,a),o);this.useNesterov?l=_e(Tt(this.c,_e(o,Tt(c,this.m))),r):l=_e(Tt(this.c,c),r),a.assign(c),r.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Xn(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _H=class extends xp{static get className(){return"RMSProp"}constructor(t,e=.9,s=0,i=null,r=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=s,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,i==null&&(this.epsilon=wt.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=wt.registeredVariables[s],a=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${s}/rms`,variable:Lt(()=>us(r).variable(a))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${s}/momentum`,variable:Lt(()=>us(r).variable(a))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${s}/mg`,variable:Lt(()=>us(r).variable(a))});const o=Array.isArray(t)?t[i].tensor:t[s];if(o==null)return;const l=this.accumulatedMeanSquares[i].variable,c=this.accumulatedMoments[i].variable;Lt(()=>{const h=_e(Tt(l,this.decay),Tt(oi(o),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[i].variable,p=_e(Tt(f,this.decay),Tt(o,1-this.decay)),g=pn(Tt(o,this.learningRate),qa(_n(h,_e(oi(p),this.epsilon)))),v=_e(Tt(c,this.momentum),g);l.assign(h),f.assign(p),c.assign(v);const _=_n(r,v);r.assign(_)}else{const f=_e(Tt(l,this.decay),Tt(oi(o),1-this.decay)),p=_e(Tt(c,this.momentum),pn(Tt(o,this.learningRate),qa(_e(f,this.epsilon))));l.assign(f),c.assign(p);const g=_n(r,p);r.assign(g)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Xn(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Xn(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Xn(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,e).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedMoments=t.slice(e,e*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hht=[yH,xH,vH,bH,SH,_H,nO];function fht(){for(const n of hht)me(n)}function sO(n,t){const e=n.shape.length,s=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${e}`);if(Zt(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const i=t.shape,r=i[i.length-1];let a=1;for(let f=0;f<i.length-1;++f)a*=i[f];const o=n.shape,l=i.slice();l.pop();let c=1;for(let f=r;f<e;++f)c*=o[f],l.push(o[f]);const h=[...ln(n.shape).map(f=>f/c),1].slice(0,r);return[l,a,c,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BR=-2,dht=-1;function iO(n,t,e){const s=n.shape.length;et(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),et(s===e.length,()=>`Error in slice${s}D: Length of size ${e} must match the rank of the array (${s}).`);for(let i=0;i<s;++i)et(t[i]+e[i]<=n.shape[i],()=>`Error in slice${s}D: begin[${i}] + size[${i}] (${t[i]+e[i]}) would overflow input.shape[${i}] (${n.shape[i]})`)}function pht(n){const t=[];let e=0;for(;n>0;)n&1&&t.push(e),n/=2,e++;return t}function rO(n,t,e){const s=[];for(let i=0;i<n.length;i++)s[i]=Math.ceil((t[i]-n[i])/e[i]);return s}function wH(n,t,e,s){const i=[...n];for(let r=i.length;r<s.length;r++)i.push(1);for(let r=0;r<e;r++)r===0?i[t]=1:(i.splice(t,0,1),i.pop());return i}function TH(n,t,e){return e<=n?e:e-(t-1)}function EH(n,t){const e=[];for(let s=0;s<n;s++)e.push(t+s);return e}function mht(n,t,e,s,i,r,a,o,l){const c=n.length;let h=new Array(c),f=new Array(c),p=new Array(c);if(t.length&&e>0){const g=t[0],v=e+1;h=CH(a,g,v,s,n),f=AH(o,g,v,i,n),p=wH(r,g,v,n)}else for(let g=0;g<c;g++)h[g]=MH(a,s,r,n,g,l),f[g]=IH(o,i,r,n,g,l),p[g]=NH(r,g,l);return{begin:h,end:f,strides:p}}function CH(n,t,e,s,i){const r=[...i],a=EH(e,t);for(let o=0;o<r.length;o++)if(a.indexOf(o)>-1)r[o]=0;else{const l=TH(t,e,o);let c=s[l];n&1<<l&&(c=0),r[o]=c}return r}function AH(n,t,e,s,i){const r=[...i],a=EH(e,t);for(let o=0;o<r.length;o++)if(a.indexOf(o)>-1)r[o]=Number.MAX_SAFE_INTEGER;else{const l=TH(t,e,o);let c=s[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),r[o]=c}for(let o=0;o<r.length;o++){const l=i[o];r[o]<0&&(r[o]+=l),r[o]=hg(0,r[o],i[o])}return r}function NH(n,t,e){let s=n[t];return(e&1<<t||s==null)&&(s=1),s}function MH(n,t,e,s,i,r){let a=t[i];const o=e[i]||1;(n&1<<i||r&1<<i||a==null)&&(o>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const l=s[i];return a<0&&(a+=l),a=hg(0,a,l-1),a}function IH(n,t,e,s,i,r){let a=t[i];const o=e[i]||1;(n&1<<i||r&1<<i||a==null)&&(o>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const l=s[i];return a<0&&(a+=l),o>0?a=hg(0,a,l):a=hg(-1,a,l-1),a}function aO(n,t,e){let s=e.length;for(let i=0;i<e.length;i++)if(e[i]>1){s=i;break}for(let i=s+1;i<e.length;i++)if(t[i]>0||e[i]!==n[i])return!1;return!0}function oO(n,t){let e=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)e+=n[s]*t[s];return e}function QA(n,t,e){let s;const i=n.shape.length;typeof t=="number"?s=[t,...new Array(i-1).fill(0)]:t.length<i?s=t.concat(new Array(i-t.length).fill(0)):s=t.slice(),s.forEach(a=>{et(a!==-1,()=>"slice() does not support negative begin indexing.")});let r;return e==null?r=new Array(i).fill(-1):typeof e=="number"?r=[e,...new Array(i-1).fill(-1)]:e.length<i?r=e.concat(new Array(i-e.length).fill(-1)):r=e,r=r.map((a,o)=>a>=0?a:(et(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${o}.`),n.shape[o]-s[o])),[s,r]}function lO(n,t,e,s,i,r,a,o,l){let c;if(s==null?(c=new Array(t.length),c.fill(1)):c=s,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const f={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:c.slice(),beginMask:i,endMask:r,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};for(let C=0;C<f.dims;C++)h&&(1<<C&o)!==0&&f.numAddAxisAfterEllipsis++,1<<C&a&&(h=!0);h||(f.ellipsisMask|=1<<f.dims,f.dims++);const p={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};ght(f,p);let g=!0,v=!0,_=!0;const S=[],b=[];for(let C=0;C<n.length;++C){if(p.strides[C]===0)throw Error(`strides[${C}] must be non-zero`);const A=!!(p.shrinkAxisMask&1<<C),I=n[C];if(I===-1){S.push(A?1:-1);continue}const D=[p.beginMask&1<<C,p.endMask&1<<C],F=[p.strides[C]>0?0:-1,p.strides[C]>0?I:I-1];if(A&&p.strides[C]<=0)throw Error("only stride 1 allowed on non-range indexing.");_=_&&p.strides[C]===1;const z=!!(p.beginMask&1<<C&&p.endMask&1<<C);if(p.beginValid&&p.endValid){if(A){const H=p.begin[C]<0?I+p.begin[C]:p.begin[C];if(p.begin[C]=H,p.end[C]=p.begin[C]+1,H<0||H>=I)throw Error(`slice index ${p.begin[C]} of dimension ${C} out of bounds.`)}else p.begin[C]=EU(p.begin[C],0,p.strides[C],I,D,F),p.end[C]=EU(p.end[C],1,p.strides[C],I,D,F);const L=p.strides[C]===1&&p.begin[C]===0&&p.end[C]===I;g=g&&L,v=v&&(C===0&&p.strides[C]===1||L)}else g=g&&p.strides[C]===1&&z,v=v&&(C===0&&p.strides[C]===1||z);let k,O=!1;if(p.beginValid&&p.endValid?(k=p.end[C]-p.begin[C],O=!0):A?(k=1,O=!0):z&&I>=0&&(p.strides[C]<0?k=-I:k=I,O=!0),O){let L;k===0||k<0!=p.strides[C]<0?L=0:L=Math.trunc(k/p.strides[C])+(k%p.strides[C]!==0?1:0),S.push(L)}else S.push(-1)}for(let C=0;C<p.finalShapeGatherIndices.length;++C){const A=p.finalShapeGatherIndices[C];A>=0?b.push(S[A]):A===BR&&b.push(1)}return{finalShapeSparse:b.filter((C,A)=>p.finalShapeGatherIndices[A]!==BR),finalShape:b,isIdentity:g,sliceDim0:v,isSimpleSlice:_,begin:p.begin,end:p.end,strides:p.strides}}function ght(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=n.begin!=null,t.endValid=n.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const i=Math.min(t.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<i;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=s}else if(1<<s&n.newAxisMask)t.finalShapeGatherIndices.push(BR),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);n.begin!=null&&(t.begin[e]=n.begin[s]),n.end!=null&&(t.end[e]=n.end[s]),t.strides[e]=n.strides[s],n.beginMask&1<<s&&(t.beginMask|=1<<e),n.endMask&1<<s&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(dht),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[e]=s,e++}}function EU(n,t,e,s,i,r){if(i[t])return e>0?r[t]:r[t+1&1];{const a=n<0?s+n:n;return a<r[0]?r[0]:a>r[1]?r[1]:a}}const yht=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:iO,computeFlatOffset:oO,computeOutShape:rO,getNormalizedAxes:mht,isSliceContinous:aO,maskToAxes:pht,parseSliceParams:QA,sliceInfo:lO,startForAxis:MH,startIndicesWithElidedDims:CH,stopForAxis:IH,stopIndicesWithElidedDims:AH,stridesForAxis:NH,stridesWithElidedDims:wH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xht{static sgd(t){return new nO(t)}static momentum(t,e,s=!1){return new SH(t,e,s)}static rmsprop(t,e=.9,s=0,i=null,r=!1){return new _H(t,e,s,i,r)}static adam(t=.001,e=.9,s=.999,i=null){return new vH(t,e,s,i)}static adadelta(t=.001,e=.95,s=null){return new yH(t,e,s)}static adamax(t=.002,e=.9,s=.999,i=null,r=0){return new bH(t,e,s,i,r)}static adagrad(t,e=.1){return new xH(t,e)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ay=xht;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vht=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function RH(){return new Promise(n=>vht(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cO(n,t){const e=n[0].length;n.forEach((i,r)=>{et(i.length===e,()=>`Error in concat${e}D: rank of tensors[${r}] must be the same as the rank of the rest (${e})`)}),et(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const s=n[0];n.forEach((i,r)=>{for(let a=0;a<e;a++)et(a===t||i[a]===s[a],()=>`Error in concat${e}D: Shape of tensors[${r}] (${i}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`)})}function lh(n,t){const e=n[0].slice();for(let s=1;s<n.length;s++)e[t]+=n[s][t];return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var jc;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(jc||(jc={}));function DH(n,t,e){let s=new Array;if(e==null&&t==null)return s;if(t==null)for(;s.length<n+e.length;)s.push(-1);else s=t.slice();if(e==null)return s;if(n+e.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${s.length}`);for(let i=1;i<e.length;++i){const r=e[i],a=s[s.length-e.length+i],o=s[a];if(r>=0)if(o>=0){if(o!==r)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${i+n}] = ${r} but shape[${i+n}] = ${o}`)}else s[a]=r}return s}function kH(n){const t={FIRST_DIM_SIZE:jc.FIRST_DIM_SIZE,VALUE_ROWIDS:jc.VALUE_ROWIDS,ROW_LENGTHS:jc.ROW_LENGTHS,ROW_SPLITS:jc.ROW_SPLITS,ROW_LIMITS:jc.ROW_LIMITS,ROW_STARTS:jc.ROW_STARTS},e=[];for(const s of n)if(s in t)e.push(t[s]);else break;return e}function OH(n){return n.length===0?0:n[0]===jc.FIRST_DIM_SIZE?n.length-1:n.length}function $H(n,t){if(n==null||t==null)return;const e=n.length,s=t.length;if(e>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${s})`);for(let i=0;i<Math.min(e,s-1);++i){const r=n[i],a=t[i+1];if(r>=0&&a>=0&&r!==1&&r!==a)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${i-n.length}] = ${r} but ragged tensor input.flatValues.shape[${i-n.length}] = ${a}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uO=30;function JA(n){return n<=uO?n:wR(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hO(n,t,e){const s=e*(typeof n=="number"?n:n[0]),i=t*(typeof n=="number"?n:n[1]);return[s,i]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f_(n,t,e,s=!0){let i=[];if(s)i=i.concat(t.slice(0)),i.push(n[0]/e),i=i.concat(n.slice(1));else{i=i.concat(n[0]);const r=t.length;for(let a=0;a<r;++a)i=i.concat([n[a+1]/t[a],t[a]]);i=i.concat(n.slice(r+1))}return i}function d_(n,t,e=!0){const s=[];if(e){s.push(t);for(let i=t+1;i<n;++i)i<=2*t?(s.push(i),s.push(i-(t+1))):s.push(i)}else{const i=[],r=[];for(let a=1;a<n;++a)a>=t*2+1||a%2===1?r.push(a):i.push(a);s.push(...i),s.push(0),s.push(...r)}return s}function p_(n,t,e,s=!0){const i=[];s?i.push(n[0]/e):i.push(n[0]*e);for(let r=1;r<n.length;++r)r<=t.length?s?i.push(t[r-1]*n[r]):i.push(n[r]/t[r-1]):i.push(n[r]);return i}function fO(n,t){const e=[0];for(let s=0;s<t;++s)e.push(n[s][0]);return e}function dO(n,t,e){const s=n.slice(0,1);for(let i=0;i<e;++i)s.push(n[i+1]-t[i][0]-t[i][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tN=1.7580993408473768,eN=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pO=.3275911,mO=.254829592,gO=-.284496736,yO=1.421413741,xO=-1.453152027,vO=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cf(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(n.length*2);for(let s=0;s<e.length;s+=2)e[s]=n[s/2],e[s+1]=t[s/2];return e}function LH(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)t[s/2]=n[s],e[s/2]=n[s+1];return{real:t,imag:e}}function FH(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let i=0;i<n.length;i+=4)e[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:e,imag:s}}function zH(n){const t=Math.floor(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let i=2;i<n.length;i+=4)e[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:e,imag:s}}function bO(n,t){const e=n[t*2],s=n[t*2+1];return{real:e,imag:s}}function UH(n,t,e,s){n[s*2]=t,n[s*2+1]=e}function BH(n,t){const e=new Float32Array(n/2),s=new Float32Array(n/2);for(let i=0;i<Math.ceil(n/2);i++){const r=(t?2:-2)*Math.PI*(i/n);e[i]=Math.cos(r),s[i]=Math.sin(r)}return{real:e,imag:s}}function PH(n,t,e){const s=(e?2:-2)*Math.PI*(n/t),i=Math.cos(s),r=Math.sin(s);return{real:i,imag:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MI="->",bht=/->/g,CU=",",AU="...";function SO(n,t){n=n.replace(/\s/g,"");const e=(n.length-n.replace(bht,"").length)/MI.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${MI}").`);const[s,i]=n.split(MI);et(s.indexOf(AU)===-1,()=>`The ellipsis notation ("${AU}") is not supported yet.`);const r=s.split(CU),a=r.length;if(t!==a)throw new Error(`Expected ${a} input tensors, received ${t}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let p=0;p<i.length;++p){const g=i[p];if(!r.some(v=>v.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);o.indexOf(g)===-1&&o.push(g)}for(let p=0;p<s.length;++p){const g=s[p];o.indexOf(g)===-1&&g!==CU&&o.push(g)}const l=new Array(r.length);for(let p=0;p<a;++p){if(new Set(r[p].split("")).size!==r[p].length)throw new Error(`Found duplicate axes in input component ${r[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let g=0;g<r[p].length;++g)l[p].push(o.indexOf(r[p][g]))}const c=o.length,h=i.length,f=[];for(let p=h;p<c;++p)f.push(p);return{allDims:o,summedDims:f,idDims:l}}function _O(n,t){let e=new Array(n);e.fill(-1);for(let i=0;i<t.length;++i)e[t[i]]=i;const s=[];for(let i=0;i<n;++i)e[i]===-1&&s.push(i);return e=e.filter(i=>i!==-1),{permutationIndices:e,expandDims:s}}function wO(n,t,e){const s=new Array(n);for(let i=0;i<e.length;++i){const r=e[i].shape;for(let a=0;a<t[i].length;++a)s[t[i][a]]===void 0?s[t[i][a]]=r[a]:et(s[t[i][a]]===r[a],()=>`Expected dimension ${s[t[i][a]]} at axis ${a} of input shaped ${JSON.stringify(r)}, but got dimension ${r[a]}`)}}function TO(n,t){const e=n,s=[];let i=0;n.length===0&&e.push(-1),i=n.length+1;for(let a=0;a<i;++a)s.push([]);const r=[];for(let a=0;a<e.length;++a){const o=e[a],l=Sht(t,o);for(const c of l)r.indexOf(c)===-1&&(s[a].push(c),r.push(c))}return{path:e,steps:s}}function EO(n){return n.every((t,e)=>t===e)}function Sht(n,t){const e=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(t)!==-1||t===-1)&&e.push(s);return e}function CO(n,t,e=0){let s=[];if(typeof t=="number")et(n.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(n.shape[e]/t);else{const i=t.reduce((a,o)=>(o===-1&&(a+=1),a),0);et(i<=1,()=>"There should be only one negative value in split array.");const r=t.indexOf(-1);if(r!==-1){const a=t.reduce((o,l)=>l>0?o+l:o);t[r]=n.shape[e]-a}et(n.shape[e]===t.reduce((a,o)=>a+o),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VH(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function GH(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function HH(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WH(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function qH(n,t){return`size ${n} must be non-negative, not ${t}`}function XH(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function jH(n,t){const e=Zt(n),s=Zt(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${t}`}function KH(n,t){const e=Zt(n),s=Zt(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PR(){return"segment ids must be >= 0"}function YH(){return"segment ids are not increasing"}function ZH(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function QH(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JH(n,t){let e=!1,s;for(n<=uO?(s=n,e=!0):s=wR(n,Math.floor(Math.sqrt(n)));!e;)s>t||s===n?e=!0:s=wR(n,s+1);return s}function t5(n,t,e){const s=[],i=n.length;for(let r=0;r<i;r++)r!==t?s.push(n[r]):s.push(e);return s}function AO(n,t,e,s){const i=t.shape.length,r=n.shape.length;if(s!==0&&(s<-i||s>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${s}`);if(s<0&&(s+=i),s>r)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${r}).`);if(e<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`);for(let f=0;f<s;++f)if(n.shape[f]!==t.shape[f])throw new Error(`x.shape[${f}]: ${n.shape[f]} should be equal to indices.shape[${f}]: ${t.shape[f]}.`);const a=n.shape[e],o=[];let l=1,c=1,h=1;for(let f=0;f<s;++f)o.push(n.shape[f]),l*=n.shape[f];for(let f=s;f<e;f++)o.push(n.shape[f]),c*=n.shape[f];for(let f=s;f<i;f++)o.push(t.shape[f]);for(let f=e+1;f<r;f++)o.push(n.shape[f]),h*=n.shape[f];return{batchSize:l,sliceSize:h,outerSize:c,dimSize:a,outputShape:o}}const _ht=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:AO,computeOutShape:t5,segOpComputeOptimalWindowSize:JH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Af(n){try{return n.map(t=>Yd(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function e5(n){return n.map(t=>Vd(t))}const wht=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:mO,ERF_A2:gO,ERF_A3:yO,ERF_A4:xO,ERF_A5:vO,ERF_P:pO,PARALLELIZE_THRESHOLD:uO,get RowPartitionType(){return jc},SELU_SCALE:eN,SELU_SCALEALPHA:tN,applyActivation:Yk,assertAndGetBroadcastShape:Rn,assertAxesAreInnerMostDims:ea,assertParamsConsistent:cO,assignToTypedArray:UH,axesAreInnerMostDims:Ok,calculateShapes:Vg,checkEinsumDimSizes:wO,checkPadOnDimRoundingMode:No,combineLocations:jG,combineRaggedTensorToTensorShapes:DH,complexWithEvenIndex:FH,complexWithOddIndex:zH,computeConv2DInfo:ta,computeConv3DInfo:mp,computeDefaultPad:Ak,computeDilation2DInfo:o_,computeOptimalWindowSize:JA,computeOutAndReduceShapes:zr,computeOutShape:lh,computePool2DInfo:dc,computePool3DInfo:Of,convertConv2DDataFormat:$f,decodeEinsumEquation:SO,eitherStridesOrDilationsAreOne:ya,expandShapeToKeepDim:or,exponent:PH,exponents:BH,fromStringArrayToUint8:e5,fromUint8ToStringArray:Af,getAxesPermutation:Ti,getBroadcastDims:ux,getComplexWithIndex:bO,getEinsumComputePath:TO,getEinsumPermutation:_O,getFusedBiasGradient:Kk,getFusedDyActivation:jk,getImageCenter:hO,getInnerMostAxes:ji,getPermuted:d_,getRaggedRank:OH,getReductionAxes:Sr,getReshaped:f_,getReshapedPermuted:p_,getRowPartitionTypesHelper:kH,getSliceBeginCoords:fO,getSliceSize:dO,getSparseFillEmptyRowsIndicesDenseShapeMismatch:VH,getSparseFillEmptyRowsNegativeIndexErrorMessage:GH,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:HH,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:XH,getSparseReshapeInputOutputMismatchErrorMessage:KH,getSparseReshapeInputOutputMultipleErrorMessage:jH,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:WH,getSparseReshapeNegativeOutputDimErrorMessage:qH,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:QH,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:PR,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:YH,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:ZH,getUndoAxesPermutation:gp,isIdentityPermutation:EO,log:ert,mergeRealAndImagArrays:Cf,prepareAndValidate:sO,prepareSplitSize:CO,segment_util:_ht,shouldFuse:Zk,slice_util:yht,splitRealAndImagArrays:LH,stridesOrDilationsArePositive:gg,tupleValuesAreOne:mg,upcastType:Jo,validateDefaultValueShape:$H,validateInput:tut,validateUpdateShape:hH,warn:bl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */fht();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n5={kernelName:GC,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(n,h_(Ge(e,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tht={kernelName:hS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=oi(Ge(e,"float32")),i=qa(_n(Ds(1),s));return Wi(pn(n,i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eht={kernelName:fS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=qa(_n(oi(Ge(e,"float32")),1));return pn(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cht={kernelName:Ix,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Rn(e.shape,s.shape);return{a:()=>{let o=n;const l=Sr(e.shape,i);return l.length>0&&(o=un(o,l)),Ct(o,e.shape)},b:()=>{let o=n;const l=Sr(s.shape,i);return l.length>0&&(o=un(o,l)),Ct(o,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aht={kernelName:F3,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((s,i)=>{e[i]=()=>n.clone()}),e}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nht={kernelName:HC,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>us(e)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mht={kernelName:WC,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>us(e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iht={kernelName:dS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>pn(n,qa(_n(Ds(1),oi(Ge(e,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rht={kernelName:pS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=qa(_e(Ds(1),oi(Ge(e,"float32"))));return pn(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dht={kernelName:yS,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Rn(e.shape,s.shape);return{a:()=>{const o=_e(oi(e),oi(s));let l=Tt(n,pn(s,o));const c=Sr(e.shape,i);return c.length>0&&(l=un(l,c)),Ct(l,e.shape)},b:()=>{const o=_e(oi(e),oi(s));let l=Wi(Tt(n,pn(e,o)));const c=Sr(s.shape,i);return c.length>0&&(l=un(l,c)),Ct(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kht={kernelName:mS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>pn(n,_e(oi(Ge(e,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oht={kernelName:gS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>pn(n,_n(Ds(1),oi(Ge(e,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ht(n,t,e,s,i,r){const a=ht(n,"dy","avgPool3dGrad"),o=ht(t,"input","avgPool3dGrad");let l=a,c=o,h=!1;o.rank===4&&(h=!0,l=Ct(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),c=Ct(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),et(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),et(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),No("avgPool3dGrad",i,r);const f={dy:l,input:c},p={filterSize:e,strides:s,pad:i,dimRoundingMode:r},g=wt.runKernel(P3,f,p);return h?Ct(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const Lht=At({avgPool3dGrad_:$ht});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fht={kernelName:XC,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:i,strides:r,pad:a,dimRoundingMode:o}=e;return{x:()=>Lht(n,s,i,r,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zht(n,t,e,s,i){const r=ht(n,"dy","avgPoolGrad"),a=ht(t,"input","avgPoolGrad");et(a.rank===r.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${r.rank})`);let o=a,l=r,c=!1;a.rank===3&&(c=!0,o=Ct(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=Ct(r,[1,r.shape[0],r.shape[1],r.shape[2]])),et(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),et(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const h={dy:l,input:o},f={filterSize:e,strides:s,pad:i},p=wt.runKernel(B3,h,f);return c?Ct(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Uht=At({avgPoolGrad_:zht});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bht={kernelName:qC,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:i,strides:r,pad:a}=e;return{x:()=>Uht(n,s,i,r,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pht={kernelName:jC,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[s,i]=t,{transposeA:r,transposeB:a}=e;return!r&&!a?{a:()=>Ns(n,i,!1,!0),b:()=>Ns(s,n,!0,!1)}:!r&&a?{a:()=>Ns(n,i,!1,!1),b:()=>Ns(n,s,!0,!1)}:r&&!a?{a:()=>Ns(i,n,!1,!0),b:()=>Ns(s,n,!1,!1)}:{a:()=>Ns(i,n,!0,!0),b:()=>Ns(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vht={kernelName:KC,gradFunc:(n,t,e)=>{const{blockShape:s,crops:i}=e;return{x:()=>Vk(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ght={kernelName:Zit,gradFunc:(n,t,e)=>{const s=e,i=s.inputShape,r=s.shape,a=Array.from(r);for(let l=i.length-1;l>=0;l--)if(i[l]===r[l])a[l]=1;else if(i[l]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${r}].`);const o=[];for(let l=0;l<a.length;l++)a[l]>1&&o.push(l);return{x:()=>un(n,o,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hht={kernelName:xS,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wht={kernelName:vS,gradFunc:n=>({x:()=>us(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qht={kernelName:bS,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{clipValueMin:i,clipValueMax:r}=e;return{x:()=>Ha(Ef(Ug(s,i),Dx(s,r)),n,us(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xht={kernelName:YC,inputsToSave:["x"],gradFunc:n5.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jht={kernelName:ZC,saveAllInputs:!0,gradFunc:(n,t,e)=>{const s=t.map(l=>l.shape),{axis:i}=e,r=Wn(i,t[0].shape)[0],a=s.map(l=>l[r]);return Cl(n,a,r).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kht={kernelName:QC,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,i]=t,{dilations:r,strides:a,pad:o,dataFormat:l}=e;return et(mg(r),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`),{x:()=>Rk(s.shape,n,i,a,o,l),filter:()=>Xk(s,n,i.shape,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yht={kernelName:JC,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[s,i]=t,{strides:r,pad:a,dataFormat:o,dimRoundingMode:l}=e;return{dy:()=>yg(n,i,r,a,o,1,l),filter:()=>Xk(n,s,i.shape,r,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zht(n,t,e,s,i){let r=n;n.rank===4&&(r=Ct(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let a=t;a.rank===4&&(a=Ct(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),et(r.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${r.shape}.`),et(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),et(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),et(r.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${r.shape[4]}) must match input depth in filter (${e[3]}.`),et(a.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${e[4]}).`);const o={x:r,dy:a},l={strides:s,pad:i,filterShape:e};return wt.runKernel(q3,o,l)}const Qht=At({conv3DBackpropFilter_:Zht});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jht={kernelName:tA,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:i,pad:r}=e;et(mg(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[a,o]=t;return{x:()=>WG(a.shape,n,o,i,r),filter:()=>Qht(a,n,o.shape,i,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tft={kernelName:SS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(Wi(oH(Ge(e,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eft={kernelName:_S,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(lH(Ge(e,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nft={kernelName:eA,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:i,exclusive:r,reverse:a}=e;return{x:()=>{const o=Ti([i],s.rank);let l=XG(n,i,r,!a);return o!=null&&(l=cs(l,o)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sft={kernelName:nA,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:i,pad:r,dimRoundingMode:a}=e,o=s??[1,1];et(mg(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,c]=t;return et(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),et(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),et(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),et(ya(i,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${o}'.`),No("depthwiseConv2d",r,a),{x:()=>vut(l.shape,n,c,i,r,o,a),filter:()=>yut(l,n,c.shape,i,r,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ift={kernelName:sA,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,i]=t,r={x:s,filter:i,dy:n},a={x:s,filter:i,dy:n};return{x:()=>wt.runKernel(TR,r,e),filter:()=>wt.runKernel(ER,a,e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rft={kernelName:TS,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,s={dy:n,y:e};return{x:()=>wt.runKernel(ek,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aft={kernelName:ES,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=Tt(Tf(Wi(oi(e))),2/Math.sqrt(Math.PI));return{x:()=>Tt(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oft={kernelName:CS,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(n,e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lft={kernelName:rA,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>Ct(n,e.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cft={kernelName:AS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(n,Tf(e))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uft={kernelName:NS,gradFunc:n=>({x:()=>us(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hft={kernelName:MS,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Rn(e.shape,s.shape);return{a:()=>{const o=pn(n,Ge(s,"float32")),l=Sr(e.shape,i);return l.length>0?Ct(un(o,l),e.shape):o},b:()=>{let o=Tt(n,Ge(e,"float32"));const l=Sr(s.shape,i);l.length>0&&(o=Ct(un(o,l),s.shape));const c=oi(s);return Wi(pn(o,Ge(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fft={kernelName:aA,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:s}=e,[i,r,a,o]=t,l=o??Ds(1),c=Sr(r.shape,i.shape),h=[];if(r.rank===1){for(let A=0;A<i.shape.length-1;++A)h.push(i.shape[A]);h.push(1)}const f=_n(i,r),p=Tt(n,l),g=iH(_e(a,Ds(s))),v=Tt(Tt(Tt(g,g),g),Ds(-.5));return{x:()=>r.rank===1?Ct(Tt(Tt(n,Qc(Ct(g,[1,1,1,r.shape[0]]),h)),l),i.shape):Ct(Tt(Tt(n,g),l),i.shape),mean:()=>{let A=Tt(Tt(g,Ds(-1)),p);return r.rank===1&&(A=un(A,c)),Ct(A,r.shape)},variance:()=>{let A=Tt(Tt(v,f),p);return r.rank===1&&(A=un(A,c)),Ct(A,r.shape)},scale:()=>{const A=Tt(f,g);let I=Tt(n,A);return r.rank===1&&(I=un(I,c)),Ct(I,r.shape)},offset:()=>{let A=n;return r.rank===1&&(A=un(A,c)),Ct(A,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dft={kernelName:oA,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[s,i]=t,{axis:r}=e,a=Wn(r,s.shape)[0];return{x:()=>{const l=s.shape,c=i.size,h=l.slice(0,a),f=h.length,p=l.slice(r,l.length).slice(1),g=p.length,v=NU(0,f),_=NU(f+1,f+1+g),S=MU([h,[c],p]),b=Ct(n,S),T=Ct(i,[c]),C=MU([[f],v,_]),A=cs(b,C);let I=dH(A,T,s.shape[a]);const D=gp(C);return I=cs(I,D),I},indices:()=>i}}};function NU(n,t){const e=[];for(let s=n;s<t;++s)e.push(s);return e}function MU(n){const t=[];for(let e=0;e<n.length;++e)for(let s=0;s<n[e].length;++s)t.push(n[e][s]);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pft={kernelName:IS,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>us(e),b:()=>us(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mft={kernelName:RS,gradFunc:n=>({x:()=>Ge(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gft={kernelName:DS,gradFunc:n=>({x:()=>us(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yft={kernelName:kS,gradFunc:n=>({x:()=>us(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xft={kernelName:OS,gradFunc:n=>({x:()=>us(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vft={kernelName:cA,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{alpha:i}=e,r=Dl(s,0);return{x:()=>Ha(r,n,Tt(n,i))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bft={kernelName:LS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>pn(n,_e(e,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sft={kernelName:$S,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>pn(n,Ge(e,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ft={kernelName:Jit,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{axis:i}=e;return{logits:()=>{const a=Tf(s);return _n(n,Tt(un(n,i,!0),a))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wft(n,t,e,s=5,i=1,r=1,a=.5){const o={x:n,y:t,dy:e},l={depthRadius:s,bias:i,alpha:r,beta:a};return wt.runKernel(ok,o,l)}const Tft=At({localResponseNormalizationBackprop_:wft});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eft={kernelName:mA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,i]=t,{depthRadius:r,bias:a,alpha:o,beta:l}=e;return{x:()=>Tft(s,i,n,r,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s5(n,t,e,s){return t.rank<e.rank&&(t=Ct(t,or(t.shape,s))),n.rank<e.rank&&(n=Ct(n,or(n.shape,s))),{x:()=>Tt(n,Ge(yh(e,t),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IU={kernelName:gA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{reductionIndices:i}=s,r=t[0],a=t[1],o=Wn(i,r.shape),l=s5(n,a,r,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cft={kernelName:FS,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>Tt(n,Ge(Ug(e,s),"float32")),b:()=>Tt(n,Ge(C2(e,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aft(n,t,e,s,i,r,a){const o=ht(n,"dy","maxPool3dGrad"),l=ht(t,"input","maxPool3dGrad"),c=ht(e,"output","maxPool3dGrad");let h=o,f=l,p=c,g=!1;l.rank===4&&(g=!0,h=Ct(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),f=Ct(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=Ct(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),et(h.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`),et(f.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${f.rank}.`),et(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),No("maxPool3dGrad",r,a);const v={dy:h,input:f,output:p},_={filterSize:s,strides:i,pad:r,dimRoundingMode:a},S=wt.runKernel(ck,v,_);return g?Ct(S,[S.shape[1],S.shape[2],S.shape[3],S.shape[4]]):S}const Nft=At({maxPool3dGrad_:Aft});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mft={kernelName:xA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,i]=t,{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=e;return{x:()=>Nft(n,s,i,r,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ift(n,t,e,s,i,r,a){const o=ht(n,"dy","maxPoolGrad"),l=ht(t,"input","maxPoolGrad"),c=ht(e,"output","maxPoolGrad");et(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),et(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),et(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),No("maxPoolGrad",r,a);const h={dy:o,input:l,output:c},f={filterSize:s,strides:i,pad:r,dimRoundingMode:a};return wt.runKernel(lk,h,f)}const Rft=At({maxPoolGrad_:Ift});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dft={kernelName:yA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,i]=t,{filterSize:r,strides:a,pad:o}=e;return{x:()=>Rft(n,s,i,r,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kft={kernelName:vA,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:i}=e,r=Wn(i,s.shape),o=zr(s.shape,r)[1],l=Zt(o);return{x:()=>{const h=s.shape.slice();r.forEach(g=>{h[g]=1});const f=Ct(n,h);return pn(Tt(f,Bg(s.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oft={kernelName:bA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{axis:i}=s,[r,a]=t,o=Wn(i,r.shape),l=s5(n,a,r,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ft={kernelName:zS,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>Tt(n,Ge(Dx(e,s),"float32")),b:()=>Tt(n,Ge(Dl(e,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lft={kernelName:SA,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:i}=e,r=i.map(a=>a[0]);return{x:()=>si(n,r,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fft={kernelName:US,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Rn(e.shape,s.shape);return{a:()=>{const o=Sr(e.shape,i);return o.length>0?Ct(un(n,o),e.shape):n},b:()=>{const o=Tt(n,Wi(ZA(pn(e,s)))),l=Sr(s.shape,i);return l.length>0?Ct(un(o,l),s.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zft={kernelName:BS,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Rn(e.shape,s.shape);return{a:()=>{const o=Tt(n,Ge(s,"float32")),l=Sr(e.shape,i);return l.length>0?Ct(un(o,l),e.shape):o},b:()=>{const o=Tt(n,Ge(e,"float32")),l=Sr(s.shape,i);return l.length>0?Ct(un(o,l),s.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uft={kernelName:_A,gradFunc:n=>({x:()=>Wi(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bft={kernelName:EA,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>Dr(e.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pft={kernelName:TA,gradFunc:n=>({x:()=>us(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vft={kernelName:CA,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:s}=e;return vg(n,s).map(r=>()=>r)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RU={kernelName:AA,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:i}=e,r=i.map(a=>a[0]);return{x:()=>si(n,r,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gft={kernelName:PS,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,s,i]=t,r=e,a=s,o=Rn(r.shape,a.shape);return{a:()=>{const h=Ge(a,"float32");let f=Tt(n,Tt(h,hx(r,_n(h,Ds(1)))));const p=Sr(r.shape,o);return p.length>0&&(f=un(f,p)),Ct(f,r.shape)},b:()=>{const h=Dl(r,0),f=Ha(h,xh(r),us(r));let p=Tt(n,Tt(i,f));const g=Sr(a.shape,o);return g.length>0&&(p=un(p,g)),Ct(p,a.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hft={kernelName:NA,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,s]=t,i=Dl(e,0);return{x:()=>Ha(i,n,Tt(n,s)),alpha:()=>{let r=Ha(i,us(n),Tt(n,e));const a=Sr(s.shape,n.shape);return a.length>0&&(r=un(r,a)),Ct(r,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wft(n,t,e){const s=n.shape.slice();s[e]=1;const i=Ct(t,s),r=zR(n,e,!0,!1),a=zR(n,e,!0,!0),o=Tt(r,a);return Tt(i,o)}function qft(n,t,e){const s=n.shape.length,i=s-e.length,r=Ti(e,s);let a=n;r!=null&&(a=cs(n,r));const o=a.shape.slice(),c=o.splice(s-e.length,e.length).reduce((p,g)=>p*g,1);o.push(c);const h=a.reshape(o);let f=Wft(h,t,i);if(f=f.reshape(a.shape),r!=null){const p=gp(r);f=cs(f,p)}return f}const Xft={kernelName:MA,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:i}=e;let r=[];return i==null?r=s.shape.map((a,o)=>o):typeof i=="number"?r=[i]:r=i,{x:()=>qft(s,n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jft={kernelName:wS,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Rn(e.shape,s.shape);return{a:()=>{const o=pn(n,Ge(s,"float32")),l=Sr(e.shape,i);return l.length>0?Ct(un(o,l),e.shape):o},b:()=>{let o=Tt(n,Ge(e,"float32"));const l=Sr(s.shape,i);l.length>0&&(o=Ct(un(o,l),s.shape));const c=oi(s);return Wi(pn(o,Ge(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kft={kernelName:VS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>pn(n,Wi(oi(e)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yft={kernelName:HS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=Tt(Dx(e,6),h_(e));return{x:()=>Tt(n,Ge(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zft={kernelName:GS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(n,Ge(h_(e),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qft={kernelName:IA,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,e.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jft={kernelName:DA,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,i={dy:n,images:s};return{images:()=>wt.runKernel(gk,i,e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tdt={kernelName:RA,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,i={dy:n,images:s};return{images:()=>wt.runKernel(mk,i,e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const edt={kernelName:kA,gradFunc:(n,t,e)=>{const{dims:s}=e,i=Wn(s,n.shape);return{x:()=>xg(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ndt={kernelName:WS,gradFunc:n=>({x:()=>us(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sdt={kernelName:qS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Wi(pn(n,Tt(hx(e,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const idt={kernelName:OA,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>Ge(us(e),"float32"),t:()=>Tt(n,Ge(e,n.dtype)),e:()=>Tt(n,Ge(zk(e),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rdt={kernelName:XS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Dl(e,Ds(0)),i=Ds(tN),r=Ds(eN),a=Tt(n,r),o=Tt(Tt(n,i),Tf(Ge(e,"float32")));return Ha(s,a,o)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const adt={kernelName:ZS,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(n,Tt(e,_n(Ds(1),e)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const odt={kernelName:YS,gradFunc:n=>({x:()=>us(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ldt={kernelName:jS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(Dk(Ge(e,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cdt={kernelName:KS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(qG(Ge(e,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const udt={kernelName:$A,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{begin:i,size:r}=e,a=s.shape,[o,l]=QA(s,i,r),c=[];for(let h=0;h<n.rank;h++)c.push([o[h],a[h]-o[h]-l[h]]);return{x:()=>Pk(n,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hdt={kernelName:UA,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{dim:i}=e,r=!0,a=Tt(n,s);return{logits:()=>_n(a,Tt(un(a,[i],r),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fdt={kernelName:QS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(n,Rx(e))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DU={kernelName:FA,gradFunc:(n,t,e)=>{const{blockShape:s,paddings:i}=e;return{x:()=>Ik(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kU={kernelName:zA,gradFunc:(n,t,e)=>{const{axis:s}=e;return{x:()=>_o(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ddt={kernelName:JS,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>pn(n,Tt(qa(Ge(e,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pdt={kernelName:yk,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(n,Tt(Ge(e,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mdt={kernelName:t_,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ds(2);return{a:()=>Tt(n,Tt(i,_n(e,s))),b:()=>Tt(n,Tt(i,_n(s,e)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gdt={kernelName:r_,gradFunc:n=>({x:()=>us(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ydt={kernelName:e_,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Rn(e.shape,s.shape);return{a:()=>{let o=n;const l=Sr(e.shape,i);return l.length>0&&(o=un(o,l)),Ct(o,e.shape)},b:()=>{let o=n;const l=Sr(s.shape,i);return l.length>0&&(o=un(o,l)),Ct(Wi(o),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xdt={kernelName:LA,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,i=s.shape.slice(),{axis:r}=e;Wn(r,s.shape).forEach(c=>{i[c]=1});const o=Ct(n,i),l=Tt(o,Bg(s.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vdt={kernelName:n_,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>pn(n,oi(Dk(e)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bdt={kernelName:s_,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(_n(Ds(1),oi(e)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sdt={kernelName:i_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{reps:i}=e;return{x:()=>{let a=us(s);if(s.rank===1)for(let o=0;o<i[0];++o)a=_e(a,si(n,[o*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let o=0;o<i[0];++o)for(let l=0;l<i[1];++l)a=_e(a,si(n,[o*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let o=0;o<i[0];++o)for(let l=0;l<i[1];++l)for(let c=0;c<i[2];++c)a=_e(a,si(n,[o*s.shape[0],l*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let o=0;o<i[0];++o)for(let l=0;l<i[1];++l)for(let c=0;c<i[2];++c)for(let h=0;h<i[3];++h)a=_e(a,si(n,[o*s.shape[0],l*s.shape[1],c*s.shape[2],h*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _dt={kernelName:Hy,gradFunc:(n,t,e)=>{const s=e,{perm:i}=s,r=gp(i);return{x:()=>cs(n,r)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wdt={kernelName:BA,gradFunc:(n,t,e)=>{const s=e,{axis:i}=s;return{value:()=>Zd(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tdt={kernelName:PA,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Edt(n,e)}}};function Edt(n,t){const e=yp(t,us(t)),s=$k(n,e);let i=Ug(t,Ds(0,"int32"));const r=s.rank-i.rank;for(let o=0;o<r;++o)i=xo(i,o+1);i=Ef(i,Bg(s.shape,"bool"));const a=us(s);return Ha(i,s,a)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cdt={kernelName:VA,gradFunc:n=>({x:()=>us(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Adt=[n5,Tht,Eht,Cht,Aht,Nht,Mht,Iht,Rht,Dht,kht,Oht,Fht,Bht,Pht,Vht,Ght,Hht,Wht,qht,Xht,jht,Yht,Kht,Jht,tft,eft,nft,sft,ift,jft,rft,aft,oft,lft,cft,hft,uft,fft,dft,pft,mft,gft,yft,xft,vft,bft,Sft,_ft,Eft,IU,IU,Cft,Mft,Dft,kft,Oft,$ft,Lft,Fft,zft,Uft,Bft,Pft,Vft,RU,RU,Gft,Hft,Xft,Kft,Yft,Zft,Qft,Jft,tdt,edt,ndt,sdt,idt,rdt,adt,odt,ldt,cdt,udt,hdt,fdt,DU,DU,kU,kU,ddt,mdt,pdt,gdt,ydt,xdt,vdt,bdt,Sdt,_dt,wdt,Tdt,Cdt];for(const n of Adt)nrt(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.abs=function(){return this.throwIfDisposed(),Oa(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.acos=function(){return this.throwIfDisposed(),rat(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.acosh=function(){return this.throwIfDisposed(),oat(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.add=function(n){return this.throwIfDisposed(),_e(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.all=function(n,t){return this.throwIfDisposed(),VG(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.any=function(n,t){return this.throwIfDisposed(),LR(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.argMax=function(n){return this.throwIfDisposed(),R1(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.argMin=function(n){return this.throwIfDisposed(),fat(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.asScalar=function(){return this.throwIfDisposed(),et(this.size===1,()=>"The array must have only 1 element."),Ct(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.asType=function(n){return this.throwIfDisposed(),Ge(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.as1D=function(){return this.throwIfDisposed(),Ct(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.as2D=function(n,t){return this.throwIfDisposed(),Ct(this,[n,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),Ct(this,[n,t,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.as4D=function(n,t,e,s){return this.throwIfDisposed(),Ct(this,[n,t,e,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.as5D=function(n,t,e,s,i){return this.throwIfDisposed(),Ct(this,[n,t,e,s,i])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.asin=function(){return this.throwIfDisposed(),pat(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.asinh=function(){return this.throwIfDisposed(),gat(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.atan=function(){return this.throwIfDisposed(),xat(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.atan2=function(n){return this.throwIfDisposed(),bat(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.atanh=function(){return this.throwIfDisposed(),_at(this)};Kt().prototype.avgPool=function(n,t,e,s){return this.throwIfDisposed(),Nk(this,n,t,e,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),Ik(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.batchNorm=function(n,t,e,s,i){return this.throwIfDisposed(),XA(this,n,t,e,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.broadcastTo=function(n){return this.throwIfDisposed(),l1(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.cast=function(n){return this.throwIfDisposed(),Ge(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.ceil=function(){return this.throwIfDisposed(),Kat(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Il(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof nr&&(n=[n]),_o([this,...n],t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.conv1d=function(n,t,e,s,i,r){return this.throwIfDisposed(),GG(this,n,t,e,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.conv2dTranspose=function(n,t,e,s,i){return this.throwIfDisposed(),HG(this,n,t,e,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.conv2d=function(n,t,e,s,i,r){return this.throwIfDisposed(),yg(this,n,t,e,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.cos=function(){return this.throwIfDisposed(),Dk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.cosh=function(){return this.throwIfDisposed(),qG(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),zR(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),XG(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),bot(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.depthwiseConv2d=function(n,t,e,s,i,r){return this.throwIfDisposed(),kk(this,n,t,e,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.dilation2d=function(n,t,e,s,i){return this.throwIfDisposed(),wot(this,n,t,e,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.divNoNan=function(n){return this.throwIfDisposed(),Not(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.div=function(n){return this.throwIfDisposed(),pn(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.dot=function(n){return this.throwIfDisposed(),Iot(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.elu=function(){return this.throwIfDisposed(),KA(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.equal=function(n){return this.throwIfDisposed(),yh(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.erf=function(){return this.throwIfDisposed(),Oot(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),Got(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.exp=function(){return this.throwIfDisposed(),Tf(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.expandDims=function(n){return this.throwIfDisposed(),xo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.expm1=function(){return this.throwIfDisposed(),Xot(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.fft=function(){return this.throwIfDisposed(),uH(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.flatten=function(){return this.throwIfDisposed(),Ct(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.floor=function(){return this.throwIfDisposed(),ZA(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.floorDiv=function(n){return this.throwIfDisposed(),PG(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.gather=function(n,t,e){return this.throwIfDisposed(),$k(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Ug(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.greater=function(n){return this.throwIfDisposed(),Dl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.ifft=function(){return this.throwIfDisposed(),UR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.irfft=function(){return this.throwIfDisposed(),Pct(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.isFinite=function(){return this.throwIfDisposed(),nlt(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.isInf=function(){return this.throwIfDisposed(),ilt(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.isNaN=function(){return this.throwIfDisposed(),alt(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Fk(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.lessEqual=function(n){return this.throwIfDisposed(),Dx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.less=function(n){return this.throwIfDisposed(),C2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.localResponseNormalization=function(n,t,e,s){return this.throwIfDisposed(),hlt(this,n,t,e,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.logSigmoid=function(){return this.throwIfDisposed(),xlt(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.logSoftmax=function(n){return this.throwIfDisposed(),QG(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),_lt(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.log=function(){return this.throwIfDisposed(),xh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.log1p=function(){return this.throwIfDisposed(),ZG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Ef(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.logicalNot=function(){return this.throwIfDisposed(),zk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.logicalOr=function(n){return this.throwIfDisposed(),JG(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.logicalXor=function(n){return this.throwIfDisposed(),Alt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),Ns(this,n,t,e)};Kt().prototype.maxPool=function(n,t,e,s){return this.throwIfDisposed(),Uk(this,n,t,e,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.max=function(n,t){return this.throwIfDisposed(),nu(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.maximum=function(n){return this.throwIfDisposed(),yp(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.mean=function(n,t){return this.throwIfDisposed(),sr(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.min=function(n,t){return this.throwIfDisposed(),E2(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.minimum=function(n){return this.throwIfDisposed(),O1(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),$lt(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.mod=function(n){return this.throwIfDisposed(),Flt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.mul=function(n){return this.throwIfDisposed(),Tt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.neg=function(){return this.throwIfDisposed(),Wi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.norm=function(n,t,e){return this.throwIfDisposed(),YA(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.notEqual=function(n){return this.throwIfDisposed(),A2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),tH(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.onesLike=function(){return this.throwIfDisposed(),uc(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.pad=function(n,t){return this.throwIfDisposed(),Pk(this,n,t)};Kt().prototype.pool=function(n,t,e,s,i,r){return this.throwIfDisposed(),Xlt(this,n,t,e,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.pow=function(n){return this.throwIfDisposed(),hx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.prelu=function(n){return this.throwIfDisposed(),Gk(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.prod=function(n,t){return this.throwIfDisposed(),Ylt(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.reciprocal=function(){return this.throwIfDisposed(),Sct(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.relu=function(){return this.throwIfDisposed(),Pg(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.relu6=function(){return this.throwIfDisposed(),nH(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.reshapeAs=function(n){return this.throwIfDisposed(),Ct(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.reshape=function(n){return this.throwIfDisposed(),Ct(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),mH(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),gH(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.reverse=function(n){return this.throwIfDisposed(),xg(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.rfft=function(){return this.throwIfDisposed(),Hct(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.round=function(){return this.throwIfDisposed(),sH(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.rsqrt=function(){return this.throwIfDisposed(),iH(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.selu=function(){return this.throwIfDisposed(),rH(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.separableConv2d=function(n,t,e,s,i,r){return this.throwIfDisposed(),aH(this,n,t,e,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.sigmoid=function(){return this.throwIfDisposed(),Rx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.sign=function(){return this.throwIfDisposed(),Ict(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.sin=function(){return this.throwIfDisposed(),oH(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.sinh=function(){return this.throwIfDisposed(),lH(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.slice=function(n,t){return this.throwIfDisposed(),si(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.softmax=function(n){return this.throwIfDisposed(),qk(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.softplus=function(){return this.throwIfDisposed(),l_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),Vk(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.split=function(n,t){return this.throwIfDisposed(),Cl(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.sqrt=function(){return this.throwIfDisposed(),qa(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.square=function(){return this.throwIfDisposed(),oi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.squaredDifference=function(n){return this.throwIfDisposed(),qct(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.squeeze=function(n){return this.throwIfDisposed(),u_(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof nr?[this,n]:[this,...n];return Zd(e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.step=function(n){return this.throwIfDisposed(),h_(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.stridedSlice=function(n,t,e,s,i,r,a,o){return this.throwIfDisposed(),Zct(this,n,t,e,s,i,r,a,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.sub=function(n){return this.throwIfDisposed(),_n(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.sum=function(n,t){return this.throwIfDisposed(),un(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.tan=function(){return this.throwIfDisposed(),Jct(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.tanh=function(){return this.throwIfDisposed(),Mk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.tile=function(n){return this.throwIfDisposed(),Qc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.toBool=function(){return this.throwIfDisposed(),Ge(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.toFloat=function(){return this.throwIfDisposed(),Ge(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.toInt=function(){return this.throwIfDisposed(),Ge(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.topk=function(n,t){return this.throwIfDisposed(),nut(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.transpose=function(n){return this.throwIfDisposed(),cs(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.unique=function(n){return this.throwIfDisposed(),rut(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),dH(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.unstack=function(n){return this.throwIfDisposed(),vg(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.where=function(n,t){return this.throwIfDisposed(),Ha(n,this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kt().prototype.zerosLike=function(){return this.throwIfDisposed(),us(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Zu extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Zu.prototype)}}class oc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,oc.prototype)}}class bt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,bt.prototype)}}class Fn extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Fn.prototype)}}class NO extends Error{constructor(t){super(t),Object.setPrototypeOf(this,NO.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class i5{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=t}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bg(n,t){if(Array.isArray(n)){let e=[];for(let s=0;s<t;s++)e=e.concat(n);return e}else{const e=new Array(t);return e.fill(n),e}}function Qu(n,t){if(!n)throw new NO(t)}function OU(n,t){let e=0;for(const s of n)s===t&&e++;return e}function vo(n){return n.length===1?n[0]:n}function ri(n){return Array.isArray(n)?n:[n]}function ff(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function zm(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let sc={};function MO(n){if(n==null)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function VR(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(t=>VR(t));else{const t=Object.keys(n);for(const e of t){const s=n[e];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[e]=s.value:VR(s))}}}function m_(n,t={},e={},s="object",i=!1){if(typeof n=="string"){const r=n;let a;if(r in e)a=e[r];else if(r in sc)a=sc[r];else if(a=t[r],a==null)throw new bt(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{const r=n;if(r.className==null||r.config==null)throw new bt(`${s}: Improper config format: ${JSON.stringify(r)}.
'className' and 'config' must set.`);const a=r.className;let o,l;if(a in e?[o,l]=e[a]:a in sc?[o,l]=sc.className:a in t&&([o,l]=t[a]),o==null)throw new bt(`Unknown ${s}: ${a}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const g of Object.keys(sc))c[g]=sc[g];for(const g of Object.keys(e))c[g]=e[g];const h=r.config;h.customObjects=c;const f=Object.assign({},sc);for(const g of Object.keys(e))sc[g]=e[g];VR(r.config);const p=l(o,r.config,e,i);return sc=Object.assign({},f),p}else{const c=Object.assign({},sc);for(const f of Object.keys(e))sc[f]=e[f];const h=new o(r.config);return sc=Object.assign({},c),h}}}function Ndt(n,t){return n<t?-1:n>t?1:0}function GT(n,t){return-1*Ndt(n,t)}function Gd(n){if(n==null)return n;const t=[];for(const e of n)t.indexOf(e)===-1&&t.push(e);return t}function Mdt(n){if(n==null)throw new bt(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function Gg(n,t,e){if(e!=null&&n.indexOf(e)<0)throw new bt(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function IO(n,t,e=0,s=1/0){return Qu(e>=0),Qu(s>=e),Array.isArray(n)&&n.length>=e&&n.length<=s&&n.every(i=>typeof i===t)}function Or(n,t){Array.isArray(n)?(et(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,s)=>Or(e,`element ${s+1} of ${t}`))):et(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${r5(n)}.`)}function r5(n){return n===null?"null":Array.isArray(n)?"["+n.map(t=>r5(t)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function Idt(n,t,e){let s=e!=null?e():yo(),i;return(...a)=>{const o=e!=null?e():yo();return o-s<t||(s=o,i=n(...a)),i}}function a5(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Rdt=0;function o5(){return Rdt++}const HT={};function nN(n=""){return n in HT||(HT[n]=0),HT[n]+=1,n+HT[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Ddt=["channelsFirst","channelsLast"],kdt=["nearest","bilinear"],Odt=["valid","same","causal"],$dt=["max","avg"],Ldt=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Ny=new Map;function Ki(n){Gg(Ddt,"DataFormat",n)}function Fdt(n){Gg(kdt,"InterpolationFormat",n)}function kl(n){Gg(Odt,"PaddingMode",n)}function l5(n){Gg($dt,"PoolMode",n)}const c1=[],$U="/";function eg(n,t){c1.push(n);try{const e=t();return c1.pop(),e}catch(e){throw c1.pop(),e}}function zdt(){return c1.length===0?"":c1.join($U)+$U}function c5(n){if(!h5(n))throw new Error("Not a valid tensor name: '"+n+"'");return zdt()+n}function u5(n){if(!h5(n))throw new Error("Not a valid tensor name: '"+n+"'");Ny.has(n)||Ny.set(n,0);const t=Ny.get(n);if(Ny.set(n,Ny.get(n)+1),t>0){const e=`${n}_${t}`;return Ny.set(e,1),e}else return n}const Udt=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function h5(n){return!!n.match(Udt)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Bdt(n){return n===parseInt(n.toString(),10)}function Hd(n,t,e){t==null&&(t=0),e==null&&(e=n.length);let s=1;for(let i=t;i<e;++i)s*=n[i];return s}function dx(n){if(n.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s<t&&(t=s)}return t}function Qd(n){if(n.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s>t&&(t=s)}return t}function au(n,t){if(t<n)throw new bt(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let s=n;s<t;++s)e.push(s);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let II;function yr(){return II==null&&(II=Qrt().epsilon()),II}function ou(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ch(n,t){return Ge(n,t)}function g_(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),Ct(n,e)}function Pdt(n,t){return Lt(()=>{if(n.shape.length!==2)throw new bt(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const e=g_(n,1);return GR(e,[1,t,1])})}function Vdt(n){const t=[Hd(n.shape)];return Ct(n,t)}function Gdt(n){if(n.rank<=1)throw new bt(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],Hd(n.shape,1)];return Ct(n,t)}function ng(n,t,e){return Lt(()=>{switch(n.rank){case 1:return Hk(n,t,e);case 2:return cH(n,[t,0],[e,n.shape[1]]);case 3:return Wk(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return M2(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return si(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return si(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new bt(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function RI(n,t,e){return Lt(()=>{switch(n.rank){case 1:return Hk(n,t,e);case 2:return cH(n,[0,t],[n.shape[0],e]);case 3:return Wk(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return M2(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new bt(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function WT(n,t,e,s){return Lt(()=>{switch(n.rank){case 1:return Hk(n,t,e);case 2:switch(s){case 1:return ng(n,t,e);case 2:return RI(n,t,e);default:throw new bt(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return ng(n,t,e);case 2:return Wk(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return RI(n,t,e);default:throw new bt(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return ng(n,t,e);case 2:return M2(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return M2(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return RI(n,t,e);default:throw new bt(`The axis is not within the rank of the tensor ${s}`)}default:throw new bt(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function RO(n,t=-1){let e;return t<0&&(e=n[0].rank,e!==0?t=e:t=0),t===n[0].rank&&(t=-1),_o(n,t)}function LU(n,t){switch(n.rank){case 1:return Qat([n,t]);case 2:return tot([n,t],0);case 3:return not([n,t],0);case 4:return iot([n,t],0);default:throw new bt(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function GR(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new bt(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Qc(n,t)}function sN(n,t=0,e=1,s,i){return yct(n,t,e,s,i)}function uh(n,t,e,s){if(n.rank<2||t.rank<2)throw new Fn(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3){const i=n.shape.slice(-1)[0],r=t.shape.slice(-2)[0];if(i!==r)throw new Fn(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)}if(n.rank===2&&t.rank===2)return _U({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?HR(n.rank,s,ou()):null,activation:e});{const i=n.shape.slice(),r=i.pop();n=Ct(n,[-1,r]);const a=t.shape.slice(),o=a.pop(),l=a.pop(),c=[...a,o],h=Array.from({length:t.rank},(v,_)=>_===0?t.rank-2:_<=t.rank-2?_-1:_);t=Ct(cs(t,h),[l,-1]);const f=[...i,...c];return Ct(_U({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?HR(n.rank,s,ou()):null,activation:e}),f)}}function f5(n,t,e){return Lt(()=>(Array.isArray(t)?t=Zo(t,"int32"):t=Ge(t,"int32"),$k(n,t,e)))}function y_(n){return Tt(n,n)}function HR(n,t,e){const s=t.shape;if(t.rank!==1&&t.rank!==n)throw new bt(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(n===5){if(e==="channelsFirst")return s.length===1?Ct(t,[1,s[0],1,1,1]):Ct(t,[1,s[3],s[0],s[1],s[2]]);if(e==="channelsLast")return s.length===1?Ct(t,[1,1,1,1,s[0]]):Ct(t,[1].concat(s))}else if(n===4){if(e==="channelsFirst")return s.length===1?Ct(t,[1,s[0],1,1]):Ct(t,[1,s[2],s[0],s[1]]);if(e==="channelsLast")return s.length===1?Ct(t,[1,1,1,s[0]]):Ct(t,[1].concat(s))}else if(n===3){if(e==="channelsFirst")return s.length===1?Ct(t,[1,s[0],1]):Ct(t,[1,s[1],s[0]]);if(e==="channelsLast")return s.length===1?Ct(t,[1,1,s[0]]):Ct(t,[1].concat(s))}else if(n<3)return t;throw new bt(`Unsupported input rank by biasAdd: ${t.rank}`)}function uu(n,t,e){return Lt(()=>(e==null&&(e=ou()),Ki(e),_e(n,HR(n.rank,t,e))))}function Hdt(n,t=1){if(t!==1)throw new Fn(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return KA(n)}function Wdt(n){return Lt(()=>pn(n,_e(Oa(n),1)))}function d5(n,t,e,s){return Lt(()=>fut(n,t,e,s))}function qdt(n){return Lt(()=>{const t=_e(.5,Tt(.2,n));return Il(t,0,1)})}function x_(n,t,e=!1){return e?n():t()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Xdt=["fanIn","fanOut","fanAvg"],jdt=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Kdt(n){Gg(Xdt,"FanMode",n)}function Ydt(n){Gg(jdt,"Distribution",n)}class pc extends $x{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class p5 extends pc{apply(t,e){return Dr(t,e)}}p5.className="Zeros";me(p5);class DO extends pc{apply(t,e){return Bg(t,e)}}DO.className="Ones";me(DO);class m5 extends pc{constructor(t){if(super(),typeof t!="object")throw new bt(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new bt(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return Lt(()=>Tt(Ds(this.value),Bg(t,e)))}getConfig(){return{value:this.value}}}m5.className="Constant";me(m5);class g5 extends pc{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return c_(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}g5.className="RandomUniform";me(g5);class y5 extends pc{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Fn(`randomNormal does not support dType ${e}.`);return sN(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}y5.className="RandomNormal";me(y5);class x5 extends pc{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Fn(`truncatedNormal does not support dType ${e}.`);return fH(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}x5.className="TruncatedNormal";me(x5);let v5=class extends pc{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return Lt(()=>{if(t.length!==2||t[0]!==t[1])throw new bt("Identity matrix initializer can only be used for 2D square matrices.");return Tt(this.gain,YG(t[0]))})}getConfig(){return{gain:this.gain}}};v5.className="Identity";me(v5);function Zdt(n,t="channelsLast"){let e,s;if(Ki(t),n.length===2)e=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(t==="channelsFirst"){const i=Hd(n,2);e=n[1]*i,s=n[0]*i}else if(t==="channelsLast"){const i=Hd(n,0,n.length-2);e=n[n.length-2]*i,s=n[n.length-1]*i}}else{const i=Hd(n);e=Math.sqrt(i),s=Math.sqrt(i)}return[e,s]}class tl extends pc{constructor(t){if(super(),t.scale<0)throw new bt(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,Kdt(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,Ydt(this.distribution),this.seed=t.seed}apply(t,e){const s=Zdt(t),i=s[0],r=s[1];let a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,i):this.mode==="fanOut"?a/=Math.max(1,r):a/=Math.max(1,(i+r)/2),this.distribution==="normal"){const o=Math.sqrt(a);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Fn(`${this.getClassName()} does not support dType ${e}.`);return fH(t,0,o,e,this.seed)}else{const o=Math.sqrt(3*a);return c_(t,-o,o,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}tl.className="VarianceScaling";me(tl);class kO extends tl{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return tl.className}}kO.className="GlorotUniform";me(kO);class OO extends tl{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return tl.className}}OO.className="GlorotNormal";me(OO);class $O extends tl{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return tl.className}}$O.className="HeNormal";me($O);class LO extends tl{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return tl.className}}LO.className="HeUniform";me(LO);class FO extends tl{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return tl.className}}FO.className="LeCunNormal";me(FO);class zO extends tl{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return tl.className}}zO.className="LeCunUniform";me(zO);class b5 extends pc{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return Lt(()=>{if(t.length<2)throw new Fn("Shape must be at least 2D.");if(e!=="int32"&&e!=="float32"&&e!==void 0)throw new TypeError(`Unsupported data type ${e}.`);e=e;const s=Zt(t.slice(0,-1)),i=t[t.length-1],r=s*i;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);const a=[Math.max(i,s),Math.min(i,s)],o=sN(a,0,1,e,this.seed),l=lht.qr(o,!1);let c=l[0];const f=l[1].flatten().stridedSlice([0],[Math.min(i,s)*Math.min(i,s)],[Math.min(i,s)+1]);return c=Tt(c,f.sign()),s<i&&(c=c.transpose()),Tt(Ds(this.gain),c.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}b5.className="Orthogonal";me(b5);const FU={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function zU(n,t={}){return m_(n,Lx.getMap().classNameMap,t,"initializer")}function _i(n){return MO(n)}function fi(n){if(typeof n=="string"){const t=n in FU?FU[n]:n;if(t==="GlorotNormal")return new OO;if(t==="GlorotUniform")return new kO;if(t==="HeNormal")return new $O;if(t==="HeUniform")return new LO;if(t==="LeCunNormal")return new FO;if(t==="LeCunUniform")return new zO;{const e={};return e.className=t,e.config={},zU(e)}}else return n instanceof pc?n:zU(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function WR(n){return Array.isArray(n)&&Array.isArray(n[0])}function I2(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function bn(n){let t;if(Array.isArray(n)){if(n.length!==1)throw new bt(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function ms(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new bt(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function R2(n){let t=0;for(const e of n)e.shape.length===0?t+=1:t+=e.shape.reduce((s,i)=>s*i);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const UU="Variable";class Qdt{constructor(t,e="float32",s=UU,i=!0,r=null){this.dtype=e??"float32",this.shape=t.shape,this.id=o5(),s=s??UU,this.originalName=c5(s),this.name=u5(this.originalName),this.trainable_=i,this.constraint=r,this.val=lut(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),Jdt(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function Jdt(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}function qR(n){return n.map(t=>t.read())}function UO(n){n.forEach(t=>{t[0].write(t[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class xr{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class nh{constructor(t,e,s,i,r,a,o){this.dtype=t,this.shape=e,this.sourceLayer=s,this.inputs=i,this.callArgs=r,this.outputTensorIndex=o,this.id=o5(),a!=null&&(this.originalName=c5(a),this.name=u5(this.originalName)),this.rank=e.length}}let tpt=0;class iN{constructor(t,e){this.callArgs=e,this.id=tpt++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const s of t.inboundLayers)s!=null&&s.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let ept=0;class qn extends $x{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=ept++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const s=this.getClassName();e=ff(s)+"_"+nN(s)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let s;if(t.batchInputShape!=null)s=t.batchInputShape;else if(t.inputShape!=null){let r=null;t.batchSize!=null&&(r=t.batchSize),s=[r].concat(t.inputShape)}this.batchInputShape=s;let i=t.dtype;i==null&&(i=t.inputDType),i==null&&(i="float32"),this.dtype=i}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new oc(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new bt(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return vo(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return vo(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Zu(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Zu(`Layer ${this.name} is not connected, no input to return.`);return vo(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Zu(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Zu(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return vo(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=ri(t),this.inputSpec==null||this.inputSpec.length===0)return;const e=ri(this.inputSpec);if(t.length!==e.length)throw new bt(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let s=0;s<t.length;s++){const i=t[s],r=e[s];if(r==null)continue;const a=i.rank;if(r.ndim!=null&&a!==r.ndim)throw new bt(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${a}`);if(r.maxNDim!=null&&a>r.maxNDim)throw new bt(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${a}`);if(r.minNDim!=null&&a<r.minNDim)throw new bt(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${a}.`);if(r.dtype!=null&&i.dtype!==r.dtype)throw new bt(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${i.dtype}.`);if(r.axes){const o=i.shape;for(const l in r.axes){const c=Number(l),h=r.axes[l],f=c>=0?o[c]:o[o.length+c];if(h!=null&&[h,null].indexOf(f)===-1)throw new bt(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${o}.`)}}if(r.shape!=null)for(let o=0;o<r.shape.length;++o){const l=r.shape[o],c=i.shape[o];if(l!=null&&c!=null&&l!==c)throw new bt(`Input ${s} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${i.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const s=ri(t);let i=!0;for(const a of s)if(!(a instanceof nh)){i=!1;break}let r=!0;for(const a of s)if(a instanceof nh){r=!1;break}if(i===r)throw new bt("Arguments to apply() must be all SymbolicTensors or all Tensors");return eg(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const a=[];for(const o of ri(t))a.push(o.shape);this.build(vo(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(t),r){let a=this.call(t,e);const o=ri(a),l=[];for(let c of o)s.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(a=vo(l),this.activityRegularizer!=null)throw new Fn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{const a=npt(t),o=this.computeOutputShape(a);let l;const c=spt(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?a[0]:a),o!=null&&o.length>0&&Array.isArray(o[0])?l=o.map((h,f)=>new nh(c,h,this,ri(t),e,this.name,f)):l=new nh(c,o,this,ri(t),e,this.name),this.addInboundNode(t,l,null,null,a,o,e),this._refCount++,this.activityRegularizer!=null)throw new Fn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((s,i)=>{s!=null&&t[i]!=null&&t[i]!==s&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Zu(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const s=JSON.stringify(e.outputShapes);t.indexOf(s)===-1&&t.push(s)}if(t.length===1){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Zu(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new oc(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return R2(this.weights)}build(t){this.built=!0}getWeights(t=!1){return qR(t?this.trainableWeights:this.weights)}setWeights(t){Lt(()=>{const e=this.weights;if(e.length!==t.length)throw new bt(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;const s=[],i=qR(e);for(let r=0;r<i.length;++r){const a=i[r],o=e[r],l=t[r];if(!Is(a.shape,l.shape))throw new bt(`Layer weight shape ${a.shape} not compatible with provided weight shape ${l.shape}`);s.push([o,l])}UO(s)})}addWeight(t,e,s,i,r,a,o,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new bt(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(i=l!=null?l():fi("zeros"));const c=i.apply(e,s),h=new Qdt(c,s,t,a,o);return c.dispose(),r!=null&&this.addLoss(()=>r.apply(h.read())),a==null&&(a=!0),a?this._trainableWeights.push(h):this._nonTrainableWeights.push(h),h}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=ri(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}addInboundNode(t,e,s,i,r,a,o=null){const l=ri(t);e=ri(e),s=ri(s),i=ri(i),r=I2(r),a=I2(a);const c=[],h=[],f=[];for(const p of l)c.push(p.sourceLayer),h.push(p.nodeIndex),f.push(p.tensorIndex);new iN({outboundLayer:this,inboundLayers:c,nodeIndices:h,tensorIndices:f,inputTensors:l,outputTensors:e,inputMasks:s,outputMasks:i,inputShapes:r,outputShapes:a},o);for(let p=0;p<e.length;p++)e[p].sourceLayer=this,e[p].nodeIndex=this.inboundNodes.length-1,e[p].tensorIndex=p}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function npt(n){n=ri(n);const t=[];for(const e of n)t.push(e.shape);return vo(t)}function spt(n){return"float32"}function S5(n,t,e){if((t==null||e!=null&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),t.inboundNodes.length===0)return[n];{const s=t.inboundNodes[e];if(s.inboundLayers.length===0)return s.inputTensors;{const i=[];for(let r=0;r<s.inboundLayers.length;r++){const a=s.inputTensors[r],o=s.inboundLayers[r],l=s.nodeIndices[r],c=S5(a,o,l);for(const h of c)i.indexOf(h)===-1&&i.push(h)}return i}}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class v_ extends qn{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:nN("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new bt("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new bt("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new bt("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=t.dtype||"float32";this.batchInputShape=e,this.dtype=s,this.inputSpec=[{shape:e}];const i=new nh(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new iN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new bt(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}v_.className="InputLayer";me(v_);function ipt(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new bt("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;n.shape!=null&&t==null&&(t=[null].concat(n.shape));let e=n.dtype;return e==null&&(e="float32"),new v_({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function rpt(n,t){if(n.dtype==null||n.dtype===t.dtype)return t;try{return Ge(t,n.dtype)}catch{throw new bt(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Fd{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Fd)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,s){if(this.id2Value[t.id]==null)this.id2Value[t.id]=rpt(t,e),this.name2Id[t.name]=t.id,s!=null&&(this.id2Mask[t.id]=s);else throw new bt(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof nh){if(this.id2Value[t.id]==null)throw new bt(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const e=this.name2Id[t];if(e==null)throw new bt(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof nh){if(this.id2Value[t.id]==null)throw new bt(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const e=this.name2Id[t];if(e==null)throw new bt(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&Xn(this.id2Mask)}}const D2=new i5,k2=new i5;function apt(n){D2!=null&&D2.setMaxEntries(n),k2!=null&&k2.setMaxEntries(n)}function Wb(n,t,e,s){const i=e==null?!1:e.training,r=Array.isArray(n),a=r?n:[n],o=a.map(v=>v.name),l=[],c=t.names();for(const v of o)c.indexOf(v)!==-1?l.push(t.getValue(v)):l.push(null);const h=o.join(",")+"|"+t.names().sort().join(",");let f=D2.get(h),p;if(f==null){const v=opt(a,t);f=v.sorted,p=v.recipientCounts,D2.put(h,f),k2.put(h,p)}p={},i||Object.assign(p,k2.get(h));const g=new Fd(t);for(let v=0;v<f.length;++v){const _=f[v],S=_.sourceLayer;if(S instanceof v_)continue;const b=[],T=[],C=[];let A=!1;for(const k of _.inputs){const O=g.getValue(k),L=g.getMask(k);b.push(O),T.push(L),L!=null&&(A=!0),i||(p[k.name]--,p[k.name]===0&&!t.hasKey(k)&&o.indexOf(k.name)===-1&&!O.isDisposed&&k.sourceLayer.stateful!==!0&&C.push(O))}A&&(e=e||{},e.mask=T[0]);const I=ri(S.apply(b,e));let D=null;S.supportsMasking&&(D=S.computeMask(b,T));const F=cpt(_),z=Array.isArray(F)?F:[F];for(let k=0;k<z.length;++k){g.hasKey(z[k])||g.add(z[k],I[k],Array.isArray(D)?D[0]:D);const O=o.indexOf(z[k].name);O!==-1&&(l[O]=I[k])}i||Xn(C)}return g.disposeMasks(),r?l:l[0]}function opt(n,t){et(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],s={};if(n.length===1){const i=BU(n[0],t);e=i.sorted,s=i.recipientMap}else{const i=new Set;for(const r of n){const{sorted:a,recipientMap:o}=BU(r,t);for(const l of a)i.has(l.name)||(e.push(l),i.add(l.name));for(const l in o)s[l]==null&&(s[l]=new Set),o[l].forEach(c=>s[l].add(c))}}return{sorted:e,recipientCounts:lpt(s)}}function lpt(n){const t={};for(const e in n)t[e]=n[e].size;return t}function BU(n,t){const e=new Set,s=[],i={};for(const o of t.names())e.add(o);const r=[],a=[];for(r.push(n);r.length>0;){const o=r[r.length-1];if(e.has(o.name)){r.pop();continue}const l=a[a.length-1]===r.length-1;if(o.inputs.length===0||l)r.pop(),s.push(o),e.add(o.name),l&&a.pop();else{a.push(r.length-1);for(const c of o.inputs)i[c.name]==null&&(i[c.name]=new Set),i[c.name].add(o.name),!e.has(c.name)&&r.push(c)}}return{sorted:s,recipientMap:i}}function cpt(n){let t;if(n.sourceLayer.inboundNodes.length===1)t=n.sourceLayer.output;else{let e=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const i of n.sourceLayer.inboundNodes[s].outputTensors)if(i.id===n.id){e=s;break}t=n.sourceLayer.getOutputAt(e)}return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const upt=Bt();upt.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,apt);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function BO(n,t){return Lt(()=>qa(un(Tt(n,n),t,!0)))}class b_ extends $x{getConfig(){return{}}}class _5 extends b_{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Lt(()=>{const e=BO(t,this.axis),s=Il(e,0,this.maxValue);return Tt(t,pn(s,_e(yr(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}_5.className="MaxNorm";me(_5);class w5 extends b_{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Lt(()=>pn(t,_e(yr(),BO(t,this.axis))))}getConfig(){return{axis:this.axis}}}w5.className="UnitNorm";me(w5);class T5 extends b_{apply(t){return Pg(t)}}T5.className="NonNeg";me(T5);class E5 extends b_{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Lt(()=>{const e=BO(t,this.axis),s=_e(Tt(this.rate,Il(e,this.minValue,this.maxValue)),Tt(1-this.rate,e));return Tt(t,pn(s,_e(yr(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}E5.className="MinMaxNorm";me(E5);const PU={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function vr(n){return MO(n)}function VU(n,t={}){return m_(n,Lx.getMap().classNameMap,t,"constraint")}function br(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in PU?PU[n]:n,config:{}};return VU(e)}else return n instanceof b_?n:VU(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Mm(n){if(n==null)return;const t=[],e=[],s=[];for(const i in n){const r=n[i];if(typeof r!="number"){const a=r;t.push(a.data()),e.push(i),s.push(a)}}if(t.length>0){const i=await Promise.all(t);for(let r=0;r<i.length;++r)n[e[r]]=i[r][0];Xn(s)}}function C5(n){if(n!=null)for(const t in n){const e=n[t];typeof e!="number"&&e.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var GU;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(GU||(GU={}));const hpt=125;class L1{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class fpt{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class dpt extends L1{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});const s=e.size==null?0:e.size;this.seen+=s;for(const i in e){const r=e[i];if(typeof r=="number")this.totals.hasOwnProperty(i)||(this.totals[i]=0),this.totals[i]=this.totals[i]+r*s;else{let a;i in this.totals?a=this.totals[i]:this.totals[i]=0;const o=Lt(()=>_e(this.totals[i],Tt(r,s)));this.totals[i]=o,a!=null&&a.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?e[s]=this.totals[s]/this.seen:Lt(()=>{const i=Tt(pn(1,this.seen),this.totals[s]);e[s]=i,this.totals[s].dispose(),oh(e[s])}))}}class ppt extends L1{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(const s in e)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(e[s])}async syncData(){const t=[],e=[],s=[];for(const r in this.history){const a=this.history[r];for(let o=0;o<a.length;++o)if(typeof a[o]!="number"){const l=a[o];t.push(l.data()),e.push(r),s.push(o)}}const i=await Promise.all(t);for(let r=0;r<i.length;++r)this.history[e[r]][s[r]].dispose(),this.history[e[r]][s[r]]=i[r][0]}}class mpt extends L1{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||RH,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=hpt),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");SR(this.yieldEvery)&&(this.maybeWait=Idt(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,s){const i=[];this.yield!=null&&(await Mm(s),i.push(this.yield(t,e,s))),i.push(this.nextFrameFunc()),await Promise.all(i)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await Mm(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const s=[];this.epochEnd!=null&&(await Mm(e),s.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(t,e){this.batchBegin!=null&&(await Mm(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const s=[];this.batchEnd!=null&&(await Mm(e),s.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):SR(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(s)}async onTrainBegin(t){this.trainBegin!=null&&(await Mm(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Mm(t),await this.trainEnd(t))}}function A5(n,t){return n==null&&(n={}),n instanceof L1?[n]:Array.isArray(n)&&n[0]instanceof L1?n:ri(n).map(s=>new mpt(s,t))}class rc{constructor(){}static registerCallbackConstructor(t,e){et(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),rc.checkForDuplicate(e),rc.constructors[t]==null&&(rc.constructors[t]=[]),rc.constructors[t].push(e)}static checkForDuplicate(t){for(const e in rc.constructors)rc.constructors[+e].forEach(i=>{if(i===t)throw new bt("Duplicate callback constructor.")})}static clear(){rc.constructors={}}static createCallbacks(t){const e=[];for(const s in rc.constructors){const i=+s;t>=i&&e.push(...rc.constructors[i])}return e.map(s=>new s)}}rc.constructors={};function N5(n,t,e,s,i,r,a,o,l){const c=new ppt,h=[new dpt,...rc.createCallbacks(t)];n!=null&&h.push(...n),h.push(c);const f=new fpt(h);return f.setParams({epochs:e,initialEpoch:s,samples:i,steps:r,batchSize:a,verbose:t,doValidation:o,metrics:l}),{callbackList:f,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _f(n,t={},e=!1){return m_(n,Lx.getMap().classNameMap,t,"layer",e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function O2(n,t){return Lt(()=>{n.dtype!=="float32"&&(n=Ge(n,"float32"));const e=un(y_(n),t,!0),s=jA(e.shape,yr()),i=qa(yp(e,s));return pn(n,i)})}function rN(n,t){return Lt(()=>sr(y_(_n(t,n)),-1))}function PO(n,t){return Lt(()=>sr(Oa(_n(t,n)),-1))}function VO(n,t){return Lt(()=>{const e=_n(n,t),s=Il(Oa(n),yr(),Number.MAX_VALUE),i=Oa(pn(e,s));return Tt(100,sr(i,-1))})}function gpt(n,t){return Lt(()=>{const e=Il(t,yr(),Number.MAX_VALUE),s=xh(_e(1,e)),i=Il(n,yr(),Number.MAX_VALUE),r=xh(_e(1,i));return sr(y_(_n(s,r)),-1)})}function ypt(n,t){return Lt(()=>{const e=yp(0,_n(1,Tt(n,t)));return sr(y_(e),-1)})}function xpt(n,t){return Lt(()=>{const e=yp(0,_n(1,Tt(n,t)));return sr(e,-1)})}function vpt(n,t){return Lt(()=>{const e=un(Tt(n,t),-1),s=nu(Tt(_n(1,n),t),-1);return yp(0,_e(1,_n(s,e)))})}function bpt(n,t){return Lt(()=>{const e=Math.log(2),s=_n(t,n),i=_n(_e(s,l_(Tt(-2,s))),e);return sr(i,-1)})}function F1(n,t,e=!1){return Lt(()=>{if(e)t=qk(t);else{const s=un(t,t.shape.length-1,!0);t=pn(t,s)}return t=Il(t,yr(),1-yr()),Wi(un(Tt(Ge(n,"float32"),xh(t)),t.shape.length-1))})}function $2(n,t,e=!1){return Lt(()=>{const s=Ge(ZA(Vdt(n)),"int32");t=Il(t,yr(),1-yr());const i=t.shape,r=Ct(tH(s,i[i.length-1]),i);return F1(r,t,e)})}function Spt(n,t){if(!Is(n.shape,t.shape))throw new bt(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return Lt(()=>{const e=Pg(t),s=Wi(Oa(t));return _e(_n(e,Tt(t,n)),ZG(Tf(s)))})}function aN(n,t){return Lt(()=>{let e;return e=Il(t,yr(),1-yr()),e=xh(pn(e,_n(1,e))),sr(Spt(n,e),-1)})}function _pt(n,t){return Lt(()=>{const e=Il(n,yr(),1),s=Il(t,yr(),1);return un(Tt(n,xh(pn(e,s))),-1)})}function wpt(n,t){return Lt(()=>{const e=xh(_e(yr(),t));return sr(_n(t,Tt(n,e)),-1)})}function M5(n,t){return Lt(()=>{const e=O2(n,-1),s=O2(t,-1),i=Tt(e,s);return Wi(un(i,-1))})}const L2={meanSquaredError:rN,meanAbsoluteError:PO,meanAbsolutePercentageError:VO,meanSquaredLogarithmicError:gpt,squaredHinge:ypt,hinge:xpt,categoricalHinge:vpt,logcosh:bpt,categoricalCrossentropy:F1,sparseCategoricalCrossentropy:$2,binaryCrossentropy:aN,kullbackLeiblerDivergence:_pt,poisson:wpt,cosineProximity:M5};function DI(n){if(typeof n=="string"){if(n in L2)return L2[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new bt(t)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function I5(n,t){return Lt(()=>{const e=Tt(.5,uc(t)),s=ch(Dl(t,e),n.dtype);return sr(yh(n,s),-1)})}function R5(n,t){return Lt(()=>ch(yh(R1(n,-1),R1(t,-1)),"float32"))}function Tpt(n,t){return Lt(()=>Ge(un(Ef(yh(n,1),yh(t,1))),"float32"))}function Ept(n,t){return Lt(()=>Ge(un(Ef(yh(n,0),yh(t,1))),"float32"))}function Cpt(n,t){return Lt(()=>{const e=Tpt(n,t),s=Ept(n,t),i=_e(e,s);return Ge(Ha(Dl(i,0),pn(e,i),0),"float32")})}function Apt(n,t){return aN(n,t)}function Npt(n,t){return n.rank===t.rank&&(n=u_(n,[n.rank-1])),t=R1(t,-1),t.dtype!==n.dtype&&(t=Ge(t,n.dtype)),Ge(yh(n,t),"float32")}const Mpt=rN,Ipt=rN,Rpt=PO,Dpt=PO,kpt=VO,Opt=VO,D5=F1,$pt=M5,k5=$2,F2={binaryAccuracy:I5,categoricalAccuracy:R5,precision:Cpt,categoricalCrossentropy:D5,sparseCategoricalCrossentropy:k5,mse:Mpt,MSE:Ipt,mae:Rpt,MAE:Dpt,mape:kpt,MAPE:Opt,cosine:$pt};function Lpt(n){if(typeof n=="string"&&n in F2)return F2[n];if(typeof n!="string"&&n!=null)return n;throw new bt(`Unknown metric ${n}`)}function qT(n){if(Qu(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let t;for(const e of Object.keys(L2))if(L2[e]===n){t=e;break}if(t!==void 0)return t;for(const e of Object.keys(F2))if(F2[e]===n){t=e;break}return t!==void 0?t:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Fpt(n){const t={Adagrad:()=>Ay.adagrad(.01),Adadelta:()=>Ay.adadelta(1,.95,yr()),Adam:()=>Ay.adam(.001,.9,.999,yr()),Adamax:()=>Ay.adamax(.002,.9,.999,yr(),0),RMSProp:()=>Ay.rmsprop(.001,.9,0,yr()),SGD:()=>Ay.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new bt(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const HU=1*1024*1024;function WU(n,t,e=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!XR(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const s=JSON.stringify(n);s.length>HU&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${HU}.`)}}function XR(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if(typeof e!="string"||!XR(n[e]))return!1;return!0}else if(Array.isArray(n)){for(const t of n)if(!XR(t))return!1;return!0}else return!1;else{const t=typeof n;return t==="string"||t==="number"||t==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function zpt(n,t,e,s=console.log){const i=Bpt(n),r=["Layer (type)","Input Shape","Output shape","Param #"];i?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(h=>Math.floor(t*h)));let a;if(!i){r.push("Receives inputs"),a=[];for(const h in n.nodesByDepth)a.push(...n.nodesByDepth[h])}s("_".repeat(t)),z2(r,e,s),s("=".repeat(t));const o=n.layers;for(let h=0;h<o.length;++h)i?Ppt(o[h],e,s):Vpt(o[h],e,a,s),s((h===o.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=Upt(n),c=R2(n.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(t))}function Upt(n){let t;return n.collectedTrainableWeights!=null?t=R2(n.collectedTrainableWeights):t=R2(n.trainableWeights),t}function Bpt(n){let t=!0;const e=[],s=[];for(const i in n.nodesByDepth)e.push(n.nodesByDepth[i]);for(const i of e){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){t=!1;break}s.push(...i)}if(t)for(const i of n.layers){let r=!1;for(const a of i.inboundNodes)if(s.indexOf(a)!==-1)if(r){t=!1;break}else r=!0;if(!t)break}return t}function z2(n,t,e=console.log){let s="";for(let i=0;i<n.length;++i)i>0&&(s=s.slice(0,s.length-1)+" "),s+=n[i],s=s.slice(0,t[i]),s+=" ".repeat(t[i]-s.length);e(s)}function Ppt(n,t,e){let s,i;try{i=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const r=n.name,a=n.getClassName(),o=[`${r} (${a})`,i,s,n.countParams().toString()];z2(o,t,e)}function Vpt(n,t,e,s){let i,r;try{r=n.inboundNodes.map(f=>JSON.stringify(f.inputShapes)).join(",")}catch{r="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const a=[];for(const f of n.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(f)===-1))for(let p=0;p<f.inboundLayers.length;++p){const g=f.inboundLayers[p].name,v=f.nodeIndices[p],_=f.tensorIndices[p];a.push(`${g}[${v}][${_}]`)}const o=n.name,l=n.getClassName(),c=a.length===0?"":a[0],h=[`${o} (${l})`,r,i,n.countParams().toString(),c];z2(h,t,s);for(let f=1;f<a.length;++f)z2(["","","","",a[f]],t,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function O5(n,t,e){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&t===0&&typeof e=="string"}function jR(n,t){if(n===null)return null;if(typeof n=="string")return zm(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let i=0;i<s;++i){const r=n[i];O5(t,i,r)?e.push(r):e.push(jR(r,t))}return e}else{const e={};for(const s of Object.keys(n)){const i=n[s];if(s==="name"&&typeof i=="string")e[s]=i;else{const r=zm(s);e[r]=jR(i,r)}}return e}}function KR(n,t){if(n==null)return null;if(typeof n=="string")return ff(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let i=0;i<s;++i){const r=n[i];O5(t,i,r)?e.push(r):e.push(KR(r,t))}return e}else{const e={};for(const s of Object.keys(n)){const i=n[s],r=ff(s);(s==="name"||s==="className")&&typeof i=="string"?e[r]=i:e[r]=KR(i,s)}return e}}/** @license See the LICENSE file. */const $5="4.10.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Wc extends qn{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const T=this.getClassName().toLowerCase();this.name=nN(T)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Gd(this.inputs).length!==this.inputs.length)throw new bt(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(T=>T.name)}`);Gd(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(T=>T.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const T of this.outputs){const C=T.sourceLayer,A=T.nodeIndex,I=T.tensorIndex;this.outputLayers.push(C),this.outputLayersNodeIndices.push(A),this.outputLayersTensorIndices.push(I)}for(const T of this.inputs){const C=T.sourceLayer,A=T.nodeIndex,I=T.tensorIndex;Qu(A===0,"input layer has >1 nodes"),Qu(I===0,"input layer has >1 tensors"),this.inputLayers.push(C),this.inputLayersNodeIndices.push(A),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let T=0;T<this.inputLayers.length;T++){const C=this.inputLayers[T];if(!(C instanceof v_))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${T} (0-based) originates from layer type ${C.getClassName()}.`);this.inputNames.push(C.name),this.feedInputShapes.push(C.batchInputShape),this.feedInputNames.push(C.name)}for(const T of this.outputLayers)this.outputNames.push(T.name);this.internalInputShapes=this.inputs.map(T=>T.shape),this.internalOutputShapes=this.outputs.map(T=>T.shape);const e={},s={},i={},r={},a={},o=[],l=(T,C,A,I,D,F)=>{(I==null||D==null||F==null)&&(I=T.sourceLayer,D=T.nodeIndex,F=T.tensorIndex);const z=I.inboundNodes[D];if(A.indexOf(z)!==-1)throw new oc(`The tensor ${T.name} at layer "${I.name}" is part of a cycle.`);if(C.indexOf(z)!==-1)return;this.containerNodes.add(Wc.nodeKey(I,D)),I.id in a||(a[I.id]=Object.keys(a).length),A.indexOf(z)===-1&&A.push(z);const k=z.inboundLayers.length;for(let O=0;O<k;O++){const L=z.inputTensors[O],H=z.inboundLayers[O],q=z.nodeIndices[O],K=z.tensorIndices[O];l(L,C,A,H,q,K)}for(C.push(z);A.indexOf(z)>=0;)A.splice(A.indexOf(z),1);o.push(z)},c=[],h=[];for(const T of this.outputs)l(T,c,h);const f=o.slice().reverse();for(const T of f){s[T.id]=T,T.id in e||(e[T.id]=0);let C=e[T.id];const A=i[T.outboundLayer.id]==null?0:i[T.outboundLayer.id];C=Math.max(C,A),i[T.outboundLayer.id]=C,r[T.outboundLayer.id]=T.outboundLayer,e[T.id]=C;for(let I=0;I<T.inboundLayers.length;I++){const D=T.inboundLayers[I],F=T.nodeIndices[I],z=D.inboundNodes[F],k=e[z.id]==null?0:e[z.id];e[z.id]=Math.max(C+1,k),s[z.id]=z}}const p={};for(const T in e){const C=e[T];C in p||(p[C]=[]),p[C].push(s[T])}const g={};for(const T in i){const C=i[T];C in g||(g[C]=[]),g[C].push(r[T])}let v=Object.keys(g).map(T=>parseInt(T,10)).sort(GT);this.layers=[];for(const T of v){const C=g[T];C.sort((A,I)=>{const D=a[A.id],F=a[I.id];return D<F?-1:D>F?1:0});for(const A of C)A instanceof Wc&&this.internalContainerRefs.push(A),this.layers.push(A)}this.layersByDepth=g,v=Object.keys(p).map(T=>parseInt(T,10)).sort(GT);const _=this.inputs.slice(),S=[];for(const T of v)for(const C of p[T]){const A=C.outboundLayer;if(A!=null){for(const I of C.inputTensors)if(_.indexOf(I)===-1)throw new oc(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${A.name}". The following previous layers were accessed without issue: ${S}`);for(const I of C.outputTensors)_.push(I);S.push(A.name)}}this.nodesByDepth=p;const b=this.layers.map(T=>T.name);for(const T of b){const C=b.filter(A=>A===T).length;if(C!==1)throw new oc(`The name "${T}" is used ${C} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new iN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(T=>null),outputMasks:this.outputs.map(T=>null),inputShapes:this.inputs.map(T=>T.shape),outputShapes:this.outputs.map(T=>T.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new bt("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.layers)e.push(...s.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const s={};let i=0;const r=Object.keys(t)[0].split("/"),a=!isNaN(parseInt(r[r.length-1],10));for(const l of this.layers)for(const[c,h]of l.weights.entries()){const f=a?`${h.name.split("/").slice(0,-1).join("/")+"/"}${c}`:h.originalName;if(s[f]!=null)throw new bt(`Duplicate weight name: ${f}`);s[f]=h,i++}const o=[];for(const l in t){let c=l;if(s[l]==null){const h=l.split("/");c=h.slice(0,-2).concat([h[h.length-1]]).join("/")}if(s[c]!=null)o.push([s[c],t[l]]);else if(e)throw new bt(`Provided weight data has no target variable: ${l}`);delete s[c]}if(e){const l=[];for(const c in s)l.push(c);if(l.length>0)throw new bt(`${l.length} of ${i} weights are not set: ${l}`)}UO(o)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${$5}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=KR(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return Lt(()=>{t=ri(t);const s=new Fd;for(let i=0;i<this.inputs.length;++i)s.add(this.inputs[i],t[i]);return Wb(this.outputs,s,e)})}computeMask(t,e){return Lt(()=>{t=ri(t);let s;return e==null?s=bg(null,t.length):s=ri(e),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){const e=I2(t);if(e.length!==this.inputLayers.length)throw new bt(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let o=0;o<e.length;o++){const l=this.inputLayers[o],c=e[o],h=l.name+"_0_0";s[h]=c}const i=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(GT);if(i.length>1)for(const o of i){const l=this.nodesByDepth[o];for(const c of l){const h=c.outboundLayer;if(this.inputLayers.map(_=>_.id).indexOf(h.id)!==-1)continue;const f=[];for(let _=0;_<c.inboundLayers.length;_++){const S=c.inboundLayers[_],b=c.nodeIndices[_],T=c.tensorIndices[_],C=`${S.name}_${b}_${T}`,A=s[C];f.push(A)}const p=h.computeOutputShape(vo(f)),g=I2(p),v=h.inboundNodes.indexOf(c);for(let _=0;_<g.length;_++){const S=`${h.name}_${v}_${_}`;s[S]=g[_]}}}const r=[],a=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],c=this.outputLayersNodeIndices[o],h=this.outputLayersTensorIndices[o],f=`${l.name}_${c}_${h}`;a.push(f)}for(let o=0;o<a.length;o++){const l=a[o];Qu(l in s),r.push(s[l])}return vo(r)}runInternalGraph(t,e){e==null&&(e=bg(null,t.length));const s={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],h=t[l],f=e[l];s[c.id]=[h,f]}const i=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(GT);for(const l of i){const c=this.nodesByDepth[l];for(const h of c){const f=h.outboundLayer,p=h.inputTensors,g=h.outputTensors,v=new Array;for(const _ of p)_.id in s&&v.push(s[_.id]);if(v.length===p.length){let _={},S,b,T,C;if(h.callArgs!=null&&(_=h.callArgs),v.length===1){const[A,I]=v[0];_.mask==null&&(_.mask=I),T=ri(f.call(A,_)),C=ri(f.computeMask(A,I)),S=[A],b=[I]}else S=v.map(A=>A[0]),b=v.map(A=>A[1]),_.mask==null&&(_.mask=b),T=ri(f.call(S,_)),C=ri(f.computeMask(S,b));if(f.activityRegularizer)throw new Fn("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let A=0;A<g.length;++A){const I=g[A],D=T[A],F=C[A];s[I.id]=[D,F]}}}}const r=[],a=[],o=[];for(const l of this.outputs){Qu(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[c,h]=s[l.id];o.push(c.shape),r.push(c),a.push(h)}return[r,a,o]}buildNodeConversionMap(t){const e={};let s;for(const i of this.layers){s=i instanceof Wc?1:0;for(let r=0;r<i.inboundNodes.length;r++){const a=Wc.nodeKey(i,r);this.containerNodes.has(a)&&(e[a]=s,s+=1)}}return e}getLayer(t,e){if(e!=null)return this.findLayer(e);if(t==null)throw new bt("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const s of this.layers)if(s.name===t)return s;throw new bt(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new bt(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return Lt(()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const i=Wc.nodeKey(e,s);this.containerNodes.has(i)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const a of this.layers){const o=a.getClassName(),l=a.getConfig(),c=[];for(let f=0;f<a.inboundNodes.length;f++){const p=a.inboundNodes[f],g=Wc.nodeKey(a,f);let v={};if(this.containerNodes.has(g)){if(p.callArgs)try{JSON.stringify(p.callArgs),v=p.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),v={}}if(p.inboundLayers.length>0){const _=[];for(let S=0;S<p.inboundLayers.length;S++){const b=p.inboundLayers[S],T=p.nodeIndices[S],C=p.tensorIndices[S],A=Wc.nodeKey(b,T);let I=e[A];I==null&&(I=0),_.push([b.name,I,C,v])}c.push(_)}}}const h={};h.name=a.name,h.className=o,h.config=l,h.inboundNodes=c,s.push(h)}t.layers=s;const i=[];for(let a=0;a<this.inputLayers.length;a++){const o=this.inputLayers[a],l=this.inputLayersNodeIndices[a],c=Wc.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let h=e[c];h==null&&(h=0);const f=this.inputLayersTensorIndices[a];i.push([o.name,h,f])}t.inputLayers=i;const r=[];for(let a=0;a<this.outputLayers.length;a++){const o=this.outputLayers[a],l=this.outputLayersNodeIndices[a],c=Wc.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let h=e[c];h==null&&(h=0);const f=this.outputLayersTensorIndices[a];r.push([o.name,h,f])}return t.outputLayers=r,t}static fromConfig(t,e,s={},i=!1){const r={},a={};function o(S,b){S.name in a?a[S.name].push(b):a[S.name]=[b]}function l(S,b){const T=[];let C;for(const A of b){const I=A[0],D=A[1],F=A[2];if(C=A[3]==null?{}:A[3],!(I in r)){o(S,b);return}const z=r[I];if(z.inboundNodes.length<=D){o(S,b);return}const k=z.inboundNodes[D];T.push(k.outputTensors[F])}T.length>0&&S.apply(vo(T),C)}function c(S){const b=S.name,T=_f(S,e.customObjects!=null?e.customObjects:{});T.setFastWeightInitDuringBuild(i),r[b]=T,S.inboundNodes.forEach(A=>{if(!(A instanceof Array))throw new bt(`Corrupted configuration, expected array for nodeData: ${A}`);o(T,A)})}const h=e.name,f=e.layers;for(const S of f)c(S);for(;!Mdt(a);)for(const S of f){const b=r[S.name];if(b.name in a){const T=a[b.name];delete a[b.name];for(const C of T)l(b,C)}}const p=[],g=[],v=e.inputLayers;for(const S of v){const b=S[0],T=S[1],C=S[2];Qu(b in r);const I=r[b].inboundNodes[T].outputTensors;p.push(I[C])}const _=e.outputLayers;for(const S of _){const b=S[0],T=S[1],C=S[2];Qu(b in r);const I=r[b].inboundNodes[T].outputTensors;g.push(I[C])}return new t({inputs:p,outputs:g,name:h})}get stateful(){if(this._stateful)throw new bt("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){Lt(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Gpt(n,t,e){const s=t.length;if(n==null||Array.isArray(n)&&n.length===0)return t.map(i=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const i=[];return t.forEach(r=>{r in n?i.push(n[r]):i.push(null)}),i}else throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}function L5(n,t){return Gpt(n,t,"classWeight")}async function F5(n,t,e,s){if(e!=null){const i=Lt(()=>{if(n.shape.length===1)return tg(n);if(n.shape.length===2){if(n.shape[1]>1)return R1(n,1);if(n.shape[1]===1)return Ct(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await i.data());Xn(i);const a=[];return r.forEach(o=>{if(e[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);a.push(e[o])}),Zo(a,"float32")}else return null}function Hpt(n,t){return Tt(n,t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Wpt=32;function z5(n,t){let e,s;const i=t;e=i.xs,s=i.ys,et(e!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const r=qU("input",n.inputNames,e),a=qU("output",n.outputNames,s),o=r[0].shape[0];et(r.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),et(a.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<r.length;l++)et(r[l].shape[0]===o,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${r[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);for(let l=0;l<a.length;l++)et(a[l].shape[0]===o,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);return{xs:r,ys:a}}function qU(n,t,e){if(e instanceof nr)return[e];if(Array.isArray(e))return et(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const s=[];for(const i of t){if(e[i]==null)throw new bt(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);s.push(e[i])}return s}}function qpt(n){if(n.length===3)throw new Fn("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function Xpt(n,t,e){const s=e.batchesPerEpoch!=null;if(et(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),et(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),et(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),et(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),et(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const i=e.validationData!=null;let r,a;if(i)if(XU(e.validationData))et(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const S=qpt(e.validationData);r=S.xs,a=S.ys}const o=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;i?c=l.slice().concat(l.map(S=>"val_"+S)):c=l.slice();const h=A5(e.callbacks,e.yieldEvery),f=e.verbose==null?1:e.verbose,{callbackList:p,history:g}=N5(h,f,e.epochs,null,null,jpt(t,e),null,i,c);p.setModel(n),n.history=g,await p.onTrainBegin(),n.stopTraining_=!1;let v=e.initialEpoch==null?0:e.initialEpoch,_=await t.iterator();for(;v<e.epochs;){const S={};await p.onEpochBegin(v);let b=0,T=0;for(s||(_=await t.iterator());!s||b<e.batchesPerEpoch;){const C=await _.next();if(s&&C.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(C.value!=null){const{xs:A,ys:I}=z5(n,C.value),D={};D.batch=T,D.size=A[0].shape[0],await p.onBatchBegin(T,D);const F=[];if(e.classWeight!=null){const O=L5(e.classWeight,n.outputNames);for(let L=0;L<O.length;++L)F.push(await F5(I[L],null,O[L]))}const z=A.concat(I).concat(F),k=o(z);Xn(z);for(let O=0;O<l.length;++O){const L=l[O],H=k[O];D[L]=H,oh(H)}await p.onBatchEnd(T,D),C5(D),T++,b++}if(s?b>=e.batchesPerEpoch:C.done){if(i){let A;XU(e.validationData)?A=ri(await n.evaluateDataset(e.validationData,{batches:e.validationBatches})):A=ri(n.evaluate(r,a,{batchSize:e.validationBatchSize==null?Wpt:e.validationBatchSize,verbose:0}));for(let I=0;I<n.metricsNames.length;++I)S[`val_${n.metricsNames[I]}`]=A[I]}break}if(n.stopTraining_)break}if(await p.onEpochEnd(v,S),v++,n.stopTraining_)break}return await p.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function jpt(n,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function XU(n){return typeof n.iterator=="function"}function Kpt(n){return typeof n.next=="function"}async function Ypt(n,t,e){e=e||{};const s=e.batches!=null,i=n.testFunction;let r=[];if(e.verbose>0)throw new Fn("Verbose mode is not implemented yet.");et(!s||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const a=Kpt(t)?t:await t.iterator();let o=0,l=0;for(;!s||l<e.batches;){const c=await a.next();if(r=Lt(()=>{if(c.value){const{xs:h,ys:f}=z5(n,c.value),p=h.concat(f),g=Lt(()=>i(p));if(Xn(p),l===0)for(let _=0;_<g.length;++_)r.push(Ds(0));const v=p[0].shape[0];for(let _=0;_<g.length;++_){const S=g[_],b=r[_];r[_]=Lt(()=>_e(r[_],Tt(v,S))),l>0&&Xn(b)}Xn(g),o+=v,++l}return r}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<r.length;++c){const h=r[c];r[c]=pn(r[c],o),Xn(h)}return vo(r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function kI(n){et(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function $b(n,t,e){return n==null?[null]:Array.isArray(n)?n.map(s=>ng(s,t,e-t)):ng(n,t,e-t)}function YR(n,t){return Lt(()=>n==null?null:Array.isArray(n)?n.map(e=>YR(e,t)):f5(n,t.dtype==="int32"?t:Ge(t,"int32")))}function OI(n,t){const e=[];let s=0,i=null;for(;s<n;)i=s+t,i>=n&&(i=n),e.push([s,i]),s=i;return e}function U5(n){const t=[];n instanceof nr&&(n=[n]);for(let e=0;e<n.length;++e){const s=n[e];if(s.rank===1)t.push(g_(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function Gc(n,t){if(n==null)return;const e=[];if(t instanceof nr)e.push(t.id);else if(Array.isArray(t))t.forEach(i=>e.push(i.id));else if(t!=null)for(const i in t){const r=t[i];e.push(r.id)}const s=[];if(n instanceof nr)e.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(i=>{e.indexOf(i.id)===-1&&s.push(i)});else if(n!=null)for(const i in n){const r=n[i];e.indexOf(r.id)===-1&&s.push(r)}s.forEach(i=>{i.isDisposed||i.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Zpt(n){return n instanceof nr}function ZR(n){return Array.isArray(n)}function jU(n){return!Zpt(n)&&!ZR(n)}function KU(n,t,e,s=!0,i=""){if(t==null||t.length===0){if(n!=null){let a=!1;if(ZR(n)&&n.length>0)a=!0;else if(jU(n)){for(const o in n)if(n.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new bt(`Error when checking model ${i} expected no data, but got ${n}`)}return[]}if(n==null)return t.map(a=>null);let r;if(jU(n)){n=n,r=[];for(const a of t){if(n[a]==null)throw new bt(`No data provided for "${a}". Need data for each key in: ${t}`);r.push(n[a])}}else if(ZR(n)){if(n=n,n.length!==t.length)throw new bt(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);r=n}else{if(n=n,t.length>1)throw new bt(`The model ${i} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);r=[n]}if(r=U5(r),e!=null)for(let a=0;a<t.length;++a){if(e[a]==null)continue;const o=r[a];if(o.shape.length!==e[a].length)throw new bt(`Error when checking ${i}: expected ${t[a]} to have ${e[a].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<e[a].length;++l){if(l===0&&!s)continue;const c=o.shape[l],h=e[a][l];if(h!=null&&h>=0&&c!==h)throw new bt(`${i} expected a batch of elements where each example has shape [${e[a].slice(1,e[a].length)}] (i.e.,tensor shape [*,${e[a].slice(1,e[a].length)}]) but the ${i} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return r}function Qpt(n,t,e){const s=Gd(n.map(r=>r.shape[0]));s.sort();const i=Gd(t.map(r=>r.shape[0]));if(i.sort(),s.length>1)throw new bt(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(r=>r.shape))}`);if(i.length>1)throw new bt(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(r=>r.shape))}`);if(s.length>0&&i.length>0&&!Is(s,i))throw new bt(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${i[0]} target sample(s).`)}function Jpt(n,t,e){const s=[rN,aN,F1];for(let i=0;i<n.length;++i){const r=n[i],a=t[i],o=e[i];if(a!=null){if(a===F1&&r.shape[r.shape.length-1]===1)throw new bt(`You are passing a target array of shape ${r.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(a)!==-1){const l=r.shape.slice(1),c=o.slice(1);for(let h=0;h<l.length;++h){const f=l[h],p=c[h];if(p!=null&&f!==p)throw new bt(`A target Tensor with shape ${r.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function YU(n,t,e,s=!0,i=""){let r;if(Array.isArray(n)){if(n.length!==t.length)throw new bt(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);r=n}else{if(t.length>1)throw new bt(`The model expects ${t.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);r=[n]}if(e!=null)for(let a=0;a<t.length;++a){if(e[a]==null)continue;const o=r[a];if(o.shape.length!==e[a].length)throw new bt(`Error when checking ${i}: expected ${t[a]} to have ${e[a].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<e[a].length;++l){if(l===0&&!s)continue;const c=o.shape[l],h=e[a][l];if(h!=null&&h!==c)throw new bt(`Error when checking ${i}: expected ${t[a]} to have shape ${JSON.stringify(e[a])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function tmt(n,t){if(n==null||Array.isArray(n)&&n.length===0)return t.map(s=>[]);let e;if(typeof n=="string"||typeof n=="function")e=[n];else if(Array.isArray(n)||typeof n=="object")e=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(e))return t.map(s=>e);{const s=[];for(const i of t){let r=e.hasOwnProperty(i)?e[i]:[];Array.isArray(r)||(r=[r]),s.push(r)}return s}}const emt="layers-model";class qy extends Wc{constructor(t){super(t),this.isTraining=!1}summary(t,e,s=console.log){if(!this.built)throw new bt("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");zpt(this,t,e,s)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=Fpt(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof xp))throw new bt("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const a in t.loss)if(this.outputNames.indexOf(a)===-1)throw new bt(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)t.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),e.push(DI(t.loss[a]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new bt(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(o=>DI(o))}else{const a=DI(t.loss);this.outputs.forEach(o=>{e.push(a)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const o=this.internalOutputShapes[a],l=this.outputNames[a];this.feedOutputNames.push(l),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],eg("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const o=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([o,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const i=tmt(t.metrics,this.outputNames),r=(a,o,l)=>{this.outputNames.length>1&&(o=this.outputNames[a]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([l,a])};eg("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const o=i[a];(c=>{let f,p,g;for(const v of c){if(typeof v=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(v)!==-1){const S=this.internalOutputShapes[a];S[S.length-1]===1||this.lossFunctions[a]===aN?["accuracy","acc"].indexOf(v)!==-1?p=I5:["crossentropy","ce"].indexOf(v)!==-1&&(p=Apt):this.lossFunctions[a]===$2?["accuracy","acc"].indexOf(v)!==-1?p=Npt:["crossentropy","ce"].indexOf(v)!==-1&&(p=k5):["accuracy","acc"].indexOf(v)!==-1?p=R5:["crossentropy","ce"].indexOf(v)!==-1&&(p=D5);let b;["accuracy","acc"].indexOf(v)!==-1?b="acc":["crossentropy","ce"].indexOf(v)!==-1&&(b="ce"),g=p,f=""+b}else g=Lpt(v),f=""+qT(v);let _;eg(f,()=>{_=g}),r(a,f,_)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,s={}){const i=s.batchSize==null?32:s.batchSize;kI(i);const a=this.standardizeUserDataXY(t,e,!0,i);try{const o=a[0].concat(a[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,o,i,s.verbose,s.steps);return vo(c)}finally{Gc(a[0],t),Gc(a[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),Ypt(this,t,e)}checkNumSamples(t,e,s,i="steps"){let r;if(s!=null){if(r=null,e!=null)throw new bt(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?r=t[0].shape[0]:r=t.shape[0];else throw new bt(`Either the input data should have a defined shape, or ${i} shoud be specified.`);return r}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new bt("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(e),i=s?e:[e],r=this.retrieveSymbolicTensors(i),a=new Fd;if(t instanceof nr&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new bt(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)a.add(this.inputs[l],t[l])}else for(const l of this.inputs){const c=t[l.name];if(c==null)throw new bt(`No value is provided for the model's input ${l.name}`);a.add(l,c)}const o=Wb(r,a);return s?o:o[0]}retrieveSymbolicTensors(t){const e=bg(null,t.length);let s=t.length;for(const i of this.layers){const r=Array.isArray(i.output)?i.output:[i.output],a=r.map(o=>o.name);for(let o=0;o<t.length;++o){const l=a.indexOf(t[o]);if(l!==-1&&(e[o]=r[l],s--),s===0)break}if(s===0)break}if(s>0){const i=[];throw e.forEach((r,a)=>{r==null&&i.push(t[a])}),new bt(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return e}predictLoop(t,e=32,s=!1){return Lt(()=>{const i=this.checkNumSamples(t);if(s)throw new Fn("Verbose predictLoop() is not implemented yet.");const r=OI(i,e),a=this.outputs.map(o=>[]);for(let o=0;o<r.length;++o)Lt(()=>{const c=r[o][0],h=r[o][1],f=$b(t,c,h),p=[];if(Array.isArray(f))for(let v=0;v<f.length;++v)p.push({key:this.inputs[v],value:f[v]});else p.push({key:this.inputs[0],value:f});const g=new Fd(p);return Wb(this.outputs,g)}).forEach((c,h)=>a[h].push(c));return vo(a.map(o=>_o(o,0)))})}predict(t,e={}){const s=U5(t);YU(s,this.inputNames,this.feedInputShapes,!1);try{const i=e.batchSize==null?32:e.batchSize;return kI(i),this.predictLoop(s,i)}finally{Gc(s,t)}}predictOnBatch(t){YU(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,s=!0,i){if(this.optimizer_==null)throw new oc("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const o=this.feedOutputShapes[a];this.feedLossFns[a]===$2?r.push(o.slice(0,o.length-1).concat([1])):r.push(o)}if(t=KU(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=KU(e,this.feedOutputNames,r,!1,"target"),Qpt(t,e),Jpt(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&i!=null&&i>0&&t[0].shape[0]%i!==0)throw new bt(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,s,i,r=!0,a){const[o,l]=this.standardizeUserDataXY(t,e,r,a);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(i!=null){const h=L5(i,this.outputNames);c=[];for(let f=0;f<h.length;++f)c.push(await F5(l[f],null,h[f]))}return[o,l,c]}testLoop(t,e,s,i=0,r){return Lt(()=>{const a=this.checkNumSamples(e,s,r,"steps"),o=[];if(i>0)throw new Fn("Verbose mode is not implemented yet.");if(r!=null)throw new Fn("steps mode in testLoop() is not implemented yet");{const l=OI(a,s),c=Zo(au(0,a));for(let h=0;h<l.length;++h){const f=l[h][0],p=l[h][1],g=ng(c,f,p-f),v=YR(e,g),_=t(v);if(h===0)for(let S=0;S<_.length;++S)o.push(Ds(0));for(let S=0;S<_.length;++S){const b=_[S];o[S]=_e(o[S],Tt(p-f,b))}}for(let h=0;h<o.length;++h)o[h]=pn(o[h],a)}return o})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let s=0;s<t.length;++s){const i=t[s];let r=i;if(OU(t,i)>1){const a=OU(t.slice(0,s),i);r+=`_${a}`}e.push(r)}return e}makeTrainFunction(){return t=>{const e=[],s=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],o=()=>{const f=[];for(let _=0;_<this.inputs.length;++_)f.push({key:this.inputs[_],value:s[_]});const p=new Fd(f),g=Wb(this.outputs,p,{training:!0});let v;for(let _=0;_<this.lossFunctions.length;++_){const S=this.lossFunctions[_];let b=S(i[_],g[_]);r[_]!=null&&(b=Hpt(b,r[_]));const T=sr(b);e.push(T),_===0?v=b:v=_e(v,b)}for(let _=0;_<this.metricsTensors.length;++_){let S;if(this.outputs.length>1&&_<this.outputs.length)S=e[_];else{const b=this.metricsTensors[_][0],T=this.metricsTensors[_][1];S=sr(b(i[T],g[T]))}oh(S),a.push(S)}return v=sr(v),this.calculateLosses().forEach(_=>{v=_e(v,_)}),v},l=this.collectedTrainableWeights.map(f=>f.read());return[this.optimizer_.minimize(o,!0,l)].concat(a)}}makeTestFunction(){this.testFunction=t=>Lt(()=>{const e=[];let s;const i=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:i[c]});const o=new Fd(a),l=Wb(this.outputs,o);for(let c=0;c<this.lossFunctions.length;++c){const h=this.lossFunctions[c],f=sr(h(r[c],l[c]));c===0?s=f:s=_e(s,f),e.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][0],f=this.metricsTensors[c][1],p=sr(h(r[f],l[f]));e.push(p)}return e})}async fit(t,e,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,r,a,o,l,c,h,f,p;try{const g=s.batchSize==null?32:s.batchSize;kI(g);const _=await this.standardizeUserData(t,e,s.sampleWeight,s.classWeight,!1,g);i=_[0],r=_[1],p=_[2];let S=!1,b;if(s.validationData!=null&&s.validationData.length>0){if(S=!0,s.validationData.length===2)l=s.validationData[0],c=s.validationData[1];else throw s.validationData.length===3?new Fn("validationData including sample weights is not supported yet."):new bt(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const O=await this.standardizeUserData(l,c,null,null,!0,g);h=O[0],f=O[1],b=h.concat(f)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){S=!0;const k=Math.floor(i[0].shape[0]*(1-s.validationSplit)),O=i[0].shape[0];h=$b(i,k,O),a=i,i=$b(i,0,k),f=$b(r,k,O),o=r,r=$b(r,0,k),b=h.concat(f)}else s.validationSteps!=null&&(S=!0);const T=i.concat(r).concat(p);this.checkTrainableWeightsConsistency();const C=this.makeTrainFunction(),A=this.getDedupedMetricsNames();let I,D;S?(this.makeTestFunction(),I=this.testFunction,D=A.slice().concat(A.map(k=>"val_"+k))):(I=null,b=[],D=A.slice());const F=A5(s.callbacks,s.yieldEvery);return await this.fitLoop(C,T,A,g,s.epochs,s.verbose,F,I,b,s.shuffle,D,s.initialEpoch,null,null)}finally{this.isTraining=!1,Gc(i,t),Gc(r,e),Gc(a,t),Gc(o,e),Gc(h,l),Gc(f,c),p!=null&&Xn(p)}}async fitLoop(t,e,s,i,r,a,o,l,c,h,f,p,g,v){i==null&&(i=32),r==null&&(r=1),h==null&&(h=!0),p==null&&(p=0);let _=!1;if(l!=null&&c!=null&&(_=!0),v!=null&&(_=!0,g==null))throw new bt("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const S=this.checkNumSamples(e,i,g,"steps_per_epoch");let b;S!=null&&(b=au(0,S)),a==null&&(a=1);const{callbackList:T,history:C}=N5(o,a,r,p,S,g,i,_,f);T.setModel(this),this.history=C,await T.onTrainBegin(),this.stopTraining_=!1;for(let A=p;A<r;++A){await T.onEpochBegin(A);const I={};if(g!=null)throw new Fn("stepsPerEpoch mode is not implemented yet.");{if(h==="batch")throw new Fn("batch shuffling is not implemneted yet");h&&zit(b);const D=Zo(b),F=OI(S,i);for(let z=0;z<F.length;++z){const k={};if(await T.onBatchBegin(z,k),Lt(()=>{const O=F[z][0],L=F[z][1],H=ng(D,O,L-O);k.batch=z,k.size=L-O;const q=YR(e,H),K=t(q);for(let Y=0;Y<s.length;++Y){const P=s[Y],W=K[Y];k[P]=W,oh(W)}if(z===F.length-1&&_){const Y=this.testLoop(l,c,i);for(let P=0;P<s.length;++P){const W=s[P],j=Y[P];oh(j),I["val_"+W]=j}}}),await T.onBatchEnd(z,k),C5(k),this.stopTraining_)break}D.dispose()}if(await T.onEpochEnd(A,I),this.stopTraining_)break}return await T.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return Xpt(this,t,e)}async trainOnBatch(t,e){const s=await this.standardizeUserData(t,e),i=s[0],r=s[1],o=this.makeTrainFunction()(i.concat(r)),l=[];for(const c of o){const h=await c.data();l.push(h[0])}return Xn(o),Gc(s[0],t),Gc(s[1],e),vo(l)}getNamedWeights(t){const e=[],s=t!=null&&t.trainableOnly,i=s?this.trainableWeights:this.weights,r=this.getWeights(s);for(let a=0;a<i.length;++a)s&&!i[a].trainable||e.push({name:i[a].originalName,tensor:r[a]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const e=fU().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-fU().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=ff(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>ff(e))}else{const e=Object.keys(this.loss);t={};const s=this.loss;for(const i of e)if(typeof s[i]=="string")t[i]=ff(s[i]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[ff(qT(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>ff(qT(t)));{const t={};for(const e in this.metrics)t[e]=ff(qT(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const e=jR(t.optimizer_config),s=_f(e);let i;if(typeof t.loss=="string")i=zm(t.loss);else if(Array.isArray(t.loss))i=t.loss.map(a=>zm(a));else if(t.loss!=null){i={};for(const a in t.loss)i[a]=zm(t.loss[a])}let r;if(Array.isArray(t.metrics))r=t.metrics.map(a=>zm(a));else if(t.metrics!=null){r={};for(const a in t.metrics)r[a]=zm(t.metrics[a])}this.compile({loss:i,metrics:r,optimizer:s})}async save(t,e){if(typeof t=="string"){const c=Drt(t);if(c.length===0)throw new bt(`Cannot find any save handlers for URL '${t}'`);if(c.length>1)throw new bt(`Found more than one (${c.length}) save handlers for URL '${t}'`);t=c[0]}if(t.save==null)throw new bt("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await lU(this.getNamedWeights(e)),o={modelTopology:this.toJSON(null,!1),format:emt,generatedBy:`TensorFlow.js tfjs-layers v${$5}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:h,specs:f}=await lU(await this.optimizer.getWeights(),c);s.specs.push(...f),s.data=Rrt([s.data,h])}return this.userDefinedMetadata!=null&&(WU(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=s.data,o.weightSpecs=s.specs,t.save(o)}setUserDefinedMetadata(t){WU(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}qy.className="Model";me(qy);class B5 extends qy{}B5.className="Functional";me(B5);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class z1 extends qy{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:nN("sequential_"),t.layers!=null)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new bt(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof z1||t instanceof qy;let s;if(e){if(s=t,s.outputs.length!==1)throw new bt("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new bt("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new bt("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=ipt({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(i)}if(e)this.outputs=s.outputs,this.inputs=s.inputs;else{if(t.inboundNodes.length!==1)throw new bt(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new bt("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=S5(this.outputs[0])}this.inboundNodes=[],new iN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:bg(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=t.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(ms(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new qy({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,s=console.log){this.built||this.build(),super.summary(t,e,s)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,s={}){if(!this.built)throw new oc("The model needs to be compiled before being used.");return this.model.evaluate(t,e,s)}async evaluateDataset(t,e){if(!this.built)throw new oc("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,s={}){if(!this.built)throw new oc("The model needs to be compiled before being used.");return this.model.fit(t,e,s)}async fitDataset(t,e){if(!this.built)throw new oc("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,s={},i=!1){let r,a={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new bt("Legacy serialization format not supported yet.");r=e}else et(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),r=e.layers,delete e.layers,a=e;const o=new t(a);if(!(o instanceof z1))throw new Fn(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const l of r){const h=_f(l,void 0,i);i&&h.setFastWeightInitDuringBuild(!0),o.add(h)}return o}set stopTraining(t){if(this.model==null)throw new bt("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new bt("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const s={};s.className=e.getClassName(),s.config=e.getConfig(),t.push(s)}return{name:this.name,layers:t}}}z1.className="Sequential";me(z1);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Mo=class extends $x{getConfig(){return{}}},P5=class extends Mo{apply(t,e=1){return Hdt(t,e)}};P5.className="elu";me(P5);let V5=class extends Mo{apply(t){return rH(t)}};V5.className="selu";me(V5);let G5=class extends Mo{apply(t){return Pg(t)}};G5.className="relu";me(G5);let H5=class extends Mo{apply(t){return Lt(()=>O1(6,Pg(t)))}};H5.className="relu6";me(H5);class W5 extends Mo{apply(t){return t}}W5.className="linear";me(W5);let q5=class extends Mo{apply(t){return Rx(t)}};q5.className="sigmoid";me(q5);class X5 extends Mo{apply(t){return qdt(t)}}X5.className="hardSigmoid";me(X5);let j5=class extends Mo{apply(t){return l_(t)}};j5.className="softplus";me(j5);class K5 extends Mo{apply(t){return Wdt(t)}}K5.className="softsign";me(K5);let Y5=class extends Mo{apply(t){return Mk(t)}};Y5.className="tanh";me(Y5);let GO=class extends Mo{apply(t,e=-1){return qk(t,e)}};GO.className="softmax";me(GO);class Z5 extends Mo{apply(t,e=-1){return QG(t,e)}}Z5.className="logSoftmax";me(Z5);class Q5 extends Mo{apply(t,e=1){return Lt(()=>Tt(Rx(Tt(t,e)),t))}}Q5.className="swish";me(Q5);class J5 extends Mo{apply(t){return Lt(()=>Tt(t,Mk(l_(t))))}}J5.className="mish";me(J5);function Jd(n){return n.getClassName()}function $I(n,t={}){return m_(n,Lx.getMap().classNameMap,t,"activation")}function tp(n){if(n==null){const t={};return t.className="linear",t.config={},$I(t)}if(typeof n=="string"){const t={};return t.className=n,t.config={},$I(t)}else return n instanceof Mo?n:$I(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nmt(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class t6 extends $x{}class e6 extends t6{constructor(t){super(),nmt(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return Lt(()=>{let e=Dr([1]);return this.hasL1&&(e=_e(e,un(Tt(this.l1,Oa(t))))),this.hasL2&&(e=_e(e,un(Tt(this.l2,y_(t))))),Ct(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}e6.className="L1L2";me(e6);const ZU={l1l2:"L1L2"};function Ys(n){return MO(n)}function QU(n,t={}){return m_(n,Lx.getMap().classNameMap,t,"regularizer")}function di(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in ZU?ZU[n]:n,config:{}};return QU(e)}else return n instanceof t6?n:QU(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class n6 extends qn{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=bn(t);let s=Pg(t);return this.maxValue!=null&&(s=Il(s,0,this.maxValue)),s}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}n6.className="ReLU";me(n6);class s6 extends qn{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=bn(t);return Fk(s,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}s6.className="LeakyReLU";me(s6);class i6 extends qn{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=fi(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=di(t.alphaRegularizer),this.alphaConstraint=br(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new bt(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=ms(t);const e=t.slice(1);if(this.sharedAxes!=null)for(const i of this.sharedAxes)e[i-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let i=1;i<t.length;++i)s[i]=t[i];this.inputSpec=[new xr({ndim:t.length,axes:s})],this.built=!0}call(t,e){return t=bn(t),Gk(t,this.alpha.read())}getConfig(){const t={alphaInitializer:_i(this.alphaInitializer),alphaRegularizer:Ys(this.alphaRegularizer),alphaConstraint:vr(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}i6.className="PReLU";me(i6);let r6=class extends qn{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Fn(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=bn(t);return KA(s)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};r6.className="ELU";me(r6);class a6 extends qn{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){const s=bn(t);return Tt(s,Ge(Dl(s,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}a6.className="ThresholdedReLU";me(a6);let o6=class extends qn{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new GO().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){const s=bn(t);return this.softmax(s,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};o6.className="Softmax";me(o6);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Xy(n,t,e){if(typeof n=="number")return bg(n,t);if(n.length!==t)throw new bt(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let s=0;s<t;++s){const i=n[s];if(!Bdt(i))throw new bt(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`)}return n}function su(n,t,e,s,i=1){if(n==null)return n;const r=t+(t-1)*(i-1);let a;return e==="same"?a=n:a=n-r+1,Math.floor((a+s-1)/s)}function Ju(n,t,e,s){if(n==null)return null;if(s==="valid")n=n*t+Qd([e-t,0]);else if(s==="same")n=n*t;else throw new bt(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function HO(n,t){return Lt(()=>(Ki(t),t==="channelsFirst"?cs(n,[0,2,3,1]):n))}function l6(n,t){return Lt(()=>(Ki(t),t==="channelsFirst"?cs(n,[0,2,3,4,1]):n))}function smt(n,t,e,s=1,i="valid",r,a=1){return Lt(()=>{if(r==null&&(r=ou()),Ki(r),n.shape.length!==3)throw new bt(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(t.shape.length!==3)throw new bt(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new bt(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(r==="channelsFirst"&&(n=cs(n,[0,2,1])),i==="causal")throw new Fn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=GG(n,t,s,i==="same"?"same":"valid","NWC",a);return e!=null&&(o=uu(o,e)),o})}function JU(n,t,e,s=[1,1],i="valid",r,a,o=null){return Lt(()=>{if(r==null&&(r=ou()),Ki(r),n.rank!==3&&n.rank!==4)throw new bt(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(t.rank!==3&&t.rank!==4)throw new bt(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=HO(n,r);if(i==="causal")throw new Fn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=mut({x:l,filter:t,strides:s,pad:i==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:e,activation:o}),r==="channelsFirst"&&(l=cs(l,[0,3,1,2])),l})}function imt(n,t,e,s=[1,1,1],i="valid",r,a){return Lt(()=>{if(r==null&&(r=ou()),Ki(r),n.rank!==4&&n.rank!==5)throw new bt(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(t.rank!==4&&t.rank!==5)throw new bt(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let o=l6(n,r);if(i==="causal")throw new Fn("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=uot(o,t,s,i==="same"?"same":"valid","NDHWC",a),e!=null&&(o=uu(o,e)),r==="channelsFirst"&&(o=cs(o,[0,4,1,2,3])),o})}class oN extends qn{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",oN.verifyArgs(e),this.rank=t,Or(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Fn(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Xy(e.kernelSize,t,"kernelSize"),this.strides=Xy(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,kl(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ki(this.dataFormat),this.activation=tp(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=fi(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=br(e.biasConstraint),this.biasRegularizer=di(e.biasRegularizer),this.activityRegularizer=di(e.activityRegularizer),this.dilationRate=Xy(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new bt(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new bt(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new bt(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Qu("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!IO(t.kernelSize,"number",1,3))throw new bt(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Jd(this.activation),useBias:this.useBias,biasInitializer:_i(this.biasInitializer),biasRegularizer:Ys(this.biasRegularizer),activityRegularizer:Ys(this.activityRegularizer),biasConstraint:vr(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Fx extends oN{constructor(t,e){super(t,e),this.kernel=null,Fx.verifyArgs(e),this.filters=e.filters,Or(this.filters,"filters"),this.kernelInitializer=fi(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=br(e.kernelConstraint),this.kernelRegularizer=di(e.kernelRegularizer)}build(t){t=ms(t);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new bt(`The channel dimension of the input should be defined. Found ${t[e]}`);const s=t[e],i=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:s}}],this.built=!0}call(t,e){return Lt(()=>{t=bn(t);let s;const i=this.bias==null?null:this.bias.read(),r=a5(this.activation.getClassName());if(r!=null&&this.rank===2)s=JU(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(this.rank===1)s=smt(t,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=JU(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=imt(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Fn("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=ms(t);const e=[],s=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let r=0;r<s.length;++r){const a=su(s[r],this.kernelSize[r],this.padding,this.strides[r],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[r]);e.push(a)}let i=[t[0]];return this.dataFormat==="channelsLast"?(i=i.concat(e),i.push(this.filters)):(i.push(this.filters),i=i.concat(e)),i}getConfig(){const t={filters:this.filters,kernelInitializer:_i(this.kernelInitializer),kernelRegularizer:Ys(this.kernelRegularizer),kernelConstraint:vr(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new bt(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let WO=class c6 extends Fx{constructor(t){super(2,t),c6.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!IO(t.kernelSize,"number",1,2))throw new bt(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};WO.className="Conv2D";me(WO);let qO=class u6 extends Fx{constructor(t){super(3,t),u6.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new bt(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};qO.className="Conv3D";me(qO);class h6 extends WO{constructor(t){if(super(t),this.inputSpec=[new xr({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new bt(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=ms(t),t.length!==4)throw new bt("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new bt("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new xr({ndim:4,axes:{[e]:s}})],this.built=!0}call(t,e){return Lt(()=>{let s=bn(t);if(s.shape.length!==4)throw new bt(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,r=i[0];let a,o;this.dataFormat==="channelsFirst"?(a=2,o=3):(a=1,o=2);const l=i[a],c=i[o],h=this.kernelSize[0],f=this.kernelSize[1],p=this.strides[0],g=this.strides[1],v=Ju(l,p,h,this.padding),_=Ju(c,g,f,this.padding),S=[r,v,_,this.filters];this.dataFormat!=="channelsLast"&&(s=cs(s,[0,2,3,1]));let b=HG(s,this.kernel.read(),S,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(b=cs(b,[0,3,1,2])),this.bias!=null&&(b=uu(b,this.bias.read(),this.dataFormat)),this.activation!=null&&(b=this.activation.apply(b)),b})}computeOutputShape(t){t=ms(t);const e=t.slice();let s,i,r;this.dataFormat==="channelsFirst"?(s=1,i=2,r=3):(s=3,i=1,r=2);const a=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return e[s]=this.filters,e[i]=Ju(e[i],l,a,this.padding),e[r]=Ju(e[r],c,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}h6.className="Conv2DTranspose";me(h6);class f6 extends qO{constructor(t){if(super(t),this.inputSpec=[new xr({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new bt(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=ms(t),t.length!==5)throw new bt("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new bt("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new xr({ndim:5,axes:{[e]:s}})],this.built=!0}call(t,e){return Lt(()=>{let s=bn(t);if(s.shape.length!==5)throw new bt(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,r=i[0];let a,o,l;this.dataFormat==="channelsFirst"?(l=2,a=3,o=4):(l=1,a=2,o=3);const c=i[l],h=i[a],f=i[o],p=this.kernelSize[0],g=this.kernelSize[1],v=this.kernelSize[2],_=this.strides[0],S=this.strides[1],b=this.strides[2],T=Ju(c,_,p,this.padding),C=Ju(h,S,g,this.padding),A=Ju(f,b,v,this.padding),I=[r,T,C,A,this.filters];this.dataFormat!=="channelsLast"&&(s=cs(s,[0,2,3,4,1]));let D=dot(s,this.kernel.read(),I,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(D=cs(D,[0,4,1,2,3])),this.bias!==null&&(D=uu(D,this.bias.read(),this.dataFormat)),this.activation!==null&&(D=this.activation.apply(D)),D})}computeOutputShape(t){t=ms(t);const e=t.slice();let s,i,r,a;this.dataFormat==="channelsFirst"?(s=1,i=2,r=3,a=4):(s=4,i=1,r=2,a=3);const o=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],h=this.strides[0],f=this.strides[1],p=this.strides[2];return e[s]=this.filters,e[i]=Ju(e[i],h,o,this.padding),e[r]=Ju(e[r],f,l,this.padding),e[a]=Ju(e[a],p,c,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}f6.className="Conv3DTranspose";me(f6);class d6 extends Fx{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new bt("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new bt("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new bt(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=fi(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=di(e.depthwiseRegularizer),this.depthwiseConstraint=br(e.depthwiseConstraint),this.pointwiseInitializer=fi(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=di(e.pointwiseRegularizer),this.pointwiseConstraint=br(e.pointwiseConstraint)}build(t){if(t=ms(t),t.length<this.rank+2)throw new bt(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new bt(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const s=t[e],i=this.kernelSize.concat([s,this.depthMultiplier]),r=[];for(let o=0;o<this.rank;++o)r.push(1);r.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new xr({ndim:this.rank+2,axes:{[e]:s}})],this.built=!0}call(t,e){return Lt(()=>{t=bn(t);let s;if(this.rank===1)throw new Fn("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=cs(t,[0,2,3,1])),s=aH(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=uu(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=cs(s,[0,3,1,2])),s})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=_i(this.depthwiseInitializer),t.pointwiseInitializer=_i(this.pointwiseInitializer),t.depthwiseRegularizer=Ys(this.depthwiseRegularizer),t.pointwiseRegularizer=Ys(this.pointwiseRegularizer),t.depthwiseConstraint=vr(this.depthwiseConstraint),t.pointwiseConstraint=vr(this.pointwiseConstraint),t}}d6.className="SeparableConv";class p6 extends d6{constructor(t){super(2,t)}}p6.className="SeparableConv2D";me(p6);class lN extends Fx{constructor(t){super(1,t),lN.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!IO(t.kernelSize,"number",1,1))throw new bt(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}lN.className="Conv1D";me(lN);class m6 extends qn{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return Lt(()=>{if(t=bn(t),this.dataFormat==="channelsLast"){const s=WT(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return WT(s,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=WT(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return WT(s,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}m6.className="Cropping2D";me(m6);class g6 extends qn{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ki(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,Fdt(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const e=t[2]==null?null:this.size[0]*t[2],s=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,s]}else{const e=t[1]==null?null:this.size[0]*t[1],s=t[2]==null?null:this.size[1]*t[2];return[t[0],e,s,t[3]]}}call(t,e){return Lt(()=>{let s=bn(t);const i=s.shape;if(this.dataFormat==="channelsFirst"){s=cs(s,[0,2,3,1]);const r=this.size[0]*i[2],a=this.size[1]*i[3],o=this.interpolation==="nearest"?bf.resizeNearestNeighbor(s,[r,a]):bf.resizeBilinear(s,[r,a]);return cs(o,[0,3,1,2])}else{const r=this.size[0]*i[1],a=this.size[1]*i[2];return this.interpolation==="nearest"?bf.resizeNearestNeighbor(s,[r,a]):bf.resizeBilinear(s,[r,a])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}g6.className="UpSampling2D";me(g6);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function rmt(n,t,e=[1,1],s="valid",i,r){return Lt(()=>{i==null&&(i=ou()),Ki(i);let a=HO(n,i);if(n.rank!==4)throw new bt(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(t.rank!==4)throw new bt(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return a=kk(a,t,e,s==="same"?"same":"valid","NHWC",r),i==="channelsFirst"&&(a=cs(a,[0,3,1,2])),a})}class y6 extends oN{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=fi(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=br(t.depthwiseConstraint),this.depthwiseRegularizer=di(t.depthwiseRegularizer)}build(t){if(t=ms(t),t.length<4)throw new bt(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new bt(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const s=t[e],i=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",i,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Lt(()=>{t=bn(t);let s=rmt(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=uu(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(t){t=ms(t);const e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],i=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,r=su(e,this.kernelSize[0],this.padding,this.strides[0]),a=su(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],i,r,a]:[t[0],r,a,i]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=_i(this.depthwiseInitializer),t.depthwiseRegularizer=Ys(this.depthwiseRegularizer),t.depthwiseConstraint=vr(this.depthwiseRegularizer),t}}y6.className="DepthwiseConv2D";me(y6);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function x6(n,t,e,s){if(Array.isArray(n)){if(t!=null||e!=null)throw new bt("When inputs is an array, neither initialState or constants should be provided");s!=null&&(e=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function i(r){return r==null||Array.isArray(r)?r:[r]}return t=i(t),e=i(e),{inputs:n,initialState:t,constants:e}}function v6(n,t,e,s=!1,i,r,a=!1,o=!1){return Lt(()=>{const l=t.shape.length;if(l<3)throw new bt(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(au(2,l));t=cs(t,c),a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=Ge(Ge(i,"bool"),"float32"),i.rank===l-1&&(i=xo(i,-1)),i=cs(i,c)),s&&(t=xg(t,0),i!=null&&(i=xg(i,0)));const h=[];let f,p=e;const g=t.shape[0],v=vg(t);let _;i!=null&&(_=vg(i));for(let b=0;b<g;++b){const T=v[b],C=Lt(()=>n(T,p));if(i==null)f=C[0],p=C[1];else{const A=Lt(()=>{const I=_[b],D=_n(uc(I),I),F=_e(Tt(C[0],I),Tt(p[0],D)),z=p.map((k,O)=>_e(Tt(C[1][O],I),Tt(k,D)));return{output:F,newStates:z}});f=A.output,p=A.newStates}o&&h.push(f)}let S;return o&&(S=Zd(h,1)),[f,S,p]})}class vp extends qn{constructor(t){super(t);let e;if(t.cell==null)throw new bt("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new KO({cells:t.cell}):e=t.cell,e.stateSize==null)throw new bt("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new xr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return au(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){WR(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const s=e[0];let i;if(this.returnSequences?i=[t[0],t[1],s]:i=[t[0],s],this.returnState){const r=[];for(const a of e)r.push([t[0],a]);return[i].concat(r)}else return i}computeMask(t,e){return Lt(()=>{Array.isArray(e)&&(e=e[0]);const s=this.returnSequences?e:null;if(this.returnState){const i=this.states.map(r=>null);return[s].concat(i)}else return s})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let s=0;s<t;++s)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Fn("Constants support is not implemented in RNN yet.");WR(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new xr({shape:[e,null,...s]});const i=[t[0]].concat(t.slice(2));this.cell.build(i);let r;if(Array.isArray(this.cell.stateSize)?r=this.cell.stateSize:r=[this.cell.stateSize],this.stateSpec!=null){if(!Is(this.stateSpec.map(a=>a.shape[a.shape.length-1]),r))throw new bt(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map(a=>new xr({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){Lt(()=>{if(!this.stateful)throw new Zu("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new bt("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Dr([s,i])):this.states_=[Dr([s,this.cell.stateSize])];else if(t==null)Xn(this.states_),this.keptStates!=null&&(Xn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Dr([s,i])):this.states_[0]=Dr([s,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new bt(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):Xn(this.states_);for(let i=0;i<this.states_.length;++i){const r=t[i],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,o=[s,a];if(!Is(r.shape,o))throw new bt(`State ${i} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${r.shape}`);this.states_[i]=r}}this.states_=this.states_.map(i=>oh(i.clone()))})}apply(t,e){let s=e==null?null:e.initialState,i=e==null?null:e.constants;e==null&&(e={});const r=x6(t,s,i,this.numConstants);t=r.inputs,s=r.initialState,i=r.constants;let a=[],o=[];if(s!=null){e.initialState=s,a=a.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new xr({shape:c.shape}));o=o.concat(this.stateSpec)}if(i!=null&&(e.constants=i,a=a.concat(i),this.numConstants=i.length),a[0]instanceof nh){const c=[t].concat(a),h=this.inputSpec.concat(o),f=this.inputSpec;this.inputSpec=h;const p=super.apply(c,e);return this.inputSpec=f,p}else return super.apply(t,e)}call(t,e){return Lt(()=>{const s=e==null?null:e.mask,i=e==null?null:e.training;let r=e==null?null:e.initialState;t=bn(t),r==null&&(this.stateful?r=this.states_:r=this.getInitialState(t));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==a)throw new bt(`RNN Layer has ${a} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:i},c=v6((v,_)=>{const S=this.cell.call([v].concat(_),o);return[S[0],S.slice(1)]},t,r,this.goBackwards,s,null,this.unroll,this.returnSequences),h=c[0],f=c[1],p=c[2];this.stateful&&this.resetStates(p,i);const g=this.returnSequences?f:h;return this.returnState?[g].concat(p):g})}getInitialState(t){return Lt(()=>{let e=Dr(t.shape);return e=un(e,[1,2]),e=g_(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?GR(e,[1,s]):e):this.cell.stateSize>1?[GR(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===vp.className&&(e.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),t),e)}static fromConfig(t,e,s={}){const i=e.cell,r=_f(i,s);return new t(Object.assign(e,{cell:r}))}}vp.className="RNN";me(vp);class cN extends qn{}class XO extends cN{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Or(this.units,"units"),this.activation=tp(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=fi(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=fi(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=fi(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=di(t.kernelRegularizer),this.recurrentRegularizer=di(t.recurrentRegularizer),this.biasRegularizer=di(t.biasRegularizer),this.kernelConstraint=br(t.kernelConstraint),this.recurrentConstraint=br(t.recurrentConstraint),this.biasConstraint=br(t.biasConstraint),this.dropout=dx([1,Qd([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=dx([1,Qd([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=ms(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Lt(()=>{if(t=t,t.length!==2)throw new bt(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let s=t[1];t=t[0];const i=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ep({ones:()=>uc(t),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ep({ones:()=>uc(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));let r;const a=this.dropoutMask,o=this.recurrentDropoutMask;a!=null?r=uh(Tt(t,a),this.kernel.read()):r=uh(t,this.kernel.read()),this.bias!=null&&(r=uu(r,this.bias.read())),o!=null&&(s=Tt(s,o));let l=_e(r,uh(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Jd(this.activation),useBias:this.useBias,kernelInitializer:_i(this.kernelInitializer),recurrentInitializer:_i(this.recurrentInitializer),biasInitializer:_i(this.biasInitializer),kernelRegularizer:Ys(this.kernelRegularizer),recurrentRegularizer:Ys(this.recurrentRegularizer),biasRegularizer:Ys(this.biasRegularizer),activityRegularizer:Ys(this.activityRegularizer),kernelConstraint:vr(this.kernelConstraint),recurrentConstraint:vr(this.recurrentConstraint),biasConstraint:vr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}XO.className="SimpleRNNCell";me(XO);class b6 extends vp{constructor(t){t.cell=new XO(t),super(t)}call(t,e){return Lt(()=>{this.cell.dropoutMask!=null&&(Xn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Xn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,i=e==null?null:e.training,r=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:r})})}static fromConfig(t,e){return new t(e)}}b6.className="SimpleRNN";me(b6);class jO extends cN{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new bt("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Or(this.units,"units"),this.activation=tp(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=tp(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=fi(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=fi(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=fi(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=di(t.kernelRegularizer),this.recurrentRegularizer=di(t.recurrentRegularizer),this.biasRegularizer=di(t.biasRegularizer),this.kernelConstraint=br(t.kernelConstraint),this.recurrentConstraint=br(t.recurrentConstraint),this.biasConstraint=br(t.biasConstraint),this.dropout=dx([1,Qd([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=dx([1,Qd([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=ms(t);const e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Lt(()=>{if(t=t,t.length!==2)throw new bt(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training==null?!1:e.training;let i=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ep({ones:()=>uc(t),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ep({ones:()=>uc(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,a=this.recurrentDropoutMask;let o,l,c;0<this.dropout&&this.dropout<1&&(t=Tt(t,r[0]));let h=uh(t,this.kernel.read());this.useBias&&(h=uu(h,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=Tt(i,a[0]));const f=this.recurrentKernel.read(),[p,g]=Cl(f,[2*this.units,this.units],f.rank-1),v=uh(i,p),[_,S,b]=Cl(h,3,h.rank-1),[T,C]=Cl(v,2,v.rank-1);o=this.recurrentActivation.apply(_e(_,T)),l=this.recurrentActivation.apply(_e(S,C));const A=uh(Tt(l,i),g);c=this.activation.apply(_e(b,A));const I=_e(Tt(o,i),Tt(_e(1,Wi(o)),c));return[I,I]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Jd(this.activation),recurrentActivation:Jd(this.recurrentActivation),useBias:this.useBias,kernelInitializer:_i(this.kernelInitializer),recurrentInitializer:_i(this.recurrentInitializer),biasInitializer:_i(this.biasInitializer),kernelRegularizer:Ys(this.kernelRegularizer),recurrentRegularizer:Ys(this.recurrentRegularizer),biasRegularizer:Ys(this.biasRegularizer),activityRegularizer:Ys(this.activityRegularizer),kernelConstraint:vr(this.kernelConstraint),recurrentConstraint:vr(this.recurrentConstraint),biasConstraint:vr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}jO.className="GRUCell";me(jO);class S6 extends vp{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new jO(t),super(t)}call(t,e){return Lt(()=>{this.cell.dropoutMask!=null&&(Xn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Xn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,i=e==null?null:e.training,r=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:r})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}S6.className="GRU";me(S6);class uN extends cN{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Or(this.units,"units"),this.activation=tp(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=tp(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=fi(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=fi(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=fi(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=di(t.kernelRegularizer),this.recurrentRegularizer=di(t.recurrentRegularizer),this.biasRegularizer=di(t.biasRegularizer),this.kernelConstraint=br(t.kernelConstraint),this.recurrentConstraint=br(t.recurrentConstraint),this.biasConstraint=br(t.biasConstraint),this.dropout=dx([1,Qd([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=dx([1,Qd([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=ms(t);const s=t[t.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let i;if(this.useBias){if(this.unitForgetBias){const r=this.biasInitializer,a=this.units;i=new(e=class extends pc{apply(l,c){const h=r.apply([a]),f=new DO().apply([a]),p=r.apply([a*2]);return LU(LU(h,f),p)}},e.className="CustomInit",e)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return Lt(()=>{const s=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new bt(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let i=t[1];const r=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ep({ones:()=>uc(t),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ep({ones:()=>uc(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=this.recurrentDropoutMask;let l,c,h,f;0<this.dropout&&this.dropout<1&&(t=Tt(t,a[0]));let p=uh(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=Tt(i,o[0])),p=_e(p,uh(i,this.recurrentKernel.read())),this.useBias&&(p=uu(p,this.bias.read()));const[g,v,_,S]=Cl(p,4,p.rank-1);l=this.recurrentActivation.apply(g),c=this.recurrentActivation.apply(v),h=_e(Tt(c,r),Tt(l,this.activation.apply(_))),f=this.recurrentActivation.apply(S);const b=Tt(f,this.activation.apply(h));return[b,b,h]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Jd(this.activation),recurrentActivation:Jd(this.recurrentActivation),useBias:this.useBias,kernelInitializer:_i(this.kernelInitializer),recurrentInitializer:_i(this.recurrentInitializer),biasInitializer:_i(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ys(this.kernelRegularizer),recurrentRegularizer:Ys(this.recurrentRegularizer),biasRegularizer:Ys(this.biasRegularizer),activityRegularizer:Ys(this.activityRegularizer),kernelConstraint:vr(this.kernelConstraint),recurrentConstraint:vr(this.recurrentConstraint),biasConstraint:vr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}uN.className="LSTMCell";me(uN);class _6 extends vp{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new uN(t),super(t)}call(t,e){return Lt(()=>{this.cell.dropoutMask!=null&&(Xn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Xn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,i=e==null?null:e.training,r=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:r})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}_6.className="LSTM";me(_6);class KO extends cN{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return Lt(()=>{t=t;let s=t.slice(1);const i=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?i.push(s.splice(0,o.stateSize.length)):i.push(s.splice(0,1));i.reverse();const r=[];let a;for(let o=0;o<this.cells.length;++o){const l=this.cells[o];s=i[o],o===0?a=[t[0]].concat(s):a=[a[0]].concat(s),a=l.call(a,e),r.push(a.slice(1))}s=[];for(const o of r.slice().reverse())s.push(...o);return[a[0]].concat(s)})}build(t){WR(t)&&(t=t[0]),t=t;let e;this.cells.forEach((s,i)=>{eg(`RNNCell_${i}`,()=>{s.build(t),Array.isArray(s.stateSize)?e=s.stateSize[0]:e=s.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=r=>({className:r.getClassName(),config:r.getConfig()}),i={cells:this.cells.map(e)};return Object.assign(Object.assign({},t),i)}static fromConfig(t,e,s={}){const i=[];for(const r of e.cells)i.push(_f(r,s));return new t({cells:i})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.cells)e.push(...s.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return qR(t)}setWeights(t){const e=[];for(const s of this.cells){const i=s.weights.length,r=t.splice(i);for(let a=0;a<s.weights.length;++a)e.push([s.weights[a],r[a]])}UO(e)}}KO.className="StackedRNNCells";me(KO);function ep(n){const{ones:t,rate:e,training:s=!1,count:i=1,dropoutFunc:r}=n,a=()=>r!=null?r(t(),e):d5(t(),e),o=()=>x_(a,t,s);return!i||i<=1?oh(o().clone()):Array(i).fill(void 0).map(o).map(c=>oh(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var amt=function(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,s=Object.getOwnPropertySymbols(n);i<s.length;i++)t.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(n,s[i])&&(e[s[i]]=n[s[i]]);return e};class w6 extends vp{constructor(t){if(t.unroll)throw new Fn("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Fn("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new xr({ndim:5})]}call(t,e){return Lt(()=>{if(this.cell.dropoutMask!=null&&(Xn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Xn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new bt("ConvRNN2D cell does not support constants");const s=e==null?null:e.mask,i=e==null?null:e.training,r=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:r})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return Lt(()=>{const{stateSize:e}=this.cell,s=t.shape,i=this.computeSingleOutputShape(s),r=[i[0],...i.slice(2)],a=Dr(r);return Array.isArray(e)?Array(e.length).fill(a):[a]})}resetStates(t,e=!1){Lt(()=>{if(!this.stateful)throw new Zu("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),r=[i[0],...i.slice(2)];if(s[0]==null)throw new bt("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Dr(r)):this.states_=[Dr(r)];else if(t==null)Xn(this.states_),this.keptStates!=null&&(Xn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Dr(r)):this.states_[0]=Dr(r);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new bt(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):Xn(this.states_);for(let o=0;o<this.states_.length;++o){const l=t[o],c=r;if(!Is(l.shape,c))throw new bt(`State ${o} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[o]=l}}this.states_=this.states_.map(o=>oh(o.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:s,kernelSize:i,padding:r,strides:a,dilationRate:o}=this.cell,l=e==="channelsFirst",c=t[l?3:2],h=t[l?4:3],f=su(c,i[0],r,a[0],o[0]),p=su(h,i[1],r,a[1],o[1]);return[...t.slice(0,2),...l?[s,f,p]:[f,p,s]]}}w6.className="ConvRNN2D";class YO extends uN{constructor(t){const{filters:e,kernelSize:s,strides:i,padding:r,dataFormat:a,dilationRate:o}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,Or(this.filters,"filters"),this.kernelSize=Xy(s,2,"kernelSize"),this.kernelSize.forEach(l=>Or(l,"kernelSize")),this.strides=Xy(i||1,2,"strides"),this.strides.forEach(l=>Or(l,"strides")),this.padding=r||"valid",kl(this.padding),this.dataFormat=a||"channelsLast",Ki(this.dataFormat),this.dilationRate=Xy(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>Or(l,"dilationRate"))}build(t){var e;t=ms(t);const s=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[s]==null)throw new bt(`The channel dimension of the input should be defined. Found ${t[s]}`);const i=t[s],r=4,a=this.kernelSize.concat([i,this.filters*r]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,h=this.filters;l=new(e=class extends pc{apply(p,g){const v=c.apply([h]),_=Bg([h]),S=c.apply([h*2]);return RO([v,_,S])}},e.className="CustomInit",e)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*r],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return Lt(()=>{if(t.length!==3)throw new bt(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training||!1,i=t[0],r=t[1],a=t[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ep({ones:()=>uc(i),rate:this.dropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(ot,X,it)=>!X||!X[it]?ot:Tt(X[it],ot);let h=c(i,l,0),f=c(i,l,1),p=c(i,l,2),g=c(i,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ep({ones:()=>uc(r),rate:this.recurrentDropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const v=this.recurrentDropoutMask;let _=c(r,v,0),S=c(r,v,1),b=c(r,v,2),T=c(r,v,3);const C=3,[A,I,D,F]=Cl(this.kernel.read(),o,C),[z,k,O,L]=this.useBias?Cl(this.bias.read(),o):[null,null,null,null];h=this.inputConv(h,A,z,this.padding),f=this.inputConv(f,I,k,this.padding),p=this.inputConv(p,D,O,this.padding),g=this.inputConv(g,F,L,this.padding);const[H,q,K,Y]=Cl(this.recurrentKernel.read(),o,C);_=this.recurrentConv(_,H),S=this.recurrentConv(S,q),b=this.recurrentConv(b,K),T=this.recurrentConv(T,Y);const P=this.recurrentActivation.apply(_e(h,_)),W=this.recurrentActivation.apply(_e(f,S)),j=_e(Tt(W,a),Tt(P,this.activation.apply(_e(p,b)))),st=Tt(this.recurrentActivation.apply(_e(g,T)),this.activation.apply(j));return[st,st,j]})}getConfig(){const t=super.getConfig(),{units:e}=t,s=amt(t,["units"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),i)}inputConv(t,e,s,i){const r=yg(t,e,this.strides,i||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?uu(r,s,this.dataFormat):r}recurrentConv(t,e){return yg(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}YO.className="ConvLSTM2DCell";me(YO);class T6 extends w6{constructor(t){const e=new YO(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}T6.className="ConvLSTM2D";me(T6);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ZO extends qn{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const e=t.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(this.noiseShape[i]==null?e[i]:this.noiseShape[i]);return s}call(t,e){return Lt(()=>{this.invokeCallHook(t,e);const s=bn(t);if(0<this.rate&&this.rate<1){const i=e.training==null?!1:e.training,r=this.getNoiseShape(s);return x_(()=>d5(s,this.rate,r,this.seed),()=>s,i)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}ZO.className="Dropout";me(ZO);class E6 extends ZO{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}E6.className="SpatialDropout1D";me(E6);class C6 extends qn{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Or(this.units,"units"),this.activation=tp(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=fi(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=fi(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=br(t.kernelConstraint),this.biasConstraint=br(t.biasConstraint),this.kernelRegularizer=di(t.kernelRegularizer),this.biasRegularizer=di(t.biasRegularizer),this.activityRegularizer=di(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=ms(t);const e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=ms(t);const e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return Lt(()=>{this.invokeCallHook(t,e);const s=bn(t),i=a5(this.activation.getClassName());let r;return i!=null?r=uh(s,this.kernel.read(),i,this.bias?this.bias.read():null):(r=uh(s,this.kernel.read()),this.bias!=null&&(r=uu(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){const t={units:this.units,activation:Jd(this.activation),useBias:this.useBias,kernelInitializer:_i(this.kernelInitializer),biasInitializer:_i(this.biasInitializer),kernelRegularizer:Ys(this.kernelRegularizer),biasRegularizer:Ys(this.biasRegularizer),activityRegularizer:Ys(this.activityRegularizer),kernelConstraint:vr(this.kernelConstraint),biasConstraint:vr(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}C6.className="Dense";me(C6);class A6 extends qn{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=ms(t);for(const e of t.slice(1))if(e==null)throw new bt(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Hd(t,1)]}call(t,e){return Lt(()=>{this.invokeCallHook(t,e);let s=bn(t);if(this.dataFormat==="channelsFirst"&&s.rank>1){const i=[0];for(let r=2;r<s.rank;++r)i.push(r);i.push(1),s=cs(s,i)}return Gdt(s)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}A6.className="Flatten";me(A6);class N6 extends qn{constructor(t){super(t),this.supportsMasking=!0,this.activation=tp(t.activation)}call(t,e){return Lt(()=>{this.invokeCallHook(t,e);const s=bn(t);return this.activation.apply(s)})}getConfig(){const t={activation:Jd(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}N6.className="Activation";me(N6);class M6 extends qn{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return Lt(()=>(t=bn(t),Pdt(t,this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}M6.className="RepeatVector";me(M6);let I6=class extends qn{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){const s="Total size of new array must be unchanged.",i=e.slice();let r=1,a=null;for(let l=0;l<i.length;++l){const c=i[l];if(this.isUnknown(c))if(a===null)a=l;else throw new bt("Can only specifiy one unknown dimension.");else r*=c}const o=Hd(t);if(a!==null){if(r===0||o%r!==0)throw new bt(s);i[a]=o/r}else if(o!==r)throw new bt(s);return i}computeOutputShape(t){let e=!1;for(let s=0;s<t.length;++s)if(this.isUnknown(t[s])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return Lt(()=>{this.invokeCallHook(t,e);const s=bn(t),i=s.shape,r=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return Ct(s,r)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}};I6.className="Reshape";me(I6);class R6 extends qn{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=au(1,t.dims.length+1);if(!Is(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new xr({ndim:this.dims.length+1})]}computeOutputShape(t){t=ms(t);const e=t.slice();return this.dims.forEach((s,i)=>{e[i+1]=t[s]}),e}call(t,e){return cs(bn(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}R6.className="Permute";me(R6);class D6 extends qn{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const s=bn(t);return LR(A2(s,this.maskValue),-1)}call(t,e){return Lt(()=>{this.invokeCallHook(t,e);const s=bn(t),a=LR(A2(s,this.maskValue),-1,!0);return Tt(s,Ge(a,s.dtype))})}}D6.className="Masking";me(D6);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class k6 extends qn{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(ri(t.inputLength))}this.inputDim=t.inputDim,Or(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Or(this.outputDim,"outputDim"),this.embeddingsInitializer=fi(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=di(t.embeddingsRegularizer),this.activityRegularizer=di(t.activityRegularizer),this.embeddingsConstraint=br(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return Lt(()=>this.maskZero?(t=bn(t),A2(t,us(t))):null)}computeOutputShape(t){if(t=ms(t),this.inputLength==null)return[...t,this.outputDim];const e=ri(this.inputLength);if(e.length!==t.length-1)throw new bt(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let s=0;for(let i=0;i<e.length;++i){const r=e[i],a=t[i+1];if(r!=null&&a!=null&&r!==a)throw new bt(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);r==null&&(e[s]=a),s++}}return[t[0],...e,this.outputDim]}call(t,e){return Lt(()=>{this.invokeCallHook(t,e);let s=bn(t);s.dtype!=="int32"&&(s=ch(s,"int32"));const i=f5(this.embeddings.read(),Ct(s,[s.size]));return Ct(i,ms(this.computeOutputShape(s.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:_i(this.embeddingsInitializer),embeddingsRegularizer:Ys(this.embeddingsRegularizer),activityRegularizer:Ys(this.activityRegularizer),embeddingsConstraint:vr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}k6.className="Embedding";me(k6);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Hg extends qn{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Fn}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;const s=t.slice(0,t.length-e.length);for(let i=0;i<e.length;++i){const r=t[t.length-e.length+i],a=e[i];if(r==null||a==null||r<0||a<0)s.push(null);else if(r===1)s.push(a);else if(a===1)s.push(r);else{if(r!==a)throw new bt("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(r)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[ms(t)]),t=t,t.length<2)throw new bt(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const r of t)r!=null&&r[0]!==null&&e.push(r[0]);if(e=Gd(e),e.length>1)throw new bt(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=t[0]==null?null:t[0].slice(1);for(let r=1;r<t.length;++r){const a=t[r]==null?null:t[r].slice(1);s=this.computeElementwiseOpOutputShape(s,a)}const i=t.map(r=>r.length);t.indexOf(null)===-1&&Gd(i).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return Lt(()=>{if(t=t,this.reshapeRequired){const s=[],i=t.map(r=>r.rank);if(i.indexOf(null)===-1){const r=Qd(i);for(let a of t){const o=a.rank;for(let l=0;l<r-o;++l)a=g_(a,1);s.push(a)}return this.mergeFunction(s)}else{let r=!1;for(const l of t){const c=l.rank;if(c==null){const h=l.shape,f=h[0],p=h.slice(1).concat([f]);let g=Ct(l,[f].concat(Hd(h.slice(1))));g=cs(g,[1,0]),g=Ct(g,p),s.push(g),r=!0}else if(c>1){const h=au(1,c).concat([0]);s.push(cs(l,h)),r=!0}else s.push(l)}let a=this.mergeFunction(s);const o=a.rank;if(r){if(o==null){const l=a.shape,c=l.length,h=l[c-1],f=[h].concat(l.slice(0,l.length-1));a=Ct(cs(Ct(a,[-1,h]),[1,0]),f)}else if(o>1){const l=[o-1].concat(au(0,o-1));a=cs(a,l)}}return a}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let i=1;i<t.length;++i){const r=t[i]==null?null:t[i].slice(1);e=this.computeElementwiseOpOutputShape(e,r)}let s=[];for(const i of t)i!=null&&i[0]!==null&&s.push(i[0]);return s=Gd(s),s.length===1?e=s.concat(e):e=[null].concat(e),e}computeMask(t,e){return Lt(()=>{if(e==null)return null;if(!Array.isArray(e))throw new bt("`mask` should be an Array");if(!Array.isArray(t))throw new bt("`inputs` should be an Array");if(e.length!==t.length)throw new bt(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(i=>i==null))return null;e=e.map(i=>i==null?i:xo(i,0));let s=e[0];for(let i=1;i<e.length-1;++i)s=Ef(s,e[i]);return s})}}let O6=class extends Hg{constructor(t){super(t)}mergeFunction(t){return Lt(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=_e(e,t[s]);return e})}};O6.className="Add";me(O6);let $6=class extends Hg{constructor(t){super(t)}mergeFunction(t){return Lt(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=Tt(e,t[s]);return e})}};$6.className="Multiply";me($6);class L6 extends Hg{constructor(t){super(t)}mergeFunction(t){return Lt(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=_e(e,t[s]);return Tt(1/t.length,e)})}}L6.className="Average";me(L6);let F6=class extends Hg{constructor(t){super(t)}mergeFunction(t){return Lt(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=yp(e,t[s]);return e})}};F6.className="Maximum";me(F6);let z6=class extends Hg{constructor(t){super(t)}mergeFunction(t){return Lt(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=O1(e,t[s]);return e})}};z6.className="Minimum";me(z6);class U6 extends Hg{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new bt("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const i of t)if(i!=null){e=!1;break}if(e)return;const s=[];for(let i=0;i<t.length;++i){const r=t[i].slice();r.splice(this.axis,1);let a=!1;for(const o of s)if(Is(o,r)){a=!0;break}a||s.push(r)}if(s.length>1)throw new bt("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return Lt(()=>RO(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new bt("A `Concatenate` layer should be called on a list of inputs.");const e=t,s=e[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const r of e.slice(1)){if(s[i]==null||r[i]==null){s[i]=null;break}s[i]+=r[i]}return s}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new bt("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new bt("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new bt(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return Lt(()=>{let s=!0;if(e.forEach(a=>{if(a!=null){s=!1;return}}),s)return null;const i=[];for(let a=0;a<t.length;++a)e[a]==null?i.push(Ge(uc(t[a]),"bool")):e[a].rank<t[a].rank?i.push(xo(e[a],-1)):i.push(e[a]);const r=_o(i,this.axis);return VG(r,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}U6.className="Concatenate";me(U6);function Lb(n,t){for(;n<0;)n+=t;return n}function omt(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new Fn("batchDot is not implemented for tensors of 4D or higher rank yet");if(et(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),et(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),n.dtype==="complex64"||t.dtype==="complex64")throw new Fn("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,i=t.shape.length;e==null&&(e=[s-1,i-2]);const r=e;return Lt(()=>{let a;if(s>i){a=s-i;const l=[];for(let c=0;c<a;++c)l.push(1);t=Ct(t,t.shape.concat(l))}else if(i>s){a=i-s;const l=[];for(let c=0;c<a;++c)l.push(1);n=Ct(n,n.shape.concat(l))}else a=0;let o;if(n.shape.length===2&&t.shape.length===2)r[0]===r[1]?o=un(Tt(n,t),r[0]):o=un(Tt(cs(n,[1,0]),t),r[1]);else{const l=r[0]!==n.shape.length-1,c=r[1]===t.shape.length-1;o=Ns(n,t,l,c)}if(a>0){let l;s>i?l=s+i-3:l=s-1;const c=[];for(let h=l;h<l+a;++h)c.push(h);o=u_(o,c)}return o.shape.length===1&&(o=xo(o,1)),o})}class B6 extends Hg{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){et(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],s=t[1];if(e.length>3||s.length>3)throw new Fn("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,s);if(e[i[0]]!==s[i[1]])throw new bt(`Dimension incompatibility: ${e[i[0]]} !== ${s[i[1]]}`)}mergeFunction(t){if(t.length!==2)throw new bt(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],s=t[1],i;return Array.isArray(this.axes)?i=this.axes.map((r,a)=>Lb(r,t[a].shape.length)):i=[Lb(this.axes,e.shape.length),Lb(this.axes,s.shape.length)],this.normalize&&(e=O2(e,i[0]),s=O2(s,i[1])),omt(e,s,i)}interpretAxes(t,e){let s;return Array.isArray(this.axes)?s=this.axes:s=[Lb(this.axes,t.length),Lb(this.axes,e.length)],s}computeOutputShape(t){et(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),s=t[1].slice();if(e.length>3||s.length>3)throw new Fn("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,s);e.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const r=e.concat(s);return r.length===1&&r.push(1),r}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}B6.className="Dot";me(B6);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class P6 extends qn{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return Lt(()=>{this.invokeCallHook(t,e);const s=bn(t);return x_(()=>_e(sN(s.shape,0,this.stddev),s),()=>s,e.training||!1)})}}P6.className="GaussianNoise";me(P6);class V6 extends qn{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return Lt(()=>{this.invokeCallHook(t,e);const s=bn(t);return this.rate>0&&this.rate<1?x_(()=>{const r=Math.sqrt(this.rate/(1-this.rate));return Tt(s,sN(s.shape,1,r))},()=>s,e.training||!1):s})}}V6.className="GaussianDropout";me(V6);class G6 extends qn{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||bn(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return Lt(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(t);return x_(()=>{const r=bn(t),o=-1.6732632423543772*1.0507009873554805;let l=Ug(c_(s),this.rate);l=ch(l,"float32");const c=((1-this.rate)*(1+this.rate*o**2))**-.5,h=-c*o*this.rate,f=_e(Tt(r,l),Tt(_e(l,-1),o));return _e(Tt(f,c),h)},()=>bn(t),e.training||!1)}return t})}}G6.className="AlphaDropout";me(G6);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function U1(n,t,e,s,i,r=.001){let a;if(n.rank===2)a=Bat(n,t,e,s,i,r);else if(n.rank===3)a=Vat(n,t,e,s,i,r);else if(n.rank===4)a=Hat(n,t,e,s,i,r);else throw new Fn(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return a}function lmt(n,t,e,s,i=.001){return Lt(()=>{const r=Bk(n,s),a=r.mean,o=r.variance;return[U1(n,a,o,e,t,i),a,o]})}function cmt(n,t,e,s,i=.001){return Lt(()=>{const r=Bk(n,s),a=r.mean,o=r.variance,l=[];for(const v of au(0,n.rank))s.indexOf(v)!==-1?l.push(1):l.push(n.shape[v]);const c=Ct(a,l),h=Ct(o,l),f=t==null?null:Ct(t,l),p=e==null?null:Ct(e,l);return[U1(n,c,h,p,f,i),a,o]})}function umt(n,t,e,s,i=.001){return Is(s.slice().sort(),au(0,n.rank-1))?lmt(n,t,e,s,i):cmt(n,t,e,s,i)}class H6 extends qn{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=fi(t.betaInitializer||"zeros"),this.gammaInitializer=fi(t.gammaInitializer||"ones"),this.movingMeanInitializer=fi(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=fi(t.movingVarianceInitializer||"ones"),this.betaConstraint=br(t.betaConstraint),this.gammaConstraint=br(t.gammaConstraint),this.betaRegularizer=di(t.betaRegularizer),this.gammaRegularizer=di(t.gammaRegularizer)}build(t){t=ms(t);const e=this.axis>=0?this.axis:this.axis+t.length,s=t[e];if(s==null)throw new bt(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new xr({ndim:t.length,axes:{[e]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return Lt(()=>{const s=e.training==null?!1:e.training,i=bn(t),r=i.shape,a=r.length,o=au(0,a),l=this.axis>=0?this.axis:this.axis+a;o.splice(l,1);const c=bg(1,a);c[l]=r[l];const h=o.slice();h.sort();const f=!Is(h,au(0,a).slice(0,a-1)),p=()=>{if(f){const T=Ct(this.movingMean.read(),c),C=Ct(this.movingVariance.read(),c),A=this.center?Ct(this.beta.read(),c):null,I=this.scale?Ct(this.gamma.read(),c):null;return U1(i,T,C,A,I,this.epsilon)}else return U1(i,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return p();const[g,v,_]=umt(i,this.gamma.read(),this.beta.read(),o,this.epsilon),S=(T,C,A)=>{Lt(()=>{const I=1-A,D=T.read(),F=Tt(_n(D,C),I);T.write(_n(D,F))})};return(()=>{S(this.movingMean,v,this.momentum),S(this.movingVariance,_,this.momentum)})(),g})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:_i(this.betaInitializer),gammaInitializer:_i(this.gammaInitializer),movingMeanInitializer:_i(this.movingMeanInitializer),movingVarianceInitializer:_i(this.movingVarianceInitializer),betaRegularizer:Ys(this.betaRegularizer),gammaRegularizer:Ys(this.gammaRegularizer),betaConstraint:vr(this.betaConstraint),gammaConstraint:vr(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}H6.className="BatchNormalization";me(H6);class W6 extends qn{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=fi(t.betaInitializer||"zeros"),this.gammaInitializer=fi(t.gammaInitializer||"ones"),this.betaRegularizer=di(t.betaRegularizer),this.gammaRegularizer=di(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=ms(t);const e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=e);for(const r of this.axis)if(r<0||r>=e)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==Gd(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(r=>t[r]),i=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,i):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,i):this.beta=null,this.built=!0}call(t,e){const s=bn(t),i=s.shape,r=i.length;return Lt(()=>{let{mean:o,variance:l}=Bk(s,this.axis,!0);const c=bg(1,r);for(const _ of this.axis)c[_]=i[_];const h=_=>_!=null&&_.shape.length!==r?Ct(_,c):_;let f=this.scale?h(this.gamma.read()):null,p=this.center?h(this.beta.read()):null;const g=[],v=[];for(let _=0;_<r;++_)this.axis.indexOf(_)!==-1?(g.push(i[_]),v.push(1)):(g.push(1),v.push(i[_]));return o=Qc(o,g),l=Qc(l,g),f!=null&&(f=Qc(f,v)),p!=null&&(p=Qc(p,v)),U1(s,o,l,p,f,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:_i(this.betaInitializer),gammaInitializer:_i(this.gammaInitializer),betaRegularizer:Ys(this.betaRegularizer),gammaRegularizer:Ys(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}W6.className="LayerNormalization";me(W6);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hmt(n,t,e){return Lt(()=>{if(n.rank!==4)throw new bt(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new bt("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=ou()),e!=="channelsLast"&&e!=="channelsFirst")throw new bt(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return e==="channelsFirst"?s=[[0,0],[0,0],t[0],t[1]]:s=[[0,0],t[0],t[1],[0,0]],Pk(n,s)})}class q6 extends qn{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?ou():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new bt(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,s;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],s=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new bt(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new bt(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);s=t.padding[1]}this.padding=[e,s]}this.inputSpec=[new xr({ndim:4})]}computeOutputShape(t){t=ms(t);let e,s;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?s=t[3]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],t[1],e,s]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?s=t[2]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],e,s,t[3]])}call(t,e){return Lt(()=>hmt(bn(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}q6.className="ZeroPadding2D";me(q6);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hN(n,t,e,s,i,r){return Lt(()=>{Ki(i),l5(r),kl(s),e==null&&(e=[1,1]),s==null&&(s="valid"),i==null&&(i=ou()),r==null&&(r="max"),n=HO(n,i);let a;const o=s==="same"?"same":"valid";return r==="max"?a=Uk(n,t,e,o):a=Nk(n,t,e,o),i==="channelsFirst"&&(a=cs(a,[0,3,1,2])),a})}function X6(n,t,e,s,i,r){return Lt(()=>{Ki(i),l5(r),kl(s),e==null&&(e=[1,1,1]),s==null&&(s="valid"),i==null&&(i=ou()),r==null&&(r="max"),n=l6(n,i);let a;const o=s==="same"?"same":"valid";return r==="max"?a=Ilt(n,t,e,o):a=Iat(n,t,e,o),i==="channelsFirst"&&(a=cs(a,[0,4,1,2,3])),a})}class j6 extends qn{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new bt(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(Or(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new bt(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);Or(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,kl(this.padding),this.inputSpec=[new xr({ndim:3})]}computeOutputShape(t){t=ms(t);const e=su(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return Lt(()=>{this.invokeCallHook(t,e),t=g_(bn(t),2);const s=this.poolingFunction(bn(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return u_(s,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class K6 extends j6{constructor(t){super(t)}poolingFunction(t,e,s,i,r){return Ki(r),kl(i),hN(t,e,s,i,r,"max")}}K6.className="MaxPooling1D";me(K6);class Y6 extends j6{constructor(t){super(t)}poolingFunction(t,e,s,i,r){return Ki(r),kl(i),hN(t,e,s,i,r,"avg")}}Y6.className="AveragePooling1D";me(Y6);class Z6 extends qn{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new bt(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Or(this.poolSize,"poolSize"),Or(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ki(this.dataFormat),kl(this.padding),this.inputSpec=[new xr({ndim:4})]}computeOutputShape(t){t=ms(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=su(e,this.poolSize[0],this.padding,this.strides[0]),s=su(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s]:[t[0],e,s,t[3]]}call(t,e){return Lt(()=>(this.invokeCallHook(t,e),this.poolingFunction(bn(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Q6 extends Z6{constructor(t){super(t)}poolingFunction(t,e,s,i,r){return Ki(r),kl(i),hN(t,e,s,i,r,"max")}}Q6.className="MaxPooling2D";me(Q6);class J6 extends Z6{constructor(t){super(t)}poolingFunction(t,e,s,i,r){return Ki(r),kl(i),hN(t,e,s,i,r,"avg")}}J6.className="AveragePooling2D";me(J6);class tW extends qn{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new bt(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Or(this.poolSize,"poolSize"),Or(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ki(this.dataFormat),kl(this.padding),this.inputSpec=[new xr({ndim:5})]}computeOutputShape(t){t=ms(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],i=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=su(e,this.poolSize[0],this.padding,this.strides[0]),s=su(s,this.poolSize[1],this.padding,this.strides[1]),i=su(i,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s,i]:[t[0],e,s,i,t[4]]}call(t,e){return Lt(()=>(this.invokeCallHook(t,e),this.poolingFunction(bn(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class eW extends tW{constructor(t){super(t)}poolingFunction(t,e,s,i,r){return Ki(r),kl(i),X6(t,e,s,i,r,"max")}}eW.className="MaxPooling3D";me(eW);class nW extends tW{constructor(t){super(t)}poolingFunction(t,e,s,i,r){return Ki(r),kl(i),X6(t,e,s,i,r,"avg")}}nW.className="AveragePooling3D";me(nW);class sW extends qn{constructor(t){super(t),this.inputSpec=[new xr({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Fn}}class iW extends sW{constructor(t){super(t||{})}call(t,e){return Lt(()=>{const s=bn(t);return sr(s,1)})}}iW.className="GlobalAveragePooling1D";me(iW);class rW extends sW{constructor(t){super(t||{})}call(t,e){return Lt(()=>{const s=bn(t);return nu(s,1)})}}rW.className="GlobalMaxPooling1D";me(rW);class aW extends qn{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ki(this.dataFormat),this.inputSpec=[new xr({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Fn}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class oW extends aW{call(t,e){return Lt(()=>{const s=bn(t);return this.dataFormat==="channelsLast"?sr(s,[1,2]):sr(s,[2,3])})}}oW.className="GlobalAveragePooling2D";me(oW);class lW extends aW{call(t,e){return Lt(()=>{const s=bn(t);return this.dataFormat==="channelsLast"?nu(s,[1,2]):nu(s,[2,3])})}}lW.className="GlobalMaxPooling2D";me(lW);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class cW extends qn{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,s={}){const i=e.layer,r=_f(i,s);delete e.layer;const a={layer:r};return Object.assign(a,e),new t(a)}}class uW extends cW{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=ms(t),t.length<3)throw new bt(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=ms(t);const e=[t[0]].concat(t.slice(2)),s=this.layer.computeOutputShape(e),i=t[1];return[s[0],i].concat(s.slice(1))}call(t,e){return Lt(()=>(t=bn(t),v6((a,o)=>[bn(this.layer.call(a,e)),[]],t,[],!1,null,null,!1,!0)[1]))}}uW.className="TimeDistributed";me(uW);function fmt(n){Gg(Ldt,"BidirectionalMergeMode",n)}const dmt="concat";class hW extends cW{constructor(t){super(t);const e=t.layer.getConfig(),s={};s.className=t.layer.getClassName(),s.config=e,this.forwardLayer=_f(s),e.goBackwards=e.goBackwards!==!0;const i={};if(i.className=t.layer.getClassName(),i.config=e,this.backwardLayer=_f(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?dmt:t.mergeMode,fmt(this.mergeMode),t.weights)throw new Fn("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,s=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,s)),this.backwardLayer.setWeights(t.slice(s))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let s,i,r;return this.returnState&&(r=e.slice(1)),s=e[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,i=[s]):this.mergeMode==null?i=[s,s.slice()]:i=[s],this.returnState?this.mergeMode==null?i.concat(r).concat(r.slice()):[s].concat(r).concat(r.slice()):vo(i)}apply(t,e){let s=e==null?null:e.initialState,i=e==null?null:e.constants;e==null&&(e={});const r=x6(t,s,i,this.numConstants);if(t=r.inputs,s=r.initialState,i=r.constants,Array.isArray(t)&&(s=t.slice(1),t=t[0]),(s==null||s.length===0)&&i==null)return super.apply(t,e);const a=[],o=[];if(s!=null){const c=s.length;if(c%2>0)throw new bt("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=s,a.push(...s);const h=s.map(f=>new xr({shape:f.shape}));this.forwardLayer.stateSpec=h.slice(0,c/2),this.backwardLayer.stateSpec=h.slice(c/2),o.push(...h)}if(i!=null)throw new Fn("Support for constants in Bidirectional layers is not implemented yet.");const l=a[0]instanceof nh;for(const c of a)if(c instanceof nh!==l)throw new bt("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[t].concat(a),h=this.inputSpec.concat(o),f=this.inputSpec;this.inputSpec=h;const p=super.apply(c,e);return this.inputSpec=f,p}else return super.apply(t,e)}call(t,e){return Lt(()=>{const s=e.initialState;let i,r;if(s==null)i=this.forwardLayer.call(t,e),r=this.backwardLayer.call(t,e);else{const l=s.slice(0,s.length/2),c=s.slice(s.length/2);i=this.forwardLayer.call(t,Object.assign(e,{initialState:l})),r=this.backwardLayer.call(t,Object.assign(e,{initialState:c}))}let a;this.returnState&&(Array.isArray(i)&&(a=i.slice(1).concat(r.slice(1))),i=i[0],r=r[0]),this.returnSequences&&(r=xg(r,1));let o;return this.mergeMode==="concat"?o=RO([i,r]):this.mergeMode==="sum"?o=_e(i,r):this.mergeMode==="ave"?o=Tt(.5,_e(i,r)):this.mergeMode==="mul"?o=Tt(i,r):this.mergeMode==null&&(o=[i,r]),this.returnState?this.mergeMode==null?o.concat(a):[o].concat(a):o})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){eg(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),eg(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[e,e]:s=e:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const r=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(r).concat(r):[s].concat(r).concat(r)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const s=_f(e.layer);if(delete e.layer,e.numConstants!=null)throw new Fn("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=e;return i.layer=s,new t(i)}}hW.className="Bidirectional";me(hW);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class fW extends qn{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return Lt(()=>(t=bn(t),t.dtype!=="float32"&&(t=ch(t,"float32")),_e(Tt(t,this.scale),this.offset)))}}fW.className="Rescaling";me(fW);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:pmt,cropAndResize:mmt}=bf;class dW extends qn{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,s,i,r,a,o,l){return Lt(()=>{let c,h=!1;const f=e/a,p=s/o,g=(i+e)/a,v=(r+s)/o,_=[f,p,g,v],S=[];t.rank===3?(h=!0,c=Zd([t])):c=t;for(let I=0;I<c.shape[0];I++)S.push(_);const b=RG(S,[S.length,4]),T=$1(0,S.length,1,"int32"),A=mmt(c,b,T,[i,r],"nearest");return ch(h?bn(vg(A)):A,l)})}upsize(t,e,s,i){return Lt(()=>{const r=pmt(t,[e,s]);return ch(r,i)})}call(t,e){return Lt(()=>{const s=bn(t),i=s.dtype,r=s.shape,a=r[r.length-3],o=r[r.length-2];let l=0;a!==this.height&&(l=Math.floor((a-this.height)/2));let c=0;return o!==this.width&&(c=Math.floor((o-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(s,l,c,this.height,this.width,a,o,i):this.upsize(t,this.height,this.width,i)})}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=ms(t);const e=t.length-3,s=t.length-2;return t[e]=this.height,t[s]=this.width,t}}dW.className="CenterCrop";me(dW);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gmt(n,t,e,s){let i=bn(n);if(i.dtype!=="int32"&&(i=ch(i,"int32")),t==="int")return i;const r=i.shape;if(i.rank===0&&(i=xo(i,-1)),t==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=xo(i,-1)),i.rank>2)throw new bt(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${r} which would result in output rank ${i.rank}.`);const a=["multiHot","oneHot"].includes(t),o=i;let l;if(typeof s<"u"&&t==="count"?l=dU(o,s,e,a):l=dU(o,[],e,a),t!=="tfIdf")return l;if(s)return Tt(l,s);throw new bt("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class pW extends qn{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return t=ms(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return Lt(()=>{t=bn(t),t.dtype!=="int32"&&(t=ch(t,"int32"));let s;if(typeof e.countWeights<"u"){if(this.outputMode!=="count")throw new bt(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);s=bn(e.countWeights)}const i=nu(t),r=E2(t),a=Dl(this.numTokens,i).bufferSync().get(0),o=Ug(r,0).bufferSync().get(0);if(!(a&&o))throw new bt(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return gmt(t,this.outputMode,this.numTokens,s)})}}pW.className="CategoryEncoding";me(pW);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ymt=["bilinear","nearest"],tB=new Set(ymt);class mW extends qn{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(tB.has(t.interpolation))this.interpolation=t.interpolation;else throw new bt(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=ms(t);const e=t[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return Lt(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return bf.resizeBilinear(t,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return bf.resizeNearestNeighbor(t,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...tB]} are supported`)})}}mW.className="Resizing";me(mW);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class gW{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}gW.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class yW extends qn{constructor(t){super(t),this.randomGenerator=new gW(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}yW.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const xmt=["bilinear","nearest"],eB=new Set(xmt);class xW extends yW{constructor(t){super(t);const{factor:e,interpolation:s="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new bt(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new bt(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new bt(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(eB.has(s))this.interpolation=s;else throw new bt(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=ms(t);const e=t[2];return[this.imgHeight,-1,e]}call(t,e){return Lt(()=>{const s=bn(t);this.imgHeight=s.shape[s.shape.length-3];const i=s.shape[s.shape.length-2];this.widthFactor=c_([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*i;r=Math.round(r);const a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return bf.resizeBilinear(t,a);case"nearest":return bf.resizeNearestNeighbor(t,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...eB]} are supported`)}})}}xW.className="RandomWidth";me(xW);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vmt=Bt();vmt.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var nB;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(nB||(nB={}));var sB;(function(n){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(sB||(sB={}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var iB;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(iB||(iB={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ze(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&et(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bmt=pH;class fN extends R3{nextDataId(){return fN.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new UV(this,Yu())}write(t,e,s){this.firstUse&&(this.firstUse=!1,Bt().get("IS_NODE")&&bl(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const i={id:this.nextDataId()};return this.data.set(i,{values:t,dtype:s,refCount:1}),i}makeTensorInfo(t,e,s){let i;if(e==="string"&&s!=null&&s.length>0&&uS(s[0])){const r=s.map(a=>Vd(a));i=this.write(r,t,e)}else i=this.write(s,t,e);return{dataId:i,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){const e=this.data.get(t);e.refCount--}}move(t,e,s,i,r){this.data.set(t,{values:e,dtype:i,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:s}=this.data.get(t);if(e==="complex64"){const i=this.readSync(s.real.dataId),r=this.readSync(s.imag.dataId);return Cf(i,r)}return Hit(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(i=>Yd(i));return Hn(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Hn(t.shape,t.dtype,e)}makeOutput(t,e,s){return Yu().makeTensorFromTensorInfo(this.makeTensorInfo(e,s,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(t);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=yo();return t(),{kernelMs:yo()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Ze([t],"where");const e=this.readSync(t.dataId);return bmt(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}fN.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vW(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const Smt=n=>{const{x:t}=n.inputs,e=n.backend;Ze(t,"abs");let s=new Float32Array(Zt(t.shape));const i=e.data.get(t.dataId).values;return s=vW(i),e.makeOutput(s,t.shape,t.dtype)},_mt={kernelName:GC,backendName:"cpu",kernelFunc:Smt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yi(n){return(t,e,s,i,r)=>{const a=Rn(t,e),o=a.length,l=ln(a),c=Zt(a),h=ma(r,c),f=t.length,p=e.length,g=ln(t),v=ln(e),_=ux(t,a),S=ux(e,a);if(_.length+S.length===0)for(let b=0;b<h.length;++b)h[b]=n(s[b%s.length],i[b%i.length]);else for(let b=0;b<h.length;++b){const T=Mx(b,o,l),C=T.slice(-f);_.forEach(F=>C[F]=0);const A=ah(C,f,g),I=T.slice(-p);S.forEach(F=>I[F]=0);const D=ah(I,p,v);h[b]=n(s[A],i[D])}return[h,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ko(n){const{inputs:t,backend:e}=n,{real:s,imag:i}=t,r=e.data.get(s.dataId).values,a=e.data.get(i.dataId).values,o=e.makeTensorInfo(s.shape,"complex64"),l=e.data.get(o.dataId);return l.complexTensorInfos={real:e.makeTensorInfo(s.shape,"float32",r),imag:e.makeTensorInfo(i.shape,"float32",a)},o}const wmt={kernelName:H3,backendName:"cpu",kernelFunc:Ko};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U2(n,t,e="float32"){if(e==="complex64"){const i=U2(n,t,"float32"),r=U2(n,t,"float32");return Ko({inputs:{real:i,imag:r},backend:n})}const s=ga(Zt(t),e);return n.makeTensorInfo(t,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vh(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Tmt={kernelName:RS,backendName:"cpu",kernelFunc:vh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sg(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.data.get(s.dataId).complexTensorInfos.real,r=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,r)}const Emt={kernelName:pk,backendName:"cpu",kernelFunc:Sg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bW(n,t,e,s){if(s==="int32"){const i=Int32Array.from(n);return[t,"int32",i]}if(s==="bool"){const i=zg([0],e),[r,a]=Yi((o,l)=>o!==l?1:0)(t,[],n,i,"bool");return[a,"bool",r]}throw new Error(`Error in Cast: failed to cast ${e} to ${s}`)}function np(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return vh({inputs:{x:i},backend:e});const h=U2(e,i.shape,i.dtype),f=np({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),p=Ko({inputs:{real:f,imag:h},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}if(i.dtype==="complex64"){const h=Sg({inputs:{input:i},backend:e}),f=np({inputs:{x:h},backend:e,attrs:{dtype:r}});return e.disposeIntermediateTensorInfo(h),f}if(!VV(i.dtype,r)){const h=vh({inputs:{x:i},backend:e});return{dataId:h.dataId,shape:h.shape,dtype:r}}const a=e.data.get(i.dataId).values,[o,l,c]=bW(a,i.shape,i.dtype,r);return e.makeTensorInfo(o,l,c)}const Cmt={kernelName:xS,backendName:"cpu",kernelFunc:np};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _r(n,t,e,s){return e==null?({inputs:i,backend:r})=>{const{a,b:o}=i,l=r;Ze([a,o],n);const c=l.data.get(a.dataId).values,h=l.data.get(o.dataId).values,f=a.dtype==="string"?Af(c):c,p=a.dtype==="string"?Af(h):h,g=s||a.dtype,[v,_]=t(a.shape,o.shape,f,p,g);return l.makeTensorInfo(_,g,v)}:({inputs:i,backend:r})=>{const{a,b:o}=i,l=r;if(a.dtype==="complex64"||o.dtype==="complex64"){const c=np({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(c.dataId),f=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,g=l.data.get(f.dataId).values,v=l.data.get(p.dataId).values,_=np({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),S=l.data.get(_.dataId),b=S.complexTensorInfos.real,T=S.complexTensorInfos.imag,C=l.data.get(b.dataId).values,A=l.data.get(T.dataId).values,[I,D,F]=e(a.shape,o.shape,g,v,C,A),z=l.makeTensorInfo(F,"float32",I),k=l.makeTensorInfo(F,"float32",D),O=Ko({inputs:{real:z,imag:k},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(_),l.disposeIntermediateTensorInfo(z),l.disposeIntermediateTensorInfo(k),O}else{const c=l.data.get(a.dataId).values,h=l.data.get(o.dataId).values,f=s||a.dtype,[p,g]=t(a.shape,o.shape,c,h,f);return l.makeTensorInfo(g,f,p)}}}function QO(n){return(t,e,s,i,r,a)=>{const o=Rn(t,e),l=Zt(o),c=o.length,h=ln(o),f=ma("float32",l),p=ma("float32",l),g=ux(t,o),v=ux(e,o),_=Cf(s,i),S=Cf(r,a),b=t.length,T=ln(t),C=e.length,A=ln(e);if(g.length+v.length===0)for(let I=0;I<f.length;I++){const D=I%_.length,F=I%S.length,z=n(_[D*2],_[D*2+1],S[F*2],S[F*2+1]);f[I]=z.real,p[I]=z.imag}else for(let I=0;I<f.length;I++){const D=Mx(I,c,h),F=D.slice(-b);g.forEach(H=>F[H]=0);const z=ah(F,b,T),k=D.slice(-C);v.forEach(H=>k[H]=0);const O=ah(k,C,A),L=n(_[z*2],_[z*2+1],S[O*2],S[O*2+1]);f[I]=L.real,p[I]=L.imag}return[f,p,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SW=Yi(((n,t)=>n+t)),Amt=QO(((n,t,e,s)=>({real:n+e,imag:t+s}))),px=_r(Ix,SW,Amt),Nmt={kernelName:Ix,backendName:"cpu",kernelFunc:px};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JO(n,t,e,s,i){const r=Zt(s),a=ga(i,e);for(let o=0;o<n.length;o++){const l=n[o];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(r>0?a[l]+=t[o]:a[l]+=1)}return a}function _W(n,t,e,s=!1){const i=n.shape[0],r=n.shape[1],a=Hn([i,e],t.dtype);for(let o=0;o<i;o++)for(let l=0;l<r;l++){const c=n.get(o,l);if(c<0)throw new Error("Input x must be non-negative!");c>=e||(s?a.set(1,o,c):t.size>0?a.set(a.get(o,c)+t.get(o,l),o,c):a.set(a.get(o,c)+1,o,c))}return a}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wW=Yi(((n,t)=>n&t)),Mmt=_r(G3,wW),Imt={kernelName:G3,backendName:"cpu",kernelFunc:Mmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sh(n){return(t,e,s)=>{const i=Hi(e,t.length);for(let r=0;r<t.length;++r)i[r]=n(t[r],s);return i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zs(n,t,e){const s=Sh(t);return bp(n,s,e)}function bp(n,t,e){return({inputs:s,attrs:i,backend:r})=>{const{x:a}=s;Ze(a,n);const o=r,l=o.data.get(a.dataId).values;let c;if(a.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=Af(l)}else c=l;const h=e||a.dtype,f=t(c,h,i);return o.makeTensorInfo(a.shape,h,f)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TW=Sh(n=>Math.ceil(n)),Rmt=bp(vS,TW),Dmt={kernelName:vS,backendName:"cpu",kernelFunc:Rmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EW(n,t,e,s){const i=Hi(e,Zt(t));if(s&&e!=="string"){let r=0;n.forEach(a=>{const o=Zt(a.shape);i.set(a.vals,r),r+=o})}else{let r=0;n.forEach(a=>{const o=e==="string"?Af(a.vals):a.vals;let l=0;for(let c=0;c<a.shape[0];++c){const h=c*t[1]+r;for(let f=0;f<a.shape[1];++f)i[h+f]=o[l++]}r+=a.shape[1]})}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CW=Yi((n,t)=>n===t?1:0),AW=_r(iA,CW,null,"bool"),kmt={kernelName:iA,backendName:"cpu",kernelFunc:AW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NW=Sh(n=>Math.exp(n)),MW=bp(CS,NW,"float32"),Omt={kernelName:CS,backendName:"cpu",kernelFunc:MW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IW=Sh(n=>Math.expm1(n)),$mt=bp(AS,IW),Lmt={kernelName:AS,backendName:"cpu",kernelFunc:$mt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RW=Sh(n=>Math.floor(n)),Fmt=bp(NS,RW),zmt={kernelName:NS,backendName:"cpu",kernelFunc:Fmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DW=Yi((n,t)=>Math.floor(n/t)),Umt=_r(MS,DW,null,"int32"),Bmt={kernelName:MS,backendName:"cpu",kernelFunc:Umt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kW(n,t,e,s,i,r,a,o,l){const c=Hn([s,r],e);for(let h=0;h<s;h++){const f=[];let p=0;for(let g=0;g<i;g++){const v=n[h*i+g];p+=v*a[g],f.push(v)}if(p<0||p>=l/r)throw new Error(`Invalid indices: ${f} does not index into ${o}`);for(let g=0;g<r;g++)c.values[h*r+g]=t.get(...t.indexToLoc(p*r+g))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OW(n,t,e){const s=Hn(e,n.dtype);for(let i=0;i<s.size;++i){const a=s.indexToLoc(i).slice(),o=a[0],l=a[2],c=t.locToIndex([o,l]);a[2]=t.values[c];const h=n.locToIndex(a);0<=h&&h<n.values.length&&(s.values[i]=n.values[h])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $W=Yi((n,t)=>n>t?1:0),Pmt=_r(lA,$W,null,"bool"),Vmt={kernelName:lA,backendName:"cpu",kernelFunc:Pmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LW=Yi((n,t)=>n>=t?1:0),Gmt=_r(IS,LW,null,"bool"),Hmt={kernelName:IS,backendName:"cpu",kernelFunc:Gmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FW=Yi((n,t)=>n<t?1:0),Wmt=_r(uA,FW,null,"bool"),qmt={kernelName:uA,backendName:"cpu",kernelFunc:Wmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zW=Yi((n,t)=>n<=t?1:0),Xmt=_r(hA,zW,null,"bool"),jmt={kernelName:hA,backendName:"cpu",kernelFunc:Xmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UW(n,t,e){const s=(t-n)/(e-1),i=ga(e,"float32");i[0]=n;for(let r=1;r<i.length;r++)i[r]=i[r-1]+s;return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BW=Sh(n=>Math.log(n)),Kmt=bp($S,BW),Ymt={kernelName:$S,backendName:"cpu",kernelFunc:Kmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PW(n,t,e,s){const i=ma(s,Zt(e));for(let r=0;r<i.length;++r){const a=r*t;let o=n[a];for(let l=0;l<t;++l){const c=n[a+l];(Number.isNaN(c)||c>o)&&(o=c)}i[r]=o}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VW=Yi(((n,t)=>Math.max(n,t))),Zmt=_r(FS,VW),Qmt={kernelName:FS,backendName:"cpu",kernelFunc:Zmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GW=Yi(((n,t)=>Math.min(n,t))),Jmt=_r(zS,GW),tgt={kernelName:zS,backendName:"cpu",kernelFunc:Jmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t$=Yi(((n,t)=>n*t)),egt=QO(((n,t,e,s)=>({real:n*e-t*s,imag:n*s+t*e}))),dN=_r(BS,t$,egt),ngt={kernelName:BS,backendName:"cpu",kernelFunc:dN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HW(n,t,e){const s=pp(-1,e);return t$([],t,s,n,e)}function sgt(n){const{inputs:t,backend:e}=n,{x:s}=t;Ze(s,"neg");const i=e.data.get(s.dataId).values,[r,a]=HW(i,s.shape,s.dtype);return e.makeTensorInfo(a,s.dtype,r)}const igt={kernelName:_A,backendName:"cpu",kernelFunc:sgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WW=Yi(((n,t)=>n!==t?1:0)),rgt=_r(wA,WW,null,"bool"),agt={kernelName:wA,backendName:"cpu",kernelFunc:rgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e$(n,t,e,s,i){const r=t.length,a=Zt(t),o=ln(t),l=ln(i),c=ma(e,Zt(i));for(let h=0;h<a;++h){const f=Mx(h,r,o),p=new Array(f.length);for(let v=0;v<p.length;v++)p[v]=f[s[v]];const g=ah(p,r,l);c[g]=n[h]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eo(n){const{inputs:t,attrs:e,backend:s}=n,{x:i}=t,{perm:r}=e;Ze(i,"transpose");const a=i.shape.length,o=new Array(a);for(let f=0;f<o.length;f++)o[f]=i.shape[r[f]];const l=s.data.get(i.dataId).values,c=e$(l,i.shape,i.dtype,r,o);return{dataId:s.write(c,o,i.dtype),shape:o,dtype:i.dtype}}const ogt={kernelName:Hy,backendName:"cpu",kernelFunc:Eo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qW(n,t,e,s){const[i,r]=zr(n,s),a=Jo(t,"int32"),o=ga(Zt(i),a),l=Zt(r);for(let c=0;c<o.length;++c){const h=c*l;let f=1;for(let p=0;p<l;++p)f*=e[h+p];o[c]=f}return{outVals:o,outShape:i,outDtype:a}}function lgt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:a}=s;Ze(i,"prod");const o=i.shape.length,l=Wn(r,i.shape),c=Ti(l,o);let h=l,f=i;const p=[];c!=null&&(f=Eo({inputs:{x:i},backend:e,attrs:{perm:c}}),p.push(f),h=ji(h.length,o));const g=e.data.get(f.dataId).values,{outVals:v,outShape:_,outDtype:S}=qW(f.shape,f.dtype,g,h);let b=_;return a&&(b=or(_,l)),p.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.makeTensorInfo(b,S,v)}const cgt={kernelName:MA,backendName:"cpu",kernelFunc:lgt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ugt(n,t,e){n.forEach((s,i)=>{if(s<0||s>=e){const r=Mx(i,t.length,ln(t)).join(",");throw new Error(`indices[${r}] = ${s} is not in [0, ${e})`)}})}function hgt(n,t){for(let e=0;e<n.length;++e){const s=n[e],i=e===n.length-1?t:n[e+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>i)throw new Error("Ragged splits must not point past values");for(let r=1;r<s.length;++r)if(s[r-1]>s[r])throw new Error("Ragged splits must be sorted in ascending order")}}function fgt(n,t,e,s){const i=[];let r=0;const a=t.length-1+e.length,o=new Array(a).fill(null).map(()=>[0]);hgt(e,s);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];const h=t[c+1];for(let f=1;f<l+1;++f)o[c].push(f*h)}for(let c=0;c<n.length;++c){let h=n[c],f=n[c]+1;for(let p=0;p<e.length;++p){const g=e[p],v=p+t.length-1;if(v>=0){const _=o[v],S=_[_.length-1]-g[h];for(let b=h;b<f;++b)o[v].push(g[b+1]+S)}h=g[h],f=g[f]}f!==h&&(i.push([h,f]),r+=f-h)}return{outSplits:o,valueSlices:i,numValues:r}}function dgt(n){const t=[];for(let e=0;e<n.length;++e){const s=n[e].length,i=Hi("int32",s);t.push(i),n[e].forEach((r,a)=>i[a]=r)}return t}function rB(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let s=t;s<n.length;s++)e[t-1]*=n[s];return e}function pgt(n,t,e,s,i,r){const a=rB(t,2)[1],o=rB(r,2)[1];let l=0;for(const c of e)for(let h=c[0];h<c[1];++h){for(let f=0;f<s;++f)i[l*o+f]=n[h*a+f];++l}}function mgt(n,t,e,s,i){const r=t.slice();r[0]=i;const a=Hi(e,Zt(r)),o=n.length,l=o===0?0:o/t[0];return pgt(n,t,s,l,a,r),[a,r]}function XW(n,t,e,s,i,r,a,o){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const l=t[0][0]-1;if(ugt(r,a,l),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:h,valueSlices:f,numValues:p}=fgt(r,a,n,c),g=dgt(h),v=mgt(e,s,i,f,p);return[g,v[0],v[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aB=2147483647;function jW(n,t,e,s,i,r,a){if(t.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const o=t.length===0,l=i.length===0,c=a.length===0,h=[];o||h.push(t[0]),l||h.push(i[0]),c||h.push(a[0]);for(let S=1;S<h.length;++S)if(h[S]!==h[S-1])throw new Error("starts, limits, and deltas must have the same shape");const f=h.length===0?1:h[0],p=Hi("int32",f+1);p[0]=0;for(let S=0;S<f;++S){const b=o?n[0]:n[S],T=l?s[0]:s[S],C=c?r[0]:r[S];if(C===0)throw new Error("Requires delta != 0");let A;if(C>0&&T<b||C<0&&T>b)A=0;else if(A=Math.ceil(Math.abs((T-b)/C)),A>aB)throw new Error(`Requires ((limit - start) / delta) <= ${aB}`);p[S+1]=p[S]+A}const g=p[f],v=Hi(e,g);let _=0;for(let S=0;S<f;++S){const b=p[S+1]-p[S];let T=o?n[0]:n[S];const C=c?r[0]:r[S];for(let A=0;A<b;++A)v[_++]=T,T+=C}return[p,v]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ic=jc;class B2{constructor(t,e,s,i,r,a,o,l,c,h){this.shape=t,this.shapeShape=e,this.values=s,this.valuesShape=i,this.valuesDType=r,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=kH(h),this.raggedRank=OH(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===ic.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===ic.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case ic.VALUE_ROWIDS:return B2.getMaxWidthValueRowID(e);case ic.ROW_SPLITS:return B2.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${ic[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(e===0||e===1)return 0;let s=0;for(let i=0;i<e-1;++i){const r=t[i+1]-t[i];r>s&&(s=r)}return s}static getMaxWidthValueRowID(t){const e=t.length;if(e===0)return 0;let s=0,i=t[0],r=0;for(let a=1;a<e;++a){const o=t[a];o!==i&&(i=o,r=Math.max(a-s,r),s=a)}return Math.max(e-s,r)}tensorShapeFromTensor(t,e,s=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return lB(t,s)}calculateOutputSize(t){const e=this.valuesShape,s=this.defaultValueShape;$H(s,e);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=DH(this.raggedRank,i,e);a[0]<0&&(a[0]=t);for(let o=1;o<=this.raggedRank;++o)a[o]<0&&(a[o]=this.getMaxWidth(o));return a}calculateFirstParentOutputIndex(t,e,s){const i=Math.min(t,s),r=[];let a=0;for(let o=0;o<i;++o,a+=e)r.push(a);for(let o=i;o<t;++o)r.push(-1);return et(r.length===t,()=>"Final length of result must be equal to firstDimension."),r}calculateOutputIndexRowSplit(t,e,s,i){const r=t.length,a=[];for(let o=0;o<r-1;++o){const l=t[o+1]-t[o];let c=Math.min(i,l),h=e[o];h===-1&&(c=0);for(let f=0;f<c;++f)a.push(h),h+=s;for(let f=0;f<l-c;++f)a.push(-1)}if(r>0&&a.length!==t[r-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(t,e,s,i){const r=t.length,a=[];if(r===0)return[];let o=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let c=e[l];a.push(c);for(let h=1;h<r;++h){const f=t[h];if(f===l)c>=0&&(++o,o<i?c+=s:c=-1);else{if(o=0,l=f,f>=e.length)throw new Error(`Got nextValueRowId=${f} which is not less than ${e.length}`);c=e[f]}a.push(c)}if(a.length!==t.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(t,e,s,i){const r=this.getRowPartitionTensor(t),a=this.getRowPartitionTypeByDimension(t);switch(a){case ic.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,e,s,i);case ic.ROW_SPLITS:if(r.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${r.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(r,e,s,i);default:throw new Error(`Unsupported partition type: ${ic[a]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case ic.FIRST_DIM_SIZE:return t[0];case ic.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ic.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ic[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),s=this.calculateOutputSize(e),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let l=i.length-2;l>=0;--l)i[l]=i[l+1]*s[l+1];const r=lB(s,!1),a=Hi(this.valuesDType,Zt(r));if(i[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(e,i[0],s[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,i[c],s[c]);this.setOutput(this.raggedRank,l,a,r)}return[r,a]}setOutput(t,e,s,i){if(s.length===0)return;const r=this.values,a=s;let o=i.slice();o=o.slice(t+1);const l=Zt(o),c=e.length;let h=this.defaultValue;if(h.length!==l&&h.length!==1){const v=this.defaultValueShape;Lt(()=>{const _=Ct(h,v);h=l1(_,o).dataSync()})}let f=0,p=0,g=0;for(let v=0;v<=c;++v){let _=v<c?e[v]:-1;if(_===g){++g;continue}if(p<g){const S=r.subarray(f*l),b=a.subarray(p*l),T=(g-p)*l;oB(b,S,T)}if(v>=c){const S=s.length;_=Math.floor(S/l)}if(_>g)if(this.defaultValue.length===1)a.subarray(g*l,_*l).fill(this.defaultValue[0]),g=_;else for(;_>g;){const S=a.slice(g*l);oB(S,h,l),++g}_<0?(f=v+1,p=g):(f=v,p=g,g=p+1)}}}function oB(n,t,e){for(let s=0;s<e;s++)n[s]=t[s]}function lB(n,t){const e=[];for(let s of n){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}e.push(s)}return e}function KW(n,t,e,s,i,r,a,o,l,c){return new B2(n,t,e,s,i,r,a,o,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YW(n,t,e,s){const i=n===t,r=n<t&&e<0,a=t<n&&e>1;if(i||r||a)return ga(0,s);const o=Math.abs(Math.ceil((t-n)/e)),l=ga(o,s);t<n&&e===1&&(e=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+e;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZW=Sh(n=>1/Math.sqrt(n)),ggt=bp(qS,ZW),ygt={kernelName:qS,backendName:"cpu",kernelFunc:ggt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xm(n,t,e,s,i,r,a,o,l,c){const h=[s/i,i],f=n.values,p=t.values;if(s===0)return Hn(e,t.dtype);const g=l instanceof Qr?l:Hn(h,t.dtype);typeof l=="string"||typeof l=="number"?g.values.fill(l):typeof l=="boolean"&&g.values.fill(+l);for(let v=0;v<r;v++){const _=[];let S=0;for(let b=0;b<a;b++){const T=f[v*a+b];_.push(T),S+=T*o[b]}if(S<0||S>=s/i)throw new Error(`Invalid indices: ${_} does not index into ${e}`);for(let b=0;b<i;b++)c?g.values[S*i+b]+=p[v*i+b]:g.values[S*i+b]=t.rank===0?p[0]:p[v*i+b]}return g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xgt=Sh(n=>1/(1+Math.exp(-n))),QW=zs(ZS,n=>1/(1+Math.exp(-n))),vgt={kernelName:ZS,backendName:"cpu",kernelFunc:QW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JW(n,t,e,s,i){const r=aO(s,t,e),a=Zt(e),o=ln(s);if(r){const f=oO(t,o);return i==="string"?n.slice(f,f+a):n.subarray(f,f+a)}const l=i==="string"?Af(n):n,c=Hn(s,i,l),h=Hn(e,i);for(let f=0;f<h.size;++f){const p=h.indexToLoc(f),g=p.map((v,_)=>v+t[_]);h.set(c.get(...g),...p)}return i==="string"?e5(h.values):h.values}function _g(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:r,size:a}=s;Ze(i,"slice");const[o,l]=QA(i,r,a);iO(i,o,l);const c=e.data.get(i.dataId).values,h=JW(c,o,l,i.shape,i.dtype);return e.makeTensorInfo(l,i.dtype,h)}const bgt={kernelName:$A,backendName:"cpu",kernelFunc:_g};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t8(n,t,e,s,i,r,a){const o=t[0],l=r[0],c=new Array(l),h=new Array(o),f=t[1];if(l===0){if(o!==0)throw new Error(VH(o));const S=Hi(e,0),b=Hi(i,0);return[S,[0,f],b,c,h]}let p=!0,g=0;const v=new Array(l).fill(0);for(let S=0;S<o;++S){const b=n[S*f];if(b<0)throw new Error(GH(S,b));if(b>=l)throw new Error(HH(S,b,l));++v[b],p=p&&b>=g,g=b}let _=!0;for(let S=0;S<l;++S){const b=v[S]===0;c[S]=b,_=_&&!b,v[S]=Math.max(v[S],1),S>0&&(v[S]+=v[S-1])}if(_&&p){const S=n,b=s;for(let T=0;T<o;++T)h[T]=T;return[S,[o,f],b,c,h]}else{const S=v[l-1],b=Hi(e,S*f),T=Hi(i,S),C=new Array(l).fill(0);for(let A=0;A<o;++A){const I=n[A*f],D=C[I],F=(I===0?0:v[I-1])+D;C[I]++;for(let z=0;z<f;++z)b[F*f+z]=n[A*f+z];T[F]=s[A],h[A]=F}for(let A=0;A<l;++A)if(C[A]===0){const D=A===0?0:v[A-1];b[D*f+0]=A;for(let F=1;F<f;++F)b[D*f+F]=0;T[D]=a}return[b,[S,f],T,c,h]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e8(n,t,e,s,i){const r=Zt(s),a=t[0],o=i.length,l=[];let c=1,h=-1;for(let S=0;S<o;++S){const b=i[S];if(b===-1){if(h!==-1)throw new Error(WH(h,S));h=S,l.push(1)}else{if(b<0)throw new Error(qH(S,b));c*=b,l.push(b)}}if(h!==-1){if(c<=0)throw new Error(XH());const S=Math.trunc(r/c);if(c*S!==r)throw new Error(jH(s,l));l[h]=S}if(Zt(l)!==r)throw new Error(KH(s,l));const p=s.length,g=[];if(p>0){g[p-1]=1;for(let S=p-2;S>=0;--S)g[S]=g[S+1]*s[S+1]}const v=[];if(o>0){v[o-1]=1;for(let S=o-2;S>=0;--S)v[S]=v[S+1]*l[S+1]}const _=Hi(e,a*o);for(let S=0;S<a;++S){let b=0;for(let T=0;T<p;++T)b+=n[S*p+T]*g[T];for(let T=0;T<o;++T)_[S*o+T]=Math.trunc(b/v[T]),b%=v[T]}return[_,[a,o],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n$(n,t,e,s,i,r=!1,a=0){const o=s.length,l=[t[0],n.length/t[0]],c=l[1],f=o>0?i[o-1]+1:0;if(f<0)throw new Error(PR());const p=t.slice();p[0]=f;const g=p.reduce((C,A)=>C*A,1),v=Hi(e,g);if(o===0)return f>0&&v.fill(a),[v,p];if(f<=0)throw new Error(PR());let _=0,S=1,b=0,T=i[_];for(;;){let C=0;if(S<o){if(C=i[S],T===C){++S;continue}if(T>=C)throw new Error(YH())}if(T<0||T>=f)throw new Error(ZH(T,f));T>b&&v.fill(a,b*c,T*c);for(let A=_;A<S;++A){const I=s[A];if(I<0||I>=l[0])throw new Error(QH(A,s[A],l[0]));for(let D=0;D<c;D++)v[T*c+D]+=n[I*c+D]}if(r)for(let A=0;A<c;A++)v[T*c+A]/=S-_;if(_=S,++S,b=T+1,T=C,S>o)break}return b<f&&v.fill(a,b*c,f*c),[v,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sgt=Sh(n=>Math.sqrt(n)),_gt=zs(JS,n=>Math.sqrt(n)),wgt={kernelName:JS,backendName:"cpu",kernelFunc:_gt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n8=Yi(((n,t)=>{const e=n-t;return e*e})),Tgt=_r(t_,n8),Egt={kernelName:t_,backendName:"cpu",kernelFunc:Tgt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s8=Sh((n,t)=>{const{pattern:e,replaceGlobal:s,rewrite:i}=t;return n.replace(new RegExp(e,s?"g":""),i)}),Cgt=bp(xk,s8),Agt={kernelName:xk,backendName:"cpu",kernelFunc:Cgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i8(n,t,e,s){const i=Hn(n,t.dtype);for(let r=0;r<i.size;r++){const a=i.indexToLoc(r),o=new Array(a.length);for(let l=0;l<o.length;l++)o[l]=a[l]*e[l]+s[l];i.set(t.get(...o),...a)}return i}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ngt{constructor(t,e,s,i,r,a){this.separator=Vd(t),this.nGramWidths=e,this.leftPad=Vd(s),this.rightPad=Vd(i),this.padWidth=r,this.preserveShort=a}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const s=this.getPadWidth(e);return Math.max(0,t+2*s-e+1)}createNGrams(t,e,s,i,r,a){for(let o=0;o<r;++o){const l=this.getPadWidth(a),c=Math.max(0,l-o),h=Math.max(0,l-(r-(o+1))),f=a-(c+h),p=e+(c>0?0:o-l);let g=0;g+=c*this.leftPad.length;for(let T=0;T<f;++T)g+=t[p+T].length;g+=h*this.rightPad.length;const v=c+h+f-1;g+=v*this.separator.length,s[i+o]=new Uint8Array(g);const _=s[i+o];let S=0;const b=T=>T.forEach(C=>_[S++]=C);for(let T=0;T<c;++T)b(this.leftPad),b(this.separator);for(let T=0;T<f-1;++T)b(t[p+T]),b(this.separator);if(f>0){b(t[p+f-1]);for(let T=0;T<h;++T)b(this.separator),b(this.rightPad)}else{for(let T=0;T<h-1;++T)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(t,e){const s=t.length,i=e.length;if(i>0){let l=e[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<i;++c){let h=e[c]>=l;if(h=h&&e[c]<=s,!h)throw new Error(`Invalid split value ${e[c]}, must be in [${l}, ${s}]`);l=e[c]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const r=i-1,a=Hi("int32",i);if(s===0||i===0){const l=new Array(s);for(let c=0;c<=r;++c)a[c]=0;return[l,a]}a[0]=0;for(let l=1;l<=r;++l){const c=e[l]-e[l-1];let h=0;this.nGramWidths.forEach(f=>{h+=this.getNumNGrams(c,f)}),this.preserveShort&&c>0&&h===0&&(h=1),a[l]=a[l-1]+h}const o=new Array(a[r]);for(let l=0;l<r;++l){const c=e[l];let h=a[l];if(this.nGramWidths.forEach(f=>{const p=e[l+1]-e[l],g=this.getNumNGrams(p,f);this.createNGrams(t,c,o,h,g,f),h+=g}),this.preserveShort&&h===a[l]){const f=e[l+1]-e[l];if(f===0)continue;const p=f+2*this.padWidth;this.createNGrams(t,c,o,h,1,p)}}return[o,a]}}function r8(n,t,e,s,i,r,a,o){return new Ngt(e,s,i,r,a,o).compute(n,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mgt(n,t,e,s){if(!n.length)return;if(t.length===0){for(let r=0;r<n.length;++r)s.push(n.subarray(r,r+1));return}if(t.length===1){const r=t[0];let a=n.indexOf(r);for(;a!==-1;){const o=n.subarray(0,a);(!e||o.length!==0)&&s.push(o),n=n.subarray(a+1),a=n.indexOf(r)}(!e||n.length!==0)&&s.push(n);return}let i=0;for(let r=0;r<n.length+1;r++)if(r===n.length||t.indexOf(n[r])!==-1){const a=n.subarray(i,r);(!e||a.length!==0)&&s.push(a),i=r+1}}function a8(n,t,e){const s=n.length,i=[];let r=0,a=0;const o=new Array(s);for(let p=0;p<s;++p){const g=i.length;Mgt(n[p],t,e,i);const v=i.length-g;o[p]=v,r+=v,a=Math.max(a,v)}const l=Hi("int32",r*2),c=new Array(r),h=[s,a];let f=0;for(let p=0;p<s;++p)for(let g=0;g<o[p];++g)l[f*2]=p,l[f*2+1]=g,c[f]=i[f],++f;return[l,c,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o8(n,t){const e=Hi("int32",n.length);for(let s=0;s<n.length;++s)e[s]=crt(n[s]).modulo(t).getLowBitsUnsigned();return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l8=Yi(((n,t)=>n-t)),Igt=QO(((n,t,e,s)=>({real:n-e,imag:t-s}))),s$=_r(e_,l8,Igt),Rgt={kernelName:e_,backendName:"cpu",kernelFunc:s$};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c8(n,t){const e=new Array(n.rank);for(let i=0;i<e.length;i++)e[i]=n.shape[i]*t[i];const s=Hn(e,n.dtype);for(let i=0;i<s.values.length;++i){const r=s.indexToLoc(i),a=new Array(n.rank);for(let l=0;l<a.length;l++)a[l]=r[l]%n.shape[l];const o=n.locToIndex(a);s.values[i]=n.values[o]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qb=(n,t)=>{const e=t.value-n.value;return e===0?n.index-t.index:e};function u8(n,t,e=0,s=n.length-1){for(;s>e;){if(s-e>600){const o=s-e+1,l=t-e+1,c=Math.log(o),h=.5*Math.exp(2*c/3),f=.5*Math.sqrt(c*h*(o-h)/o)*Math.sign(l-o/2),p=Math.max(e,Math.floor(t-l*h/o+f)),g=Math.min(s,Math.floor(t+(o-l)*h/o+f));u8(n,t,p,g)}const i=n[t];let r=e,a=s;for(Ry(n,e,t),qb(n[s],i)>0&&Ry(n,e,s);r<a;){for(Ry(n,r,a),r++,a--;qb(n[r],i)<0;)r=r+1;for(;qb(n[a],i)>0;)a=a-1}qb(n[e],i)===0?Ry(n,e,a):(a=a+1,Ry(n,a,s)),a<=t&&(e=a+1),t<=a&&(s=a-1)}}function h8(n,t,e,s,i){const r=t[t.length-1],[a,o]=[n.length/r,r],l=ma(e,a*s),c=ma("int32",a*s);for(let f=0;f<a;f++){const p=f*o,g=n.subarray(p,p+o);let v=new Array(g.length);g.forEach((T,C)=>v[C]={value:T,index:C}),s<v.length&&(u8(v,s),v=v.slice(0,s)),i&&v.sort(qb);const _=f*s,S=l.subarray(_,_+s),b=c.subarray(_,_+s);for(let T=0;T<s;T++)S[T]=v[T].value,b[T]=v[T].index}const h=t.slice();return h[h.length-1]=s,[Hn(h,e,l),Hn(h,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f8(n,t,e,s){const i=Wn(t,e)[0],r=[1,e[0],1];for(let v=0;v<i;v++)r[0]*=e[v];r[1]=e[i];for(let v=i+1;v<e.length;v++)r[2]*=e[v];const a=new Map,o=new Int32Array(e[i]),l=new Qr(r,s,n),c=[],h=r[0]===1&&r[2]===1;for(let v=0;v<e[i];v++){let _;if(h)_=n[v].toString();else{const b=[];for(let T=0;T<r[0];T++)for(let C=0;C<r[2];C++)b.push(l.get(T,v,C));_=b.join(",")}const S=a.get(_);if(S!=null)o[v]=S;else{const b=a.size;a.set(_,b),o[v]=b,c.push(v)}}const f=r.slice();f[1]=a.size;const p=new Qr(f,s);c.forEach((v,_)=>{for(let S=0;S<r[0];S++)for(let b=0;b<r[2];b++)p.set(l.get(S,v,b),S,_,b)});const g=e.slice();return g[i]=f[1],{outputValues:p.values,outputShape:g,indices:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dgt=Object.freeze(Object.defineProperty({__proto__:null,addImpl:SW,bincountImpl:JO,bincountReduceImpl:_W,bitwiseAndImpl:wW,castImpl:bW,ceilImpl:TW,concatImpl:EW,equalImpl:CW,expImpl:NW,expm1Impl:IW,floorDivImpl:DW,floorImpl:RW,gatherNdImpl:kW,gatherV2Impl:OW,greaterEqualImpl:LW,greaterImpl:$W,lessEqualImpl:zW,lessImpl:FW,linSpaceImpl:UW,logImpl:BW,maxImpl:PW,maximumImpl:VW,minimumImpl:GW,multiplyImpl:t$,negImpl:HW,notEqualImpl:WW,prodImpl:qW,raggedGatherImpl:XW,raggedRangeImpl:jW,raggedTensorToTensorImpl:KW,rangeImpl:YW,rsqrtImpl:ZW,scatterImpl:Xm,sigmoidImpl:xgt,simpleAbsImpl:vW,sliceImpl:JW,sparseFillEmptyRowsImpl:t8,sparseReshapeImpl:e8,sparseSegmentReductionImpl:n$,sqrtImpl:Sgt,squaredDifferenceImpl:n8,staticRegexReplaceImpl:s8,stridedSliceImpl:i8,stringNGramsImpl:r8,stringSplitImpl:a8,stringToHashBucketFastImpl:o8,subImpl:l8,tileImpl:c8,topKImpl:h8,transposeImpl:e$,uniqueImpl:f8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */BG("cpu",()=>new fN,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d8=zs(TS,n=>n>=0?n:Math.exp(n)-1),kgt={kernelName:TS,backendName:"cpu",kernelFunc:d8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p8(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{alpha:r}=s;Ze([i],"leakyRelu");const a=Zt(i.shape),o=e.data.get(i.dataId).values,l=ma("float32",a);for(let c=0;c<o.length;c++)l[c]=o[c]<0?r*o[c]:o[c];return e.makeTensorInfo(i.shape,"float32",l)}const Ogt={kernelName:cA,backendName:"cpu",kernelFunc:p8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $gt=Yi((n,t)=>n<0?t*n:n);function m8(n){const{inputs:t,backend:e}=n,{x:s,alpha:i}=t;Ze([s,i],"prelu");const r=e.data.get(s.dataId).values,a=e.data.get(i.dataId).values,[o,l]=$gt(s.shape,i.shape,r,a,"float32");return e.makeTensorInfo(l,"float32",o)}const Lgt={kernelName:NA,backendName:"cpu",kernelFunc:m8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g8=zs(GS,n=>Math.max(0,n)),Fgt={kernelName:GS,backendName:"cpu",kernelFunc:g8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y8=zs(HS,n=>Math.min(Math.max(0,n),6)),zgt={kernelName:HS,backendName:"cpu",kernelFunc:y8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P2(n,t,e,s,i){if(e==="linear")return vh({inputs:{x:t},backend:n});if(e==="relu")return g8({inputs:{x:t},backend:n});if(e==="elu")return d8({inputs:{x:t},backend:n});if(e==="relu6")return y8({inputs:{x:t},backend:n});if(e==="prelu")return m8({inputs:{x:t,alpha:s},backend:n});if(e==="leakyrelu")return p8({inputs:{x:t},backend:n,attrs:{alpha:i}});if(e==="sigmoid")return QW({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ii(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{shape:r}=s,a=Zt(i.shape),o=PV(r,a),l=Zt(o);et(a===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),e.incRef(i.dataId);const c=e.data.get(i.dataId);if(c.complexTensorInfos!=null){const h=c.complexTensorInfos.real,f=c.complexTensorInfos.imag;h.shape=o,f.shape=o}return{dataId:i.dataId,shape:o,dtype:i.dtype}}const Ugt={kernelName:IA,backendName:"cpu",kernelFunc:ii};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x8(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:r}=t,{transposeA:a,transposeB:o}=s;Ze([i,r],"matMul");const l=i.shape.length,c=r.shape.length,h=a?i.shape[l-2]:i.shape[l-1],f=o?r.shape[c-1]:r.shape[c-2],p=a?i.shape[l-1]:i.shape[l-2],g=o?r.shape[c-2]:r.shape[c-1],v=i.shape.slice(0,-2),_=r.shape.slice(0,-2),S=Zt(v),b=Zt(_),C=Rn(i.shape.slice(0,-2),r.shape.slice(0,-2)).concat([p,g]);et(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${i.shape} and ${r.shape} and transposeA=${a} and transposeB=${o} must match.`);const A=a?[S,h,p]:[S,p,h],I=o?[b,g,f]:[b,f,g],D=ii({inputs:{x:i},backend:e,attrs:{shape:A}}),F=ii({inputs:{x:r},backend:e,attrs:{shape:I}}),z=a?D.shape[1]:D.shape[2],k=a?D.shape[2]:D.shape[1],O=o?F.shape[1]:F.shape[2],L=Math.max(S,b),H=e.data.get(D.dataId).values,q=e.data.get(F.dataId).values,K=ln(D.shape),Y=ln(F.shape),[P,W,j]=a?[K[0],1,K[1]]:[K[0],K[1],1],[st,ot,X]=o?[1,Y[1],Y[0]]:[Y[1],1,Y[0]],it=k*O,ct=Hn([L,k,O],D.dtype),yt=ct.values,Rt=e.blockSize;for(let ft=0;ft<L;ft++){const _t=ft%S,qt=ft%b;for(let Qt=0;Qt<k;Qt+=Rt){const se=Math.min(Qt+Rt,k);for(let Ee=0;Ee<O;Ee+=Rt){const He=Math.min(Ee+Rt,O);for(let Ae=0;Ae<z;Ae+=Rt){const Ht=Math.min(Ae+Rt,z);for(let Jt=Qt;Jt<se;Jt++)for(let Xt=Ee;Xt<He;Xt++){let ce=0;for(let rt=Ae;rt<Ht;rt++){const Fe=H[_t*P+Jt*W+rt*j],he=q[rt*st+Xt*ot+qt*X];ce+=Fe*he}yt[ft*it+(Jt*O+Xt)]+=ce}}}}}return e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(F),e.makeTensorInfo(C,ct.dtype,ct.values)}const Bgt={kernelName:jC,backendName:"cpu",kernelFunc:x8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pgt(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:r,bias:a,preluActivationWeights:o}=t,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:f}=s;let p,g,v;const _=[];p=x8({inputs:{a:i,b:r},attrs:{transposeA:l,transposeB:c},backend:e}),a&&(g=px({inputs:{a:p,b:a},backend:e}),_.push(p),p=g),h&&(v=P2(e,p,h,o,f),_.push(p),p=v);for(const b of _)e.disposeIntermediateTensorInfo(b);return p}const Vgt={kernelName:S2,backendName:"cpu",kernelFunc:Pgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ggt=zs(hS,n=>Math.acos(n)),Hgt={kernelName:hS,backendName:"cpu",kernelFunc:Ggt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wgt=zs(fS,n=>Math.acosh(n)),qgt={kernelName:fS,backendName:"cpu",kernelFunc:Wgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xgt(n){const{inputs:t,backend:e}=n,s=t;Ze(t,"addN");const i=s.map(o=>e.data.get(o.dataId).values),r=Hn(s[0].shape,s[0].dtype),a=r.values;for(let o=0;o<s.length;o++){const l=i[o];for(let c=0;c<a.length;c++)a[c]+=l[c]}return e.makeTensorInfo(r.shape,r.dtype,r.values)}const jgt={kernelName:F3,backendName:"cpu",kernelFunc:Xgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kgt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:a}=s;Ze(i,"all");const o=Wn(r,i.shape);let l=o;const c=Ti(l,i.shape.length);let h=i;c!=null&&(h=Eo({inputs:{x:i},backend:e,attrs:{perm:c}}),l=ji(l.length,i.shape.length)),ea("all",l,h.shape.length);const[f,p]=zr(h.shape,l),g=Zt(p),v=ga(Zt(f),h.dtype),_=e.data.get(h.dataId).values;for(let b=0;b<v.length;++b){const T=b*g;let C=_[T];for(let A=0;A<g;++A){const I=_[T+A];C=C&&I}v[b]=C}c!=null&&e.disposeIntermediateTensorInfo(h);const S=e.makeTensorInfo(f,h.dtype,v);if(a){const b=or(f,o),T=ii({inputs:{x:S},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(S),T}return S}const Ygt={kernelName:z3,backendName:"cpu",kernelFunc:Kgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zgt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:a}=s;Ze(i,"any");const o=Wn(r,i.shape);let l=o;const c=Ti(l,i.shape.length);let h=i;c!=null&&(h=Eo({inputs:{x:i},backend:e,attrs:{perm:c}}),l=ji(l.length,i.shape.length)),ea("any",l,h.shape.length);const[f,p]=zr(h.shape,l),g=Zt(p),v=ga(Zt(f),h.dtype),_=e.data.get(h.dataId).values;for(let b=0;b<v.length;++b){const T=b*g;let C=_[T];for(let A=0;A<g;++A){const I=_[T+A];C=C||I}v[b]=C}c!=null&&e.disposeIntermediateTensorInfo(h);const S=e.makeTensorInfo(f,h.dtype,v);if(a){const b=or(f,o),T=ii({inputs:{x:S},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(S),T}return S}const Qgt={kernelName:U3,backendName:"cpu",kernelFunc:Zgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jgt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r}=s;Ze(i,"argMax");let a=Wn(r,i.shape);const o=Ti(a,i.shape.length);let l=i;const c=[];o!=null&&(l=Eo({inputs:{x:i},backend:e,attrs:{perm:o}}),c.push(l),a=ji(a.length,l.shape.length)),a=[a[0]],ea("argMax",a,l.shape.length);const[h,f]=zr(l.shape,a),p=Zt(h),g=ga(p,"int32"),v=Zt(f),_=e.data.get(l.dataId).values;for(let S=0;S<g.length;++S){const b=S*v;let T=_[b],C=0;for(let A=0;A<v;++A){const I=_[b+A];I>T&&(T=I,C=A)}g[S]=C}return c.forEach(S=>e.disposeIntermediateTensorInfo(S)),e.makeTensorInfo(h,"int32",g)}const t0t={kernelName:HC,backendName:"cpu",kernelFunc:Jgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r}=s;Ze(i,"argMin");let a=Wn(r,i.shape);const o=Ti(a,i.shape.length);let l=i;const c=[];o!=null&&(l=Eo({inputs:{x:i},backend:e,attrs:{perm:o}}),c.push(l),a=ji(a.length,l.shape.length)),a=[a[0]],ea("argMin",a,l.shape.length);const[h,f]=zr(l.shape,a),p=Zt(h),g=ga(p,"int32"),v=Zt(f),_=e.data.get(l.dataId).values;for(let S=0;S<g.length;++S){const b=S*v;let T=_[b],C=0;for(let A=0;A<v;++A){const I=_[b+A];I<T&&(T=I,C=A)}g[S]=C}return c.forEach(S=>e.disposeIntermediateTensorInfo(S)),e.makeTensorInfo(h,"int32",g)}const n0t={kernelName:WC,backendName:"cpu",kernelFunc:e0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s0t=zs(dS,n=>Math.asin(n)),i0t={kernelName:dS,backendName:"cpu",kernelFunc:s0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r0t=zs(pS,n=>Math.asinh(n)),a0t={kernelName:pS,backendName:"cpu",kernelFunc:r0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o0t=zs(mS,n=>Math.atan(n)),l0t={kernelName:mS,backendName:"cpu",kernelFunc:o0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c0t=Yi((n,t)=>Math.atan2(n,t)),u0t=_r(yS,c0t),h0t={kernelName:yS,backendName:"cpu",kernelFunc:u0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f0t=zs(gS,n=>Math.atanh(n)),d0t={kernelName:gS,backendName:"cpu",kernelFunc:f0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i$(n,t,e,s,i,r){const a=i.strideHeight,o=i.strideWidth,l=i.dilationHeight,c=i.dilationWidth,h=i.effectiveFilterHeight,f=i.effectiveFilterWidth,p=i.padInfo.top,g=i.padInfo.left,v=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,_=Hn(i.outShape,e),S=_.values,b=i.outShape[1]*i.outShape[2]*i.outShape[3],T=i.outShape[2]*i.outShape[3],C=i.outShape[3];for(let A=0;A<i.batchSize;++A){const I=A*b,D=A*s[0];for(let F=0;F<i.inChannels;++F)for(let z=0;z<i.outHeight;++z){const k=z*a-p,O=Math.max(0,k),L=Math.min(i.inHeight,h+k),H=I+z*T;for(let q=0;q<i.outWidth;++q){const K=q*o-g,Y=Math.max(0,K),P=Math.min(i.inWidth,f+K);let W=v,j=0,st=0;for(let X=O;X<L;X+=l){const it=D+X*s[1];for(let ct=Y;ct<P;ct+=c){const yt=it+ct*s[2],Rt=n[yt+F];r==="max"&&Rt>W?W=Rt:r==="avg"&&(j+=Rt,st++)}if(isNaN(W))break}const ot=H+q*C+F;S[ot]=r==="avg"?j/st:W}}}return _}function v8(n,t,e,s,i=!1,r=!1){const a=Hn(s.outShape,"int32"),o=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,h=s.dilationWidth,f=s.effectiveFilterHeight,p=s.effectiveFilterWidth,g=s.padInfo.top,v=s.padInfo.left,_=Hn(t,e,n);for(let S=0;S<s.batchSize;++S)for(let b=0;b<s.inChannels;++b)for(let T=0;T<s.outHeight;++T){const C=T*o-g;let A=C;for(;A<0;)A+=c;const I=Math.min(s.inHeight,f+C);for(let D=0;D<s.outWidth;++D){const F=D*l-v;let z=F;for(;z<0;)z+=h;const k=Math.min(s.inWidth,p+F);let O=Number.NEGATIVE_INFINITY,L=-1;for(let H=A;H<I;H+=c){const q=H-C;for(let K=z;K<k;K+=h){const Y=K-F,P=_.get(S,H,K,b);P>O&&(O=P,i?L=r?((S*s.inHeight+H)*s.inWidth+K)*s.inChannels+b:(H*s.inWidth+K)*s.inChannels+b:L=q*p+Y)}}a.set(L,S,T,D,b)}}return a}function b8(n,t,e,s,i,r){const a=i.strideDepth,o=i.strideHeight,l=i.strideWidth,c=i.dilationDepth,h=i.dilationHeight,f=i.dilationWidth,p=i.effectiveFilterDepth,g=i.effectiveFilterHeight,v=i.effectiveFilterWidth,_=i.padInfo.front,S=i.padInfo.top,b=i.padInfo.left,T=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,C=Hn(i.outShape,e),A=C.values,I=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],D=i.outShape[2]*i.outShape[3]*i.outShape[4],F=i.outShape[3]*i.outShape[4],z=i.outShape[4];for(let k=0;k<i.batchSize;++k){const O=k*I,L=k*s[0];for(let H=0;H<i.inChannels;++H)for(let q=0;q<i.outDepth;++q){const K=q*a-_;let Y=K;for(;Y<0;)Y+=c;const P=Math.min(i.inDepth,p+K),W=O+q*D;for(let j=0;j<i.outHeight;++j){const st=j*o-S;let ot=st;for(;ot<0;)ot+=h;const X=Math.min(i.inHeight,g+st),it=W+j*F;for(let ct=0;ct<i.outWidth;++ct){const yt=ct*l-b;let Rt=yt;for(;Rt<0;)Rt+=f;const ft=Math.min(i.inWidth,v+yt),_t=it+ct*z;let qt=T,Qt=0,se=0;for(let He=Y;He<P;He+=c){const Ae=L+He*s[1];for(let Ht=ot;Ht<X;Ht+=h){const Jt=Ae+Ht*s[2];for(let Xt=Rt;Xt<ft;Xt+=f){const ce=Jt+Xt*s[3],rt=n[ce+H];if(r==="max"&&rt>qt?qt=rt:r==="avg"&&(Qt+=rt,se++),isNaN(qt))break}if(isNaN(qt))break}if(isNaN(qt))break}const Ee=_t+H;A[Ee]=r==="avg"?Qt/Math.max(se,1):qt}}}}return C}function p0t(n,t){const e=Hn(t.outShape,"int32"),s=t.strideDepth,i=t.strideHeight,r=t.strideWidth,a=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth,p=t.padInfo.front,g=t.padInfo.top,v=t.padInfo.left;for(let _=0;_<t.batchSize;++_)for(let S=0;S<t.inChannels;++S)for(let b=0;b<t.outDepth;++b){const T=b*s-p;let C=T;for(;C<0;)C+=a;const A=Math.min(t.inDepth,c+T);for(let I=0;I<t.outHeight;++I){const D=I*i-g;let F=D;for(;F<0;)F+=o;const z=Math.min(t.inHeight,h+D);for(let k=0;k<t.outWidth;++k){const O=k*r-v;let L=O;for(;L<0;)L+=l;const H=Math.min(t.inWidth,f+O);let q=Number.NEGATIVE_INFINITY,K=-1;for(let Y=C;Y<A;Y+=a){const P=Y-T;for(let W=F;W<z;W+=o){const j=W-D;for(let st=L;st<H;st+=l){const ot=st-O,X=n.get(_,Y,W,st,S);X>=q&&(q=X,K=P*h*f+j*h+ot)}}}e.set(K,_,b,I,k,S)}}}return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;Ze(i,"avgPool");const{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=s,c=1;et(ya(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=dc(i.shape,r,a,c,o,l);let f;if(h.filterWidth===1&&h.filterHeight===1&&Is(h.inShape,h.outShape))f=vh({inputs:{x:i},backend:e});else{const p=e.data.get(i.dataId).values,g=ln(i.shape),v=i$(p,i.shape,i.dtype,g,h,"avg");f=e.makeTensorInfo(h.outShape,i.dtype,v.values)}return f}const g0t={kernelName:qC,backendName:"cpu",kernelFunc:m0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:r,strides:a,pad:o,dimRoundingMode:l,dataFormat:c}=s;Ze(i,"avgPool3d");const h=Of(i.shape,r,a,1,o,l,c),f=e.data.get(i.dataId).values,p=b8(f,i.shape,i.dtype,ln(i.shape),h,"avg");return e.makeTensorInfo(p.shape,"float32",p.values)}const x0t={kernelName:XC,backendName:"cpu",kernelFunc:y0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v0t(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r}=t,{filterSize:a,strides:o,pad:l,dimRoundingMode:c}=s;Ze([i,r],"avgPool3DGrad");const h=Of(r.shape,a,o,1,l,c),f=h.strideDepth,p=h.strideHeight,g=h.strideWidth,v=h.filterDepth,_=h.filterHeight,S=h.filterWidth,b=h.dilationDepth,T=h.dilationHeight,C=h.dilationWidth,A=h.effectiveFilterDepth,I=h.effectiveFilterHeight,D=h.effectiveFilterWidth,F=A-1-h.padInfo.front,z=D-1-h.padInfo.left,k=I-1-h.padInfo.top,O=Hn(r.shape,"float32"),L=1/(v*_*S),H=e.bufferSync(i);for(let q=0;q<h.batchSize;++q)for(let K=0;K<h.inChannels;++K)for(let Y=0;Y<h.inDepth;++Y)for(let P=0;P<h.inHeight;++P)for(let W=0;W<h.inWidth;++W){const j=Y-F,st=P-k,ot=W-z;let X=0;for(let it=0;it<A;it+=b){const ct=(j+it)/f;if(!(ct<0||ct>=h.outDepth||Math.floor(ct)!==ct))for(let yt=0;yt<I;yt+=T){const Rt=(st+yt)/p;if(!(Rt<0||Rt>=h.outHeight||Math.floor(Rt)!==Rt))for(let ft=0;ft<D;ft+=C){const _t=(ot+ft)/g;if(_t<0||_t>=h.outWidth||Math.floor(_t)!==_t)continue;const qt=H.get(q,ct,Rt,_t,K);X+=qt}}}O.set(X*L,q,Y,P,W,K)}return e.makeTensorInfo(O.shape,O.dtype,O.values)}const b0t={kernelName:P3,backendName:"cpu",kernelFunc:v0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S0t(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r}=t,a=r;Ze([i,r],"avgPoolGrad");const{filterSize:o,strides:l,pad:c}=s,h=dc(a.shape,o,l,1,c),f=h.strideHeight,p=h.strideWidth,g=h.filterHeight,v=h.filterWidth,_=h.dilationHeight,S=h.dilationWidth,b=h.effectiveFilterHeight,T=h.effectiveFilterWidth,C=T-1-h.padInfo.left,A=b-1-h.padInfo.top,I=Hn(a.shape,"float32"),D=1/(g*v),F=e.data.get(i.dataId).values,z=Hn(i.shape,"float32",F);for(let k=0;k<h.batchSize;++k)for(let O=0;O<h.inChannels;++O)for(let L=0;L<h.inHeight;++L)for(let H=0;H<h.inWidth;++H){const q=L-A,K=H-C;let Y=0;for(let P=0;P<b;P+=_){const W=(q+P)/f;if(!(W<0||W>=h.outHeight||Math.floor(W)!==W))for(let j=0;j<T;j+=S){const st=(K+j)/p;if(st<0||st>=h.outWidth||Math.floor(st)!==st)continue;const ot=z.get(k,W,st,O);Y+=ot}}I.set(Y*D,k,L,H,O)}return e.makeTensorInfo(I.shape,I.dtype,I.values)}const _0t={kernelName:B3,backendName:"cpu",kernelFunc:S0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,scale:r,offset:a,mean:o,variance:l}=t;et(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),et(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),et(r==null||o.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ze([i,o,l,r,a],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);const h=e.data.get(i.dataId).values,f=e.data.get(o.dataId).values,p=e.data.get(l.dataId).values,g=r?e.data.get(r.dataId).values:new Float32Array([1]),v=a?e.data.get(a.dataId).values:new Float32Array([0]),_=new Float32Array(h.length),S=v.length,b=g.length,T=p.length,C=f.length;let A=0,I=0,D=0,F=0;for(let z=0;z<h.length;++z)_[z]=v[A++]+(h[z]-f[I++])*g[D++]/Math.sqrt(p[F++]+c),A>=S&&(A=0),I>=C&&(I=0),D>=b&&(D=0),F>=T&&(F=0);return e.makeTensorInfo(i.shape,i.dtype,_)}const T0t={kernelName:aA,backendName:"cpu",kernelFunc:w0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:r,crops:a}=s;Ze([i],"batchToSpaceND");const o=r.reduce((b,T)=>b*T),l=f_(i.shape,r,o),c=d_(l.length,r.length),h=p_(i.shape,r,o),f=fO(a,r.length),p=dO(h,a,r.length),g=ii({inputs:{x:i},backend:e,attrs:{shape:l}}),v=Eo({inputs:{x:g},backend:e,attrs:{perm:c}}),_=ii({inputs:{x:v},backend:e,attrs:{shape:h}}),S=_g({inputs:{x:_},backend:e,attrs:{begin:f,size:p}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(_),S}const C0t={kernelName:KC,backendName:"cpu",kernelFunc:E0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:r}=t,{size:a}=s,o=e.data.get(i.dataId).values,l=e.data.get(r.dataId).values,c=JO(o,l,r.dtype,r.shape,a);return e.makeTensorInfo([a],r.dtype,c)}const N0t={kernelName:V3,backendName:"cpu",kernelFunc:A0t};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M0t(n){const{inputs:t,backend:e}=n,{s0:s,s1:i}=t,r=e.data.get(s.dataId).values,a=e.data.get(i.dataId).values,o=Rn(Array.from(r),Array.from(a));return e.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const I0t={kernelName:XV,backendName:"cpu",kernelFunc:M0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R0t=zs(bS,(n,t)=>{const e=t;return n>e.clipValueMax?e.clipValueMax:n<e.clipValueMin?e.clipValueMin:n}),D0t={kernelName:bS,backendName:"cpu",kernelFunc:R0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k0t=n=>{const{x:t}=n.inputs,e=n.backend,s=new Float32Array(Zt(t.shape)),i=e.data.get(t.dataId),r=i.complexTensorInfos.real,a=i.complexTensorInfos.imag,o=e.data.get(r.dataId).values,l=e.data.get(a.dataId).values;for(let c=0;c<o.length;c++){const h=o[c],f=l[c];s[c]=Math.hypot(h,f)}return e.makeOutput(s,t.shape,"float32")},O0t={kernelName:YC,backendName:"cpu",kernelFunc:k0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mx(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.data.get(s.dataId).complexTensorInfos.imag,r=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,r)}const $0t={kernelName:ak,backendName:"cpu",kernelFunc:mx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gx(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s,r=Wn(i,t[0].shape)[0],a=t.map(_=>_.shape);cO(a,r);let o=lh(t.map(_=>_.shape),r);if(Zt(o)===0)return e.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter(_=>Zt(_.shape)>0);if(l.length===1)return vh({inputs:{x:l[0]},backend:e});if(l[0].dtype==="complex64"){const _=l.map(A=>Sg({inputs:{input:A},backend:e})),S=l.map(A=>mx({inputs:{input:A},backend:e})),b=gx({inputs:_,backend:e,attrs:{axis:r}}),T=gx({inputs:S,backend:e,attrs:{axis:r}}),C=Ko({inputs:{real:b,imag:T},backend:e});return _.forEach(A=>e.disposeIntermediateTensorInfo(A)),S.forEach(A=>e.disposeIntermediateTensorInfo(A)),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(T),C}const c=l.map(_=>{const b=[-1,Zt(_.shape.slice(r))];return ii({inputs:{x:_},backend:e,attrs:{shape:b}})}),h=c.map(_=>({vals:e.data.get(_.dataId).values,shape:_.shape}));o=lh(c.map(_=>_.shape),1);const f=c[0].shape[0]===1,p=EW(h,o,t[0].dtype,f),g=lh(l.map(_=>_.shape),r),v=e.makeTensorInfo(g,t[0].dtype,p);return c.forEach(_=>e.disposeIntermediateTensorInfo(_)),v}const L0t={kernelName:ZC,backendName:"cpu",kernelFunc:gx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S8(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:a,pad:o,dataFormat:l,dilations:c,dimRoundingMode:h}=s;Ze([i,r],"conv2d");const f=$f(l),p=ta(i.shape,r.shape,a,c,o,h,!1,f),g=p.filterHeight,v=p.filterWidth,_=p.dilationHeight,S=p.dilationWidth,b=p.padInfo.left,T=p.padInfo.top,C=p.dataFormat==="channelsLast",A=new Qr(p.outShape,i.dtype),I=ln(i.shape),D=ln(r.shape),F=I[0],z=C?I[1]:I[2],k=C?I[2]:1,O=C?1:I[1],L=A.strides[0],H=C?A.strides[1]:A.strides[2],q=C?A.strides[2]:1,K=C?1:A.strides[1],Y=e.data.get(i.dataId).values,P=e.data.get(r.dataId).values,W=A.values;for(let j=0;j<p.batchSize;++j){const st=j*F,ot=j*L;for(let X=0;X<p.outHeight;++X){const it=ot+X*H,ct=X*p.strideHeight-T;for(let yt=0;yt<g;++yt){const Rt=ct+yt*_;if(Rt<0||Rt>=p.inHeight)continue;const ft=yt*D[0],_t=st+Rt*z;for(let qt=0;qt<p.outWidth;++qt){const Qt=it+qt*q,se=qt*p.strideWidth-b;for(let Ee=0;Ee<v;++Ee){const He=se+Ee*S;if(He<0||He>=p.inWidth)continue;const Ae=ft+Ee*D[1],Ht=_t+He*k;let Jt=Ae;for(let Xt=0;Xt<p.inChannels;++Xt){const ce=Y[Ht+Xt*O];for(let rt=0;rt<p.outChannels;++rt)W[Qt+rt*K]+=ce*P[Jt+rt];Jt+=p.outChannels}}}}}}return e.makeTensorInfo(A.shape,A.dtype,W)}const F0t={kernelName:QC,backendName:"cpu",kernelFunc:S8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:r}=t,{strides:a,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:h}=s;Ze([i,r],"conv2dBackpropFilter");const f=$f(l),p=ta(i.shape,h,a,1,o,c,!1,f),{strideHeight:g,strideWidth:v,filterHeight:_,filterWidth:S}=p,b=p.dataFormat==="channelsLast",T=new Qr(p.filterShape,"float32"),C=p.padInfo.left,A=p.padInfo.top,I=e.data.get(i.dataId).values,D=e.data.get(r.dataId).values,F=new Qr(i.shape,i.dtype,I),z=new Qr(r.shape,r.dtype,D);for(let k=0;k<_;++k){const O=Math.max(0,Math.ceil((A-k)/g)),L=Math.min(p.outHeight,(p.inHeight+A-k)/g);for(let H=0;H<S;++H){const q=Math.max(0,Math.ceil((C-H)/v)),K=Math.min(p.outWidth,(p.inWidth+C-H)/v);for(let Y=0;Y<p.inChannels;++Y)for(let P=0;P<p.outChannels;++P){let W=0;for(let j=0;j<p.batchSize;++j)for(let st=O;st<L;++st){const ot=k+st*g-A;for(let X=q;X<K;++X){const it=H+X*v-C;b?W+=F.get(j,ot,it,Y)*z.get(j,st,X,P):W+=F.get(j,Y,ot,it)*z.get(j,P,st,X)}}T.set(W,k,H,Y,P)}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}const U0t={kernelName:W3,backendName:"cpu",kernelFunc:z0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B0t(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:r}=t,{inputShape:a,strides:o,pad:l,dataFormat:c,dimRoundingMode:h}=s;Ze([i,r],"conv2dBackpropInput");const f=ln(r.shape),p=ln(i.shape);let g=$f(c);const v=ta(a,r.shape,o,1,l,h,!1,g),_=new Qr(v.inShape,"float32"),S=_.values,b=e.data.get(i.dataId).values,T=e.data.get(r.dataId).values,[C,A,I]=f,{batchSize:D,filterHeight:F,filterWidth:z,inChannels:k,inHeight:O,inWidth:L,outChannels:H,outHeight:q,outWidth:K,strideHeight:Y,strideWidth:P}=v;g=v.dataFormat;const W=F-1-v.padInfo.top,j=z-1-v.padInfo.left,st=g==="channelsLast",ot=_.strides[0],X=st?_.strides[1]:_.strides[2],it=st?_.strides[2]:1,ct=st?1:_.strides[1],yt=p[0],Rt=st?p[1]:p[2],ft=st?p[2]:1,_t=st?1:p[1];for(let qt=0;qt<D;++qt)for(let Qt=0;Qt<k;++Qt)for(let se=0;se<O;++se){const Ee=se-W,He=Math.max(0,Math.ceil(Ee/Y)),Ae=Math.min(q,(F+Ee)/Y);for(let Ht=0;Ht<L;++Ht){const Jt=Ht-j,Xt=Math.max(0,Math.ceil(Jt/P)),ce=Math.min(K,(z+Jt)/P);let rt=0;for(let he=He;he<Ae;++he){const Pe=he*Y-Ee;for(let pe=Xt;pe<ce;++pe){const nt=pe*P-Jt,G=yt*qt+Rt*he+ft*pe,vt=C*(F-1-Pe)+A*(z-1-nt)+I*Qt;for(let Vt=0;Vt<H;++Vt){const te=b[G+_t*Vt],Pt=T[vt+Vt];rt+=te*Pt}}}const Fe=ot*qt+X*se+it*Ht+ct*Qt;S[Fe]=rt}}return e.makeTensorInfo(_.shape,_.dtype,_.values)}const P0t={kernelName:JC,backendName:"cpu",kernelFunc:B0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:a,pad:o,dilations:l}=s;Ze([i,r],"conv3d");const c=mp(i.shape,r.shape,a,l,o),{filterDepth:h,filterHeight:f,filterWidth:p,dilationDepth:g,dilationHeight:v,dilationWidth:_,padInfo:S}=c,b=S.front,T=S.left,C=S.top,A=new Qr(c.outShape,i.dtype),I=e.data.get(i.dataId).values,D=e.data.get(r.dataId).values,F=A.values,z=ln(i.shape),k=ln(r.shape);for(let O=0;O<c.batchSize;++O){const L=O*z[0],H=O*A.strides[0];for(let q=0;q<c.outDepth;++q){const K=H+q*A.strides[1],Y=q*c.strideDepth-b;for(let P=0;P<h;++P){const W=Y+P*g;if(W<0||W>=c.inDepth)continue;const j=P*k[0],st=L+W*z[1];for(let ot=0;ot<c.outHeight;++ot){const X=K+ot*A.strides[2],it=ot*c.strideHeight-C;for(let ct=0;ct<f;++ct){const yt=it+ct*v;if(yt<0||yt>=c.inHeight)continue;const Rt=j+ct*k[1],ft=st+yt*z[2];for(let _t=0;_t<c.outWidth;++_t){const qt=X+_t*c.outChannels,Qt=_t*c.strideWidth-T;for(let se=0;se<p;++se){const Ee=Qt+se*_;if(Ee<0||Ee>=c.inWidth)continue;const He=Rt+se*k[2],Ae=ft+Ee*c.inChannels;let Ht=He;for(let Jt=0;Jt<c.inChannels;++Jt){const Xt=I[Ae+Jt];for(let ce=0;ce<c.outChannels;++ce)F[qt+ce]+=Xt*D[Ht+ce];Ht+=c.outChannels}}}}}}}}return e.makeTensorInfo(A.shape,A.dtype,A.values)}const G0t={kernelName:tA,backendName:"cpu",kernelFunc:V0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:r}=t,{strides:a,pad:o,filterShape:l}=s;Ze([i,r],"conv3dBackpropFilterV2");const c=ln(i.shape),h=ln(r.shape),f=mp(i.shape,l,a,1,o),p=f.strideDepth,g=f.strideHeight,v=f.strideWidth,_=f.filterDepth,S=f.filterHeight,b=f.filterWidth,T=new Qr(f.filterShape,"float32"),C=T.values,[A,I,D,F]=T.strides,z=e.data.get(r.dataId).values,[k,O,L,H]=h,q=e.data.get(i.dataId).values,[K,Y,P,W]=c,j=f.padInfo.front,st=f.padInfo.left,ot=f.padInfo.top;for(let X=0;X<_;++X){const it=Math.max(0,Math.ceil((j-X)/p)),ct=Math.min(f.outDepth,(f.inDepth+j-X)/p),yt=X*A;for(let Rt=0;Rt<S;++Rt){const ft=Math.max(0,Math.ceil((ot-Rt)/g)),_t=Math.min(f.outHeight,(f.inHeight+ot-Rt)/g),qt=Rt*I+yt;for(let Qt=0;Qt<b;++Qt){const se=Math.max(0,Math.ceil((st-Qt)/v)),Ee=Math.min(f.outWidth,(f.inWidth+st-Qt)/v),He=Qt*D+qt;for(let Ae=0;Ae<f.inChannels;++Ae){const Ht=Ae*F+He;for(let Jt=0;Jt<f.outChannels;++Jt){let Xt=0;for(let ce=0;ce<f.batchSize;++ce){const rt=ce*K,Fe=ce*k;for(let he=it;he<ct;++he){const pe=(X+he*p-j)*Y+rt,nt=he*O+Fe;for(let G=ft;G<_t;++G){const Vt=(Rt+G*g-ot)*P+pe,te=G*L+nt;for(let Pt=se;Pt<Ee;++Pt){const we=(Qt+Pt*v-st)*W+Vt,ze=Pt*H+te;Xt+=q[we+Ae]*z[ze+Jt]}}}}C[Ht+Jt]=Xt}}}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}const W0t={kernelName:q3,backendName:"cpu",kernelFunc:H0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q0t(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:r}=t,{pad:a,strides:o,inputShape:l}=s;Ze([i],"conv3dBackpropInputV2");const c=ln(i.shape),h=ln(r.shape),f=mp(l,r.shape,o,1,a),p=new Qr(f.inShape,"float32"),g=p.values,[v,_,S,b]=p.strides,T=e.data.get(i.dataId).values,[C,A,I,D]=c,F=e.data.get(r.dataId).values,[z,k,O,L]=h,{batchSize:H,filterDepth:q,filterHeight:K,filterWidth:Y,inChannels:P,inDepth:W,inHeight:j,inWidth:st,outChannels:ot,outDepth:X,outHeight:it,outWidth:ct,strideDepth:yt,strideHeight:Rt,strideWidth:ft}=f,_t=q-1-f.padInfo.front,qt=K-1-f.padInfo.top,Qt=Y-1-f.padInfo.left;for(let se=0;se<H;++se)for(let Ee=0;Ee<P;++Ee)for(let He=0;He<W;++He){const Ae=He-_t,Ht=Math.max(0,Math.ceil(Ae/yt)),Jt=Math.min(X,(q+Ae)/yt);for(let Xt=0;Xt<j;++Xt){const ce=Xt-qt,rt=Math.max(0,Math.ceil(ce/Rt)),Fe=Math.min(it,(K+ce)/Rt);for(let he=0;he<st;++he){const Pe=he-Qt,pe=Math.max(0,Math.ceil(Pe/ft)),nt=Math.min(ct,(Y+Pe)/ft);let G=0;for(let vt=Ht;vt<Jt;++vt){const Vt=vt*yt-Ae;for(let te=rt;te<Fe;++te){const Pt=te*Rt-ce;for(let Ue=pe;Ue<nt;++Ue){const we=Ue*ft-Pe,ze=C*se+A*vt+I*te+D*Ue,nn=z*(q-1-Vt)+k*(K-1-Pt)+O*(Y-1-we)+L*Ee;for(let ae=0;ae<ot;++ae){const de=T[ze+ae],Ne=F[nn+ae];G+=de*Ne}}}}g[v*se+_*He+S*Xt+b*he+Ee]=G}}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}const X0t={kernelName:X3,backendName:"cpu",kernelFunc:q0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j0t=zs(SS,n=>Math.cos(n)),K0t={kernelName:SS,backendName:"cpu",kernelFunc:j0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y0t=zs(_S,n=>Math.cosh(n)),Z0t={kernelName:_S,backendName:"cpu",kernelFunc:Y0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q0t(n){const{inputs:t,backend:e,attrs:s}=n,{image:i,boxes:r,boxInd:a}=t,{cropSize:o,method:l,extrapolationValue:c}=s,[h,f,p,g]=i.shape,v=r.shape[0],[_,S]=o,b=Hn([v,_,S,g],"float32"),T=e.data.get(r.dataId).values,C=e.data.get(a.dataId).values,A=e.data.get(i.dataId).values,I=ln(i.shape),D=ln(b.shape);for(let F=0;F<v;F++){const z=F*4,k=T[z],O=T[z+1],L=T[z+2],H=T[z+3],q=C[F];if(q>=h)continue;const K=_>1?(L-k)*(f-1)/(_-1):0,Y=S>1?(H-O)*(p-1)/(S-1):0;for(let P=0;P<_;P++){const W=_>1?k*(f-1)+P*K:.5*(k+L)*(f-1);if(W<0||W>f-1){for(let j=0;j<S;j++)for(let st=0;st<g;st++){const ot=st+j*D[2]+P*D[1]+F*D[0];b.values[ot]=c}continue}if(l==="bilinear"){const j=Math.floor(W),st=Math.ceil(W),ot=W-j;for(let X=0;X<S;X++){const it=S>1?O*(p-1)+X*Y:.5*(O+H)*(p-1);if(it<0||it>p-1){for(let ft=0;ft<g;ft++){const _t=ft+X*D[2]+P*D[1]+F*D[0];b.values[_t]=c}continue}const ct=Math.floor(it),yt=Math.ceil(it),Rt=it-ct;for(let ft=0;ft<g;ft++){let _t=ft+ct*I[2]+j*I[1]+q*I[0];const qt=A[_t];_t=ft+yt*I[2]+j*I[1]+q*I[0];const Qt=A[_t];_t=ft+ct*I[2]+st*I[1]+q*I[0];const se=A[_t];_t=ft+yt*I[2]+st*I[1]+q*I[0];const Ee=A[_t],He=qt+(Qt-qt)*Rt,Ae=se+(Ee-se)*Rt;_t=ft+X*D[2]+P*D[1]+F*D[0],b.values[_t]=He+(Ae-He)*ot}}}else for(let j=0;j<S;++j){const st=S>1?O*(p-1)+j*Y:.5*(O+H)*(p-1);if(st<0||st>p-1){for(let it=0;it<g;it++){const ct=it+j*D[2]+P*D[1]+F*D[0];b.values[ct]=c}continue}const ot=Math.round(st),X=Math.round(W);for(let it=0;it<g;it++){const ct=it+ot*I[2]+X*I[1]+q*I[0],yt=it+j*D[2]+P*D[1]+F*D[0];b.values[yt]=A[ct]}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}const J0t={kernelName:K3,backendName:"cpu",kernelFunc:Q0t};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,exclusive:a,reverse:o}=s;Ze(i,"cumprod");const l=Ti([r],i.shape.length);let c=i;l!=null&&(c=Eo({inputs:{x:i},backend:e,attrs:{perm:l}}));const h=ji(1,i.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);const f=Jo(c.dtype,"int32"),p=O3(Zt(c.shape),f),g=e.data.get(c.dataId).values,v=c.shape[c.shape.length-1],_=o?(b,T)=>b+v-T-1:(b,T)=>b+T;for(let b=0;b<g.length;b+=v)for(let T=0;T<v;T++){const C=_(b,T);if(T===0)p[C]=a?1:g[C];else{const A=_(b,T-1);p[C]=a?g[A]*p[A]:g[C]*p[A]}}const S=e.makeTensorInfo(c.shape,f,p);if(l!=null){const b=gp(l),T=Eo({inputs:{x:S},backend:e,attrs:{perm:b}});return e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(c),T}return S}const eyt={kernelName:j3,backendName:"cpu",kernelFunc:tyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,exclusive:a,reverse:o}=s;Ze(i,"cumsum");const l=Ti([r],i.shape.length);let c=i;l!=null&&(c=Eo({inputs:{x:i},backend:e,attrs:{perm:l}}));const h=ji(1,i.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);const f=Jo(c.dtype,"int32"),p=ga(Zt(c.shape),f),g=e.data.get(c.dataId).values,v=c.shape[c.shape.length-1],_=o?(b,T)=>b+v-T-1:(b,T)=>b+T;for(let b=0;b<g.length;b+=v)for(let T=0;T<v;T++){const C=_(b,T);if(T===0)p[C]=a?0:g[C];else{const A=_(b,T-1);p[C]=a?g[A]+p[A]:g[C]+p[A]}}const S=e.makeTensorInfo(c.shape,f,p);if(l!=null){const b=gp(l),T=Eo({inputs:{x:S},backend:e,attrs:{perm:b}});return e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(c),T}return S}const syt={kernelName:eA,backendName:"cpu",kernelFunc:nyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:r}=t,{size:a,binaryOutput:o}=s;if(i.shape.length===1){const l=e.data.get(i.dataId).values,c=e.data.get(r.dataId).values,h=JO(l,c,r.dtype,r.shape,a);return e.makeTensorInfo([a],r.dtype,h)}else if(i.shape.length===2){const l=e.bufferSync(i),c=e.bufferSync(r),h=_W(l,c,a,o);return e.makeTensorInfo(h.shape,r.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const ryt={kernelName:Y3,backendName:"cpu",kernelFunc:iyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ayt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockSize:r,dataFormat:a}=s;et(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const o=i.shape[0],l=i.shape[1],c=i.shape[2],h=i.shape[3],f=l*r,p=c*r,g=h/(r*r),v=e.data.get(i.dataId).values,_=new Float32Array(o*f*p*g);let S=0;for(let b=0;b<o;++b)for(let T=0;T<f;++T){const C=Math.floor(T/r),A=T%r;for(let I=0;I<p;++I){const D=Math.floor(I/r),F=I%r,z=(A*r+F)*g;for(let k=0;k<g;++k){const L=k+z+h*(D+c*(C+l*b));_[S++]=v[L]}}}return e.makeTensorInfo([o,f,p,g],i.dtype,_)}const oyt={kernelName:Z3,backendName:"cpu",kernelFunc:ayt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _8(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:a,pad:o,dilations:l,dimRoundingMode:c}=s;Ze([i,r],"depthwiseConv2DNative");const h=ln(i.shape),f=ln(r.shape);let p=l;p==null&&(p=[1,1]),et(ya(a,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);const g=ta(i.shape,r.shape,a,p,o,c,!0),{filterHeight:v,filterWidth:_,dilationHeight:S,dilationWidth:b,padInfo:T}=g,C=T.left,A=T.top,I=g.outChannels/g.inChannels,D=new Qr(g.outShape,i.dtype),F=e.data.get(i.dataId).values,z=e.data.get(r.dataId).values,k=D.values;for(let O=0;O<g.batchSize;++O){const L=O*h[0],H=O*D.strides[0];for(let q=0;q<g.outHeight;++q){const K=H+q*D.strides[1],Y=q*g.strideHeight-A;for(let P=0;P<v;++P){const W=Y+P*S;if(W<0||W>=g.inHeight)continue;const j=P*f[0],st=L+W*h[1];for(let ot=0;ot<g.outWidth;++ot){const X=K+ot*D.strides[2],it=ot*g.strideWidth-C;for(let ct=0;ct<_;++ct){const yt=it+ct*b;if(yt<0||yt>=g.inWidth)continue;const Rt=j+ct*f[1],ft=st+yt*g.inChannels;let _t=X,qt=Rt;for(let Qt=0;Qt<g.inChannels;++Qt){const se=F[ft+Qt];for(let Ee=0;Ee<I;++Ee)k[_t+Ee]+=se*z[qt+Ee];_t+=I,qt+=I}}}}}}return e.makeTensorInfo(D.shape,D.dtype,D.values)}const lyt={kernelName:nA,backendName:"cpu",kernelFunc:_8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:r}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:c,filterShape:h}=s;Ze([i,r],"depthwiseConv2dNativeBackpropFilter");const f=ta(i.shape,h,a,o,l,c,!0),{strideHeight:p,strideWidth:g,filterHeight:v,filterWidth:_}=f,S=new Qr(f.filterShape,"float32"),b=f.padInfo.left,T=f.padInfo.top,C=f.outChannels/f.inChannels,A=e.data.get(i.dataId).values,I=new Qr(i.shape,i.dtype,A),D=e.data.get(r.dataId).values,F=new Qr(r.shape,r.dtype,D);for(let z=0;z<v;++z){const k=Math.max(0,Math.ceil((T-z)/p)),O=Math.min(f.outHeight,(f.inHeight+T-z)/p);for(let L=0;L<_;++L){const H=Math.max(0,Math.ceil((b-L)/g)),q=Math.min(f.outWidth,(f.inWidth+b-L)/g);for(let K=0;K<f.outChannels;++K){const Y=Math.trunc(K/C),P=K%C;let W=0;for(let j=0;j<f.batchSize;++j)for(let st=k;st<O;++st){const ot=z+st*p-T;for(let X=H;X<q;++X){const it=L+X*g-b;W+=I.get(j,ot,it,Y)*F.get(j,st,X,K)}}S.set(W,z,L,Y,P)}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}const uyt={kernelName:Q3,backendName:"cpu",kernelFunc:cyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hyt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:r}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:c,inputShape:h}=s;Ze([i,r],"depthwiseConv2DNativeBackpropInput");const f=ln(i.shape),p=ln(r.shape),g=ta(h,r.shape,a,o,l,c,!0),v=new Qr(g.inShape,"float32"),_=v.values,[S,b,T]=v.strides,C=e.data.get(i.dataId).values,[A,I,D]=f,F=e.data.get(r.dataId).values,[z,k,O]=p,{batchSize:L,filterHeight:H,filterWidth:q,inChannels:K,inHeight:Y,inWidth:P,outChannels:W,outHeight:j,outWidth:st,strideHeight:ot,strideWidth:X}=g,it=H-1-g.padInfo.top,ct=q-1-g.padInfo.left,yt=W/K;for(let Rt=0;Rt<L;++Rt)for(let ft=0;ft<K;++ft)for(let _t=0;_t<Y;++_t){const qt=_t-it,Qt=Math.max(0,Math.ceil(qt/ot)),se=Math.min(j,(H+qt)/ot);for(let Ee=0;Ee<P;++Ee){const He=Ee-ct,Ae=Math.max(0,Math.ceil(He/X)),Ht=Math.min(st,(q+He)/X);let Jt=0;for(let Xt=Qt;Xt<se;++Xt){const ce=Xt*ot-qt;for(let rt=Ae;rt<Ht;++rt){const Fe=rt*X-He,he=A*Rt+I*Xt+D*rt,Pe=z*(H-1-ce)+k*(q-1-Fe)+O*ft;for(let pe=0;pe<yt;++pe){const nt=ft*yt+pe,G=C[he+nt],vt=F[Pe+pe];Jt+=G*vt}}}_[S*Rt+b*_t+T*Ee+ft]=Jt}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}const fyt={kernelName:J3,backendName:"cpu",kernelFunc:hyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dyt(n){const{inputs:t,backend:e}=n,{x:s}=t,i=Zt(s.shape),r=e.data.get(s.dataId).values,a=Hn([i,i],s.dtype),o=a.values;for(let c=0;c<r.length;c++)o[c*i+c]=r[c];const l=[...s.shape,...s.shape];return e.makeTensorInfo(l,a.dtype,a.values)}const pyt={kernelName:jV,backendName:"cpu",kernelFunc:dyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const myt={kernelName:sA,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:i}=n,{strides:r,pad:a,dilations:o}=e,l=t,c=l.data.get(s.dataId).values,h=s.shape.length,f=l.data.get(i.dataId).values,p=i.shape.length,{batchSize:g,inHeight:v,inWidth:_,inChannels:S,outHeight:b,outWidth:T,padInfo:C,strideHeight:A,strideWidth:I,filterHeight:D,filterWidth:F,dilationHeight:z,dilationWidth:k,outShape:O}=o_(s.shape,i.shape,r,a,"NHWC",o),L=Zt(O),H=O.length,q=Hi(s.dtype,L);for(let Y=0;Y<g;++Y)for(let P=0;P<b;++P){const W=P*A-C.top;for(let j=0;j<T;++j){const st=j*I-C.left;for(let ot=0;ot<S;++ot){let X=Number.MIN_SAFE_INTEGER;for(let ct=0;ct<D;++ct){const yt=W+ct*z;if(yt>=0&&yt<v)for(let Rt=0;Rt<F;++Rt){const ft=st+Rt*k;if(ft>=0&&ft<_){const _t=ah([Y,yt,ft,ot],h,ln(s.shape)),qt=ah([ct,Rt,ot],p,ln(i.shape)),Qt=c[_t]+f[qt];Qt>X&&(X=Qt)}}}const it=ah([Y,P,j,ot],H,ln(O));q[it]=X}}}return{dataId:l.write(zg(q,s.dtype),O,s.dtype),shape:O,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gyt={kernelName:ER,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:i,dy:r}=n,{strides:a,pad:o,dilations:l}=e,c=t,h=eu(s.shape,c.data.get(s.dataId).values),f=eu(i.shape,c.data.get(i.dataId).values),{batchSize:p,inHeight:g,inWidth:v,inChannels:_,outHeight:S,outWidth:b,padInfo:T,strideHeight:C,strideWidth:A,filterHeight:I,filterWidth:D,dilationHeight:F,dilationWidth:z,outShape:k}=o_(s.shape,i.shape,a,o,"NHWC",l);et(r.rank===k.length,()=>`Error in ${ER}, dy must have the same rank as output ${k.length}, but got ${r.rank}`);const O=eu(k,c.data.get(r.dataId).values),L=HV(i.shape,i.dtype);for(let q=0;q<p;++q)for(let K=0;K<S;++K){const Y=K*C-T.top;for(let P=0;P<b;++P){const W=P*A-T.left;for(let j=0;j<_;++j){let st=Number.MIN_SAFE_INTEGER,ot=0,X=0;for(let it=0;it<I;++it){const ct=Y+it*F;if(ct>=0&&ct<g)for(let yt=0;yt<D;++yt){const Rt=W+yt*z;if(Rt>=0&&Rt<v){const ft=h[q][ct][Rt][j]+f[it][yt][j];ft>st&&(st=ft,ot=it,X=yt)}}}L[ot][X][j]+=O[q][K][P][j]}}}return{dataId:c.write(zg(L,s.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yyt={kernelName:TR,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:i,dy:r}=n,{strides:a,pad:o,dilations:l}=e,c=t,h=eu(s.shape,c.data.get(s.dataId).values),f=eu(i.shape,c.data.get(i.dataId).values),{batchSize:p,inHeight:g,inWidth:v,inChannels:_,outHeight:S,outWidth:b,padInfo:T,strideHeight:C,strideWidth:A,filterHeight:I,filterWidth:D,dilationHeight:F,dilationWidth:z,outShape:k}=o_(s.shape,i.shape,a,o,"NHWC",l);et(r.rank===k.length,()=>`Error in ${TR}, dy must have the same rank as output ${k.length}, but got ${r.rank}`);const O=eu(k,c.data.get(r.dataId).values),L=HV(s.shape,s.dtype);for(let q=0;q<p;++q)for(let K=0;K<S;++K){const Y=K*C-T.top;for(let P=0;P<b;++P){const W=P*A-T.left;for(let j=0;j<_;++j){let st=Number.MIN_SAFE_INTEGER,ot=Y<0?0:Y,X=W<0?0:W;for(let it=0;it<I;++it){const ct=Y+it*F;if(ct>=0&&ct<g)for(let yt=0;yt<D;++yt){const Rt=W+yt*z;if(Rt>=0&&Rt<v){const ft=h[q][ct][Rt][j]+f[it][yt][j];ft>st&&(st=ft,ot=ct,X=Rt)}}}L[q][ot][X][j]+=O[q][K][P][j]}}}return{dataId:c.write(zg(L,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xyt(n){const{inputs:t,backend:e,attrs:s}=n,{image:i}=t,{canvas:r,options:a}=s,{contextOptions:o,imageOptions:l}=a||{},c=(l==null?void 0:l.alpha)||1,h=(o==null?void 0:o.contextType)||"2d";if(h!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const f=r.getContext(h,(o==null?void 0:o.contextAttributes)||{});if(f==null)throw new Error(`Could not get the context with ${h} type.`);const[p,g]=i.shape.slice(0,2),v=i.shape.length===2?1:i.shape[2],_=e.data.get(i.dataId).values,S=i.dtype==="float32"?255:1,b=new Uint8ClampedArray(g*p*4);for(let C=0;C<p*g;++C){const A=[0,0,0,255*c];for(let D=0;D<v;D++){const F=_[C*v+D];if(i.dtype==="float32"){if(F<0||F>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${F}.`)}else if(i.dtype==="int32"&&(F<0||F>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${F}.`);v===1?(A[0]=F*S,A[1]=F*S,A[2]=F*S):A[D]=F*S}const I=C*4;b[I+0]=Math.round(A[0]),b[I+1]=Math.round(A[1]),b[I+2]=Math.round(A[2]),b[I+3]=Math.round(A[3])}r.width=g,r.height=p;const T=new ImageData(b,g,p);return f.putImageData(T,0,0),i}const vyt={kernelName:Qit,backendName:"cpu",kernelFunc:xyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S_(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:a}=s;Ze(i,"sum");let o;i.dtype==="bool"?o=np({inputs:{x:i},backend:e,attrs:{dtype:"int32"}}):o=vh({inputs:{x:i},backend:e});const l=o.shape.length,c=Wn(r,o.shape),h=Ti(c,l);let f=c,p=o;h!=null&&(p=Eo({inputs:{x:o},backend:e,attrs:{perm:h}}),f=ji(f.length,l)),ea("sum",f,p.shape.length);const[g,v]=zr(p.shape,f),_=Jo(p.dtype,"int32");let S=U2(e,g,_);const b=Zt(v),T=e.data.get(S.dataId).values,C=e.data.get(p.dataId).values;for(let A=0;A<T.length;++A){const I=A*b;let D=0;for(let F=0;F<b;++F)D+=C[I+F];T[A]=D}if(a){const A=or(S.shape,c),I=S;S=ii({inputs:{x:S},backend:e,attrs:{shape:A}}),e.disposeIntermediateTensorInfo(I)}return e.disposeIntermediateTensorInfo(o),h!=null&&e.disposeIntermediateTensorInfo(p),S}const byt={kernelName:LA,backendName:"cpu",kernelFunc:S_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Syt(n){const{inputs:t,backend:e,attrs:s}=n,{equation:i}=s,r=t,{allDims:a,summedDims:o,idDims:l}=SO(i,r.length);wO(a.length,l,r);const{path:c,steps:h}=TO(o,l),f=h.length;let p=null,g=a.length;const v=[];for(let _=0;_<f;++_){for(const S of h[_]){const{permutationIndices:b,expandDims:T}=_O(g,l[S]);let C;EO(b)?C=r[S]:(C=Eo({inputs:{x:r[S]},backend:e,attrs:{perm:b}}),v.push(C));const A=C.shape.slice();for(let I=0;I<T.length;++I)A.splice(T[I],0,1);Is(C.shape,A)||(C=ii({inputs:{x:C},backend:e,attrs:{shape:A}}),v.push(C)),p===null?p=C:(p=dN({inputs:{a:C,b:p},backend:e}),v.push(p))}_<f-1&&(c[_]>=0&&(p=S_({inputs:{x:p},backend:e,attrs:{axis:c[_]-(a.length-g),keepDims:!1}}),v.push(p)),g--)}for(const _ of v)_!==p&&e.disposeIntermediateTensorInfo(_);return p}const _yt={kernelName:tk,backendName:"cpu",kernelFunc:Syt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wyt(n){const{inputs:t,backend:e}=n,{dy:s,y:i}=t;Ze([s,i],"eluGrad");const r=new Float32Array(Zt(i.shape)),a=e.data.get(i.dataId).values,o=e.data.get(s.dataId).values;for(let l=0;l<a.length;++l){const c=a[l];c>=0?r[l]=o[l]:r[l]=o[l]*(c+1)}return e.makeTensorInfo(i.shape,"float32",r)}const Tyt={kernelName:ek,backendName:"cpu",kernelFunc:wyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eyt=pO,Cyt=mO,Ayt=gO,Nyt=yO,Myt=xO,Iyt=vO,Ryt=zs(ES,n=>{const t=Math.sign(n),e=Math.abs(n),s=1/(1+Eyt*e);return t*(1-((((Iyt*s+Myt)*s+Nyt)*s+Ayt)*s+Cyt)*s*Math.exp(-e*e))}),Dyt={kernelName:ES,backendName:"cpu",kernelFunc:Ryt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V2(n){const{inputs:t,backend:e,attrs:s}=n,{input:i}=t,{dim:r}=s,a=i.shape.length,o=i.shape.slice();let l=r;return r<0&&(et(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+r+1),o.splice(l,0,1),ii({inputs:{x:i},backend:e,attrs:{shape:o}})}const kyt={kernelName:rA,backendName:"cpu",kernelFunc:V2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oyt=Yi((n,t)=>n/t),r$=_r(wS,Oyt),QR={kernelName:wS,backendName:"cpu",kernelFunc:r$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w8(n,t,e){const s=n.shape,i=s[0],r=s[1],a=e.data.get(n.dataId),o=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,c=[i,r],h=Zt(c),f=ma("float32",h),p=ma("float32",h);for(let S=0;S<i;S++){const b=_g({inputs:{x:o},backend:e,attrs:{begin:[S,0],size:[1,r]}}),T=_g({inputs:{x:l},backend:e,attrs:{begin:[S,0],size:[1,r]}}),C=Ko({inputs:{real:b,imag:T},backend:e}),{real:A,imag:I}=$yt(C,t,e),D=Cf(A,I);for(let F=0;F<r;F++){const z=bO(D,F);f[S*r+F]=z.real,p[S*r+F]=z.imag}e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(C)}const g=e.makeTensorInfo(c,"float32",f),v=e.makeTensorInfo(c,"float32",p),_=Ko({inputs:{real:g,imag:v},backend:e});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(v),_}function $yt(n,t,e){const s=Zt(n.shape),i=e.data.get(n.dataId),r=e.data.get(i.complexTensorInfos.real.dataId).values,a=e.data.get(i.complexTensorInfos.imag.dataId).values;if(Lyt(s)){const o=JR(r,a,s,t,e),l=[n.shape[0],n.shape[1]];if(t){const c=e.makeTensorInfo(l,"float32",o.real),h=e.makeTensorInfo(l,"float32",o.imag),f=e.makeTensorInfo([],"float32",pp(s,"float32")),p=vh({inputs:{x:f},backend:e}),g=QR.kernelFunc({inputs:{a:c,b:f},backend:e}),v=QR.kernelFunc({inputs:{a:h,b:p},backend:e}),_=e.data.get(g.dataId).values,S=e.data.get(v.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(v),{real:_,imag:S}}return o}else{const o=Cf(r,a),l=Fyt(o,s,t);return LH(l)}}function Lyt(n){return(n&n-1)===0}function JR(n,t,e,s,i){if(e===1)return{real:n,imag:t};const r=Cf(n,t),a=e/2,o=FH(r),l=o.real,c=o.imag,h=[l.length],f=i.makeTensorInfo(h,"float32",l),p=i.makeTensorInfo(h,"float32",c),g=Ko({inputs:{real:f,imag:p},backend:i}),v=zH(r),_=v.real,S=v.imag,b=[_.length],T=i.makeTensorInfo(b,"float32",_),C=i.makeTensorInfo(b,"float32",S),A=Ko({inputs:{real:T,imag:C},backend:i}),I=JR(l,c,a,s,i),D=I.real,F=I.imag,z=[D.length],k=i.makeTensorInfo(z,"float32",D),O=i.makeTensorInfo(z,"float32",F),L=Ko({inputs:{real:k,imag:O},backend:i}),H=JR(_,S,a,s,i),q=H.real,K=H.imag,Y=[q.length],P=i.makeTensorInfo(Y,"float32",q),W=i.makeTensorInfo(Y,"float32",K),j=Ko({inputs:{real:P,imag:W},backend:i}),st=BH(e,s),ot=[st.real.length],X=i.makeTensorInfo(ot,"float32",st.real),it=i.makeTensorInfo(ot,"float32",st.imag),ct=Ko({inputs:{real:X,imag:it},backend:i}),yt=dN({inputs:{a:ct,b:j},backend:i}),Rt=px({inputs:{a:L,b:yt},backend:i}),ft=s$({inputs:{a:L,b:yt},backend:i}),_t=Sg({inputs:{input:Rt},backend:i}),qt=Sg({inputs:{input:ft},backend:i}),Qt=mx({inputs:{input:Rt},backend:i}),se=mx({inputs:{input:ft},backend:i}),Ee=gx({inputs:[_t,qt],backend:i,attrs:{axis:0}}),He=gx({inputs:[Qt,se],backend:i,attrs:{axis:0}}),Ae=i.data.get(Ee.dataId).values,Ht=i.data.get(He.dataId).values;return i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(g),i.disposeIntermediateTensorInfo(T),i.disposeIntermediateTensorInfo(C),i.disposeIntermediateTensorInfo(A),i.disposeIntermediateTensorInfo(k),i.disposeIntermediateTensorInfo(O),i.disposeIntermediateTensorInfo(L),i.disposeIntermediateTensorInfo(P),i.disposeIntermediateTensorInfo(W),i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(X),i.disposeIntermediateTensorInfo(it),i.disposeIntermediateTensorInfo(ct),i.disposeIntermediateTensorInfo(yt),i.disposeIntermediateTensorInfo(Rt),i.disposeIntermediateTensorInfo(ft),i.disposeIntermediateTensorInfo(_t),i.disposeIntermediateTensorInfo(Qt),i.disposeIntermediateTensorInfo(qt),i.disposeIntermediateTensorInfo(se),i.disposeIntermediateTensorInfo(Ee),i.disposeIntermediateTensorInfo(He),{real:Ae,imag:Ht}}function Fyt(n,t,e){const s=new Float32Array(t*2);for(let i=0;i<t;i++){let r=0,a=0;for(let o=0;o<t;o++){const l=PH(i*o,t,e),c=bO(n,o);r+=c.real*l.real-c.imag*l.imag,a+=c.real*l.imag+c.imag*l.real}e&&(r/=t,a/=t),UH(s,r,a,i)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zyt(n){const{inputs:t,backend:e}=n,{input:s}=t,i=Zt(s.shape),r=s.shape[s.shape.length-1],a=i/r,o=ii({inputs:{x:s},backend:e,attrs:{shape:[a,r]}}),l=w8(o,!1,e),c=ii({inputs:{x:l},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}const Uyt={kernelName:nk,backendName:"cpu",kernelFunc:zyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$(n){const{backend:t,attrs:e}=n,{shape:s,value:i,dtype:r}=e,a=r||Nx(i),o=Hi(a,Zt(s));return Pyt(o,i,a),t.makeTensorInfo(s,a,o)}const Byt={kernelName:sk,backendName:"cpu",kernelFunc:a$};function Pyt(n,t,e){n.fill(t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vyt={kernelName:ik,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,i=e,r=ma(s.dtype,Zt(s.shape)),[a,o,l,c]=s.shape,h=i.data.get(s.dataId).values;for(let p=0;p<a;p++){const g=p*l*o*c;for(let v=0;v<o;v++){const _=v*(l*c);for(let S=0;S<l;S++){const b=S*c;for(let T=0;T<c;T++){const C=Math.round(l-S-1),A=g+_+b+T;let I=h[A];if(C>=0&&C<l){const D=C*c,F=g+_+D+T;I=h[F]}r[A]=I}}}}return{dataId:i.write(r,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r,bias:a,preluActivationWeights:o}=t,{strides:l,pad:c,dataFormat:h,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:v}=s;let _=S8({inputs:{x:i,filter:r},backend:e,attrs:{strides:l,pad:c,dataFormat:h,dilations:f,dimRoundingMode:p}});if(a){const S=_;if(h==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){const b=ii({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});_=px({inputs:{a:_,b},backend:e}),e.disposeIntermediateTensorInfo(b)}else _=px({inputs:{a:_,b:a},backend:e});e.disposeIntermediateTensorInfo(S)}if(g){const S=_;if(h==="NCHW"&&g==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const b=ii({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});_=P2(e,_,g,b,v),e.disposeIntermediateTensorInfo(b)}else _=P2(e,_,g,o,v);e.disposeIntermediateTensorInfo(S)}return _}const Hyt={kernelName:_2,backendName:"cpu",kernelFunc:Gyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r,bias:a,preluActivationWeights:o}=t,{strides:l,pad:c,dataFormat:h,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:v}=s;let _=_8({inputs:{x:i,filter:r},backend:e,attrs:{strides:l,pad:c,dataFormat:h,dilations:f,dimRoundingMode:p}});if(a){const S=_;_=px({inputs:{a:_,b:a},backend:e}),e.disposeIntermediateTensorInfo(S)}if(g){const S=_;_=P2(e,_,g,o,v),e.disposeIntermediateTensorInfo(S)}return _}const qyt={kernelName:dG,backendName:"cpu",kernelFunc:Wyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xyt(n){const{inputs:t,backend:e}=n,{params:s,indices:i}=t,r=Zt(s.shape),a=i.shape,o=a[a.length-1],[l,c,h,f]=sO(s,i);if(c===0)return e.makeTensorInfo(l,s.dtype,[]);const p=e.data.get(i.dataId).values,g=e.bufferSync(s),v=kW(p,g,s.dtype,c,o,h,f,s.shape,r);return e.makeTensorInfo(l,s.dtype,v.values)}const jyt={kernelName:KV,backendName:"cpu",kernelFunc:Xyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,indices:r}=t,{axis:a,batchDims:o}=s;Ze([i,r],"gatherV2");const l=Wn(a,i.shape)[0],c=e.data.get(r.dataId).values,h=i.shape[l];for(let A=0;A<c.length;++A){const I=c[A];et(I<=h-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${h-1}]`)}let f=o;o==null&&(f=0);const p=Zt(r.shape),g=AO(i,r,l,f),v=ii({inputs:{x:i},backend:e,attrs:{shape:[g.batchSize,g.outerSize,g.dimSize,g.sliceSize]}}),_=ii({inputs:{x:r},backend:e,attrs:{shape:[g.batchSize,p/g.batchSize]}}),S=[g.batchSize,g.outerSize,p/g.batchSize,g.sliceSize],b=e.bufferSync(_),T=e.bufferSync(v),C=OW(T,b,S);return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(_),e.makeTensorInfo(g.outputShape,C.dtype,C.values)}const Yyt={kernelName:oA,backendName:"cpu",kernelFunc:Kyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zyt(n){const{inputs:t,backend:e}=n,{input:s}=t,i=Zt(s.shape),r=s.shape[s.shape.length-1],a=i/r,o=ii({inputs:{x:s},backend:e,attrs:{shape:[a,r]}}),l=w8(o,!0,e),c=ii({inputs:{x:l},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}const Qyt={kernelName:rk,backendName:"cpu",kernelFunc:Zyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jyt=zs(DS,n=>Number.isFinite(n)?1:0,"bool"),txt={kernelName:DS,backendName:"cpu",kernelFunc:Jyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ext=zs(kS,n=>Math.abs(n)===1/0?1:0,"bool"),nxt={kernelName:kS,backendName:"cpu",kernelFunc:ext};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sxt=zs(OS,n=>Number.isNaN(n)?1:0,"bool"),ixt={kernelName:OS,backendName:"cpu",kernelFunc:sxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rxt(n){const{backend:t,attrs:e}=n,{start:s,stop:i,num:r}=e,a=UW(s,i,r);return t.makeTensorInfo([a.length],"float32",a)}const axt={kernelName:YV,backendName:"cpu",kernelFunc:rxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oxt=zs(LS,n=>Math.log1p(n)),lxt={kernelName:LS,backendName:"cpu",kernelFunc:oxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cxt=Yi((n,t)=>n&&t),uxt=_r(fA,cxt,null,"bool"),hxt={kernelName:fA,backendName:"cpu",kernelFunc:uxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fxt=zs(dA,n=>n?0:1,"bool"),dxt={kernelName:dA,backendName:"cpu",kernelFunc:fxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pxt=Yi((n,t)=>n||t),mxt=_r(pA,pxt,null,"bool"),gxt={kernelName:pA,backendName:"cpu",kernelFunc:mxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yxt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{depthRadius:r,bias:a,alpha:o,beta:l}=s;Ze(i,"LRN");const c=i.shape[3],h=c-1,f=e.data.get(i.dataId).values,p=Zt(i.shape),g=new Float32Array(p);function v(_){const S=_%c;let b=_-S+Math.max(0,S-r);const T=_-S+Math.min(S+r,h);let C=0;for(;b<=T;b++){const A=f[b];C+=A*A}return C}for(let _=0;_<p;_++){const S=v(_),b=f[_]*Math.pow(a+o*S,-l);g[_]=b}return e.makeTensorInfo(i.shape,i.dtype,g)}const xxt={kernelName:mA,backendName:"cpu",kernelFunc:yxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vxt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,y:r,dy:a}=t,{depthRadius:o,bias:l,alpha:c,beta:h}=s;Ze(a,"LRNGrad");const f=Zt(a.shape),p=a.shape[3],g=e.data.get(a.dataId).values,v=e.data.get(i.dataId).values,_=e.data.get(r.dataId).values,S=new Float32Array(f),b=f;for(let T=0;T<b;T++){const C=T%p,A=T-C+Math.max(0,C-o),I=T-C+Math.min(p,C+o+1);let D=0;for(let F=A;F<I;F++)D+=Math.pow(v[F],2);D=c*D+l;for(let F=A;F<I;F++){let z=-2*c*h*v[F]*_[T]/D;T===F&&(z+=Math.pow(D,-h)),z*=g[T],S[F]+=z}}return e.makeTensorInfo(a.shape,i.dtype,S)}const bxt={kernelName:ok,backendName:"cpu",kernelFunc:vxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T8(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reductionIndices:r,keepDims:a}=s,o=e;let l=i.shape;const c=l.length,h=Wn(r,l);let f=h;const p=Ti(f,c);let g=o.data.get(i.dataId).values;if(p!=null){const A=new Array(c);for(let I=0;I<A.length;I++)A[I]=l[p[I]];g=e$(g,l,i.dtype,p,A),f=ji(f.length,c),l=A}Ze(i,"max"),ea("max",f,c);const[v,_]=zr(l,f),S=Zt(_),b=PW(g,S,v,i.dtype),T=o.write(b,v,i.dtype);let C=v;return a&&(C=or(v,h)),{dataId:T,shape:C,dtype:i.dtype}}const Sxt={kernelName:gA,backendName:"cpu",kernelFunc:T8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _xt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;Ze(i,"maxPool");const{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=s,c=1;et(ya(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=dc(i.shape,r,a,c,o,l);let f;if(h.filterWidth===1&&h.filterHeight===1&&Is(h.inShape,h.outShape))f=vh({inputs:{x:i},backend:e});else{const p=e.data.get(i.dataId).values,g=ln(i.shape),v=i$(p,i.shape,i.dtype,g,h,"max");f=e.makeTensorInfo(h.outShape,i.dtype,v.values)}return f}const wxt={kernelName:yA,backendName:"cpu",kernelFunc:_xt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Txt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:r,strides:a,pad:o,dimRoundingMode:l,dataFormat:c}=s;Ze(i,"maxPool3d");const h=Of(i.shape,r,a,1,o,l,c),f=e.data.get(i.dataId).values,p=b8(f,i.shape,i.dtype,ln(i.shape),h,"max");return e.makeTensorInfo(p.shape,"float32",p.values)}const Ext={kernelName:xA,backendName:"cpu",kernelFunc:Txt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cxt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r}=t,{filterSize:a,strides:o,pad:l,dimRoundingMode:c}=s;Ze([i,r],"maxPool3DGrad");const h=Of(r.shape,a,o,1,l,c),f=e.bufferSync(r),p=p0t(f,h),g=h.strideDepth,v=h.strideHeight,_=h.strideWidth,S=h.dilationDepth,b=h.dilationHeight,T=h.dilationWidth,C=h.effectiveFilterDepth,A=h.effectiveFilterHeight,I=h.effectiveFilterWidth,D=C-1-h.padInfo.front,F=I-1-h.padInfo.left,z=A-1-h.padInfo.top,k=Hn(r.shape,"float32"),O=e.bufferSync(i);for(let L=0;L<h.batchSize;++L)for(let H=0;H<h.inChannels;++H)for(let q=0;q<h.inDepth;++q)for(let K=0;K<h.inHeight;++K)for(let Y=0;Y<h.inWidth;++Y){const P=q-D,W=K-z,j=Y-F;let st=0;for(let ot=0;ot<C;ot+=S){const X=(P+ot)/g;if(!(X<0||X>=h.outDepth||Math.floor(X)!==X))for(let it=0;it<A;it+=b){const ct=(W+it)/v;if(!(ct<0||ct>=h.outHeight||Math.floor(ct)!==ct))for(let yt=0;yt<I;yt+=T){const Rt=(j+yt)/_;if(Rt<0||Rt>=h.outWidth||Math.floor(Rt)!==Rt)continue;const ft=C*A*I-1-p.get(L,X,ct,Rt,H),_t=ot*A*I+it*I+yt,qt=ft===_t?1:0;if(qt===0)continue;const Qt=O.get(L,X,ct,Rt,H);st+=Qt*qt}}}k.set(st,L,q,K,Y,H)}return e.makeTensorInfo(k.shape,k.dtype,k.values)}const Axt={kernelName:ck,backendName:"cpu",kernelFunc:Cxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nxt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r,output:a}=t,o=r;Ze([r,a],"maxPoolGrad");const{filterSize:l,strides:c,pad:h,dimRoundingMode:f}=s,p=dc(o.shape,l,c,1,h,f),g=e.data.get(o.dataId).values,v=Hn(p.outShape,o.dtype,v8(g,o.shape,o.dtype,p).values),_=p.strideHeight,S=p.strideWidth,b=p.dilationHeight,T=p.dilationWidth,C=p.effectiveFilterHeight,A=p.effectiveFilterWidth,I=A-1-p.padInfo.left,D=C-1-p.padInfo.top,F=Hn(o.shape,"float32"),z=e.data.get(i.dataId).values,k=Hn(i.shape,"float32",z);for(let O=0;O<p.batchSize;++O)for(let L=0;L<p.inChannels;++L)for(let H=0;H<p.inHeight;++H)for(let q=0;q<p.inWidth;++q){const K=H-D,Y=q-I;let P=0;for(let W=0;W<C;W+=b){const j=(K+W)/_;if(!(j<0||j>=p.outHeight||Math.floor(j)!==j))for(let st=0;st<A;st+=T){const ot=(Y+st)/S;if(ot<0||ot>=p.outWidth||Math.floor(ot)!==ot)continue;const X=C*A-1-v.get(O,j,ot,L),it=W*A+st,ct=X===it?1:0;if(ct===0)continue;const yt=k.get(O,j,ot,L);P+=yt*ct}}F.set(P,O,H,q,L)}return e.makeTensorInfo(F.shape,F.dtype,F.values)}const Mxt={kernelName:lk,backendName:"cpu",kernelFunc:Nxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ixt(n,t,e,s,i){const r=ln(t),a=i$(n,t,e,r,i,"max"),o=v8(n,t,e,i,!0,s);return[a.values,o.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rxt={kernelName:ZV,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:i,strides:r,pad:a,includeBatchInIndex:o}=t,l=e;Ze(s,"MaxPoolWithArgmax");const c=l.data.get(s.dataId).values,h=dc(s.shape,i,r,[1,1],a),[f,p]=Ixt(c,s.shape,s.dtype,o,h),g=l.write(f,h.outShape,s.dtype),v=l.write(p,h.outShape,s.dtype);return[{dataId:g,shape:h.outShape,dtype:s.dtype},{dataId:v,shape:h.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dxt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:a}=s,o=Wn(r,i.shape),c=zr(i.shape,o)[1],h=Zt(c),f=[],p=e.makeTensorInfo([],"float32",new Float32Array([h]));f.push(p);const g=np({inputs:{x:i},backend:e,attrs:{dtype:"float32"}});f.push(g);const v=r$({inputs:{a:g,b:p},backend:e});f.push(v);const _=S_({inputs:{x:v},backend:e,attrs:{axis:r,keepDims:a}});return f.forEach(S=>e.disposeIntermediateTensorInfo(S)),_}const kxt={kernelName:vA,backendName:"cpu",kernelFunc:Dxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oxt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:a}=s;Ze(i,"min");const o=Wn(r,i.shape);let l=o;const c=Ti(l,i.shape.length);let h=i;c!=null&&(h=Eo({inputs:{x:i},backend:e,attrs:{perm:c}}),l=ji(l.length,i.shape.length)),ea("min",l,h.shape.length);const[f,p]=zr(h.shape,l),g=Zt(p),v=ga(Zt(f),h.dtype),_=e.data.get(h.dataId).values;for(let b=0;b<v.length;++b){const T=b*g;let C=_[T];for(let A=0;A<g;++A){const I=_[T+A];(Number.isNaN(I)||I<C)&&(C=I)}v[b]=C}c!=null&&e.disposeIntermediateTensorInfo(h);const S=e.makeTensorInfo(f,h.dtype,v);if(a){const b=or(f,o),T=ii({inputs:{x:S},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(S),T}return S}const $xt={kernelName:bA,backendName:"cpu",kernelFunc:Oxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lxt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{paddings:r,mode:a}=s;Ze(i,"mirrorPad");const o=r.map((C,A)=>C[0]+i.shape[A]+C[1]),l=r.map(C=>C[0]),c=r.map((C,A)=>C[0]+i.shape[A]),h=a==="reflect"?0:1,f=e.data.get(i.dataId).values,p=i.shape.length,g=ln(i.shape),v=Zt(o),_=o.length,S=ln(o),b=ma(i.dtype,v);for(let C=0;C<v;C++){let A=Mx(C,_,S);for(let D=0;D<_;D++)A[D]<l[D]?A[D]=l[D]*2-A[D]-h:A[D]>=c[D]&&(A[D]=(c[D]-1)*2-A[D]+h);A=A.map((D,F)=>D-l[F]);const I=ah(A,p,g);b[C]=f[I]}return{dataId:e.write(b,o,i.dtype),shape:o,dtype:i.dtype}}const Fxt={kernelName:SA,backendName:"cpu",kernelFunc:Lxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zxt=Yi(((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t})),Uxt=_r(US,zxt),Bxt={kernelName:US,backendName:"cpu",kernelFunc:Uxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E8(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{dim:r}=s,a=i.shape.length;let o=r;if(o===-1&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const l=Wn([o],i.shape),c=T8({inputs:{x:i},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),h=or(c.shape,l),f=ii({inputs:{x:c},backend:e,attrs:{shape:h}}),p=s$({inputs:{a:i,b:f},backend:e}),g=MW({inputs:{x:p},backend:e}),v=S_({inputs:{x:g},backend:e,attrs:{axis:l,keepDims:!1}}),_=ii({inputs:{x:v},backend:e,attrs:{shape:h}}),S=r$({inputs:{a:g,b:_},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(_),S}const Pxt={kernelName:UA,backendName:"cpu",kernelFunc:E8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vxt(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{numSamples:r,seed:a,normalized:o}=s;Ze(i,"multinomial");const l=o?i:E8({inputs:{logits:i},backend:e,attrs:{dim:-1}}),c=l.shape[0],h=l.shape[1],f=e.data.get(l.dataId).values,p=[c,r],g=ga(Zt(p),"int32");for(let v=0;v<c;++v){const _=v*h,S=new Float32Array(h-1);S[0]=f[_];for(let C=1;C<S.length;++C)S[C]=S[C-1]+f[_+C];const b=kx.alea(a.toString()),T=v*r;for(let C=0;C<r;++C){const A=b();g[T+C]=S.length;for(let I=0;I<S.length;I++)if(A<S[I]){g[T+C]=I;break}}}return o||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(p,"int32",g)}const Gxt={kernelName:QV,backendName:"cpu",kernelFunc:Vxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hxt=Qk;function Wxt(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:r}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s;Ze(i,"NonMaxSuppression");const c=e.data.get(i.dataId).values,h=e.data.get(r.dataId).values,{selectedIndices:f}=Hxt(c,h,a,o,l);return e.makeTensorInfo([f.length],"int32",new Int32Array(f))}const qxt={kernelName:uk,backendName:"cpu",kernelFunc:Wxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xxt=Jk;function jxt(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:r}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=s;Ze(i,"NonMaxSuppressionPadded");const h=e.data.get(i.dataId).values,f=e.data.get(r.dataId).values,{selectedIndices:p,validOutputs:g}=Xxt(h,f,a,o,l,c);return[e.makeTensorInfo([p.length],"int32",new Int32Array(p)),e.makeTensorInfo([],"int32",new Int32Array([g]))]}const Kxt={kernelName:hk,backendName:"cpu",kernelFunc:jxt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yxt=tO;function Zxt(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:r}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=s;Ze(i,"NonMaxSuppressionWithScore");const h=e.data.get(i.dataId).values,f=e.data.get(r.dataId).values,p=a,g=o,v=l,_=c,{selectedIndices:S,selectedScores:b}=Yxt(h,f,p,g,v,_);return[e.makeTensorInfo([S.length],"int32",new Int32Array(S)),e.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const Qxt={kernelName:fk,backendName:"cpu",kernelFunc:Zxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jxt(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i}=t,{dtype:r,depth:a,onValue:o,offValue:l}=s;Ze(i,"oneHot");const c=Zt(i.shape),h=new Float32Array(c*a);h.fill(l);const f=e.data.get(i.dataId).values;for(let p=0;p<c;++p)f[p]>=0&&f[p]<a&&(h[p*a+f[p]]=o);return e.makeTensorInfo([...i.shape,a],r,h)}const tvt={kernelName:EA,backendName:"cpu",kernelFunc:Jxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G2(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const i=Sg({inputs:{input:s},backend:e}),r=G2({inputs:{x:i},backend:e}),a=mx({inputs:{input:s},backend:e}),o=G2({inputs:{x:a},backend:e}),l=Ko({inputs:{real:r,imag:o},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),l}else return a$({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const evt={kernelName:VA,backendName:"cpu",kernelFunc:G2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C8(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const i=Sg({inputs:{input:s},backend:e}),r=C8({inputs:{x:i},backend:e}),a=mx({inputs:{input:s},backend:e}),o=G2({inputs:{x:a},backend:e}),l=Ko({inputs:{real:r,imag:o},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),l}else return a$({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const nvt={kernelName:TA,backendName:"cpu",kernelFunc:C8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A8(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s;if(t.length===1)return V2({inputs:{input:t[0]},backend:e,attrs:{dim:i}});const r=t[0].shape,a=t[0].dtype;t.forEach(h=>{k3(r,h.shape,"All tensors passed to stack must have matching shapes"),et(a===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=t.map(h=>{const f=V2({inputs:{input:h},backend:e,attrs:{dim:i}});return o.push(f),f}),c=gx({inputs:l,backend:e,attrs:{axis:i}});return o.forEach(h=>e.disposeIntermediateTensorInfo(h)),c}const svt={kernelName:CA,backendName:"cpu",kernelFunc:A8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ivt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{paddings:r,constantValue:a}=s;Ze(i,"pad");const o=r.map((T,C)=>T[0]+i.shape[C]+T[1]),l=r.map(T=>T[0]),c=e.data.get(i.dataId).values,h=Zt(i.shape),f=i.shape.length,p=ln(i.shape),g=Zt(o),v=o.length,_=ln(o),S=ma(i.dtype,g);a!==0&&S.fill(a);for(let T=0;T<h;T++){const A=Mx(T,f,p).map((D,F)=>D+l[F]),I=ah(A,v,_);S[I]=c[T]}return{dataId:e.write(S,o,i.dtype),shape:o,dtype:i.dtype}}const N8={kernelName:AA,backendName:"cpu",kernelFunc:ivt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rvt=Yi((n,t)=>Math.pow(n,t)),avt=_r(PS,rvt),ovt={kernelName:PS,backendName:"cpu",kernelFunc:avt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lvt(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:r,indices:a}=t,{outputRaggedRank:o}=s,l=i.map(b=>e.data.get(b.dataId).values),c=i.map(b=>b.shape),h=e.data.get(r.dataId).values,f=e.data.get(a.dataId).values,[p,g,v]=XW(l,c,h,r.shape,r.dtype,f,a.shape),_=p.map(b=>e.makeTensorInfo([b.length],"int32",b)),S=e.makeTensorInfo(v,r.dtype,g);return _.concat([S])}const cvt={kernelName:JV,backendName:"cpu",kernelFunc:lvt};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uvt(n){const{inputs:t,backend:e}=n,{starts:s,limits:i,deltas:r}=t,a=e.data.get(s.dataId).values,o=e.data.get(i.dataId).values,l=e.data.get(r.dataId).values,[c,h]=jW(a,s.shape,s.dtype,o,i.shape,l,r.shape),f=e.makeTensorInfo([c.length],"int32",c),p=e.makeTensorInfo([h.length],s.dtype,h);return[f,p]}const hvt={kernelName:tG,backendName:"cpu",kernelFunc:uvt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fvt(n){const{inputs:t,backend:e,attrs:s}=n,{shape:i,values:r,defaultValue:a,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=s,c=e.data.get(i.dataId).values,h=e.data.get(r.dataId).values,f=e.data.get(a.dataId).values,p=o.map(S=>e.data.get(S.dataId).values),g=o.map(S=>S.shape),[v,_]=KW(c,i.shape,h,r.shape,r.dtype,f,a.shape,p,g,l);return e.makeTensorInfo(v,r.dtype,_)}const dvt={kernelName:eG,backendName:"cpu",kernelFunc:fvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pvt(n){const{backend:t,attrs:e}=n,{start:s,stop:i,dtype:r,step:a}=e,o=YW(s,i,a,r);return t.makeTensorInfo([o.length],r,o)}const mvt={kernelName:dk,backendName:"cpu",kernelFunc:pvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gvt=zs(VS,n=>1/n),yvt={kernelName:VS,backendName:"cpu",kernelFunc:gvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xvt(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:r,halfPixelCenters:a,size:o}=s;Ze(i,"resizeBilinear");const l=ln(i.shape),[c,h]=o,[f,p,g,v]=i.shape,_=e.data.get(i.dataId).values,S=new Float32Array(Zt([f,c,h,v])),b=[r&&c>1?p-1:p,r&&h>1?g-1:g],T=[r&&c>1?c-1:c,r&&h>1?h-1:h];let C=0;const A=b[0]/T[0],I=b[1]/T[1];for(let D=0;D<f;D++)for(let F=0;F<c;F++){let z;a?z=A*(F+.5)-.5:z=A*F;const k=Math.max(0,Math.floor(z)),O=z-k,L=Math.min(p-1,Math.ceil(z)),H=D*l[0]+k*l[1],q=D*l[0]+L*l[1];for(let K=0;K<h;K++){let Y;a?Y=I*(K+.5)-.5:Y=I*K;const P=Math.max(0,Math.floor(Y)),W=Y-P,j=Math.min(g-1,Math.ceil(Y)),st=H+P*l[2],ot=q+P*l[2],X=H+j*l[2],it=q+j*l[2];for(let ct=0;ct<v;ct++){const yt=_[st+ct],Rt=_[ot+ct],ft=_[X+ct],_t=_[it+ct],qt=yt+(ft-yt)*W,Qt=Rt+(_t-Rt)*W,se=qt+(Qt-qt)*O;S[C++]=se}}}return e.makeTensorInfo([f,c,h,v],"float32",S)}const vvt={kernelName:DA,backendName:"cpu",kernelFunc:xvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bvt(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:r}=t,{alignCorners:a}=s;Ze([r,i],"resizeBilinearGrad");const o=ln(i.shape),[l,c,h,f]=i.shape,[,p,g]=r.shape,v=new Float32Array(l*c*h*f),_=[a&&p>1?c-1:c,a&&g>1?h-1:h],S=[a&&p>1?p-1:p,a&&g>1?g-1:g],b=_[0]/S[0],T=_[1]/S[1],C=e.data.get(r.dataId).values;let A=0;for(let I=0;I<l;I++){const D=I*o[0];for(let F=0;F<p;F++){const z=F*b,k=Math.floor(z),O=Math.min(Math.ceil(z),c-1),L=D+k*o[1],H=D+O*o[1],q=z-k,K=1-q;for(let Y=0;Y<g;Y++){const P=Y*T,W=Math.floor(P),j=Math.min(Math.ceil(P),h-1),st=P-W,ot=1-st,X=L+W*o[2],it=L+j*o[2],ct=H+W*o[2],yt=H+j*o[2],Rt=K*ot,ft=K*st,_t=q*ot,qt=q*st;for(let Qt=0;Qt<f;Qt++){const se=C[A++];v[X+Qt]+=se*Rt,v[it+Qt]+=se*ft,v[ct+Qt]+=se*_t,v[yt+Qt]+=se*qt}}}}return e.makeTensorInfo([l,h,c,f],"float32",v)}const Svt={kernelName:gk,backendName:"cpu",kernelFunc:bvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _vt(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:r,halfPixelCenters:a,size:o}=s;Ze(i,"resizeNearestNeighbor");const l=ln(i.shape),[c,h]=o,[f,p,g,v]=i.shape,_=e.data.get(i.dataId).values,S=new Float32Array(f*c*h*v),b=[r&&c>1?p-1:p,r&&h>1?g-1:g],T=[r&&c>1?c-1:c,r&&h>1?h-1:h],C=b[0]/T[0],A=b[1]/T[1];let I=0;for(let D=0;D<f;D++){const F=D*l[0];for(let z=0;z<c;z++){const k=a?C*(z+.5):C*z;let O=Math.min(p-1,r?Math.round(k):Math.floor(k));a&&(O=Math.max(0,O));const L=F+O*l[1];for(let H=0;H<h;H++){const q=a?A*(H+.5):A*H;let K=Math.min(g-1,r?Math.round(q):Math.floor(q));a&&(K=Math.max(0,K));const Y=L+K*l[2];for(let P=0;P<v;P++){const W=_[Y+P];S[I++]=W}}}}return e.makeTensorInfo([f,c,h,v],i.dtype,S)}const wvt={kernelName:RA,backendName:"cpu",kernelFunc:_vt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tvt(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:r}=t,{alignCorners:a}=s;Ze([r,i],"resizeNearestNeighborGrad");const o=ln(i.shape),l=ln(r.shape),[c,h,f,p]=i.shape,[,g,v]=r.shape,_=new Float32Array(c*h*f*p),S=e.data.get(r.dataId).values,b=[a&&g>1?h-1:h,a&&v>1?f-1:f],T=[a&&g>1?g-1:g,a&&v>1?v-1:v],C=b[0]/T[0],A=b[1]/T[1],I=1/C,D=1/A,F=Math.ceil(I)*2+2,z=Math.ceil(D)*2+2;for(let k=0;k<c;k++){const O=k*o[0];for(let L=0;L<h;L++){const H=O+L*o[1],q=Math.floor(L*I),K=Math.floor(q-F/2);for(let Y=0;Y<f;Y++){const P=H+Y*o[2],W=Math.floor(Y*D),j=Math.floor(W-z/2);for(let st=0;st<p;st++){let ot=0;for(let X=0;X<F;X++){const it=X+K;if(it<0||it>=g)continue;const ct=O+it*l[1],yt=it*C,Rt=Math.min(h-1,a?Math.round(yt):Math.floor(yt));if(L===Rt)for(let ft=0;ft<z;ft++){const _t=ft+j;if(_t<0||_t>=v)continue;const qt=ct+_t*l[2],Qt=_t*A,se=Math.min(f-1,a?Math.round(Qt):Math.floor(Qt));Y===se&&(ot+=S[qt+st])}}_[P+st]=ot}}}}return e.makeTensorInfo(i.shape,i.dtype,_)}const Evt={kernelName:mk,backendName:"cpu",kernelFunc:Tvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cvt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dims:r}=s;Ze(i,"reverse");const a=i.shape.length,o=Wn(r,i.shape);if(a===0)return vh({inputs:{x:i},backend:e});const l=new Qr(i.shape,i.dtype),c=e.bufferSync(i);for(let h=0;h<l.size;h++){const f=l.indexToLoc(h),p=f.slice();o.forEach(g=>p[g]=i.shape[g]-1-p[g]),l.set(c.get(...p),...f)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}const Avt={kernelName:kA,backendName:"cpu",kernelFunc:Cvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nvt={kernelName:wk,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:i,fillValue:r,center:a}=t,o=e,l=ma(s.dtype,Zt(s.shape)),[c,h,f,p]=s.shape,[g,v]=hO(a,h,f),_=255,S=Math.sin(i),b=Math.cos(i),T=o.data.get(s.dataId).values;for(let A=0;A<c;A++){const I=A*f*h*p;for(let D=0;D<h;D++){const F=D*(f*p);for(let z=0;z<f;z++){const k=z*p;for(let O=0;O<p;O++){const L=[c,D,z,O],H=L[2],q=L[1];let K=(H-g)*b-(q-v)*S,Y=(H-g)*S+(q-v)*b;K=Math.round(K+g),Y=Math.round(Y+v);let P=r;if(typeof r!="number"&&(O===3?P=_:P=r[O]),K>=0&&K<f&&Y>=0&&Y<h){const j=Y*(f*p),st=K*p,ot=I+j+st+O;P=T[ot]}const W=I+F+k+O;l[W]=P}}}}return{dataId:o.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mvt=zs(WS,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2===0?t:t+1}),Ivt={kernelName:WS,backendName:"cpu",kernelFunc:Mvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rvt(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i,updates:r}=t,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:c,strides:h,outputSize:f}=Vg(r,i,a),p=!0,g=e.bufferSync(i),v=e.bufferSync(r),_=Xm(g,v,a,f,c,l,o,h,0,p);return e.makeTensorInfo(a,_.dtype,_.values)}const Dvt={kernelName:nG,backendName:"cpu",kernelFunc:Rvt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kvt(n,t){let e=0,s=n.length,i=0;for(;e<s;)i=Math.floor((e+s)/2),n[i]<t?e=i+1:s=i;return s}function Ovt(n,t){let e=0,s=n.length,i=0;for(;e<s;)i=Math.floor((e+s)/2),n[i]<=t?e=i+1:s=i;return s}function $vt(n,t,e,s,i,r){const a=Hi("int32",e*i);for(let o=0;o<e;++o){const l=n.slice(o*s,(o+1)*s),c=o*i;for(let h=0;h<i;++h)a[c+h]=r==="left"?kvt(l,t[h+c]):Ovt(l,t[h+c])}return a}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lvt(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:i,values:r}=t,{side:a}=s,o=e.data.get(i.dataId).values,l=e.data.get(r.dataId).values,c=$vt(o,l,i.shape[0],i.shape[1],r.shape[1],a);return e.makeTensorInfo(r.shape,"int32",c)}const Fvt={kernelName:iG,backendName:"cpu",kernelFunc:Lvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zvt(n){const{inputs:t,backend:e}=n,{condition:s,t:i,e:r}=t;Ze([s,i,r],"select");const a=s.shape.length,o=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,c=e.data.get(r.dataId).values,h=Jo(i.dtype,r.dtype),f=ga(Zt(i.shape),h);let p=0;const g=a===0||a>1||i.shape.length===1?1:Zt(i.shape.slice(1));for(let v=0;v<o.length;v++)for(let _=0;_<g;_++)o[v]===1?f[p++]=l[v]:f[p++]=c[v];return e.makeTensorInfo(i.shape,h,f)}const Uvt={kernelName:OA,backendName:"cpu",kernelFunc:zvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bvt=tN,Pvt=eN,Vvt=zs(XS,n=>n>=0?Pvt*n:Bvt*(Math.exp(n)-1)),Gvt={kernelName:XS,backendName:"cpu",kernelFunc:Vvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hvt=zs(YS,n=>n<0?-1:n>0?1:0),Wvt={kernelName:YS,backendName:"cpu",kernelFunc:Hvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qvt=zs(jS,n=>Math.sin(n)),Xvt={kernelName:jS,backendName:"cpu",kernelFunc:qvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jvt=zs(KS,n=>Math.sinh(n)),Kvt={kernelName:KS,backendName:"cpu",kernelFunc:jvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yvt=11920928955078125e-23,cB=Math.log(Yvt)+2,Zvt=zs(QS,n=>{const t=n>-cB,e=n<cB,s=Math.exp(n);let i;return e?i=s:t?i=n:i=Math.log(1+s),i}),Qvt={kernelName:QS,backendName:"cpu",kernelFunc:Zvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jvt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:r,paddings:a}=s;Ze([i],"spaceToBatchND");const o=Zt(r),l=[[0,0]];l.push(...a);for(let D=1+r.length;D<i.shape.length;++D)l.push([0,0]);const c=N8.kernelFunc({inputs:{x:i},backend:e,attrs:{paddings:l,constantValue:0}}),h=f_(c.shape,r,o,!1),f=d_(h.length,r.length,!1),p=p_(c.shape,r,o,!1),_=ii({inputs:{x:c},backend:e,attrs:{shape:h}}),T=Eo({inputs:{x:_},backend:e,attrs:{perm:f}}),I=ii({inputs:{x:T},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(T),I}const tbt={kernelName:FA,backendName:"cpu",kernelFunc:Jvt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ebt(n){const{inputs:t,backend:e}=n,{indices:s,values:i,denseShape:r,defaultValue:a}=t;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${r.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,c=e.data.get(r.dataId).values,h=e.data.get(a.dataId).values[0],[f,p,g,v,_]=t8(o,s.shape,s.dtype,l,i.dtype,c,h);return[e.makeTensorInfo(p,s.dtype,f),e.makeTensorInfo([p[0]],i.dtype,g),e.makeTensorInfo([v.length],"bool",new Uint8Array(v.map(S=>Number(S)))),e.makeTensorInfo([_.length],s.dtype,new Int32Array(_))]}const nbt={kernelName:rG,backendName:"cpu",kernelFunc:ebt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sbt(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:i,newShape:r}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const a=Array.from(e.data.get(i.dataId).values),o=e.data.get(s.dataId).values,l=Array.from(e.data.get(r.dataId).values),[c,h,f]=e8(o,s.shape,s.dtype,a,l);return[e.makeTensorInfo(h,s.dtype,c),e.makeTensorInfo([f.length],r.dtype,new Int32Array(f))]}const ibt={kernelName:aG,backendName:"cpu",kernelFunc:sbt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rbt(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:r}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const a=e.data.get(s.dataId).values,o=e.data.get(i.dataId).values,l=e.data.get(r.dataId).values,[c,h]=n$(a,s.shape,s.dtype,o,l,!0);return e.makeTensorInfo(h,s.dtype,c)}const abt={kernelName:oG,backendName:"cpu",kernelFunc:rbt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function obt(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:r}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const a=e.data.get(s.dataId).values,o=e.data.get(i.dataId).values,l=e.data.get(r.dataId).values,[c,h]=n$(a,s.shape,s.dtype,o,l);return e.makeTensorInfo(h,s.dtype,c)}const lbt={kernelName:lG,backendName:"cpu",kernelFunc:obt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cbt(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:a}=t,{outputShape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:f,outputSize:p}=Vg(r,i,o),g=!1,v=e.bufferSync(i);let _;switch(r.dtype){case"bool":{const S=e.bufferSync(r),b=!!e.data.get(a.dataId).values[0];_=Xm(v,S,o,p,h,c,l,f,b,g);break}case"float32":{const S=e.bufferSync(r),b=e.data.get(a.dataId).values[0];_=Xm(v,S,o,p,h,c,l,f,b,g);break}case"int32":{const S=e.bufferSync(r),b=e.data.get(a.dataId).values[0];_=Xm(v,S,o,p,h,c,l,f,b,g);break}case"string":{const S=e.bufferSync(r),b=Yd(e.data.get(a.dataId).values[0]);_=Xm(v,S,o,p,h,c,l,f,b,g);break}default:throw new Error(`Unsupported type ${r.dtype}`)}return e.makeTensorInfo(o,_.dtype,_.values)}const ubt={kernelName:cG,backendName:"cpu",kernelFunc:cbt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hbt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{numOrSizeSplits:r,axis:a}=s,o=Wn(a,i.shape)[0],l=CO(i,r,o),c=new Array(i.shape.length).fill(0),h=i.shape.slice();return l.map(f=>{const p=[...h];p[o]=f;const g=_g({inputs:{x:i},backend:e,attrs:{begin:c,size:p}});return c[o]+=f,g})}const fbt={kernelName:zA,backendName:"cpu",kernelFunc:hbt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dbt={kernelName:yk,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t;Ze(e,"square");const i=s.data.get(e.dataId).values,r=new Float32Array(i.length);for(let o=0;o<i.length;++o){const l=i[o];r[o]=l*l}return{dataId:s.write(r,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pbt=zs(r_,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),mbt={kernelName:r_,backendName:"cpu",kernelFunc:pbt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gbt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:r,end:a,strides:o,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:f,shrinkAxisMask:p}=s;Ze(i,"stridedSlice");const{finalShapeSparse:g,finalShape:v,isIdentity:_,sliceDim0:S,isSimpleSlice:b,begin:T,end:C,strides:A}=lO(i.shape,r,a,o,l,c,h,f,p);let I;if(_)I=ii({inputs:{x:i},backend:e,attrs:{shape:v}});else if(S||b){et(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const D=rO(T,C,A),F=_g({inputs:{x:i},backend:e,attrs:{begin:T,size:D}});I=ii({inputs:{x:F},backend:e,attrs:{shape:v}}),e.disposeIntermediateTensorInfo(F)}else{const D=e.bufferSync(i),F=i8(g,D,A,T);I=e.makeTensorInfo(v,F.dtype,F.values)}return I}const ybt={kernelName:vk,backendName:"cpu",kernelFunc:gbt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xbt(n){const{inputs:t,backend:e,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:c}=s,{data:h,dataSplits:f}=t,p=e.data.get(h.dataId).values,g=e.data.get(f.dataId).values,[v,_]=r8(p,g,i,r,a,o,l,c);return[e.makeTensorInfo([v.length],"string",v),e.makeTensorInfo(f.shape,"int32",_)]}const vbt={kernelName:uG,backendName:"cpu",kernelFunc:xbt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bbt(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:i}=s,{input:r,delimiter:a}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=e.data.get(r.dataId).values,l=e.data.get(a.dataId).values[0],[c,h,f]=a8(o,l,i),p=h.length;return[e.makeTensorInfo([p,2],"int32",c),e.makeTensorInfo([p],"string",h),e.makeTensorInfo([2],"int32",new Int32Array(f))]}const Sbt={kernelName:hG,backendName:"cpu",kernelFunc:bbt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _bt(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:i}=s,{input:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=e.data.get(r.dataId).values,o=o8(a,i);return e.makeTensorInfo(r.shape,"int32",o)}const wbt={kernelName:fG,backendName:"cpu",kernelFunc:_bt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tbt=zs(n_,n=>Math.tan(n)),Ebt={kernelName:n_,backendName:"cpu",kernelFunc:Tbt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cbt=zs(s_,n=>Math.tanh(n)),Abt={kernelName:s_,backendName:"cpu",kernelFunc:Cbt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nbt(n){const{inputs:t,backend:e}=n,{tensor:s,indices:i,updates:r}=t,{sliceRank:a,numUpdates:o,sliceSize:l,strides:c,outputSize:h}=Vg(r,i,s.shape),f=!1,p=e.bufferSync(i),g=e.bufferSync(r),v=e.bufferSync(s),_=Xm(p,g,s.shape,h,l,o,a,c,v,f);return e.makeTensorInfo(s.shape,_.dtype,_.values)}const Mbt={kernelName:sG,backendName:"cpu",kernelFunc:Nbt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ibt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reps:r}=s;Ze(i,"tile");const a=c8(e.bufferSync(i),r);return e.makeTensorInfo(a.shape,a.dtype,a.values)}const Rbt={kernelName:i_,backendName:"cpu",kernelFunc:Ibt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dbt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{k:r,sorted:a}=s;Ze(i,"topk");const o=e.data.get(i.dataId).values,[l,c]=h8(o,i.shape,i.dtype,r,a);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}const kbt={kernelName:bk,backendName:"cpu",kernelFunc:Dbt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Obt(n){const{inputs:t,attrs:e,backend:s}=n,{image:i,transforms:r}=t,{interpolation:a,fillMode:o,fillValue:l,outputShape:c}=e,[h,f,p,g]=i.shape,[v,_]=c??[f,p],S=[h,v,_,g],b=ln(i.shape),T=b[0],C=b[1],A=b[2],I=ln(S),D=I[0],F=I[1],z=I[2],k=ma(i.dtype,Zt(S));k.fill(l);const O=s.data.get(i.dataId).values,L=s.data.get(r.dataId).values;for(let q=0;q<h;++q){const K=r.shape[0]===1?L:L.subarray(q*8,q*8+8);for(let Y=0;Y<v;++Y)for(let P=0;P<_;++P)for(let W=0;W<g;++W){let j;const st=K[6]*P+K[7]*Y+1;if(st===0)continue;const ot=(K[0]*P+K[1]*Y+K[2])/st,X=(K[3]*P+K[4]*Y+K[5])/st,it=uB(ot,p,o),ct=uB(X,f,o);switch(a){case"nearest":j=Bbt(O,f,p,T,C,A,q,ct,it,W,l);break;case"bilinear":j=Pbt(O,f,p,T,C,A,q,ct,it,W,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}const yt=q*D+Y*F+P*z+W;k[yt]=j}return s.makeTensorInfo(S,i.dtype,k)}return{dataId:s.write(k,S,i.dtype),shape:i.shape,dtype:i.dtype}}const $bt={kernelName:Sk,backendName:"cpu",kernelFunc:Obt};function uB(n,t,e){switch(e){case"reflect":return Lbt(n,t);case"wrap":return Fbt(n,t);case"nearest":return Ubt(n,t);case"constant":default:return zbt(n)}}function Lbt(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=2*t;e<s&&(e=s*Math.trunc(-e/s)+e),e=e<-t?e+s:-e-1}else if(e>t-1)if(t<=1)e=0;else{const s=2*t;e-=s*Math.trunc(e/s),e>=t&&(e=s-e-1)}return hg(0,e,t-1)}function Fbt(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=t-1;e+=t*(Math.trunc(-e/s)+1)}else if(e>t-1)if(t<=1)e=0;else{const s=t-1;e-=t*Math.trunc(e/s)}return hg(0,e,t-1)}function zbt(n,t){return n}function Ubt(n,t){return hg(0,n,t-1)}function Xb(n,t,e,s,i,r,a,o,l,c,h){const f=a*s+o*i+l*r+c;return 0<=o&&o<t&&0<=l&&l<e?n[f]:h}function Bbt(n,t,e,s,i,r,a,o,l,c,h){const f=Math.round(o),p=Math.round(l);return Xb(n,t,e,s,i,r,a,f,p,c,h)}function Pbt(n,t,e,s,i,r,a,o,l,c,h){const f=Math.floor(o),p=Math.floor(l),g=f+1,v=p+1,_=(v-l)*Xb(n,t,e,s,i,r,a,f,p,c,h)+(l-p)*Xb(n,t,e,s,i,r,a,f,v,c,h),S=(v-l)*Xb(n,t,e,s,i,r,a,g,p,c,h)+(l-p)*Xb(n,t,e,s,i,r,a,g,v,c,h);return(g-o)*_+(o-f)*S}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vbt(n){const{inputs:t,attrs:e,backend:s}=n,{axis:i}=e,{x:r}=t;Ze(r,"unique");const a=s.data.get(r.dataId).values,{outputValues:o,outputShape:l,indices:c}=f8(a,i,r.shape,r.dtype);return[s.makeTensorInfo(l,r.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}const Gbt={kernelName:_k,backendName:"cpu",kernelFunc:Vbt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hbt(n){const{inputs:t,backend:e,attrs:s}=n,{value:i}=t;let{axis:r}=s;r<0&&(r+=i.shape.length);const a=i.shape.length,o=i.shape[r],l=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==r&&(l[c++]=i.shape[g]);const h=new Array(a).fill(0),f=i.shape.slice();f[r]=1;const p=new Array(o);for(let g=0;g<p.length;g++){h[r]=g;const v=_g({inputs:{x:i},backend:e,attrs:{begin:h,size:f}});p[g]=ii({inputs:{x:v},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(v)}return p}const Wbt={kernelName:BA,backendName:"cpu",kernelFunc:Hbt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qbt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,segmentIds:r}=t,{numSegments:a}=s;Ze(i,"unsortedSegmentSum");const o=i.shape.length,l=r.shape.length,c=[],h=[],f=o-l;let p=r;for(let v=0;v<f;++v){const _=V2({inputs:{input:p},backend:e,attrs:{dim:v+1}});p=_,h.push(_)}for(let v=0;v<a;++v){const _=pp(v,"int32"),S=e.makeTensorInfo([],"int32",_),b=AW({inputs:{a:S,b:p},backend:e}),T=np({inputs:{x:b},backend:e,attrs:{dtype:"float32"}}),C=dN({inputs:{a:T,b:i},backend:e}),A=S_({inputs:{x:C},backend:e,attrs:{axis:0,keepDims:!1}});c.push(A),h.push(S),h.push(b),h.push(T),h.push(C),h.push(A)}const g=A8({inputs:c,backend:e,attrs:{axis:0}});return h.forEach(v=>e.disposeIntermediateTensorInfo(v)),g}const Xbt={kernelName:PA,backendName:"cpu",kernelFunc:qbt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jbt=[Vgt,_mt,Hgt,qgt,Nmt,jgt,Ygt,Qgt,t0t,n0t,i0t,a0t,l0t,h0t,d0t,g0t,x0t,b0t,_0t,Bgt,T0t,C0t,N0t,Imt,I0t,Cmt,Dmt,D0t,wmt,O0t,L0t,F0t,U0t,P0t,G0t,W0t,X0t,K0t,Z0t,J0t,eyt,syt,ryt,oyt,lyt,uyt,fyt,pyt,myt,gyt,yyt,vyt,_yt,kgt,Tyt,kmt,Dyt,Omt,kyt,Lmt,Uyt,Byt,Vyt,zmt,Bmt,Hyt,qyt,jyt,Yyt,Vmt,Hmt,Tmt,Qyt,$0t,txt,nxt,ixt,Ogt,qmt,jmt,axt,Ymt,lxt,hxt,dxt,gxt,xxt,bxt,Sxt,Qmt,wxt,Ext,Axt,Mxt,Rxt,kxt,$xt,tgt,Fxt,Bxt,Gxt,ngt,igt,qxt,Kxt,Qxt,agt,tvt,nvt,svt,N8,ovt,Lgt,cgt,cvt,hvt,dvt,mvt,Emt,QR,yvt,Fgt,zgt,Ugt,vvt,Svt,wvt,Evt,Avt,Nvt,Ivt,ygt,Dvt,Fvt,Uvt,Gvt,vgt,Wvt,Xvt,Kvt,bgt,Pxt,Qvt,tbt,nbt,ibt,abt,lbt,ubt,fbt,wgt,dbt,Egt,Agt,mbt,ybt,vbt,Sbt,wbt,Rgt,byt,Ebt,Abt,Mbt,Rbt,kbt,$bt,ogt,Gbt,Wbt,Xbt,evt];for(const n of jbt)pG(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Um={},XT={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Kbt(n,t){Um[n]=t}function lu(n,t){if(!(n in Um)||t!=null){const s=Zbt(n,t);if(s!==null)Um[n]=s;else return console.log("Could not get context for WebGL version",n),null}const e=Um[n];return e==null||e.isContextLost()?(delete Um[n],lu(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Um[n])}function Ybt(n){if(!Bt().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Zbt(n,t){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??Ybt(n);return e.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Um[n]},!1),Bt().getBool("SOFTWARE_WEBGL_ENABLED")&&(XT.failIfMajorPerformanceCaveat=!1),n===1?e.getContext("webgl",XT)||e.getContext("experimental-webgl",XT):e.getContext("webgl2",XT)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var B1;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(B1||(B1={}));var wl;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(wl||(wl={}));var Yr;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Yr||(Yr={}));function __(n,t){return[t,n]}function Qbt(n,t){return n*t}function jT(n){const t=Zt(n),e=Math.ceil(t/4);return bR(e)}function zx(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function Jbt(n,t){const[e,s]=zx(n,t);return e*s*4}function o$(n,t){const e=n;let s,i,r,a,o,l,c,h,f,p;return Bt().getNumber("WEBGL_VERSION")===2?(s=e.R32F,i=e.R16F,r=e.RGBA16F,a=e.RGBA32F,o=e.RED,c=4,h=1,f=e.HALF_FLOAT,p=e.FLOAT,l=e.RGBA8):(s=n.RGBA,i=n.RGBA,r=n.RGBA,a=e.RGBA,o=n.RGBA,c=4,h=4,f=t!=null?t.HALF_FLOAT_OES:null,p=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:h,textureTypeHalfFloat:f,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Be(n,t){const e=t();return Bt().getBool("DEBUG")&&t1t(n),e}function t1t(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+i1t(n,t))}const e1t=596e-10,n1t=65504;function s1t(n){return!!(Bt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||e1t<Math.abs(n)&&Math.abs(n)<n1t)}function i1t(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function KT(n,t){return Lf(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function r1t(n,t){const e=Lf(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Be(n,()=>n.shaderSource(e,t)),Be(n,()=>n.compileShader(e)),n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function a1t(n,t){const e=Lf(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Be(n,()=>n.shaderSource(e,t)),Be(n,()=>n.compileShader(e)),Bt().get("ENGINE_COMPILE_ONLY"))return e;if(n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw M8(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}const o1t=/ERROR: [0-9]+:([0-9]+):/g;function M8(n,t){const e=o1t.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(n);return}const s=+e[1],i=n.split(`
`),r=i.length.toString().length+2,a=i.map((f,p)=>Gy((p+1).toString(),r)+f);let o=0;for(let f=0;f<a.length;f++)o=Math.max(a[f].length,o);const l=a.slice(0,s-1),c=a.slice(s-1,s),h=a.slice(s);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${Gy(c[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join(`
`))}function l1t(n){return Lf(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function c1t(n,t){if(Be(n,()=>n.linkProgram(t)),!Bt().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(t,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function LI(n,t){if(Be(n,()=>n.validateProgram(t)),n.getProgramParameter(t,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function u1t(n,t){const e=Lf(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Be(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),Be(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function h1t(n,t){const e=Lf(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Be(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),Be(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function f1t(n){return Lf(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function d1t(n,t){const e=Bt().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0){const s=`[${n}x${t}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>e||t>e){const s=`[${n}x${t}]`,i=`[${e}x${e}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+i+".")}}function p1t(n){return Lf(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function hB(n,t,e,s,i,r,a){const o=n.getAttribLocation(t,e);return o===-1?!1:(Be(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),Be(n,()=>n.vertexAttribPointer(o,i,n.FLOAT,!1,r,a)),Be(n,()=>n.enableVertexAttribArray(o)),!0)}function m1t(n,t,e){b1t(n,e),Be(n,()=>n.activeTexture(n.TEXTURE0+e)),Be(n,()=>n.bindTexture(n.TEXTURE_2D,t))}function g1t(n,t,e){return Lf(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function y1t(n,t,e){return n.getUniformLocation(t,e)}function x1t(n,t,e,s){Be(n,()=>m1t(n,t,s)),Be(n,()=>n.uniform1i(e,s))}function FI(n,t,e){Be(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Be(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function fB(n,t){Be(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Be(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function YT(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+v1t(n,t))}function v1t(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Lf(n,t,e){const s=Be(n,()=>t());if(s==null)throw new Error(e);return s}function b1t(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+n.TEXTURE0;if(s<n.TEXTURE0||s>e){const i=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${i}.`)}}function yx(n,t=2){return Zt(n.slice(0,n.length-t))}function xx(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function ZT(n){let t=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(t=[yx(n),...xx(n)]),t}function S1t(n,t=!1){let e=Bt().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=Bt().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&Bt().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=e/2),t&&(e=e*2,s=s*2,n=n.map((o,l)=>l>=n.length-2?D3(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=dp(n).newShape);let i=Zt(n),r=null;n.length<=1&&i<=e?r=[1,i]:n.length===2&&n[0]<=e&&n[1]<=e?r=n:n.length===3&&n[0]*n[1]<=e&&n[2]<=e?r=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=e&&n[1]*n[2]<=e?r=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=e&&n[3]<=e?r=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(r=[n[0],n[1]*n[2]*n[3]]);const a=r!=null&&Math.max(...r)>s&&Math.min(...r)<=(t?2:1)&&Math.min(...r)>0;if(r==null||a)if(t){const o=yx(n);let l=2,c=2;n.length&&([l,c]=xx(n)),i=o*(l/2)*(c/2),r=bR(i).map(h=>h*2)}else r=bR(i);return r}function QT(n){return n%2===0}function H2(n,t){if(n=n.slice(-2),t=t.slice(-2),Is(n,t)||!n.length||!t.length||n[0]===0||n[1]===0||t[0]===0||t[1]===0)return!0;if(n.length!==t.length){const e=n[n.length-1],s=t[t.length-1];if(e===s||QT(e)&&QT(s)&&(n[0]===1||t[0]===1))return!0}return n[1]===t[1]&&QT(n[0])&&QT(t[0])}let zI,UI;function _1t(n){if(zI==null){const t=lu(n);zI=t.getParameter(t.MAX_TEXTURE_SIZE)}return zI}function w1t(n){if(UI==null){const t=lu(n);UI=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,UI)}function T1t(n){if(n===0)return 0;let t;const e=lu(n);return lc(e,"EXT_disjoint_timer_query_webgl2")&&n===2?t=2:lc(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function lc(n,t){return n.getExtension(t)!=null}function dB(n){try{if(lu(n)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function E1t(n){if(n===0)return!1;const t=lu(n);if(n===1){if(!lc(t,"OES_texture_float"))return!1}else if(!lc(t,"EXT_color_buffer_float"))return!1;return tD(t)}function C1t(n){if(n===0)return!1;const t=lu(n);if(n===1){if(!lc(t,"OES_texture_float")||!lc(t,"WEBGL_color_buffer_float"))return!1}else{if(lc(t,"EXT_color_buffer_float"))return tD(t);const s="EXT_color_buffer_half_float";if(lc(t,s)){const i=t.getExtension(s);return A1t(t,i)}return!1}return tD(t)}function tD(n){const t=o$(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,r),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(r),a}function A1t(n,t){const e=o$(n,t),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(a),o}function N1t(n){return n!==2?!1:lu(n).fenceSync!=null}function w_(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&et(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qe=Bt();Qe.registerFlag("HAS_WEBGL",()=>Qe.getNumber("WEBGL_VERSION")>0);Qe.registerFlag("WEBGL_VERSION",()=>dB(2)?2:dB(1)?1:0);Qe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Qe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Qe.get("WEBGL_VERSION")===2);Qe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Qe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Qe.registerFlag("WEBGL_PACK",()=>Qe.getBool("HAS_WEBGL"));Qe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_CLIP",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_REDUCE",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_LAZILY_UNPACK",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_CONV_IM2COL",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>_1t(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>w1t(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Qe.getNumber("WEBGL_VERSION");return n===0?0:T1t(n)});Qe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Qe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!AG());Qe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>E1t(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Qe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Qe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Qe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>C1t(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>N1t(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Qe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Qe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Qe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>AG()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Qe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Qe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Qe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Qe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Qe.registerFlag("WEBGL_EXP_CONV",()=>!1);Qe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Qe.getBool("IS_TEST"));Qe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Qe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Qe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Qe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ja(){let n,t,e,s,i,r,a,o,l,c;return Bt().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",t="in",e="out",s="in",i="texture",r="outputColor",a="out vec4 outputColor;",o=Bt().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",t="attribute",e="varying",s="varying",i="texture2D",r="gl_FragColor",a="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:t,varyingVs:e,varyingFs:s,texture2D:i,output:r,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wg(n,t,e="index"){const s=ln(t);return s.map((i,r)=>{const a=`int ${n[r]} = ${e} / ${i}`,o=r===s.length-1?`int ${n[r+1]} = ${e} - ${n[r]} * ${i}`:`index -= ${n[r]} * ${i}`;return`${a}; ${o};`}).join("")}function pN(n,t,e="index"){const s=ln(t);return s.map((i,r)=>{const a=`int ${n[r]} = ${e} / outShapeStrides[${r}]`,o=r===s.length-1?`int ${n[r+1]} = ${e} - ${n[r]} * outShapeStrides[${r}]`:`index -= ${n[r]} * outShapeStrides[${r}]`;return`${a}; ${o};`}).join("")}function M1t(n,t){const e=n.length,s=n.map(r=>`${t}[${r}]`),i=new Array(e-1);i[e-2]=s[e-1];for(let r=e-3;r>=0;--r)i[r]=`(${i[r+1]} * ${s[r+1]})`;return i}function I1t(n,t,e="index"){const s=n.map((r,a)=>a),i=M1t(s,t);return i.map((r,a)=>{const o=`int ${n[a]} = ${e} / ${i[a]}`,l=a===i.length-1?`int ${n[a+1]} = ${e} - ${n[a]} * ${i[a]}`:`index -= ${n[a]} * ${i[a]}`;return`${o}; ${l};`}).join("")}function l$(n){const t=ln(n).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function c$(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const I8=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:R8}=wht;function R1t(n,t,e){const s=[];if(n.forEach(g=>{const v=Zt(g.shapeInfo.logicalShape);if(g.shapeInfo.isUniform?s.push(`uniform float ${g.name}${v>1?`[${v}]`:""};`):(s.push(`uniform sampler2D ${g.name};`),s.push(`uniform int offset${g.name};`)),e.enableShapeUniforms){const{uniformShape:_}=u$(e.packedInputs,g.shapeInfo.logicalShape,g.shapeInfo.texShape);switch(_.length){case 1:s.push(`uniform int ${g.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${g.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${g.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${g.name}Shape;`);break}s.push(`uniform ivec2 ${g.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(g=>{s.push(`uniform ${g.type} ${g.name}${g.arrayIndex?`[${g.arrayIndex}]`:""};`)});const i=s.join(`
`),r=n.map(g=>D1t(g,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),a=t.texShape,o=ja(),l=$1t(o);let c,h,f=z1t(o);return t.isPacked?(c=k1t(t.logicalShape,a,e.enableShapeUniforms),h=F1t(o)):(c=O1t(t.logicalShape,a,e.enableShapeUniforms),h=L1t(o)),e.packedInputs&&(f+=V1t),[f,l,h,i,c,r,e.userCode].join(`
`)}function Ux(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return tSt(n,t);case 1:return nSt(n,t);case 2:return iSt(n,t);case 3:return aSt(n,t);case 4:return lSt(n,t);case 5:return cSt(n);case 6:return uSt(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function D8(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return J1t(n);case 1:return eSt(n,t);case 2:return sSt(n,t);case 3:return rSt(n,t);default:return oSt(n,t)}}function D1t(n,t,e=!1,s){let i="";e?i+=D8(n,s):i+=Ux(n,s);const r=n.shapeInfo.logicalShape,a=t.logicalShape;return r.length<=a.length&&(e?i+=hSt(n,t):i+=fSt(n,t)),i}function k1t(n,t,e){switch(n.length){case 0:return k8();case 1:return G1t(n,t,e);case 2:return Z1t(n,t,e);case 3:return W1t(n,t,e);default:return X1t(n,t,e)}}function O1t(n,t,e){switch(n.length){case 0:return k8();case 1:return H1t(n,t,e);case 2:return Q1t(n,t,e);case 3:return q1t(n,t,e);case 4:return j1t(n,t,e);case 5:return K1t(n,t);case 6:return Y1t(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function $1t(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function L1t(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function F1t(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function z1t(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${U1t}
    ${B1t}
    ${P1t}
  `}const U1t=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,B1t=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,P1t=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,V1t=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function k8(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function G1t(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return s[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function H1t(n,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function W1t(n,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(n[2]/2),r=i*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function q1t(n,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${pN(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=Wg(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function X1t(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(n[n.length-1]/2),r=i*Math.ceil(n[n.length-2]/2);let a=r,o="",l="b, r, c";for(let c=2;c<n.length-1;c++)a*=n[n.length-c-1],o=`
      int b${c} = index / ${a};
      index -= b${c} * ${a};
    `+o,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${o}

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${n.length}(${l});
    }
  `}function j1t(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${pN(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Wg(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function K1t(n,t){const e=Wg(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Y1t(n,t){const e=Wg(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Z1t(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Is(n,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const i=Math.ceil(n[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function Q1t(n,t,e){return Is(n,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:n[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function qg(n){return`offset${n}`}function J1t(n){const t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),s=ja();return`
    vec4 ${e}() {
      return ${s.texture2D}(${t}, halfCR);
    }
  `}function tSt(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${e};}`;const[i,r]=n.shapeInfo.texShape;if(i===1&&r===1)return`
      float ${s}() {
        return sampleTexture(${e}, halfCR);
      }
    `;const a=qg(e);if(t)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${a});
      return sampleTexture(${e}, uv);
    }
  `;const[o,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${a});
      return sampleTexture(${e}, uv);
    }
  `}function eSt(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),i=n.shapeInfo.texShape,r=ja();if(t)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${r.texture2D}(${e}, uv);
    }
  `;const a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${r.texture2D}(${e}, uv);
    }
  `}function nSt(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Bx(n)}
      }
    `;const i=n.shapeInfo.texShape,r=i[0],a=i[1];if(a===1&&r===1)return`
      float ${s}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;const o=qg(e);return a===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${r}.0);
        return sampleTexture(${e}, uv);
      }
    `:r===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${o});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${r}, ${a}, index + ${o});
      return sampleTexture(${e}, uv);
    }
  `}function sSt(n,t){const e=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape,a=r[0],o=r[1],l=ja();if(r!=null&&Is(e,r))return t?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(t)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],h=Math.ceil(e[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${h}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function iSt(n,t){const e=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape;if(r!=null&&Is(e,r)){if(t)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const p=r[0],g=r[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:a,keptDims:o}=dp(e),l=a;if(l.length<e.length){const p=Px(n,l),g=["row","col"];return`
      ${Ux(p,t)}
      float ${i}(int row, int col) {
        return ${i}(${Vx(g,o)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${Bx(n)}
      }
    `;const c=r[0],h=r[1],f=qg(s);return h===1?t?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?t?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:t?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${f};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${f};
    vec2 uv = uvFromFlat(${c}, ${h}, index);
    return sampleTexture(${s}, uv);
  }
`}function rSt(n,t){const e=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape,a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(e[0]===1){const p=e.slice(1),g=[1,2],v=Px(n,p),_=["b","row","col"];return`
        ${D8(v,t)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${Vx(_,g)});
        }
      `}const o=ja();if(t)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `;const l=a[0],c=a[1],h=Math.ceil(e[2]/2),f=h*Math.ceil(e[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${f}, ${h}, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `}function aSt(n,t){const e=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=e[1]*e[2],a=e[2],{newShape:o,keptDims:l}=dp(e),c=o;if(c.length<e.length){const _=Px(n,c),S=["row","col","depth"];return`
        ${Ux(_,t)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${Vx(S,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${r}, ${a}, 1)));
        ${Bx(n)}
      }
    `;const h=n.shapeInfo.texShape,f=h[0],p=h[1],g=n.shapeInfo.flatOffset;if(p===r&&g==null)return t?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${f}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(p===a&&g==null)return t?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${f}.0);
      return sampleTexture(${s}, uv);
    }
  `;const v=qg(s);return t?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${v};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r} + col * ${a} + depth + ${v};
        vec2 uv = uvFromFlat(${f}, ${p}, index);
        return sampleTexture(${s}, uv);
      }
  `}function oSt(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),i=ja();if(t)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${e}, uv);
    }
  `;const r=n.shapeInfo.logicalShape,a=r.length,o=n.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=l[0],h=l[1],f=Math.ceil(r[a-1]/2);let p=f*Math.ceil(r[a-2]/2),g="int b, int row, int col",v=`b * ${p} + (row / 2) * ${f} + (col / 2)`;for(let _=2;_<a-1;_++)g=`int b${_}, `+g,p*=r[a-_-1],v=`b${_} * ${p} + `+v;return`
    vec4 ${s}(${g}) {
      int index = ${v};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${c});
      return ${i.texture2D}(${e}, uv);
    }
  `}function lSt(n,t){const e=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=e[3],a=e[2]*r,o=e[1]*a,{newShape:l,keptDims:c}=dp(e);if(l.length<e.length){const T=Px(n,l),C=["row","col","depth","depth2"];return`
      ${Ux(T,t)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${Vx(C,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${a}, ${r}, 1)));
        ${Bx(n)}
      }
    `;const h=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,p=f[0],g=f[1],v=`int stride2 = ${s}Shape[3];`,_=`int stride1 = ${s}Shape[2] * stride2;`,S=`int stride0 = ${s}Shape[1] * stride1;`;if(g===o&&h==null)return t?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${v}
        ${_}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(g===r&&h==null)return t?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;const b=qg(s);return t?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${v}
      ${_}
      ${S}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${b});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} +
          depth * ${r} + depth2;
      vec2 uv = uvFromFlat(${p}, ${g}, index + ${b});
      return sampleTexture(${s}, uv);
    }
  `}function cSt(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),i=t[4],r=t[3]*i,a=t[2]*r,o=t[1]*a,{newShape:l,keptDims:c}=dp(t);if(l.length<t.length){const _=Px(n,l),S=["row","col","depth","depth2","depth3"];return`
      ${Ux(_)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Vx(S,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${a}, ${r}, ${i})) +
          depth3;
        ${Bx(n)}
      }
    `;const h=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,p=f[0],g=f[1];if(g===o&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${r}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(g===i&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${e}, uv);
      }
    `;const v=qg(e);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} + depth * ${r} +
          depth2 * ${i} + depth3 + ${v};
      vec2 uv = uvFromFlat(${p}, ${g}, index);
      return sampleTexture(${e}, uv);
    }
  `}function uSt(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:i,keptDims:r}=dp(t);if(i.length<t.length){const S=Px(n,i),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${Ux(S)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Vx(b,r)});
      }
    `}const a=t[5],o=t[4]*a,l=t[3]*o,c=t[2]*l,h=t[1]*c;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${c}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Bx(n)}
      }
    `;const f=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,g=p[0],v=p[1];if(v===h&&f==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${o}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${v}.0, ${g}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(v===a&&f==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${v}.0, ${g}.0);
        return sampleTexture(${e}, uv);
      }
    `;const _=qg(e);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${c} + depth * ${l} +
          depth2 * ${o} + depth3 * ${a} + depth4 + ${_};
      vec2 uv = uvFromFlat(${g}, ${v}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Bx(n){const t=n.name,e=Zt(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function hSt(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),i="get"+s+"AtOutCoords",r=n.shapeInfo.logicalShape.length,a=t.logicalShape.length,o=R8(n.shapeInfo.logicalShape,t.logicalShape),l=Ws(a),c=a-r;let h;const f=["x","y","z","w","u","v"];r===0?h="":a<2&&o.length>=1?h="coords = 0;":h=o.map(T=>`coords.${f[T+c]} = 0;`).join(`
`);let p="";a<2&&r>0?p="coords":p=n.shapeInfo.logicalShape.map((T,C)=>`coords.${f[C+c]}`).join(", ");let g="return outputValue;";const _=Zt(n.shapeInfo.logicalShape)===1,b=Zt(t.logicalShape)===1;if(r===1&&!_&&!b)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(_&&!b)a===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(o.length){const T=r-2,C=r-1;o.indexOf(T)>-1&&o.indexOf(C)>-1?g="return vec4(outputValue.x);":o.indexOf(T)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(C)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${h}
      vec4 outputValue = get${s}(${p});
      ${g}
    }
  `}function fSt(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),i="get"+s+"AtOutCoords",r=t.texShape,a=n.shapeInfo.texShape,o=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&o===l&&n.shapeInfo.flatOffset==null&&Is(a,r))return`
      float ${i}() {
        return sampleTexture(${e}, resultUV);
      }
    `;const c=Ws(l),h=R8(n.shapeInfo.logicalShape,t.logicalShape),f=l-o;let p;const g=["x","y","z","w","u","v"];o===0?p="":l<2&&h.length>=1?p="coords = 0;":p=h.map(_=>`coords.${g[_+f]} = 0;`).join(`
`);let v="";return l<2&&o>0?v="coords":v=n.shapeInfo.logicalShape.map((_,S)=>`coords.${g[S+f]}`).join(", "),`
    float ${i}() {
      ${c} coords = getOutputCoords();
      ${p}
      return get${s}(${v});
    }
  `}function Ws(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function u$(n,t,e){const{newShape:s,keptDims:i}=dp(t),r=t.length,a=n&&r===3&&t[0]===1,o=a?t.slice(1):s,l=!n&&r>1&&!Is(t,e)&&s.length<r||a;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:i}}function Px(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function Vx(n,t){return t.map(e=>n[e]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dSt(n,t,e,s){const i=e.map((h,f)=>{const p={logicalShape:h.shape,texShape:h.isUniform?null:h.texData.texShape,isUniform:h.isUniform,isPacked:h.isUniform?!1:h.texData.isPacked,flatOffset:null};return h.texData!=null&&h.texData.slice!=null&&h.texData.slice.flatOffset>0&&(p.flatOffset=h.texData.slice.flatOffset),{name:t.variableNames[f],shapeInfo:p}}),r=i.map(h=>h.shapeInfo),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},o=R1t(i,a,t),l=a1t(n.gl,o),c=n.createProgram(l);return Bt().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:r,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:r,outShapeInfo:a},O8(n,t,c)))}function O8(n,t,e){const s=[],i=[];let r,a,o,l=null,c=null;c=n.getUniformLocation(e,"NAN",!1),Bt().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(e,"INFINITY",!1));const h=!1;for(const f of t.variableNames){const p={name:f,uniform:n.getUniformLocation(e,f,h),offset:n.getUniformLocation(e,`offset${f}`,h)};t.enableShapeUniforms&&(p.shape=n.getUniformLocation(e,`${f}Shape`,h),p.texShape=n.getUniformLocation(e,`${f}TexShape`,h)),s.push(p)}if(t.enableShapeUniforms&&(r=n.getUniformLocation(e,"outShape",h),o=n.getUniformLocation(e,"outShapeStrides",h),a=n.getUniformLocation(e,"outTexShape",h)),t.customUniforms)for(const f of t.customUniforms)i.push(n.getUniformLocation(e,f.name,h));return{variablesLocations:s,customUniformLocations:i,infLoc:l,nanLoc:c,outShapeLocation:r,outShapeStridesLocation:o,outTexShapeLocation:a}}function pB(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,s)=>{const i=e.logicalShape,r=t[s],a=r.shape;if(!Is(i,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${a} must match`);if(e.isUniform&&r.isUniform)return;const o=e.texShape,l=r.isUniform?null:r.texData.texShape;if(!Is(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function pSt(n,t,e,s,i){t.program.enableShapeUniforms||(pB(t.inShapeInfos,e),pB([t.outShapeInfo],[s]));const r=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(r.texture,a[0],a[1]):n.setOutputMatrixTexture(r.texture,a[0],a[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),Bt().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&n.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&n.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<e.length;++l){const c=e[l],{uniform:h,offset:f,shape:p,texShape:g}=t.variablesLocations[l];if(p){const{uniformShape:v}=u$(t.program.packedInputs,c.shape,c.texData.texShape);switch(v.length){case 1:n.gl.uniform1iv(p,new Int32Array(v));break;case 2:n.gl.uniform2iv(p,new Int32Array(v));break;case 3:n.gl.uniform3iv(p,new Int32Array(v));break;case 4:n.gl.uniform4iv(p,new Int32Array(v));break}}if(g&&n.gl.uniform2i(g,c.texData.texShape[0],c.texData.texShape[1]),h!=null){if(c.isUniform){if(Zt(c.shape)<2)n.gl.uniform1f(h,c.uniformValues[0]);else{let v=c.uniformValues;v instanceof Float32Array||(v=new Float32Array(v)),n.gl.uniform1fv(h,v)}continue}c.texData.slice!=null&&f!=null&&n.gl.uniform1i(f,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,h,l)}}const o=t.outShapeLocation;if(o)switch(s.shape.length){case 1:n.gl.uniform1iv(o,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(o,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(o,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(o,new Int32Array(s.shape));break}if(t.outShapeStridesLocation){const l=ln(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&i)for(let l=0;l<t.program.customUniforms.length;++l){const c=t.program.customUniforms[l],h=t.customUniformLocations[l],f=i[l];if(c.type==="float")n.gl.uniform1fv(h,f);else if(c.type==="vec2")n.gl.uniform2fv(h,f);else if(c.type==="vec3")n.gl.uniform3fv(h,f);else if(c.type==="vec4")n.gl.uniform4fv(h,f);else if(c.type==="int")n.gl.uniform1iv(h,f);else if(c.type==="ivec2")n.gl.uniform2iv(h,f);else if(c.type==="ivec3")n.gl.uniform3iv(h,f);else if(c.type==="ivec4")n.gl.uniform4iv(h,f);else throw Error(`uniform type ${c.type} is not supported yet.`)}n.executeProgram()}function mSt(n,t,e){let s="";t.concat(e).forEach(a=>{const o=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const l=a.texData.texShape,{useSqueezeShape:c,uniformShape:h,keptDims:f}=u$(n.packedInputs,a.shape,l);let p="",g="",v="";if(h.length===1&&n.packedInputs){const I=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${I[0]>1}_${I[1]>1}`}else if(h.length===2&&!n.packedInputs)g=`${h[0]>1}_${h[1]>1}`;else if(h.length>2&&!n.packedInputs){const I=ln(h);v=`${I[0]===l[1]}_${I[I.length-1]===l[1]}`}const _=a.shape.length,S=h.length===2&&Is(a.shape,l),b=Zt(a.shape)===1,T=ux(a.shape,e.shape),C=!n.packedInputs&&_===e.shape.length&&Is(l,e.texData.texShape),A=n.packedInputs||h.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${_}_${C}_${c?f:""}_${h.length}_${b}_${T}_${S}_${p}_${g}_${v}_${A}_${o}`}else{const l=a.isUniform?"uniform":a.texData.texShape;s+=`${a.shape}_${l}_${o}`}});const i=n.userCode;let r=n.constructor.name;return r+="_"+s+"_"+i+`${Bt().getNumber("WEBGL_VERSION")}`,r}function xa(n){return Bt().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gSt{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=B1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=ja();this.outputShape=t,this.enableShapeUniforms=xa(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?pN(["r","c","d"],t):Wg(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ySt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=B1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=ja();this.outputShape=t,this.enableShapeUniforms=xa(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?pN(["r","c","d"],t):Wg(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xSt{constructor(t){this.variableNames=["A"],this.outTexUsage=wl.DOWNLOAD;const e=ja();this.outputShape=t,this.userCode=`
      ${I8}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vSt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=wl.DOWNLOAD;const e=ja();this.outputShape=t,this.userCode=`
      ${I8}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bSt={R:0,G:1,B:2,A:3};class mB{constructor(t,e=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=ja();this.outputShape=t,this.enableShapeUniforms=xa(this.outputShape.length);let r="result";e&&(r="floor(result * 255. + 0.5)");let a="";for(let o=0;o<s.length;o++){const l=s[o];a+=`
          if(offset == ${o}) {
            result = values[${bSt[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?c$():l$(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${a}
        }
        ${i.output} = vec4(${r}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SSt{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=ja();this.outputShape=t,this.enableShapeUniforms=xa(this.outputShape.length);let i="",r="result";e&&(r="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let o=0;o<=1;o++){const l=a*2+o;i+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?c$():l$(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${s.output} = ${r};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _St(n){const t=ja(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return r1t(n,e)}function wSt(n){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return u1t(n,t)}function TSt(n){const t=new Uint16Array([0,1,2,2,1,3]);return h1t(n,t)}function T_(n,t,e,s,i,r){d1t(t,e);const a=f1t(n),o=n.TEXTURE_2D;return Be(n,()=>n.bindTexture(o,a)),Be(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Be(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Be(n,()=>n.texParameteri(o,n.TEXTURE_MIN_FILTER,n.NEAREST)),Be(n,()=>n.texParameteri(o,n.TEXTURE_MAG_FILTER,n.NEAREST)),Bt().getNumber("WEBGL_VERSION")===1?Be(n,()=>n.texImage2D(o,0,s,t,e,0,i,r,null)):Be(n,()=>n.texStorage2D(o,1,s,t,e)),Be(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[e,t]}}function $8(n){return n.internalFormatFloat}function ESt(n,t,e,s){const[i,r]=__(t,e);return T_(n,i,r,$8(s),s.textureFormatFloat,n.FLOAT)}function L8(n){return n.internalFormatHalfFloat}function CSt(n,t,e,s){const[i,r]=__(t,e);return T_(n,i,r,L8(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function F8(n){return n.downloadTextureFormat}function ASt(n,t,e,s){const[i,r]=__(t,e);return T_(n,i,r,F8(s),n.RGBA,n.UNSIGNED_BYTE)}function z8(n){return n.internalFormatPackedFloat}function NSt(n,t,e,s){const[i,r]=zx(t,e);return T_(n,i,r,z8(s),n.RGBA,n.FLOAT)}function U8(n){return n.internalFormatPackedHalfFloat}function MSt(n,t,e,s){const[i,r]=zx(t,e);return T_(n,i,r,U8(s),n.RGBA,s.textureTypeHalfFloat)}function ISt(n,t,e){return Be(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),hB(n,t,"clipSpacePos",e,3,20,0)&&hB(n,t,"uv",e,2,20,12)}function RSt(n,t,e,s,i,r){Be(n,()=>n.bindTexture(n.TEXTURE_2D,t));let a,o,l;i instanceof Uint8Array?(a=new Uint8Array(e*s*4),o=n.UNSIGNED_BYTE,l=n.RGBA):(a=new Float32Array(e*s*4),o=n.FLOAT,l=r.internalFormatPackedFloat),a.set(i),Bt().getNumber("WEBGL_VERSION")===2?Be(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,s,n.RGBA,o,a)):Be(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,s,0,n.RGBA,o,a)),Be(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function DSt(n,t,e){Be(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?Bt().getNumber("WEBGL_VERSION")===2?Be(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):Be(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):Bt().getNumber("WEBGL_VERSION")===2?Be(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):Be(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),Be(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function kSt(n,t,e,s){const i=n.createBuffer();Be(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,i));const o=4*4*t*e;return Be(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,o,n.STREAM_READ)),Be(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),Be(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),i}function OSt(n,t,e){const s=n,i=new Float32Array(e);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,i),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),i}function $St(n,t,e,s){const[i,r]=__(t,e),a=4,o=new Uint8Array(Qbt(t*e,a));return Be(n,()=>n.readPixels(0,0,i,r,s.downloadTextureFormat,n.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function LSt(n,t,e,s,i,r,a,o){const l=n,c=new Float32Array(Jbt(r,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function FSt(n,t,e){const s=new Float32Array(t*e*4);return Be(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BI{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=Bt().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,Kbt(e,t)):this.gl=lu(e),t=this.gl,Bt().getNumber("WEBGL_VERSION")===2){const r=t;this.createVertexArray=()=>Be(r,()=>r.createVertexArray()),this.bindVertexArray=a=>Be(r,()=>r.bindVertexArray(a)),this.deleteVertexArray=a=>Be(r,()=>r.deleteVertexArray(a)),this.getVertexArray=()=>Be(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(t!=null){const r=t.getExtension("OES_vertex_array_object");if(r==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Be(t,()=>r.createVertexArrayOES()),this.bindVertexArray=a=>Be(t,()=>r.bindVertexArrayOES(a)),this.deleteVertexArray=a=>Be(t,()=>r.deleteVertexArrayOES(a)),this.getVertexArray=()=>Be(t,()=>t.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Bt().getNumber("WEBGL_VERSION")===1){const r="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=KT(this.gl,r),lc(this.gl,a))this.textureHalfFloatExtension=KT(this.gl,a);else if(Bt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),lc(this.gl,i))this.colorBufferHalfFloatExtension=KT(this.gl,i);else if(Bt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",lc(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(lc(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=wSt(this.gl),this.indexBuffer=TSt(this.gl),this.framebuffer=p1t(this.gl),this.textureConfig=o$(this.gl,this.textureHalfFloatExtension)}get debug(){return Bt().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;Be(t,()=>t.finish()),Be(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Be(t,()=>t.deleteFramebuffer(this.framebuffer)),Be(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Be(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Be(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),ESt(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),CSt(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),ASt(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),DSt(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,s,i){this.throwIfDisposed(),RSt(this.gl,t,e,s,i,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),MSt(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),NSt(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(fB(this.gl,this.framebuffer),this.outputTexture=null),Be(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,s){return this.downloadMatrixDriver(t,()=>$St(this.gl,e,s,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,s,i,r,a){return LSt(this.gl,t,e,s,i,r,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return OSt(this.gl,t,e)}createBufferFromTexture(t,e,s){this.bindTextureToFrameBuffer(t);const i=kSt(this.gl,e,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,s;if(Bt().getBool("WEBGL_FENCE_API_ENABLED")){const i=t,r=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),s=()=>{const a=i.clientWaitSync(r,0,0);return a===i.ALREADY_SIGNALED||a===i.CONDITION_SATISFIED},e=r}else Bt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(e,Bt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:e,isFencePassed:s}}downloadMatrixFromPackedTexture(t,e,s){return this.downloadMatrixDriver(t,()=>FSt(this.gl,e,s))}createProgram(t){this.throwIfDisposed();const e=this.gl;this.vertexShader==null&&(this.vertexShader=_St(e));const s=l1t(e);Be(e,()=>e.attachShader(s,this.vertexShader)),Be(e,()=>e.attachShader(s,t)),c1t(e,s);const i=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&LI(e,i),i}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;Be(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),ISt(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(Be(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&LI(this.gl,this.program),Be(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,s=!0){return this.throwIfDisposed(),s?g1t(this.gl,t,e):y1t(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),Be(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,s){this.throwIfDisposed(),this.throwIfNoProgram(),x1t(this.gl,t,e,s)}setOutputMatrixTexture(t,e,s){this.setOutputMatrixTextureDriver(t,s,e)}setOutputPackedMatrixTexture(t,e,s){this.throwIfDisposed();const[i,r]=zx(e,s);this.setOutputMatrixTextureDriver(t,i,r)}setOutputMatrixWriteRegion(t,e,s,i){this.setOutputMatrixWriteRegionDriver(s,t,i,e)}setOutputPackedMatrixWriteRegion(t,e,s,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&LI(this.gl,this.program),YT(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Be(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Be(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=KT(this.gl,Bt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Bt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=s.createQuery();return s.beginQuery(i.TIME_ELAPSED_EXT,r),r}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(Bt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl,s=this.getQueryTimerExtensionWebGL2();e.endQuery(s.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await Yz(()=>this.disposed||this.isQueryAvailable(t,Bt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,Bt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){const s=this.gl;return s.getQueryParameter(t,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(t,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),i=s.getQueryObjectEXT(t,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=zSt(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:s}=this.itemsToPoll[e];s()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in Bt().platform&&(s=Bt().platform.setTimeoutCustom.bind(Bt().platform)),Yz(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),FI(this.gl,t,this.framebuffer),this.debug&&YT(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(FI(this.gl,this.outputTexture,this.framebuffer),this.debug&&YT(this.gl)):fB(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const s=e();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(t,e,s){this.throwIfDisposed();const i=this.gl;FI(i,t,this.framebuffer),this.debug&&YT(i),this.outputTexture=t,Be(i,()=>i.viewport(0,0,e,s)),Be(i,()=>i.scissor(0,0,e,s))}setOutputMatrixWriteRegionDriver(t,e,s,i){this.throwIfDisposed(),Be(this.gl,()=>this.gl.scissor(t,e,s,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function zSt(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:USt,bincountImpl:B8,bincountReduceImpl:BSt,bitwiseAndImpl:PSt,castImpl:VSt,ceilImpl:GSt,concatImpl:HSt,equalImpl:WSt,expImpl:qSt,expm1Impl:XSt,floorImpl:jSt,gatherNdImpl:KSt,gatherV2Impl:YSt,greaterImpl:ZSt,greaterEqualImpl:QSt,lessImpl:JSt,lessEqualImpl:t_t,linSpaceImpl:e_t,logImpl:n_t,maxImpl:s_t,maximumImpl:i_t,minimumImpl:r_t,multiplyImpl:a_t,negImpl:o_t,notEqualImpl:l_t,prodImpl:c_t,raggedGatherImpl:u_t,raggedRangeImpl:h_t,raggedTensorToTensorImpl:f_t,rangeImpl:d_t,rsqrtImpl:p_t,scatterImpl:m_t,sigmoidImpl:g_t,simpleAbsImpl:P8,sliceImpl:y_t,sparseFillEmptyRowsImpl:x_t,sparseReshapeImpl:v_t,sparseSegmentReductionImpl:V8,sqrtImpl:b_t,staticRegexReplaceImpl:S_t,stridedSliceImpl:__t,stringNGramsImpl:w_t,stringSplitImpl:T_t,stringToHashBucketFastImpl:E_t,subImpl:C_t,tileImpl:A_t,topKImpl:N_t,transposeImpl:h$,uniqueImpl:M_t}=Dgt;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G8(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function za(n,t){return t===1?[n]:G8(n,t)}function I_t(n,t){if(n===1)return"rc";let e="";for(let s=0;s<n;s++)e+=t[s],s<n-1&&(e+=",");return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R_t{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=xa(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const e=za("rc",this.rank),s=Ws(this.rank),i=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(t){const e=[];for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let r=`${s===0?"r":"rp1"}, ${i===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)r=`${t[t.length-1-a]},`+r;e.push(r)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let s=this.rank-2;s<this.rank;s++)e+=`${t[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";const e=t.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${i};
    `}getOutput(t){const e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H8{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=xa(this.outputShape.length);let s="";for(let i=0;i<4;i++){let r="thisRC = rc;";i%2===1&&(r+="thisRC.z += 1;"),i>1&&(r+="thisRC.y += 1;"),s+=`
        ${r}
        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i>0?"}":""}
      `}this.userCode=`
      ${D_t(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?c$():l$(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${s}

        setOutput(result);
      }
    `}}function D_t(n,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?I1t(["r","c","d"],"inputShape"):Wg(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k_t{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,s){const i=yB(e,s),r=xB(t,i,s);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const a=gB(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const l=this.freeTextures[r].pop();return this.usedTextures[r].push(l),l}let o;return i===Yr.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):i===Yr.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):i===Yr.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):i===Yr.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):i===Yr.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[r].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(t,e,s,i){if(this.freeTextures==null)return;const r=yB(s,i),a=xB(e,r,i);a in this.freeTextures||(this.freeTextures[a]=[]);const o=gB(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,i),l=Bt().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=o):(this.freeTextures[a].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const c=this.usedTextures[a],h=c&&c.indexOf(t);if(h==null||h<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[h]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function O_t(n,t){const e=n;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function gB(n,t,e,s,i){const r=$_t(t,s);let a;if(i){const[l,c]=zx(n[0],n[1]);a=l*c}else{const[l,c]=__(n[0],n[1]);a=l*c}const o=O_t(e,r);return a*o}function $_t(n,t){switch(n){case Yr.PACKED_2X2_FLOAT32:return z8(t);case Yr.PACKED_2X2_FLOAT16:return U8(t);case Yr.UNPACKED_FLOAT32:return $8(t);case Yr.UNPACKED_FLOAT16:return L8(t);case Yr.PACKED_4X1_UNSIGNED_BYTE:return F8(t);default:throw new Error(`Unknown physical texture type ${n}`)}}function L_t(n){return Bt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Yr.PACKED_2X2_FLOAT32:Yr.UNPACKED_FLOAT32:n?Yr.PACKED_2X2_FLOAT16:Yr.UNPACKED_FLOAT16}function yB(n,t){if(n===wl.UPLOAD)return Yr.PACKED_2X2_FLOAT32;if(n===wl.RENDER||n==null)return L_t(t);if(n===wl.DOWNLOAD||n===wl.PIXELS)return Yr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function xB(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sh{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=xa(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const mc="if (isnan(x)) return x;",F_t="return x;",vB="return abs(x);",z_t="return (x >= 0.0) ? x : (exp(x) - 1.0);",U_t=mc+`
  return (x < 0.0) ? 0.0 : x;
`,B_t=mc+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Rd="return x;",P_t="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V_t="return x;",G_t=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,H_t=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,W_t=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,q_t="return 1.0 / (1.0 + exp(-1.0 * x));";class zd{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=xa(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X_t{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=xa(this.outputShape.length);const e=t.length,s=za("rc",e),i=Ws(e),r=I_t(e,s),a=s.slice(-2),o=e<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j_t=pH,K_t=1e-7,Y_t=1e-4,JT={};function Z_t(n){return n in JT||(JT[n]={}),JT[n]}const Q_t=Bt().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),J_t=600;function twt(){return Bt().global.screen==null?1024:Bt().global.screen.height*Bt().global.screen.width*window.devicePixelRatio*J_t/1024/1024}class mN extends R3{nextDataId(){return mN.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Bt().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof BI)e=t;else{const s=lu(Bt().getNumber("WEBGL_VERSION"),t);e=new BI(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=lu(Bt().getNumber("WEBGL_VERSION"));e=new BI(s),this.binaryCache=Z_t(Bt().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new k_t(this.gpgpu),this.numMBBeforeWarning=twt(),this.texData=new UV(this,Yu())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,s,i,r,a){const o=this.makeTensorInfo(e,s),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[i,r]},l.texShape=[i,r];const c=ZT(e),h=new mB(c,!1,a),f=this.runWebGLProgram(h,[o],s,[[i,r]]);return f.shape=e,l.texture=null,this.disposeIntermediateTensorInfo(o),f.dataId}write(t,e,s){if((Bt().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Bt().getBool("DEBUG"))&&this.checkNumericalProblems(t),s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:e,dtype:s,values:t,usage:wl.UPLOAD,refCount:1}),i}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){const e=this.texData.get(t);e.refCount--}}move(t,e,s,i,r){if(Bt().getBool("DEBUG")&&this.checkNumericalProblems(e),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:s,dtype:i,values:e,usage:wl.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:s,dtype:i,complexTensorInfos:r,slice:a,shape:o,isPacked:l}=e;if(a!=null){let p;l?p=new zd(o,Rd):p=new sh(o,Rd);const g=this.runWebGLProgram(p,[{dataId:t,shape:o,dtype:i}],i),v=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),v}if(s!=null)return this.convertAndCacheOnCPU(t);if(i==="string")return s;const c=this.activeTimers!=null;let h;c&&(h=yo());let f;if(i==="complex64"){const p=this.readSync(r.real.dataId),g=this.readSync(r.imag.dataId);f=Cf(p,g)}else f=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=yo()-h),this.convertAndCacheOnCPU(t,f)}async read(t){if(this.pendingRead.has(t)){const v=this.pendingRead.get(t);return new Promise(_=>v.push(_))}const e=this.texData.get(t),{values:s,shape:i,slice:r,dtype:a,complexTensorInfos:o,isPacked:l}=e;if(r!=null){let v;l?v=new zd(i,Rd):v=new sh(i,Rd);const _=this.runWebGLProgram(v,[{dataId:t,shape:i,dtype:a}],a),S=this.read(_.dataId);return this.disposeIntermediateTensorInfo(_),S}if(s!=null)return this.convertAndCacheOnCPU(t);if(Bt().getBool("DEBUG")&&!Bt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Bt().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,h;if(a!=="complex64"&&Bt().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(t);const v=this.texData.get(h.dataId);c=this.gpgpu.createBufferFromTexture(v.texture.texture,...jT(i))}this.pendingRead.set(t,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let f;if(a==="complex64"){const v=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),_=v[0],S=v[1];f=Cf(_,S)}else if(c==null)f=this.getValuesFromTexture(t);else{const v=Zt(i);f=this.gpgpu.downloadFloat32MatrixFromBuffer(c,v)}if(h!=null&&this.disposeIntermediateTensorInfo(h),c!=null){const v=this.gpgpu.gl;Be(v,()=>v.deleteBuffer(c))}const p=this.convertAndCacheOnCPU(t,f),g=this.pendingRead.get(t);return this.pendingRead.delete(t),g.forEach(v=>v(p)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Yu().removeDataId(t,this),this.pendingDeletes--),p}readToGPU(t,e={}){const s=this.texData.get(t),{values:i,shape:r,slice:a,dtype:o,isPacked:l,texture:c}=s;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let g;l?g=new zd(r,Rd):g=new sh(r,Rd);const v=this.runWebGLProgram(g,[{dataId:t,shape:r,dtype:o}],o),_=this.readToGPU(v,e);return this.disposeIntermediateTensorInfo(v),_}if(c==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(t,e.customTexShape),f=Yu().makeTensorFromTensorInfo(h),p=this.texData.get(h.dataId);return Object.assign({tensorRef:f},p.texture)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(i=>Yd(i));return Hn(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Hn(t.shape,t.dtype,e)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){const s=t[e];if(!s1t(s))throw Bt().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:e,dtype:s,isPacked:i}=this.texData.get(t),r=Zt(e);if(Bt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(t),g=this.texData.get(p.dataId),v=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...jT(e)).subarray(0,r);return this.disposeIntermediateTensorInfo(p),v}const a=Bt().getBool("WEBGL_PACK")&&i===!0,o=a?ZT(e):e,l=a?new vSt(o):new xSt(o),c=this.runWebGLProgram(l,[{shape:o,dtype:s,dataId:t}],"float32"),h=this.texData.get(c.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(c),f}timerAvailable(){return Bt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,s=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,t();const r=fg(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=fg(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=e,i&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Bt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(r);o.kernelMs=Uit(l),o.getExtraProfileInfo=()=>l.map((c,h)=>({name:a[h],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Bt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:yo(),endMs:null}}endTimer(t){return Bt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=yo(),t)}async getQueryTime(t){if(Bt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:s}=this.texData.get(t);return s!=null&&(this.disposeData(s.real.dataId,e),this.disposeData(s.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:s,texShape:i,usage:r,isPacked:a,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),e!=null&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(e,i,r,a)));const h=this.texData.get(t);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=Q_t){return Bt().getBool("WEBGL_CPU_FORWARD")&&t.every(s=>this.texData.get(s.dataId).texture==null&&Zt(s.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){bl("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return j_t(t.shape,e)}packedUnaryOp(t,e,s){const i=new zd(t.shape,e),r=this.compileAndRun(i,[t],s);return Yu().makeTensorFromTensorInfo(r)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const i=P8(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,i)}if(Bt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,vB,t.dtype);const e=new sh(t.shape,vB),s=this.compileAndRun(e,[t]);return Yu().makeTensorFromTensorInfo(s)}makeTensorInfo(t,e,s){let i;if(e==="string"&&s!=null&&s.length>0&&uS(s[0])){const r=s.map(a=>Vd(a));i=this.write(r,t,e)}else i=this.write(s,t,e);return this.texData.get(i).usage=null,{dataId:i,shape:t,dtype:e}}makeOutput(t,e,s){return Yu().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,s),this)}unpackTensor(t){const e=new X_t(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new R_t(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const s=[yx(t.shape),...xx(t.shape)],i={dtype:t.dtype,shape:s,dataId:t.dataId},r=[yx(e),...xx(e)],a=new H8(r,s),o=!0,l=[s],c=this.runWebGLProgram(a,[i],t.dtype,l,o);return{dataId:c.dataId,shape:e,dtype:c.dtype}}decode(t,e){const s=this.texData.get(t),{isPacked:i,shape:r,dtype:a}=s;if(e!=null){const p=Zt(r),g=e[0]*e[1]*4;et(p<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=ZT(r);let l;i?l=new ySt(o):l=new gSt(o);const c=!0,h=[e??jT(o)],f=this.runWebGLProgram(l,[{shape:o,dtype:a,dataId:t}],a,h,c,e);return{dtype:a,shape:r,dataId:f.dataId}}runWebGLProgram(t,e,s,i,r=!1,a){const o=this.makeTensorInfo(t.outputShape,s),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===B1.DENSE){const b=a??jT(t.outputShape);l.texShape=b.map(T=>T*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),Zt(o.shape)===0)return l.values=ma(o.dtype,0),o;const c=[],h=e.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let T=this.texData.get(b.dataId);if(T.texture==null){if(!t.packedInputs&&Zt(b.shape)<=Bt().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:T.values};t.packedInputs&&(T.isPacked=!0,T.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!T.isPacked!=!!t.packedInputs)b=T.isPacked?this.unpackTensor(b):this.packTensor(b),c.push(b),T=this.texData.get(b.dataId);else if(T.isPacked&&!H2(T.shape,b.shape)){const C=b,A=b.shape;b.shape=T.shape,b=this.packedReshape(b,A),c.push(b),T=this.texData.get(b.dataId),C.shape=A}return{shape:b.shape,texData:T,isUniform:!1}});this.uploadToGPU(o.dataId);const f={shape:o.shape,texData:l,isUniform:!1},p=mSt(t,h,f),g=this.getAndSaveBinary(p,()=>dSt(this.gpgpu,t,h,f)),v=this.activeTimers!=null;let _;v&&(_=this.startTimer()),Bt().get("ENGINE_COMPILE_ONLY")||pSt(this.gpgpu,g,h,f,i),c.forEach(b=>this.disposeIntermediateTensorInfo(b)),v&&(_=this.endTimer(_),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(_)}));const S=Bt().getNumber("WEBGL_FLUSH_THRESHOLD");if(S>0){const b=yo();b-this.lastGlFlushTime>S&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!Bt().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&r===!1){const b=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),b}return o}compileAndRun(t,e,s,i,r=!1){return s=s||e[0].dtype,this.runWebGLProgram(t,e,s,i,r)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Bt().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Lt(()=>{if(!Bt().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Bt().getBool("DEBUG");Bt().set("DEBUG",!1);const e=this.abs(Ds(1e-8)).dataSync()[0];if(Bt().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?K_t:Y_t}uploadToGPU(t){const e=this.texData.get(t),{shape:s,dtype:i,values:r,texture:a,usage:o,isPacked:l}=e;if(a!=null)return;const c=this.activeTimers!=null;let h;c&&(h=yo());let f=e.texShape;if(f==null&&(f=S1t(s,l),e.texShape=f),r!=null){const p=ZT(s);let g,v=f[1],_=f[0];const S=r instanceof Uint8Array||r instanceof Uint8ClampedArray;(l||!S)&&([v,_]=zx(f[0],f[1])),l?g=new SSt(p,S):g=new mB(p,S);const b=S?[_,v]:f,T=this.makeTensorInfo(b,i),C=this.texData.get(T.dataId);S?C.usage=wl.PIXELS:C.usage=wl.UPLOAD,C.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(T.dataId),v,_,r);const A=[[_,v]],D=this.runWebGLProgram(g,[T],i,A,!0),F=this.texData.get(D.dataId);e.texShape=F.texShape,e.isPacked=F.isPacked,e.usage=F.usage,Bt().get("ENGINE_COMPILE_ONLY")?this.disposeData(D.dataId):(e.texture=F.texture,e.values=null,this.texData.delete(D.dataId)),this.disposeIntermediateTensorInfo(T),c&&(this.uploadWaitMs+=yo()-h)}else{const p=this.acquireTexture(f,o,i,l);e.texture=p}}convertAndCacheOnCPU(t,e){const s=this.texData.get(t),{dtype:i}=s;return e!=null&&(s.values=ewt(e,i)),s.values}acquireTexture(t,e,s,i){if(this.numBytesInGPU+=this.computeBytes(t,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const r=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${r} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,i)}computeBytes(t,e){return t[0]*t[1]*b2(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(const[,e]of Object.entries(this.binaryCache)){const s=new Promise(i=>{try{this.checkCompletion_(e),i(!0)}catch(r){throw r}});t.push(s)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await RH(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(M8(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:e,customUniformLocations:s,infLoc:i,nanLoc:r,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:l}=O8(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=e,t.customUniformLocations=s,t.infLoc=i,t.nanLoc=r,t.outShapeLocation=a,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,e,s){t.channels=t.channels||"RGBA";const{texture:i,height:r,width:a,channels:o}=t,l=Yu().backend;if(!l.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(i,e,s,r,a,o);return Yu().makeTensorFromDataId(c,e,s,l)}}mN.nextDataId=0;function ewt(n,t){if(t==="float32"||t==="complex64")return n;if(t==="int32"||t==="bool"){const e=t==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<e.length;++s)e[s]=Math.round(n[s]);return e}else throw new Error(`Unknown dtype ${t}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */NG()&&BG("webgl",()=>new mN,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f$=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class wg{constructor(t,e,s){this.variableNames=["A","B"],this.outputShape=Rn(e,s),this.enableShapeUniforms=xa(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xg=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Gx{constructor(t,e,s,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Rn(e,s);const r=this.outputShape.length;this.enableShapeUniforms=xa(r);let a="";if(i)if(r===0||Zt(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Ws(r)} coords = getOutputCoords();
        `,r===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=za("coords",r);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${l[r-2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${l[r-1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${l[r-2]} + 1) >= ${this.outputShape[r-2]};
            bool nextColOutOfBounds =
              (${l[r-1]} + 1) >= ${this.outputShape[r-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function el(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const nwt={kernelName:RS,backendName:"webgl",kernelFunc:el};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sp(n){const{inputs:t,backend:e}=n,{real:s,imag:i}=t,r=e.makeTensorInfo(s.shape,"complex64"),a=e.texData.get(r.dataId),o=el({inputs:{x:s},backend:e}),l=el({inputs:{x:i},backend:e});return a.complexTensorInfos={real:o,imag:l},r}const swt={kernelName:H3,backendName:"webgl",kernelFunc:Sp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W8="return (a < 0.) ? b * a : a;",q8=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function iwt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{alpha:r}=s,a=e.makeTensorInfo([],"float32",pp(r,"float32")),o=Bt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gx(q8,i.shape,a.shape):new wg(W8,i.shape,a.shape),l=e.runWebGLProgram(o,[i,a],"float32");return e.disposeIntermediateTensorInfo(a),l}const rwt={kernelName:cA,backendName:"webgl",kernelFunc:iwt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X8="return (a < 0.) ? b * a : a;",j8=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function awt(n){const{inputs:t,backend:e}=n,{x:s,alpha:i}=t,r=Bt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gx(j8,s.shape,i.shape):new wg(X8,s.shape,i.shape);return e.runWebGLProgram(r,[s,i],"float32")}const owt={kernelName:NA,backendName:"webgl",kernelFunc:awt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hx="if (isnan(x)) return x;";function fs({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:s}){return({inputs:i,backend:r})=>{const{x:a}=i,o=r,l=s||a.dtype;if(o.shouldExecuteOnCPU([a])&&e!=null){const f=o.texData.get(a.dataId),p=e(f.values,l);return o.makeTensorInfo(a.shape,l,p)}const c=Bt().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let h;return c?h=new zd(a.shape,t):h=new sh(a.shape,n),o.runWebGLProgram(h,[a],l)}}function na({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:s=!1,cpuKernelImpl:i,dtype:r}){return({inputs:a,backend:o})=>{const{a:l,b:c}=a,h=o;if(s&&l.dtype==="complex64"){const v=h.texData.get(l.dataId),_=h.texData.get(c.dataId),[S,b]=[[v.complexTensorInfos.real,_.complexTensorInfos.real],[v.complexTensorInfos.imag,_.complexTensorInfos.imag]].map(C=>{const[A,I]=C,D={dataId:A.dataId,dtype:A.dtype,shape:l.shape},F={dataId:I.dataId,dtype:I.dtype,shape:c.shape},z=new wg(n,l.shape,c.shape);return h.runWebGLProgram(z,[D,F],Jo(A.dtype,I.dtype))}),T=Sp({inputs:{real:S,imag:b},backend:h});return h.disposeIntermediateTensorInfo(S),h.disposeIntermediateTensorInfo(b),T}const f=r||Jo(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||h.shouldExecuteOnCPU([l,c]))&&i!=null){const v=h.texData.get(l.dataId).values,_=h.texData.get(c.dataId).values,S=l.dtype==="string"?Af(v):v,b=l.dtype==="string"?Af(_):_,[T,C]=i(l.shape,c.shape,S,b,f),A=h.makeTensorInfo(C,f),I=h.texData.get(A.dataId);return I.values=T,A}const p=Bt().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let g;return p?g=new Gx(t,l.shape,c.shape,e):g=new wg(n,l.shape,c.shape),h.runWebGLProgram(g,[l,c],f)}}function P1(n,t=!1){if(n==="linear")return t?V_t:F_t;if(n==="relu")return t?H_t:U_t;if(n==="elu")return t?G_t:z_t;if(n==="relu6")return t?W_t:B_t;if(n==="prelu")return t?j8:X8;if(n==="leakyrelu")return t?q8:W8;if(n==="sigmoid")return t?q_t:P_t;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K8{constructor(t,e,s,i=!1,r=!1,a=!1,o=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=xa(this.outputShape.length);const h=i?t[1]:t[2],f=Math.ceil(h/2),p=i?"i * 2, rc.y":"rc.y, i * 2",g=r?"rc.z, i * 2":"i * 2, rc.z",v=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],_=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let S="",b="";o&&(l?S=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:c?S=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:S=`vec4 activation(vec4 x) {
          ${o}
        }`,b="result = activation(result);");const T=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let C="rc.x",A="rc.x";t[0]<e[0]?C=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(A=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${S}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${f}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${C};
        int batchB = ${A};
        for (int i = 0; i < ${f}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${g});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${v[0]} * ${_[0]});
          result += (${v[1]} * ${_[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${T}

        ${b}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bB={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class SB{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Rn(e,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _B="return a * b;";function d$(n){const{inputs:t,backend:e}=n,{a:s,b:i}=t,r=Jo(s.dtype,i.dtype);if(s.dtype==="complex64"){const o=e.texData.get(s.dataId),l=e.texData.get(i.dataId),c=new SB(bB.REAL,s.shape,i.shape),h=new SB(bB.IMAG,s.shape,i.shape),f=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:s.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],p=e.runWebGLProgram(c,f,"float32"),g=e.runWebGLProgram(h,f,"float32"),v=Sp({inputs:{real:p,imag:g},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),v}if(e.shouldExecuteOnCPU([s,i])){const o=e.texData.get(s.dataId),l=e.texData.get(i.dataId),[c,h]=a_t(s.shape,i.shape,o.values,l.values,r),f=e.makeTensorInfo(h,r),p=e.texData.get(f.dataId);return p.values=c,f}let a;return Bt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Gx(_B,s.shape,i.shape):a=new wg(_B,s.shape,i.shape),e.runWebGLProgram(a,[s,i],r)}const lwt={kernelName:BS,backendName:"webgl",kernelFunc:d$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cwt(n,t,e){const s=[yx(n.shape),...xx(n.shape)],i={dtype:n.dtype,shape:s,dataId:n.dataId},r=[yx(t),...xx(t)],a=new H8(r,s),o=!0,l=[s],c=e.runWebGLProgram(a,[i],n.dtype,l,o);return{dataId:c.dataId,shape:t,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ie(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{shape:r}=s,a=e,o=Zt(i.shape),l=PV(r,o),c=Zt(l);et(o===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const h=a.texData.get(i.dataId);return h.isPacked&&!H2(i.shape,l)&&!(h.texture!==null&&H2(h.shape,l))?cwt(i,l,a):(a.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype})}const uwt={kernelName:IA,backendName:"webgl",kernelFunc:Ie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wB{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:r,outSize:a}=t;this.outputShape=[i,a];const o=Math.floor(s/4)*4,l=s%4;let c="sumValue += dot(values, ones);";if(e!=null){const f=1/e;c=`sumValue += dot(values * ${lx(f)?f.toPrecision(2):f}, ones);`}let h="";r%s>0&&(h=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${o};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hwt{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:r,outSize:a}=t;this.outputShape=[i,a];let o="0.0",l="";e==="prod"?o="1.0":e==="min"?(o="1.0 / 1e-20",l="min"):e==="max"&&(o="-1.0 / 1e-20",l="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?c="sumValue":e==="prod"?c="prodValue":e==="all"?c="allValue":e==="any"&&(c="anyValue");const h=Math.floor(s/4)*4,f=s%4;let p=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,g="vec4";e==="all"?(o="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,g="bvec4"):e==="any"&&(o="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,g="bvec4");let v="";r%s>0&&(v=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${v}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${h};
        if (${f===1}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${f===2}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${f===3}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fwt(n){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const e=t.length?t[t.length-1].outSize:n[1],s=JA(e);t.push({inSize:e,windowSize:s,outSize:Math.ceil(e/s)})}return t}function jg(n,t,e,s){const i=fwt(n.shape);let r=n;for(let a=0;a<i.length;a++){const{inSize:o,windowSize:l,outSize:c}=i[a];let h,f;e==="mean"?h=a===0?new wB({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:c},o):new wB({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:c}):h=new hwt({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:c},e),f=r,r=s.runWebGLProgram(h,[r],t),f.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(f)}return r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dwt{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let a=0;a<s.length;a++)s[a]=t[e[a]];this.outputShape=s,this.rank=s.length;const i=Ws(this.rank),r=pwt(e);this.userCode=`
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `}}function pwt(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let i=0;i<n.length;i++)s[n[i]]=e[i];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mwt{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(t.length);for(let h=0;h<s.length;h++)s[h]=t[e[h]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=Ws(this.rank),r=G8("rc",this.rank),a=new Array(this.rank);for(let h=0;h<e.length;h++)a[e[h]]=r[h];const o=`vec2(${a.slice(-2).join()})`,l=`++${r[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${r[this.rank-1]};
      if(++${r[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gN(n,t,e){const s=Bt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mwt(n.shape,t):new dwt(n.shape,t);return e.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gwt(n,t,e,s){const i=t,r=n.shape.length,a=Wn(i,n.shape);let o=a;const l=Ti(o,r),c=l!=null;let h=n;c&&(h=gN(n,l,s),o=ji(o.length,r)),ea("sum",o,r);const[f,p]=zr(h.shape,o);let g=f;e&&(g=or(f,a));const v=Zt(p),S=Zt(n.shape)/v,b=Ie({inputs:{x:h},attrs:{shape:[S,v]},backend:s}),T=Tk(n.dtype),C=jg(b,T,"sum",s),A=Ie({inputs:{x:C},attrs:{shape:g},backend:s});return s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(C),c&&s.disposeIntermediateTensorInfo(h),A}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yN(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:a}=s;return gwt(i,r,a,e)}const ywt={kernelName:LA,backendName:"webgl",kernelFunc:yN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xa(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{perm:r}=s,a=e,o=i.shape.length,l=new Array(o);for(let h=0;h<l.length;h++)l[h]=i.shape[r[h]];let c;if(a.shouldExecuteOnCPU([i])){const f=a.texData.get(i.dataId).values,p=h$(f,i.shape,i.dtype,r,l);c=a.makeTensorInfo(l,i.dtype);const g=a.texData.get(c.dataId);g.values=p}else c=gN(i,r,a);return c}const xwt={kernelName:Hy,backendName:"webgl",kernelFunc:Xa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y8=1e3;function W2({a:n,b:t,transposeA:e,transposeB:s,backend:i,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const c=n.shape.length,h=t.shape.length,f=e?n.shape[c-2]:n.shape[c-1],p=s?t.shape[h-1]:t.shape[h-2],g=e?n.shape[c-1]:n.shape[c-2],v=s?t.shape[h-2]:t.shape[h-1],_=n.shape.slice(0,-2),S=t.shape.slice(0,-2),b=Zt(_),T=Zt(S),A=Rn(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([g,v]);et(f===p,()=>`Error in matMul: inner shapes (${f}) and (${p}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const I=e?[b,f,g]:[b,g,f],D=s?[T,v,p]:[T,p,v],F=Ie({inputs:{x:n},backend:i,attrs:{shape:I}}),z=Ie({inputs:{x:t},backend:i,attrs:{shape:D}}),k=[F,z],O=Math.max(b,T),L=e?F.shape[1]:F.shape[2],H=r!=null,q=a!=null,K=l==="leakyrelu",Y=l!=null?P1(l,!0):null,P=H||q||K||Y!=null;let W;if((g===1||v===1)&&L>Y8&&P===!1){let st=F,ot=z;e&&(st=Xa({inputs:{x:F},backend:i,attrs:{perm:[0,2,1]}}),k.push(st)),s&&(ot=Xa({inputs:{x:z},backend:i,attrs:{perm:[0,2,1]}}),k.push(ot));const X=v!==1,it=v===1;let ct=st;X&&(ct=Ie({inputs:{x:st},backend:i,attrs:{shape:[O,L,1]}}),k.push(ct));const yt=v===1?2:1;let Rt=ot;it&&(Rt=Ie({inputs:{x:ot},backend:i,attrs:{shape:[O,1,L]}}),k.push(Rt));const ft=d$({inputs:{a:ct,b:Rt},backend:i});W=yN({inputs:{x:ft},backend:i,attrs:{axis:yt,keepDims:!0}}),k.push(ft)}else{const st=Jo(n.dtype,t.dtype),ot=new K8(I,D,[O,g,v],e,s,H,Y,q,K),X=[F,z];if(r!=null&&X.push(r),q&&X.push(a),K){const it=i.makeTensorInfo([],"float32",pp(o,"float32"));X.push(it),k.push(it)}W=i.runWebGLProgram(ot,X,st)}const j=Ie({inputs:{x:W},backend:i,attrs:{shape:A}});k.push(W);for(const st of k)i.disposeIntermediateTensorInfo(st);return j}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vwt(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:r,bias:a,preluActivationWeights:o}=t,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:f}=s;return W2({a:i,b:r,transposeA:l,transposeB:c,backend:e,bias:a,preluActivationWeights:o,leakyreluAlpha:f,activation:h})}const bwt={kernelName:S2,backendName:"webgl",kernelFunc:vwt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TB="return abs(x);";function Swt(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const r=e.texData.get(s.dataId),a=P8(r.values);return e.makeTensorInfo(s.shape,s.dtype,a)}let i;return Bt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new zd(s.shape,TB):i=new sh(s.shape,TB),e.runWebGLProgram(i,[s],s.dtype)}const _wt={kernelName:GC,backendName:"webgl",kernelFunc:Swt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wwt=mc+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Twt=fs({opSnippet:wwt}),Ewt={kernelName:hS,backendName:"webgl",kernelFunc:Twt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cwt=mc+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Awt=fs({opSnippet:Cwt}),Nwt={kernelName:fS,backendName:"webgl",kernelFunc:Awt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EB="return a + b;",Mwt=na({opSnippet:EB,packedOpSnippet:EB,supportsComplex:!0,cpuKernelImpl:USt}),Iwt={kernelName:Ix,backendName:"webgl",kernelFunc:Mwt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rwt{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((r,a)=>`T${a}`);const s=[];this.variableNames.forEach(r=>{s.push(`float v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dwt{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((r,a)=>`T${a}`);const s=[];this.variableNames.forEach(r=>{s.push(`vec4 v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yE(n){const{inputs:t,backend:e}=n,s=t;if(s.length===1)return el({inputs:{x:s[0]},backend:e});if(s.length>Bt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),c=yE({inputs:s.slice(0,l),backend:e}),h=yE({inputs:s.slice(l),backend:e});return yE({inputs:[c,h],backend:e})}const i=s.map(l=>l.dtype).reduce((l,c)=>Jo(l,c)),r=s.map(l=>l.shape),o=Bt().getBool("WEBGL_PACK")?new Dwt(s[0].shape,r):new Rwt(s[0].shape,r);return e.runWebGLProgram(o,s,i)}const kwt={kernelName:F3,backendName:"webgl",kernelFunc:yE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Owt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:a}=s,o=i.shape.length,l=Wn(r,i.shape);let c=l;const h=Ti(c,o);let f=i;h!=null&&(f=Xa({inputs:{x:i},backend:e,attrs:{perm:h}}),c=ji(c.length,o)),ea("all",c,o);const[p,g]=zr(f.shape,c),v=Zt(g),_=Ie({inputs:{x:f},backend:e,attrs:{shape:[-1,v]}}),S=jg(_,_.dtype,"all",e);let b;if(a){const T=or(p,l);b=Ie({inputs:{x:S},backend:e,attrs:{shape:T}})}else b=Ie({inputs:{x:S},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(S),h!=null&&e.disposeIntermediateTensorInfo(f),b}const $wt={kernelName:z3,backendName:"webgl",kernelFunc:Owt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lwt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:a}=s,o=i.shape.length,l=Wn(r,i.shape);let c=l;const h=Ti(c,o);let f=i;h!=null&&(f=Xa({inputs:{x:i},backend:e,attrs:{perm:h}}),c=ji(c.length,o)),ea("any",c,o);const[p,g]=zr(f.shape,c),v=Zt(g),_=Ie({inputs:{x:f},backend:e,attrs:{shape:[-1,v]}}),S=jg(_,_.dtype,"any",e);let b;if(a){const T=or(p,l);b=Ie({inputs:{x:S},backend:e,attrs:{shape:T}})}else b=Ie({inputs:{x:S},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(S),h!=null&&e.disposeIntermediateTensorInfo(f),b}const Fwt={kernelName:U3,backendName:"webgl",kernelFunc:Lwt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zwt{constructor(t,e,s){this.variableNames=["A"];const{windowSize:i,batchSize:r,outSize:a}=t;s||this.variableNames.push("bestIndicesA"),this.outputShape=[r,a];const o=e==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uwt{constructor(t,e,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,et(t.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const r=t[t.length-1],a=Math.ceil(r/e);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),i||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,c=Ws(l),h=za("coords",l);let f,p;if(a===1){p=l+1;const z=Ws(p);f=`
        ${z} sourceLocR = ${z}(${h.join()}, 0);
        ++${h[l-1]};
        ${z} sourceLocG = ${z}(${h.join()}, 0);
        ++${h[l-2]};
        ${z} sourceLocA = ${z}(${h.join()}, 0);
        --${h[l-1]};
        ${z} sourceLocB = ${z}(${h.join()}, 0);
        --${h[l-2]};`}else p=l,f=`
        ${c} sourceLocR = coords;
        ++${h[l-1]};
        ${c} sourceLocG = coords;
        ++${h[l-2]};
        ${c} sourceLocA = coords;
        --${h[l-1]};
        ${c} sourceLocB = coords;
        --${h[l-2]};`;const g=["x","y","z","w","u","v"].slice(0,p),v="."+g[p-1],_=g.map(z=>"int "+z),S=za("sourceLocR",p-1).concat("inIdx.r"),b=za("sourceLocG",p-1).concat("inIdx.g"),T=za("sourceLocB",p-1).concat("inIdx.b"),C=za("sourceLocA",p-1).concat("inIdx.a"),A=s==="max"?"greaterThan":"lessThan",I=i?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${T.join()}),
                             getBestIndicesAChannel(${C.join()})));`,D=`vec4(
            getAChannel(${S.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${T.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${C.join()}) : 0.)`,F=i?"":`
      float getBestIndicesAChannel(${_.join()}) {
        return getChannel(getBestIndicesA(${g.join()}),
                                          vec2(${g.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${_.join()}) {
        return getChannel(getA(${g.join()}),
                               vec2(${g.slice(-2).join()}));
      }
      ${F}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${h[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${h[l-2]} < ${o[l-2]-1};
        ${f}
        ivec4 srcIdx = ivec4(sourceLocR${v}, sourceLocG${v},
          sourceLocB${v}, sourceLocA${v}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${D};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${I}
          vec4 candidate = ${D};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${A}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z8(n,t,e,s=null){let i=t.shape[0],r=t.shape[1];s!=null&&(i=s.shape[0],r=s.shape[1]);const a=JA(r),o={windowSize:a,inSize:r,batchSize:i,outSize:Math.ceil(r/a)},l=new zwt(o,e,s==null),c=[t];s!=null&&c.push(s);const h=n.runWebGLProgram(l,c,"int32");if(h.shape[1]===1)return h;const f=Z8(n,t,e,h);return n.disposeIntermediateTensorInfo(h),f}function Q8(n,t,e,s=null){const i=s!=null?s.shape:t.shape,r=i[i.length-1],a=JA(r),o=new Uwt(i,a,e,s==null),l=s==null?[t]:[t,s],c=n.runWebGLProgram(o,l,"int32");if(c.shape.length===t.shape.length){const h=Q8(n,t,e,c);return n.disposeIntermediateTensorInfo(c),h}return c}function J8(n,t,e,s){const i=[e];if(ea("arg"+s.charAt(0).toUpperCase()+s.slice(1),i,t.shape.length),!Bt().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const r=[],a=n.texData.get(t.dataId),o=a!==null&&a.isPacked;let l=t;o&&(l=n.unpackTensor(t),r.push(l));const[c,h]=zr(l.shape,i),f=Zt(h),p=Ie({inputs:{x:l},backend:n,attrs:{shape:[-1,f]}});r.push(p);const g=Z8(n,p,s);r.push(g);const v=Ie({inputs:{x:g},backend:n,attrs:{shape:c}});return r.forEach(_=>n.disposeIntermediateTensorInfo(_)),v}return Q8(n,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bwt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r}=s;let a=Wn(r,i.shape);const o=Ti(a,i.shape.length);let l=i;const c=[];o!=null&&(l=Xa({inputs:{x:i},backend:e,attrs:{perm:o}}),c.push(l),a=ji(a.length,l.shape.length)),ea("argMax",[a[0]],l.shape.length);const h=J8(e,l,a[0],"max");return c.forEach(f=>e.disposeIntermediateTensorInfo(f)),h}const Pwt={kernelName:HC,backendName:"webgl",kernelFunc:Bwt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vwt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r}=s;let a=Wn(r,i.shape);const o=Ti(a,i.shape.length);let l=i;const c=[];o!=null&&(l=Xa({inputs:{x:i},backend:e,attrs:{perm:o}}),c.push(l),a=ji(a.length,l.shape.length)),ea("argMin",[a[0]],l.shape.length);const h=J8(e,l,a[0],"min");return c.forEach(f=>e.disposeIntermediateTensorInfo(f)),h}const Gwt={kernelName:WC,backendName:"webgl",kernelFunc:Vwt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hwt=mc+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Wwt=fs({opSnippet:Hwt}),qwt={kernelName:dS,backendName:"webgl",kernelFunc:Wwt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xwt=mc+"return log(x + sqrt(x * x + 1.0));",jwt=fs({opSnippet:Xwt}),Kwt={kernelName:pS,backendName:"webgl",kernelFunc:jwt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ywt=mc+`
  return atan(x);
`,Zwt=fs({opSnippet:Ywt}),Qwt={kernelName:mS,backendName:"webgl",kernelFunc:Zwt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jwt=f$+`
  return atan(a, b);
`,tTt=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Xg+`
  return result;
`,eTt=na({opSnippet:Jwt,packedOpSnippet:tTt}),nTt={kernelName:yS,backendName:"webgl",kernelFunc:eTt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sTt=mc+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,iTt=fs({opSnippet:sTt}),rTt={kernelName:gS,backendName:"webgl",kernelFunc:iTt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V1{constructor(t,e,s,i=!1,r=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=t.filterWidth,o=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,h=t.dilationWidth,f=t.effectiveFilterHeight,p=t.effectiveFilterWidth,g=t.padInfo.top,v=t.padInfo.left;this.outputShape=t.outShape;const _=e==="avg",S=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,b=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let T="0.0";if(_||(T="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${g}, ${v});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${h}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i?r?S:b:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const C="max";let A=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(A="avgValue / max(count, 1.0)");const I=Math.floor(a/4)*4,D=a%4,F=`
      if (${_}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${g}, ${v});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${f};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC += 4) {
            int xC = xCCorner + wC * ${h};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              getValue(batch, xR, xC + 3 * ${h}, d)
            );

            ${F}
          }

          int xC = xCCorner + ${I};
          if (${D===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${D===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${D===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              initializationValue
            );

            ${F}
          }
        }
        setOutput(${A});
      }
    `}}class p${constructor(t,e,s,i=!1,r=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=t.filterWidth,o=t.strideDepth,l=t.strideHeight,c=t.strideWidth,h=t.dilationDepth,f=t.dilationHeight,p=t.dilationWidth,g=t.effectiveFilterDepth,v=t.effectiveFilterHeight,_=t.effectiveFilterWidth,S=t.padInfo.front,b=t.padInfo.top,T=t.padInfo.left;this.outputShape=t.outShape;const C=e==="avg";let A="0.0";if(C||(A="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${l}, ${c});
        const ivec3 pads = ivec3(${S}, ${b}, ${T});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${g};
              wD += ${h}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${v};
                wR += ${f}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${_};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i?r?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${v} * ${_} +
                      wR * ${_} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const I="max";let D=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(D="avgValue / max(count, 1.0)");const F=Math.floor(a/4)*4,z=a%4,k=`
      if (${C}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${l}, ${c});
      const ivec3 pads = ivec3(${S}, ${b}, ${T});
      const float initializationValue = ${A};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${A});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${g};
            wD += ${h}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${v};
            wR += ${f}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${F}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${k}
            }

            int xC = xCCorner + ${F};
            if (${z===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${k}
            } else if (${z===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${k}
            } else if (${z===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${k}
            }
          }
        }
        setOutput(${D});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aTt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;w_(i,"avgPool");const{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=s,c=1;et(ya(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=dc(i.shape,r,a,c,o,l);if(h.filterWidth===1&&h.filterHeight===1&&Is(h.inShape,h.outShape))return el({inputs:{x:i},backend:e});const f=new V1(h,"avg",!1);return e.runWebGLProgram(f,[i],"float32")}const oTt={kernelName:qC,backendName:"webgl",kernelFunc:aTt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lTt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:r,strides:a,pad:o,dimRoundingMode:l,dataFormat:c}=s,h=[1,1,1],f=Of(i.shape,r,a,h,o,l,c),p=new p$(f,"avg",!1);return e.runWebGLProgram(p,[i],"float32")}const cTt={kernelName:XC,backendName:"webgl",kernelFunc:lTt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uTt{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,i=t.strideHeight,r=t.strideWidth,a=t.dilationHeight,o=t.dilationWidth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,h=l-1-t.padInfo.top,f=c-1-t.padInfo.left,p=1/(e*s);this.userCode=`
      const ivec2 pads = ivec2(${h}, ${f});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class hTt{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,i=t.filterWidth,r=t.strideDepth,a=t.strideHeight,o=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,f=t.effectiveFilterDepth,p=t.effectiveFilterHeight,g=t.effectiveFilterWidth,v=f-1-t.padInfo.front,_=p-1-t.padInfo.top,S=g-1-t.padInfo.left,b=1/(e*s*i);this.userCode=`
      const ivec3 pads = ivec3(${v}, ${_}, ${S});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${g};
                wC += ${h}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fTt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r}=t,a=r,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s,f=[1,1,1],p=Of(a.shape,o,l,f,c,h),g=new hTt(p);return e.runWebGLProgram(g,[i],a.dtype)}const dTt={kernelName:P3,backendName:"webgl",kernelFunc:fTt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pTt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r}=t,a=r;w_([i,r],"avgPoolGrad");const{filterSize:o,strides:l,pad:c}=s,h=dc(a.shape,o,l,1,c),f=new uTt(h);return e.runWebGLProgram(f,[i],a.dtype)}const mTt={kernelName:B3,backendName:"webgl",kernelFunc:pTt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gTt(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:r}=t,{transposeA:a,transposeB:o}=s;return W2({a:i,b:r,transposeA:a,transposeB:o,backend:e})}const yTt={kernelName:jC,backendName:"webgl",kernelFunc:gTt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xTt{constructor(t,e,s,i,r,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Rn(t,e),Rn(t,s);let o="0.0";i!=null&&(Rn(t,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";r!=null&&(Rn(t,r),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vTt{constructor(t,e,s,i,r,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Rn(t,e),Rn(t,s);let o="vec4(0.0)";i!=null&&(Rn(t,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";r!=null&&(Rn(t,r),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bTt=({inputs:n,backend:t,attrs:e})=>{const{x:s,mean:i,variance:r,offset:a,scale:o}=n;et(i.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),et(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),et(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;l==null&&(l=.001);const c=[s,i,r];let h=null;a!=null&&(h=a.shape,c.push(a));let f=null;o!=null&&(f=o.shape,c.push(o));const p=Bt().getBool("WEBGL_PACK_NORMALIZATION")?new vTt(s.shape,i.shape,r.shape,h,f,l):new xTt(s.shape,i.shape,r.shape,h,f,l);return t.runWebGLProgram(p,c,c[0].dtype)},STt={kernelName:aA,backendName:"webgl",kernelFunc:bTt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _Tt{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Ws(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=wTt(this.rank);let i;const r=t.map((a,o)=>`sourceLoc.${eD[o]} = start[${o}] + coords.${eD[o]};`);i=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${r.join(`
`)}
      `,this.userCode=`
      void main() {
        ${i}
        setOutput(getSource(${s}));
      }
    `}}const eD=["x","y","z","w","u","v"];function wTt(n){if(n===1)return"sourceLoc";if(n<=6)return eD.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TTt{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=Ws(this.rank),s=za("coords",this.rank),i=za("sourceLoc",this.rank),r=this.rank===1?"sourceLoc":`vec2(${i.slice(-2).join()})`,a=`getChannel(getSource(${i.join()}), ${r})`,o=`
      result.x = ${a};
      if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
        ++${i[this.rank-1]};
        result.y = ${a};
        --${i[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${t[this.rank-2]}) {
        ++${i[this.rank-2]};
        result.z = ${a};
        if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
          ++${i[this.rank-1]};
          result.w = ${a};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((h,f)=>`start[${f}]`).join()});`:t.map((h,f)=>`${i[f]} = ${s[f]} + start[${f}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ETt(n,t,e,s){const i=s.texData.get(n.dataId),r=s.makeTensorInfo(e,n.dtype),a=s.texData.get(r.dataId);Object.assign(a,i),a.refCount=1,a.shape=e,a.dtype=n.dtype;let o=oO(t,ln(n.shape));i.slice&&(o+=i.slice.flatOffset),a.slice={flatOffset:o,origDataId:i.slice&&i.slice.origDataId||n.dataId};const l=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,l+1),r}function Wx(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:r,size:a}=s,[o,l]=QA(i,r,a);if(iO(i,o,l),Zt(l)===0)return e.makeTensorInfo(l,i.dtype,[]);if(e.shouldExecuteOnCPU([i])||i.dtype==="string"){const f=e.texData.get(i.dataId),p=y_t(f.values,o,l,i.shape,i.dtype);return e.makeTensorInfo(l,i.dtype,p)}const{isPacked:c}=e.texData.get(i.dataId),h=aO(i.shape,o,l);if(c||!h){const f=Bt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TTt(l):new _Tt(l),p=[o];return e.runWebGLProgram(f,[i],i.dtype,p)}return e.uploadToGPU(i.dataId),ETt(i,o,l,e)}const CTt={kernelName:$A,backendName:"webgl",kernelFunc:Wx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ATt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:r,crops:a}=s;et(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=r.reduce((T,C)=>T*C),l=f_(i.shape,r,o),c=d_(l.length,r.length),h=p_(i.shape,r,o),f=fO(a,r.length),p=dO(h,a,r.length),g=[],v=Ie({inputs:{x:i},backend:e,attrs:{shape:l}}),_=Xa({inputs:{x:v},backend:e,attrs:{perm:c}}),S=Ie({inputs:{x:_},backend:e,attrs:{shape:h}}),b=Wx({inputs:{x:S},backend:e,attrs:{begin:f,size:p}});return g.push(v),g.push(_),g.push(S),g.forEach(T=>e.disposeIntermediateTensorInfo(T)),b},NTt={kernelName:KC,backendName:"webgl",kernelFunc:ATt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MTt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:r}=t,{size:a}=s,o=e.readSync(i.dataId),l=e.readSync(r.dataId),c=B8(o,l,r.dtype,r.shape,a);return e.makeTensorInfo([a],r.dtype,c)}const ITt={kernelName:V3,backendName:"webgl",kernelFunc:MTt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RTt=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,DTt=`
  return float(int(a.r) & int(b.r));
`;function kTt(n){const{inputs:t,backend:e}=n,{a:s,b:i}=t,r=Bt().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=Bt().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([s,i])||a===1){const l=e.texData.get(s.dataId).values,c=e.texData.get(i.dataId).values,[h,f]=PSt(s.shape,i.shape,l,c,s.dtype),p=e.makeTensorInfo(f,s.dtype),g=e.texData.get(p.dataId);return g.values=h,p}let o;return r?o=new Gx(RTt,s.shape,i.shape,!1):o=new wg(DTt,s.shape,i.shape),e.runWebGLProgram(o,[s,i],s.dtype)}const OTt={kernelName:G3,backendName:"webgl",kernelFunc:kTt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Tt(n){const{inputs:t,backend:e}=n,{s0:s,s1:i}=t,r=e.readSync(s.dataId),a=e.readSync(i.dataId),o=Rn(Array.from(r),Array.from(a));return e.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const LTt={kernelName:XV,backendName:"webgl",kernelFunc:$Tt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FTt="return float(a != b);",tq=na({opSnippet:FTt,cpuKernelImpl:l_t,dtype:"bool"}),zTt={kernelName:wA,backendName:"webgl",kernelFunc:tq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E_(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.texData.get(s.dataId);return el({inputs:{x:i.complexTensorInfos.real},backend:e})}const UTt={kernelName:pk,backendName:"webgl",kernelFunc:E_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BTt="return float(int(x));";function PTt(n,t){const e=new sh(n.shape,BTt),s=t.runWebGLProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nD(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return el({inputs:{x:i},backend:e});const a=Dr(i.shape),o=nD({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),l=Sp({inputs:{real:o,imag:a},backend:e});return a.dispose(),e.disposeIntermediateTensorInfo(o),l}if(i.dtype==="complex64"){const a=E_({inputs:{input:i},backend:e}),o=nD({inputs:{x:a},backend:e,attrs:{dtype:r}});return e.disposeIntermediateTensorInfo(a),o}if(!VV(i.dtype,r)){const a=el({inputs:{x:i},backend:e});return{dataId:a.dataId,shape:a.shape,dtype:r}}if(e.shouldExecuteOnCPU([i])){const a=e.texData.get(i.dataId).values,[o,l,c]=VSt(a,i.shape,i.dtype,r);return e.makeTensorInfo(o,l,c)}if(r==="int32")return PTt(i,e);if(r==="bool"){const a=e.makeTensorInfo([],"bool",ma("bool",1)),l=tq({inputs:{a:i,b:a},backend:e});return e.disposeIntermediateTensorInfo(a),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${r}`)}const VTt={kernelName:xS,backendName:"webgl",kernelFunc:nD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CB="return ceil(x);",GTt=fs({opSnippet:CB,packedOpSnippet:CB,cpuKernelImpl:GSt}),HTt={kernelName:vS,backendName:"webgl",kernelFunc:GTt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WTt{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qTt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XTt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{clipValueMin:r,clipValueMax:a}=s;let o;Bt().getBool("WEBGL_PACK_CLIP")?o=new qTt(i.shape):o=new WTt(i.shape);const l=[[r],[a]];return e.runWebGLProgram(o,[i],i.dtype,l)}const jTt={kernelName:bS,backendName:"webgl",kernelFunc:XTt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KTt{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AB(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}function YTt(n){const{inputs:t,backend:e}=n,{x:s}=t,i=e.texData.get(s.dataId),r=new KTt(s.shape),a=[AB(s,i.complexTensorInfos.real),AB(s,i.complexTensorInfos.imag)];return e.runWebGLProgram(r,a,a[0].dtype)}const ZTt={kernelName:YC,backendName:"webgl",kernelFunc:YTt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QTt{constructor(t){this.outputShape=[],this.outputShape=lh(t,1),this.variableNames=t.map((a,o)=>`T${o}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let a=1;a<e.length;a++)e[a]=e[a-1]+t[a][1];const s=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<e.length;a++){const o=e[a-1];s.push(`else if (yC < ${e[a]}) setOutput(getT${a}(yR, yC-${o}));`)}const i=e.length,r=e[e.length-1];s.push(`else setOutput(getT${i}(yR, yC-${r}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JTt{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=lh(t,e);const s=this.outputShape,i=s.length,r=Ws(i),a=za("coords",i),o=["x","y","z","w","u","v"].slice(0,i);this.variableNames=t.map((_,S)=>`T${S}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let _=1;_<l.length;_++)l[_]=l[_-1]+t[_][e];const c=o[e],h=o.slice(-2),f=o.join();let p=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${f}), vec2(${h.join()}));
        }`;for(let _=1;_<l.length;_++){const S=l[_-1];p+=`
        if (${c} < ${l[_]}  && ${c} >= ${l[_-1]}) {
          return getChannel(
            getT${_}(${tE(o,c,S)}),
            vec2(${tE(h,c,S)}));
        }`}const g=l.length,v=l[l.length-1];p+=`
        return getChannel(
          getT${g}(${tE(o,c,v)}),
          vec2(${tE(h,c,v)}));`,this.userCode=`
      float getValue(${o.map(_=>"int "+_)}) {
        ${p}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[i-1]} = ${a[i-1]} + 1;
        if (${a[i-1]} < ${s[i-1]}) {
          result.g = getValue(${a});
        }

        ${a[i-2]} = ${a[i-2]} + 1;
        if (${a[i-2]} < ${s[i-2]}) {
          result.a = getValue(${a});
        }

        ${a[i-1]} = ${a[i-1]} - 1;
        if (${a[i-2]} < ${s[i-2]} &&
            ${a[i-1]} < ${s[i-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function tE(n,t,e){const s=n.indexOf(t);return n.map((r,a)=>a===s?`${r} - ${e}`:r).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xN(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.texData.get(s.dataId);return el({inputs:{x:i.complexTensorInfos.imag},backend:e})}const tEt={kernelName:ak,backendName:"webgl",kernelFunc:xN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jb(n,t,e){const s=n[0].dtype;if(s==="complex64"){const g=n.map(T=>E_({inputs:{input:T},backend:e})),v=n.map(T=>xN({inputs:{input:T},backend:e})),_=jb(g,t,e),S=jb(v,t,e),b=Sp({inputs:{real:_,imag:S},backend:e});return g.forEach(T=>e.disposeIntermediateTensorInfo(T)),v.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(S),b}let i=e.shouldExecuteOnCPU(n);if(s==="string"&&(i=!0),i){const g=n.map(A=>{const D=[-1,Zt(A.shape.slice(t))];return Ie({inputs:{x:A},backend:e,attrs:{shape:D}})}),v=g.map(A=>({vals:e.readSync(A.dataId),shape:A.shape})),_=lh(g.map(A=>A.shape),1),S=g[0].shape[0]===1,b=HSt(v,_,s,S),T=lh(n.map(A=>A.shape),t),C=e.makeTensorInfo(T,s,b);return g.forEach(A=>e.disposeIntermediateTensorInfo(A)),C}const r=n.filter(g=>Zt(g.shape)>0),a=Bt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1;if(r.length===1){const g=a?new sh(n[0].shape,Rd):new zd(n[0].shape,Rd);return e.runWebGLProgram(g,n,s)}const o=Bt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>o){const g=[];for(let _=0;_<r.length;_+=o){const S=r.slice(_,_+o);g.push(jb(S,t,e))}const v=jb(g,t,e);for(const _ of g)e.disposeIntermediateTensorInfo(_);return v}if(a){const g=new JTt(r.map(v=>v.shape),t);return e.runWebGLProgram(g,r,s)}const{tensors2D:l,outShape:c}=eEt(r,t,e),h=new QTt(l.map(g=>g.shape)),f=e.runWebGLProgram(h,l,s);l.forEach(g=>e.disposeIntermediateTensorInfo(g));const p=Ie({inputs:{x:f},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(f),p}function eEt(n,t,e){const s=lh(n.map(r=>r.shape),t);return{tensors2D:n.map(r=>Ie({inputs:{x:r},attrs:{shape:[-1,Zt(r.shape.slice(t))]},backend:e})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eq(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s,r=Wn(i,t[0].shape)[0],a=t.map(c=>c.shape);cO(a,r);const o=lh(t.map(c=>c.shape),r);if(Zt(o)===0)return e.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter(c=>Zt(c.shape)>0);return l.length===1?el({inputs:{x:l[0]},backend:e}):jb(l,r,e)}const nEt={kernelName:ZC,backendName:"webgl",kernelFunc:eq};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nq{constructor(t,e=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const a=t.padInfo.top,o=t.padInfo.left,l=t.strideHeight,c=t.strideWidth,h=t.dilationHeight,f=t.dilationWidth,p=t.filterHeight,g=t.filterWidth,v=Math.floor(t.inChannels/4)*4,_=t.inChannels%4,S=t.dataFormat==="channelsLast",b=S?1:2,T=S?2:3,C=S?3:1;let A="",I="";s&&(i?A=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?A=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:A=`
          float activation(float x) {
            ${s}
          }
        `,I="result = activation(result);");const D=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${A}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${C}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${T}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${h};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${g}; wC++) {
            int xC = xCCorner + wC * ${f};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${v}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${S}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${_===1}) {

              if (${S}) {
                dotProd +=
                    getX(batch, xR, xC, ${v}) *
                    getW(wR, wC, ${v}, d2);
              } else {
                dotProd +=
                    getX(batch, ${v}, xR, xC) *
                    getW(wR, wC, ${v}, d2);
              }

            } else if (${_===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${v}, d2),
                getW(wR, wC, ${v} + 1, d2)
              );

              if (${S}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${v}),
                  getX(batch, xR, xC, ${v} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${v}, xR, xC),
                  getX(batch, ${v} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${_===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${v}, d2),
                getW(wR, wC, ${v} + 1, d2),
                getW(wR, wC, ${v} + 2, d2)
              );

              if (${S}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${v}),
                  getX(batch, xR, xC, ${v} + 1),
                  getX(batch, xR, xC, ${v} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${v}, xR, xC),
                  getX(batch, ${v} + 1, xR, xC),
                  getX(batch, ${v} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${D}
        ${I}
        setOutput(result);
      }
    `}}class sEt{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,s=t.padInfo.top,i=t.padInfo.left,r=t.strideDepth,a=t.strideHeight,o=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,f=t.filterDepth,p=t.filterHeight,g=t.filterWidth,v=Math.floor(t.inChannels/4)*4,_=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${r}, ${a}, ${o});
      const ivec3 pads = ivec3(${e}, ${s}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${f}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${g}; wC++) {
              int xC = xCCorner + wC * ${h};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${v}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${_===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${v}) *
                  getW(wF, wR, wC, ${v}, d2);
              } else if (${_===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${v}),
                  getX(batch, xF, xR, xC, ${v} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${v}, d2),
                  getW(wF, wR, wC, ${v} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${_===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${v}),
                  getX(batch, xF, xR, xC, ${v} + 1),
                  getX(batch, xF, xR, xC, ${v} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${v}, d2),
                  getW(wF, wR, wC, ${v} + 1, d2),
                  getW(wF, wR, wC, ${v} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sq{constructor(t,e=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=xa(this.outputShape.length);const a=t.padInfo.left,o=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,h=t.filterWidth,f=h;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<h;S++)p+=`
           vec4 xTexelC${S*2};
           int xTexelC${S*2}Ready;
           vec4 xTexelC${S*2+1};
           int xTexelC${S*2+1}Ready;
           vec4 xC${S};`;p+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let S=0;S<h;S++)p+=`
           xTexelC${S*2} = vec4(0.0);
           xTexelC${S*2}Ready = 0;
           xTexelC${S*2+1} = vec4(0.0);
           xTexelC${S*2+1}Ready = 0;
           xC${S} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let S=0;S<(f+1)/2;S++){const b=S*2;if(p+=`
           xC = xCCorner + ${b*l};
           `,o===1){if(b<h&&(a%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,l===1&&b>0?p+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<h)){const T=a%2===0?D3(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${T};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,l>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:p+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):T===1?p+=`
                     xC${b+1} = xTexelC${b};
                     `:p+=`
                     xCOffset = xC + ${T};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<h&&(a%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<h&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<h&&(p+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<h&&(p+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<h&&(p+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let g="",v="";s&&(i?g=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:r?g=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:g=`vec4 activation(vec4 x) {
           ${s}
         }`,v="result = activation(result);");const _=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${g}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${_}
         ${v}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iEt{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=xa(this.outputShape.length);const{dataFormat:s}=e,i=ja(),r=s==="channelsLast",a=r?1:2,o=r?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let h=0;h<=1;h++)for(let f=0;f<=1;f++)c+=`
          blockIndex = rc.z + ${f};
          pos = rc.y + ${h};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${h*2+f}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${h*2+f}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${i.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q2(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&e===1&&n[0]>1?[n[0],1]:null}function iq({x:n,filter:t,convInfo:e,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:o=null}){const l=n.shape,c=s.texData.get(n.dataId),h=e.inChannels,f=l[0]*l[1]*l[2],p=e.outChannels,g=e.dataFormat==="channelsLast",v=!1,_=!1;let S;const b=[];if(r!=null){const A=q2(r.shape,g);A!=null&&(r=Ie({inputs:{x:r},backend:s,attrs:{shape:A}}),b.push(r))}if(i!=null){const A=q2(i.shape,g);A!=null&&(i=Ie({inputs:{x:i},backend:s,attrs:{shape:A}}),b.push(i))}if(!((f===1||p===1)&&h>Y8)&&c.isPacked&&g&&c.texture!=null&&l[2]%2!==0&&Is(c.shape.slice(-3),l.slice(-3))){const A=l[0]*l[1]*(l[2]+1),I={dataId:n.dataId,shape:[1,A,e.inChannels],dtype:n.dtype},D=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,et(H2(c.shape,I.shape),()=>`packed reshape ${c.shape} to ${I.shape} isn't free`);const F=Ie({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});b.push(F);const z=W2({a:I,b:F,backend:s,transposeA:v,transposeB:_,bias:i,activation:o,preluActivationWeights:r,leakyreluAlpha:a}),k=s.texData.get(z.dataId);et(k.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=D,k.shape=e.outShape,S=el({inputs:{x:z},backend:s}),S.shape=e.outShape,b.push(z)}else{const A=e.outHeight*e.outWidth,I=Ie({inputs:{x:n},backend:s,attrs:{shape:g?[e.batchSize,A,e.inChannels]:[e.batchSize,e.inChannels,A]}}),D=Ie({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}}),F=W2({a:g?I:D,b:g?D:I,transposeA:!g,transposeB:_,backend:s,bias:i,activation:o,preluActivationWeights:r,leakyreluAlpha:a});S=Ie({inputs:{x:F},backend:s,attrs:{shape:e.outShape}}),b.push(I),b.push(D),b.push(F)}for(const A of b)s.disposeIntermediateTensorInfo(A);return S}function rq({x:n,filter:t,convInfo:e,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:l,filterHeight:c,inChannels:h,outWidth:f,outHeight:p,dataFormat:g}=e,v=g==="channelsLast",_=l*c*h,S=p*f,b=[e.batchSize,_,S],T=!0,C=!1,A=[];if(r!=null){const j=q2(r.shape,v);j!=null&&(r=Ie({inputs:{x:r},backend:s,attrs:{shape:j}}),A.push(r))}if(i!=null){const j=q2(i.shape,v);j!=null&&(i=Ie({inputs:{x:i},backend:s,attrs:{shape:j}}),A.push(i))}const I=Ie({inputs:{x:t},backend:s,attrs:{shape:[1,_,Zt(t.shape)/_]}});A.push(I);const D=new iEt(b,e),F=[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],z=s.runWebGLProgram(D,[n],"float32",F),k=Ie({inputs:{x:z},backend:s,attrs:{shape:b}});A.push(z),A.push(k);const O=i!=null,L=r!=null,H=o==="leakyrelu",q=o?P1(o,!0):null,K=new K8(v?k.shape:I.shape,v?I.shape:k.shape,v?[e.batchSize,S,e.outChannels]:[e.batchSize,e.outChannels,S],T,C,O,q,L,H),Y=v?[k,I]:[I,k];if(i&&Y.push(i),L&&Y.push(r),H){const j=s.makeTensorInfo([],"float32",pp(a,"float32"));Y.push(j),A.push(j)}const P=s.runWebGLProgram(K,Y,"float32"),W=Ie({inputs:{x:P},backend:s,attrs:{shape:e.outShape}});A.push(P);for(const j of A)s.disposeIntermediateTensorInfo(j);return W}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rEt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:a,pad:o,dataFormat:l,dilations:c,dimRoundingMode:h}=s,f=$f(l),p=ta(i.shape,r.shape,a,c,o,h,!1,f);let g;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))g=iq({x:i,filter:r,convInfo:p,backend:e});else if(p.strideWidth<=2&&f==="channelsLast"&&Bt().getBool("WEBGL_EXP_CONV")){const _=new sq(p),S=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];g=e.runWebGLProgram(_,[i,r],"float32",S)}else if(Bt().getBool("WEBGL_CONV_IM2COL"))g=rq({x:i,filter:r,convInfo:p,backend:e});else{const _=new nq(p);g=e.runWebGLProgram(_,[i,r],"float32")}const v=Ie({inputs:{x:g},backend:e,attrs:{shape:p.outShape}});return e.disposeIntermediateTensorInfo(g),v}const aEt={kernelName:QC,backendName:"webgl",kernelFunc:rEt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oEt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,i=t.padInfo.top,r=t.padInfo.left,a=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${i};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class lEt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,i=t.strideHeight,r=t.strideWidth,a=t.dataFormat==="channelsLast",o=e-1-t.padInfo.top,l=s-1-t.padInfo.left,c=a?1:2,h=a?2:3,f=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${f}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${h}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class cEt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,s=t.strideHeight,i=t.strideWidth,r=t.padInfo.front,a=t.padInfo.top,o=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${r};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${a};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${o};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class uEt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,i=t.filterWidth,r=t.strideDepth,a=t.strideHeight,o=t.strideWidth,l=e-1-t.padInfo.front,c=s-1-t.padInfo.top,h=i-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hEt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:r}=t,{strides:a,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:h}=s,f=$f(l),p=ta(i.shape,h,a,1,o,c,!1,f),g=new oEt(p);return e.runWebGLProgram(g,[i,r],"float32")}const fEt={kernelName:W3,backendName:"webgl",kernelFunc:hEt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dEt{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=xa(this.outputShape.length);const e=t.filterHeight,s=t.filterWidth,i=e-1-t.padInfo.top,r=s-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${r});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pEt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:r}=t,{inputShape:a,strides:o,pad:l,dataFormat:c,dimRoundingMode:h}=s,f=$f(c),p=ta(a,r.shape,o,1,l,h,!1,f);if(Bt().getBool("WEBGL_PACK")&&f==="channelsLast"){const g=[[p.strideHeight,p.strideWidth]],v=new dEt(p);return e.runWebGLProgram(v,[i,r],"float32",g)}else{const g=new lEt(p);return e.runWebGLProgram(g,[i,r],"float32")}}const mEt={kernelName:JC,backendName:"webgl",kernelFunc:pEt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gEt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:a,pad:o,dilations:l}=s,c=mp(i.shape,r.shape,a,l,o),h=new sEt(c);return e.runWebGLProgram(h,[i,r],"float32")}const yEt={kernelName:tA,backendName:"webgl",kernelFunc:gEt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xEt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:r}=t,{strides:a,pad:o,filterShape:l}=s,c=mp(i.shape,l,a,1,o),h=new cEt(c);return e.runWebGLProgram(h,[i,r],"float32")}const vEt={kernelName:q3,backendName:"webgl",kernelFunc:xEt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bEt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:r}=t,{pad:a,strides:o,inputShape:l}=s,c=mp(l,r.shape,o,1,a),h=new uEt(c);return e.runWebGLProgram(h,[i,r],"float32")}const SEt={kernelName:X3,backendName:"webgl",kernelFunc:bEt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Et=Hx+`
  return cos(x);
`,wEt=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Xg}
  return result;
`,TEt=fs({opSnippet:_Et,packedOpSnippet:wEt}),EEt={kernelName:SS,backendName:"webgl",kernelFunc:TEt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CEt=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,AEt=fs({opSnippet:CEt}),NEt={kernelName:_S,backendName:"webgl",kernelFunc:AEt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MEt{constructor(t,e,s,i,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,o,l,c]=t,[h]=e,[f,p]=s;this.outputShape=[h,f,p,c];const g=i==="bilinear"?1:0,[v,_]=[`${o-1}.0`,`${l-1}.0`],[S,b,T]=f>1?[`${(o-1)/(f-1)}`,"(y2-y1) * height_ratio",`y1*${v} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${v}`],[C,A,I]=p>1?[`${(l-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${_} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${_}`];this.userCode=`
      const float height_ratio = float(${S});
      const float width_ratio = float(${C});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${A};

        float in_y = ${T};
        if( in_y < 0.0 || in_y > ${v} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${I};
        if( in_x < 0.0 || in_x > ${_} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${g} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IEt=n=>{const{inputs:t,backend:e,attrs:s}=n,{image:i,boxes:r,boxInd:a}=t,{cropSize:o,method:l,extrapolationValue:c}=s,h=new MEt(i.shape,r.shape,o,l,c);return e.runWebGLProgram(h,[i,r,a],"float32")},REt={kernelName:K3,backendName:"webgl",kernelFunc:IEt};var G1;(function(n){n.Prod="*",n.Sum="+"})(G1||(G1={}));class NB{constructor(t,e,s,i){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,a=this.op===G1.Prod?"1.0":"0.0",o=s?a:`getX(${MB(r,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",h="";s?(c=i?`end != ${l-1}`:"end != 0",h=i?"end + 1":"end - 1"):(c=i?`end + pow2 < ${l}`:"end >= pow2",h=i?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ws(r)} coords = getOutputCoords();
        int end = ${IB(r,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${h};
          ${IB(r,"coords",this.op)} = idx;
          val ${this.op}= getX(${MB(r,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function MB(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function IB(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aq(n,t,e,s,i,r){const a=t.shape.length,o=Ti([s],a);let l=t;o!=null&&(l=Xa({inputs:{x:t},backend:e,attrs:{perm:o}}));const c=ji(1,a)[0];if(c!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const h=l.shape[c];let f=el({inputs:{x:l},backend:e});for(let p=0;p<=Math.ceil(Math.log2(h))-1;p++){const g=new NB(n,l.shape,!1,r),v=[[p]],_=f;f=e.runWebGLProgram(g,[f],f.dtype,v),e.disposeIntermediateTensorInfo(_)}if(i){const p=new NB(n,l.shape,i,r),g=f;f=e.runWebGLProgram(p,[f],f.dtype),e.disposeIntermediateTensorInfo(g)}if(o!=null){const p=gp(o),g=Xa({inputs:{x:f},backend:e,attrs:{perm:p}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(l),g}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DEt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,exclusive:a,reverse:o}=s;return aq(G1.Prod,i,e,r,a,o)}const kEt={kernelName:j3,backendName:"webgl",kernelFunc:DEt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OEt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,exclusive:a,reverse:o}=s;return aq(G1.Sum,i,e,r,a,o)}const $Et={kernelName:eA,backendName:"webgl",kernelFunc:OEt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LEt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:r}=t,{size:a,binaryOutput:o}=s;if(i.shape.length===1){const l=e.readSync(i.dataId),c=e.readSync(r.dataId),h=B8(l,c,r.dtype,r.shape,a);return e.makeTensorInfo([a],r.dtype,h)}else if(i.shape.length===2){const l=e.bufferSync(i),c=e.bufferSync(r),h=BSt(l,c,a,o);return e.makeTensorInfo(h.shape,r.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const FEt={kernelName:Y3,backendName:"webgl",kernelFunc:LEt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zEt{constructor(t,e,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UEt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockSize:r,dataFormat:a}=s,o=i.shape[0],l=a==="NHWC"?i.shape[1]:i.shape[2],c=a==="NHWC"?i.shape[2]:i.shape[3],h=a==="NHWC"?i.shape[3]:i.shape[1],f=l*r,p=c*r,g=h/(r*r),v=a==="NHWC"?[o,f,p,g]:[o,g,f,p],_=new zEt(v,r,a);return e.runWebGLProgram(_,[i],i.dtype)}const BEt={kernelName:Z3,backendName:"webgl",kernelFunc:UEt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oq{constructor(t,e=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=xa(this.outputShape.length);const a=t.filterHeight,o=t.filterWidth,l=t.outChannels/t.inChannels;let c="",h="";s&&(i?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,h="result = activation(result);");const f=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${f}
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lq{constructor(t,e=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=xa(this.outputShape.length);const a=t.outChannels/t.inChannels,o=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,h=t.filterHeight,f=t.filterWidth,p=f;let g=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<f;b++)g+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;g+=`
    for (int r = 0; r < ${h}; r++) {
      `;for(let b=0;b<f;b++)g+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;g+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(p+1)/2;b++){const T=b*2;if(g+=`
          xC = xCCorner + ${T*c};
          `,l===1){if(T<f&&(o%2===1?(g+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }
              `,c===1&&T>0?g+=`
                xC${T} = vec4(xTexelC${T-2}.zw, xTexelC${T}.xy);
                `:g+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${T} = vec4(previous.zw, xTexelC${T}.xy);
                  } else {
                    xC${T} = vec4(0.0, 0.0, xTexelC${T}.xy);
                  }
                  `):g+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xC${T} = xTexelC${T};
                `,T+1<f)){const C=o%2===0?D3(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(g+=`
                  xCOffset = xC + imod(pads[1], 2) + ${C};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                    xTexelC${T+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${T+1}.zw = vec2(0.0);
                    }
                    xTexelC${T+1}Ready = 1;
                  }
                  `,c>1?g+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${T+1} = vec4(previous.zw, xTexelC${T+1}.xy);
                    } else {
                     xC${T+1} = vec4(0.0, 0.0, xTexelC${T+1}.xy);
                    }
                    `:g+=`
                    xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.xy);
                    `):C===1?g+=`
                    xC${T+1} = xTexelC${T};
                    `:g+=`
                    xCOffset = xC + ${C};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                      xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${T+1}.zw = vec2(0.0);
                      }
                      xTexelC${T+1}Ready = 1;
                    }

                    xC${T+1} = xTexelC${T+1};
                    `}}else T<f&&(o%2===1?(g+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.0);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
              `,T+1<f&&(g+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${T+1} = vec4(xTexelC${T+1}.xy, final.xy);
                `)):(g+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(
                  xTexelC${T}.xy, xTexelC${T+1}.xy);
              `,T+1<f&&(g+=`
                  xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
                `)));T<f&&(g+=`
            wTexel = getW(r, ${T}, d1, q);
            dotProd += xC${T} * vec4(wTexel.xz, wTexel.xz);
          `,T+1<f&&(g+=`
              wTexel = getW(r, ${T+1}, d1, q);
              dotProd += xC${T+1} * vec4(wTexel.xz, wTexel.xz);
            `))}g+=`
    }
  `,g+=`
      }
    `;let v="",_="";s&&(i?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:v=`vec4 activation(vec4 x) {
          ${s}
        }`,_="result = activation(result);");const S=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${g}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${S}
        ${_}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PEt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:a,pad:o,dilations:l,dimRoundingMode:c}=s;let h=l;h==null&&(h=[1,1]),et(ya(a,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const f=ta(i.shape,r.shape,a,h,o,c,!0);let p;Bt().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1?p=new lq(f):p=new oq(f);const g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return e.runWebGLProgram(p,[i,r],"float32",g)}const VEt={kernelName:nA,backendName:"webgl",kernelFunc:PEt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GEt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,i=t.padInfo.top,r=t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${i};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class HEt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,i=t.strideHeight,r=t.strideWidth,a=e-1-t.padInfo.top,o=s-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WEt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:r}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:c,filterShape:h}=s,f=ta(i.shape,h,a,o,l,c,!0),p=new GEt(f);return e.runWebGLProgram(p,[i,r],"float32")}const qEt={kernelName:Q3,backendName:"webgl",kernelFunc:WEt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XEt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:r}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:c,inputShape:h}=s,f=ta(h,r.shape,a,o,l,c,!0),p=new HEt(f);return e.runWebGLProgram(p,[i,r],"float32")}const jEt={kernelName:J3,backendName:"webgl",kernelFunc:XEt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KEt{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YEt(n){const{inputs:t,backend:e}=n,{x:s}=t,i=[...s.shape,...s.shape],r=Zt(s.shape),a=Ie({inputs:{x:s},backend:e,attrs:{shape:[r]}}),o=new KEt(r),l=e.runWebGLProgram(o,[a],a.dtype),c=Ie({inputs:{x:l},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}const ZEt={kernelName:jV,backendName:"webgl",kernelFunc:YEt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QEt{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:s,padInfo:i,strideHeight:r,strideWidth:a,filterHeight:o,filterWidth:l,dilationHeight:c,dilationWidth:h}=t,{top:f,left:p}=i;this.userCode=`
      const ivec2 strides = ivec2(${r}, ${a});
      const ivec2 pads = ivec2(${f}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${h};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JEt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:a,pad:o,dilations:l}=s,c=o_(i.shape,r.shape,a,o,"NHWC",l);let h;const f=new QEt(c);h=e.runWebGLProgram(f,[i,r],"float32");const p=Ie({inputs:{x:h},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(h),p}const t2t={kernelName:sA,backendName:"webgl",kernelFunc:JEt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e2t(n){const{inputs:t,backend:e,attrs:s}=n,{equation:i}=s,r=t,{allDims:a,summedDims:o,idDims:l}=SO(i,r.length);wO(a.length,l,r);const{path:c,steps:h}=TO(o,l),f=h.length;let p=null,g=a.length;const v=[];for(let _=0;_<f;++_){for(const S of h[_]){const{permutationIndices:b,expandDims:T}=_O(g,l[S]);let C;EO(b)?C=r[S]:(C=Xa({inputs:{x:r[S]},backend:e,attrs:{perm:b}}),v.push(C));const A=C.shape.slice();for(let I=0;I<T.length;++I)A.splice(T[I],0,1);Is(C.shape,A)||(C=Ie({inputs:{x:C},backend:e,attrs:{shape:A}}),v.push(C)),p===null?p=C:(p=d$({inputs:{a:C,b:p},backend:e}),v.push(p))}_<f-1&&(c[_]>=0&&(p=yN({inputs:{x:p},backend:e,attrs:{axis:c[_]-(a.length-g),keepDims:!1}}),v.push(p)),g--)}for(const _ of v)_!==p&&e.disposeIntermediateTensorInfo(_);return p}const n2t={kernelName:tk,backendName:"webgl",kernelFunc:e2t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s2t="return (x >= 0.0) ? x : (exp(x) - 1.0);",i2t=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,r2t=fs({opSnippet:s2t,packedOpSnippet:i2t}),a2t={kernelName:TS,backendName:"webgl",kernelFunc:r2t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o2t="return (b >= 0.0) ? a : a * (b + 1.0);",l2t=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,c2t=n=>{const{inputs:t,backend:e}=n,{dy:s,y:i}=t,r=Bt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gx(l2t,s.shape,i.shape):new wg(o2t,s.shape,i.shape);return e.runWebGLProgram(r,[s,i],s.dtype)},u2t={kernelName:ek,backendName:"webgl",kernelFunc:c2t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h2t=`
  return vec4(equal(a, b));
`,f2t="return float(a == b);",d2t=na({opSnippet:f2t,packedOpSnippet:h2t,dtype:"bool",cpuKernelImpl:WSt}),p2t={kernelName:iA,backendName:"webgl",kernelFunc:d2t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m2t=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${pO};
  float a1 = ${mO};
  float a2 = ${gO};
  float a3 = ${yO};
  float a4 = ${xO};
  float a5 = ${vO};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,g2t=fs({opSnippet:m2t}),y2t={kernelName:ES,backendName:"webgl",kernelFunc:g2t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x2t=Hx+`
  return exp(x);
`,v2t=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cq=fs({opSnippet:x2t,packedOpSnippet:v2t,cpuKernelImpl:qSt,dtype:"float32"}),b2t={kernelName:CS,backendName:"webgl",kernelFunc:cq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sD(n){const{inputs:t,attrs:e,backend:s}=n,{dim:i}=e,{input:r}=t,a=r.shape.length,o=r.shape.slice();let l=i;return i<0&&(et(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+i+1),o.splice(l,0,1),Ie({inputs:{x:r},backend:s,attrs:{shape:o}})}const S2t={kernelName:rA,backendName:"webgl",kernelFunc:sD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RB="return exp(x) - 1.0;",_2t=fs({opSnippet:RB,packedOpSnippet:RB,cpuKernelImpl:XSt}),w2t={kernelName:AS,backendName:"webgl",kernelFunc:_2t};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DB{constructor(t,e,s){this.variableNames=["real","imag"];const i=e[1];this.outputShape=e;const r=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=s?`${i}.0`:"1.0";let o;if(t==="real")o="return real * expR - imag * expI;";else if(t==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uq(n,t,e){const s=e.texData.get(n.dataId),i=Zt(n.shape),r=n.shape[n.shape.length-1],a=i/r,o=Ie({inputs:{x:n},backend:e,attrs:{shape:[a,r]}}),l=o.shape,c=new DB("real",l,t),h=new DB("imag",l,t),f=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],p=e.runWebGLProgram(c,f,"float32"),g=e.runWebGLProgram(h,f,"float32"),v=Sp({inputs:{real:p,imag:g},backend:e});e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g);const _=Ie({inputs:{x:v},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(v),_}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T2t(n){const{inputs:t,backend:e}=n,{input:s}=t;return uq(s,!1,e)}const E2t={kernelName:nk,backendName:"webgl",kernelFunc:T2t};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C2t{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C_(n){const{backend:t,attrs:e}=n,{shape:s,value:i}=e;let{dtype:r}=e;if(r=r||Nx(i),r==="string"){const a=Hi(r,Zt(s));return a.fill(i),t.makeTensorInfo(s,r,a)}else{const a=new C2t(s,i),o=[[i]];return t.runWebGLProgram(a,[],r,o)}}const A2t={kernelName:sk,backendName:"webgl",kernelFunc:C_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N2t{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M2t={kernelName:ik,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,s=t,i=new N2t(e.shape);return s.runWebGLProgram(i,[e],e.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kB="return floor(x);",I2t=fs({opSnippet:kB,packedOpSnippet:kB,cpuKernelImpl:jSt}),R2t={kernelName:NS,backendName:"webgl",kernelFunc:I2t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D2t=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,k2t=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,O2t=na({opSnippet:D2t,packedOpSnippet:k2t,dtype:"int32"}),$2t={kernelName:MS,backendName:"webgl",kernelFunc:O2t};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class L2t{constructor(t){this.variableNames=["A"];const e=ja(),[s,i]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${s}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F2t{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=ja(),[s,i]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${s}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z2t={kernelName:trt,backendName:"webgl",kernelFunc:U2t};let My,PI=Bt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function U2t(n){const{inputs:t,backend:e,attrs:s}=n;let{pixels:i}=t;const{numChannels:r}=s,a=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,c]=a?[i.videoWidth,i.videoHeight]:[i.width,i.height],h=[c,l],f=[c,l,r];if(o||a){const _=Bt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(My==null||_!==PI)&&(PI=_,My=document.createElement("canvas").getContext("2d",{willReadFrequently:PI})),My.canvas.width=l,My.canvas.height=c,My.drawImage(i,0,0,l,c),i=My.canvas}const p=e.makeTensorInfo(h,"int32");e.texData.get(p.dataId).usage=wl.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(p.dataId),i);const g=Bt().getBool("WEBGL_PACK")?new F2t(f):new L2t(f),v=e.runWebGLProgram(g,[p],"int32");return e.disposeData(p.dataId),v}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B2t(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r,bias:a,preluActivationWeights:o}=t,{strides:l,pad:c,dataFormat:h,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:v}=s,_=$f(h),S=ta(i.shape,r.shape,l,f,c,p,!1,_);let b;const T=[],C=a!=null,A=o!=null,I=g==="leakyrelu",D=()=>{const z=[i,r],k=(O,L)=>{if(L==="NCHW"&&O.shape.length===1&&O.shape[0]!==1){const H=Ie({inputs:{x:O},backend:e,attrs:{shape:[O.shape[0],1,1]}});return T.push(H),H}return O};if(C&&z.push(k(a,h)),A&&z.push(k(o,h)),I){const O=e.makeTensorInfo([],"float32",pp(v,"float32"));z.push(O),T.push(O)}return z};if(S.filterHeight===1&&S.filterWidth===1&&S.dilationHeight===1&&S.dilationWidth===1&&S.strideHeight===1&&S.strideWidth===1&&(S.padInfo.type==="SAME"||S.padInfo.type==="VALID"))b=iq({x:i,filter:r,convInfo:S,backend:e,bias:a,activation:g,preluActivationWeights:o,leakyreluAlpha:v});else if(S.strideWidth<=2&&_==="channelsLast"&&Bt().getBool("WEBGL_EXP_CONV")){const z=g?P1(g,!0):null,k=new sq(S,C,z,A,I),O=[[S.padInfo.top,S.padInfo.left],[S.strideHeight,S.strideWidth],[S.dilationHeight,S.dilationWidth],[S.inHeight,S.inWidth]],L=D();b=e.runWebGLProgram(k,L,"float32",O)}else if(Bt().getBool("WEBGL_CONV_IM2COL"))b=rq({x:i,filter:r,convInfo:S,backend:e,bias:a,activation:g,preluActivationWeights:o,leakyreluAlpha:v});else{const z=g?P1(g,!1):null,k=new nq(S,C,z,A,I),O=D();b=e.runWebGLProgram(k,O,"float32")}const F=Ie({inputs:{x:b},backend:e,attrs:{shape:S.outShape}});return T.push(b),T.forEach(z=>e.disposeIntermediateTensorInfo(z)),F}const P2t={kernelName:_2,backendName:"webgl",kernelFunc:B2t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V2t(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r,bias:a,preluActivationWeights:o}=t,{strides:l,pad:c,dilations:h,dimRoundingMode:f,activation:p,leakyreluAlpha:g}=s,v=[];let _=h;_==null&&(_=[1,1]),et(ya(l,_),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${_}'`);const S=ta(i.shape,r.shape,l,_,c,f,!0),b=Bt().getBool("WEBGL_PACK_DEPTHWISECONV")&&S.strideWidth<=2&&S.outChannels/S.inChannels===1,T=p?P1(p,b):null,C=[i,r],A=a!=null,I=o!=null,D=p==="leakyrelu";if(A&&C.push(a),I&&C.push(o),D){const O=e.makeTensorInfo([],"float32",pp(g,"float32"));C.push(O),v.push(O)}let F;b?F=new lq(S,A,T,I,D):F=new oq(S,A,T,I,D);const z=[[S.padInfo.top,S.padInfo.left],[S.strideHeight,S.strideWidth],[S.dilationHeight,S.dilationWidth],[S.inHeight,S.inWidth]],k=e.runWebGLProgram(F,C,"float32",z);return v.forEach(O=>e.disposeIntermediateTensorInfo(O)),k}const G2t={kernelName:dG,backendName:"webgl",kernelFunc:V2t};class H2t{constructor(t,e,s,i){this.sliceDim=t,this.strides=e,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=s;const r=Ws(s.length);let a=`
    int index;`;for(let o=0;o<this.sliceDim;o++)a+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W2t(n){const{inputs:t,backend:e}=n,{params:s,indices:i}=t,r=i.shape,a=r[r.length-1],o=Zt(s.shape),[l,c,h,f]=sO(s,i),p=Ie({inputs:{x:i},backend:e,attrs:{shape:[c,a]}}),g=Ie({inputs:{x:s},backend:e,attrs:{shape:[Zt(s.shape)/h,h]}});if(e.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const b=e.readSync(i.dataId),T=e.bufferSync(s),C=KSt(b,T,s.dtype,c,a,h,f,s.shape,o);return e.makeTensorInfo(l,s.dtype,C.values)}const v=new H2t(a,f,[c,h],s.shape),_=e.runWebGLProgram(v,[g,p],g.dtype),S=Ie({inputs:{x:_},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(_),S}const q2t={kernelName:KV,backendName:"webgl",kernelFunc:W2t};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X2t{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const s=Ws(this.rank),i=j2t(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `}}function j2t(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<n.length;i++)i===2?s.push("index"):s.push(`${e[i]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hq(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,indices:r}=t,{axis:a,batchDims:o}=s,l=Wn(a,i.shape)[0];if(Bt().get("DEBUG")){const T=e.readSync(r.dataId),C=i.shape[l];for(let A=0;A<T.length;++A){const I=T[A];et(I<=C-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${C-1}]`)}}const c=AO(i,r,l,o),h=Zt(r.shape),f=[],p=Ie({inputs:{x:i},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=Ie({inputs:{x:r},backend:e,attrs:{shape:[c.batchSize,h/c.batchSize]}});f.push(p),f.push(g);const v=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([i,r])||i.dtype==="string"){const T=e.bufferSync(g),C=e.bufferSync(p),A=YSt(C,T,v);return f.forEach(I=>e.disposeIntermediateTensorInfo(I)),e.makeTensorInfo(c.outputShape,A.dtype,A.values)}const _=new X2t(p.shape,v),S=e.runWebGLProgram(_,[p,g],p.dtype);f.push(S);const b=Ie({inputs:{x:S},backend:e,attrs:{shape:c.outputShape}});return f.forEach(T=>e.disposeIntermediateTensorInfo(T)),b}const K2t={kernelName:oA,backendName:"webgl",kernelFunc:hq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y2t="return float(a > b);",Z2t=`
  return vec4(greaterThan(a, b));
`,Q2t=na({opSnippet:Y2t,packedOpSnippet:Z2t,cpuKernelImpl:ZSt,dtype:"bool"}),J2t={kernelName:lA,backendName:"webgl",kernelFunc:Q2t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tCt="return float(a >= b);",eCt=`
  return vec4(greaterThanEqual(a, b));
`,nCt=na({opSnippet:tCt,packedOpSnippet:eCt,dtype:"bool",cpuKernelImpl:QSt}),sCt={kernelName:IS,backendName:"webgl",kernelFunc:nCt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iCt(n){const{inputs:t,backend:e}=n,{input:s}=t;return uq(s,!0,e)}const rCt={kernelName:rk,backendName:"webgl",kernelFunc:iCt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aCt="return float(!isnan(x) && !isinf(x));",oCt=fs({opSnippet:aCt,dtype:"bool"}),lCt={kernelName:DS,backendName:"webgl",kernelFunc:oCt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cCt="return float(isinf(x));",uCt=fs({opSnippet:cCt,dtype:"bool"}),hCt={kernelName:kS,backendName:"webgl",kernelFunc:uCt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fCt="return float(isnan(x));",dCt=fs({opSnippet:fCt,dtype:"bool"}),pCt={kernelName:OS,backendName:"webgl",kernelFunc:dCt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mCt="return float(a < b);",gCt=`
  return vec4(lessThan(a, b));
`,yCt=na({opSnippet:mCt,packedOpSnippet:gCt,cpuKernelImpl:JSt,dtype:"bool"}),xCt={kernelName:uA,backendName:"webgl",kernelFunc:yCt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vCt="return float(a <= b);",bCt=`
  return vec4(lessThanEqual(a, b));
`,SCt=na({opSnippet:vCt,packedOpSnippet:bCt,cpuKernelImpl:t_t,dtype:"bool"}),_Ct={kernelName:hA,backendName:"webgl",kernelFunc:SCt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wCt(n){const{backend:t,attrs:e}=n,{start:s,stop:i,num:r}=e,a=e_t(s,i,r);return t.makeTensorInfo([a.length],"float32",a)}const TCt={kernelName:YV,backendName:"webgl",kernelFunc:wCt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ECt=Hx+`
  return x < 0.0 ? 0./0. : log(x);
`,CCt=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,ACt=fs({opSnippet:ECt,packedOpSnippet:CCt,cpuKernelImpl:n_t}),NCt={kernelName:$S,backendName:"webgl",kernelFunc:ACt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MCt=Hx+`
  return log(1.0 + x);
`,ICt=fs({opSnippet:MCt}),RCt={kernelName:LS,backendName:"webgl",kernelFunc:ICt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DCt="return float(a >= 1.0 && b >= 1.0);",kCt=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,OCt=na({opSnippet:DCt,packedOpSnippet:kCt,dtype:"bool"}),$Ct={kernelName:fA,backendName:"webgl",kernelFunc:OCt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LCt="return float(!(x >= 1.0));",FCt=fs({opSnippet:LCt}),zCt={kernelName:dA,backendName:"webgl",kernelFunc:FCt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UCt="return float(a >= 1.0 || b >= 1.0);",BCt=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,PCt=na({opSnippet:UCt,packedOpSnippet:BCt,dtype:"bool"}),VCt={kernelName:pA,backendName:"webgl",kernelFunc:PCt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GCt{constructor(t,e,s,i,r){this.variableNames=["x"],this.outputShape=[];const a=e,o=t[3]-1;this.outputShape=t;let l;const c=`float(${s}) + float(${i}) * sum`;r===.5?l=`inversesqrt(${c})`:r===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HCt{constructor(t,e,s,i,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=e,o=t[3]-1;this.outputShape=t;let l;const c=`float(${s}) + float(${i}) * sum`;r===.5?l=`inversesqrt(${c})`:r===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WCt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{depthRadius:r,bias:a,alpha:o,beta:l}=s,c=Bt().getBool("WEBGL_PACK_NORMALIZATION")?new HCt(i.shape,r,a,o,l):new GCt(i.shape,r,a,o,l);return e.runWebGLProgram(c,[i],i.dtype)},qCt={kernelName:mA,backendName:"webgl",kernelFunc:WCt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XCt{constructor(t,e,s,i,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=s,this.alpha=i,this.beta=r,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jCt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i,y:r,dy:a}=t,{depthRadius:o,bias:l,alpha:c,beta:h}=s,f=new XCt(i.shape,o,l,c,h);return e.runWebGLProgram(f,[i,r,a],i.dtype)},KCt={kernelName:ok,backendName:"webgl",kernelFunc:jCt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YCt(n,t,e,s){const i=Zt(t),a=Zt(n.shape)/i,o=Ie({inputs:{x:n},attrs:{shape:[a,i]},backend:s}),l=jg(o,n.dtype,"max",s),c=Ie({inputs:{x:l},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fq(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reductionIndices:r,keepDims:a}=s,o=i.shape.length,l=Wn(r,i.shape);let c=l;const h=Ti(c,o),f=h!=null,p=e.shouldExecuteOnCPU([i]);let g=i;if(f){if(p){const C=e.texData.get(g.dataId).values,A=new Array(o);for(let F=0;F<A.length;F++)A[F]=i.shape[h[F]];const I=h$(C,i.shape,i.dtype,h,A);g=e.makeTensorInfo(A,i.dtype);const D=e.texData.get(g.dataId);D.values=I}else g=gN(i,h,e);c=ji(c.length,o)}ea("max",c,o);const[v,_]=zr(g.shape,c);let S=v;a&&(S=or(v,l));let b;if(p){const C=e.texData.get(g.dataId).values,A=s_t(C,Zt(_),S,i.dtype);b=e.makeTensorInfo(S,i.dtype);const I=e.texData.get(b.dataId);I.values=A}else b=YCt(g,_,S,e);return f&&e.disposeIntermediateTensorInfo(g),b}const ZCt={kernelName:gA,backendName:"webgl",kernelFunc:fq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QCt=f$+`
  return max(a, b);
`,JCt=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Xg+`
  return result;
`,tAt=na({opSnippet:QCt,packedOpSnippet:JCt,cpuKernelImpl:i_t}),eAt={kernelName:FS,backendName:"webgl",kernelFunc:tAt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nAt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;w_(i,"maxPool");const{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=s,c=1;et(ya(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=dc(i.shape,r,a,c,o,l);if(h.filterWidth===1&&h.filterHeight===1&&Is(h.inShape,h.outShape))return el({inputs:{x:i},backend:e});const f=new V1(h,"max",!1);return e.runWebGLProgram(f,[i],i.dtype)}const sAt={kernelName:yA,backendName:"webgl",kernelFunc:nAt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iAt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:r,strides:a,pad:o,dataFormat:l,dimRoundingMode:c}=s,h=[1,1,1],f=Of(i.shape,r,a,h,o,c,l),p=new p$(f,"max",!1);return e.runWebGLProgram(p,[i],i.dtype)}const rAt={kernelName:xA,backendName:"webgl",kernelFunc:iAt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aAt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,s=t.strideWidth,i=t.dilationHeight,r=t.effectiveFilterHeight,a=t.effectiveFilterWidth,o=r-1-t.padInfo.top,l=a-1-t.padInfo.left,c=r*a-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class oAt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,s=t.strideHeight,i=t.strideWidth,r=t.dilationDepth,a=t.dilationHeight,o=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,f=l-1-t.padInfo.front,p=c-1-t.padInfo.top,g=h-1-t.padInfo.left,v=l*c*h-1;this.userCode=`
      const ivec3 pads = ivec3(${f}, ${p}, ${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${v} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${h} +
                  wR * ${h} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lAt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r}=t,a=r,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s,f=[1,1,1],p=Of(a.shape,o,l,f,c,h),g=new p$(p,"max",!0),v=e.runWebGLProgram(g,[a],a.dtype),_=new oAt(p),S=e.runWebGLProgram(_,[i,v],a.dtype);return e.disposeIntermediateTensorInfo(v),S}const cAt={kernelName:ck,backendName:"webgl",kernelFunc:lAt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uAt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r,output:a}=t,o=r;w_([r,a],"maxPoolGrad");const{filterSize:l,strides:c,pad:h,dimRoundingMode:f}=s,p=dc(o.shape,l,c,1,h,f),g=!0,v=new V1(p,"max",g),_=e.runWebGLProgram(v,[o],o.dtype),S=new aAt(p),b=e.runWebGLProgram(S,[i,_],o.dtype);return e.disposeIntermediateTensorInfo(_),b}const hAt={kernelName:lk,backendName:"webgl",kernelFunc:uAt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fAt(n,t,e,s){let i=new V1(e,"max",!1);const r=s.runWebGLProgram(i,[n],"float32");i=new V1(e,"max",!0,!0,t);const a=s.runWebGLProgram(i,[n],"float32");return[r,a]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dAt={kernelName:ZV,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:i,strides:r,pad:a,includeBatchInIndex:o}=t,l=e;et(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];et(ya(r,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${c}'`);const h=dc(s.shape,i,r,c,a),[f,p]=fAt(s,o,h,l);return[f,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pAt(n,t,e,s){const i=Zt(t),a=Zt(n.shape)/i,o=Ie({inputs:{x:n},attrs:{shape:[a,i]},backend:s}),l=jg(o,"float32","mean",s),c=Ie({inputs:{x:l},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mAt={kernelName:vA,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{keepDims:i,axis:r}=t,a=e,o=s.shape.length,l=Wn(r,s.shape);let c=l;const h=Ti(c,o),f=h!=null,p=a.shouldExecuteOnCPU([s]),g=[];let v=s;if(f){if(p){const A=a.texData.get(v.dataId).values,I=new Array(o);for(let z=0;z<I.length;z++)I[z]=s.shape[h[z]];const D=h$(A,s.shape,s.dtype,h,I);v=a.makeTensorInfo(I,s.dtype);const F=a.texData.get(v.dataId);F.values=D}else v=gN(s,h,a);g.push(v),c=ji(c.length,o)}ea("sum",c,o);const[_,S]=zr(v.shape,c);let b=_;i&&(b=or(_,l));const T=pAt(v,S,b,a);for(const C of g)a.disposeIntermediateTensorInfo(C);return T}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gAt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:a}=s,o=i.shape.length,l=Wn(r,i.shape);let c=l;const h=Ti(c,o);let f=i;h!=null&&(f=Xa({inputs:{x:i},backend:e,attrs:{perm:h}}),c=ji(c.length,i.shape.length)),ea("min",c,o);const[p,g]=zr(f.shape,c),v=Zt(g),_=Ie({inputs:{x:f},backend:e,attrs:{shape:[-1,v]}}),S=jg(_,_.dtype,"min",e);let b;if(a){const T=or(p,l);b=Ie({inputs:{x:S},backend:e,attrs:{shape:T}})}else b=Ie({inputs:{x:S},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(S),h!=null&&e.disposeIntermediateTensorInfo(f),b}const yAt={kernelName:bA,backendName:"webgl",kernelFunc:gAt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xAt=f$+`
  return min(a, b);
`,vAt=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Xg+`
  return result;
`,bAt=na({opSnippet:xAt,packedOpSnippet:vAt,cpuKernelImpl:r_t}),SAt={kernelName:zS,backendName:"webgl",kernelFunc:bAt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _At{constructor(t,e,s){this.variableNames=["x"],this.outputShape=e.map((h,f)=>h[0]+t[f]+h[1]);const i=t.length,r=Ws(i),a=e.map(h=>h[0]).join(","),o=e.map((h,f)=>h[0]+t[f]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),c=s==="reflect"?0:1;if(i===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${a});
      ${r} end = ${r}(${o});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wAt{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((v,_)=>v[0]+t[_]+v[1]);const i=t.length,r=Ws(i),a=e.map(v=>v[0]).join(","),o=e.map((v,_)=>v[0]+t[_]).join(","),l=za("rc",i),c=za("source",i),h=`${l[i-1]} < ${this.outputShape[i-1]}`,f=i===1?"source":`vec2(${c.slice(-2).join()})`,p=s==="reflect"?0:1;let g="";if(i===1){const v=`
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;g=`
        ${r} rc = outputLoc;
        ${v}
        result[0] = getChannel(getX(${c.join()}), ${f});
        ${l[i-1]} += 1;
        if(${h}) {
          ${v}
          result[1] = getChannel(getX(${c.join()}), ${f});
        }
      `}else{const v=`
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;g=`
        ${r} rc = outputLoc;
        ${v}
        result[0] = getChannel(getX(${c.join()}), ${f});
        ${l[i-1]} += 1;
        if(${h}) {
          ${v}
          result[1] = getChannel(getX(${c.join()}), ${f});
        }
        rc = outputLoc;
        ${l[i-2]} += 1;
        if(${l[i-2]} < ${this.outputShape[i-2]}) {
          ${v}
          result[2] = getChannel(getX(${c.join()}), ${f});
          ${l[i-1]} += 1;
          if(${h}) {
            ${v}
            result[3] = getChannel(getX(${c.join()}), ${f});
          }
        }
      `}this.userCode=`
      const ${r} start = ${r}(${a});
      const ${r} end = ${r}(${o});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TAt=({inputs:n,backend:t,attrs:e})=>{const{x:s}=n,{paddings:i,mode:r}=e,a=Bt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wAt(s.shape,i,r):new _At(s.shape,i,r);return t.runWebGLProgram(a,[s],s.dtype)},EAt={kernelName:SA,backendName:"webgl",kernelFunc:TAt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CAt=`if (b == 0.0) return NAN;
  return mod(a, b);`,AAt=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Xg+`
  return result;
`,NAt=na({opSnippet:CAt,packedOpSnippet:AAt}),MAt={kernelName:US,backendName:"webgl",kernelFunc:NAt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IAt{constructor(t,e,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RAt=`
if (a == b) {
  return 1.0;
};
return a / b;`,DAt=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,dq=na({opSnippet:RAt,packedOpSnippet:DAt,checkOutOfBounds:!0}),kAt={kernelName:wS,backendName:"webgl",kernelFunc:dq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OB="return a - b;",pq=na({opSnippet:OB,packedOpSnippet:OB,supportsComplex:!0,cpuKernelImpl:C_t}),OAt={kernelName:e_,backendName:"webgl",kernelFunc:pq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mq(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{dim:r}=s,a=Wn([r],i.shape),o=fq({inputs:{x:i},backend:e,attrs:{reductionIndices:a,keepDims:!1}}),l=or(o.shape,a),c=Ie({inputs:{x:o},backend:e,attrs:{shape:l}}),h=pq({inputs:{a:i,b:c},backend:e}),f=cq({inputs:{x:h},backend:e}),p=yN({inputs:{x:f},backend:e,attrs:{axis:a,keepDims:!1}}),g=Ie({inputs:{x:p},backend:e,attrs:{shape:l}}),v=dq({inputs:{a:f,b:g},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),v}const $At={kernelName:UA,backendName:"webgl",kernelFunc:mq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LAt(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{numSamples:r,seed:a,normalized:o}=s,l=o?i:mq({inputs:{logits:i},backend:e,attrs:{dim:i.shape.length-1}}),c=l.shape[0],h=l.shape[1],f=new IAt(c,h,r),p=[[a]],g=e.runWebGLProgram(f,[l],"int32",p);return o||e.disposeIntermediateTensorInfo(l),g}const FAt={kernelName:QV,backendName:"webgl",kernelFunc:LAt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zAt=mc+`
  return -x;
`,UAt=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function BAt(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const r=e.texData.get(s.dataId),[a,o]=o_t(r.values,s.shape,s.dtype);return e.makeTensorInfo(o,s.dtype,a)}let i;return Bt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new zd(s.shape,UAt):i=new sh(s.shape,zAt),e.runWebGLProgram(i,[s],s.dtype)}const PAt={kernelName:_A,backendName:"webgl",kernelFunc:BAt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VAt=Qk;function GAt(n){bl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:r}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s,c=e.readSync(i.dataId),h=e.readSync(r.dataId),{selectedIndices:f}=VAt(c,h,a,o,l);return e.makeTensorInfo([f.length],"int32",new Int32Array(f))}const HAt={kernelName:uk,backendName:"webgl",kernelFunc:GAt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WAt=Jk;function qAt(n){bl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:r}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=s,h=e.readSync(i.dataId),f=e.readSync(r.dataId),{selectedIndices:p,validOutputs:g}=WAt(h,f,a,o,l,c);return[e.makeTensorInfo([p.length],"int32",new Int32Array(p)),e.makeTensorInfo([],"int32",new Int32Array([g]))]}const XAt={kernelName:hk,backendName:"webgl",kernelFunc:qAt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jAt=tO;function KAt(n){bl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:r}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=s,h=e.readSync(i.dataId),f=e.readSync(r.dataId),p=a,g=o,v=l,_=c,{selectedIndices:S,selectedScores:b}=jAt(h,f,p,g,v,_);return[e.makeTensorInfo([S.length],"int32",new Int32Array(S)),e.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const YAt={kernelName:fk,backendName:"webgl",kernelFunc:KAt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZAt{constructor(t,e,s,i){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QAt=n=>{const{inputs:t,backend:e,attrs:s}=n,{indices:i}=t,{dtype:r,depth:a,onValue:o,offValue:l}=s,c=Zt(i.shape),h=new ZAt(c,a,o,l),f=Ie({inputs:{x:i},backend:e,attrs:{shape:[c]}}),p=e.runWebGLProgram(h,[f],r);e.disposeIntermediateTensorInfo(f);const g=[...i.shape,a],v=Ie({inputs:{x:p},backend:e,attrs:{shape:g}});return e.disposeIntermediateTensorInfo(p),v},JAt={kernelName:EA,backendName:"webgl",kernelFunc:QAt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X2(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="complex64"){const i=E_({inputs:{input:s},backend:e}),r=X2({inputs:{x:i},backend:e}),a=xN({inputs:{input:s},backend:e}),o=X2({inputs:{x:a},backend:e}),l=Sp({inputs:{real:r,imag:o},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),l}else return C_({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}const tNt={kernelName:VA,backendName:"webgl",kernelFunc:X2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gq(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const i=E_({inputs:{input:s},backend:e}),r=gq({inputs:{x:i},backend:e}),a=xN({inputs:{input:s},backend:e}),o=X2({inputs:{x:a},backend:e}),l=Sp({inputs:{real:r,imag:o},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),l}else return C_({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}const eNt={kernelName:TA,backendName:"webgl",kernelFunc:gq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nNt(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s;if(t.length===1)return sD({inputs:{input:t[0]},backend:e,attrs:{dim:i}});const r=t[0].shape,a=t[0].dtype;t.forEach(h=>{k3(r,h.shape,"All tensors passed to stack must have matching shapes"),et(a===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=t.map(h=>{const f=sD({inputs:{input:h},backend:e,attrs:{dim:i}});return o.push(f),f}),c=eq({inputs:l,backend:e,attrs:{axis:i}});return o.forEach(h=>e.disposeIntermediateTensorInfo(h)),c}const sNt={kernelName:CA,backendName:"webgl",kernelFunc:nNt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iNt{constructor(t,e,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,h)=>c[0]+t[h]+c[1]);const i=t.length,r=Ws(i),a=e.map(c=>c[0]).join(","),o=e.map((c,h)=>c[0]+t[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);if(i===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${a});
      ${r} end = ${r}(${o});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rNt{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((_,S)=>_[0]+t[S]+_[1]);const i=t.length,r=Ws(i),a=e.map(_=>_[0]).join(","),o=e.map((_,S)=>_[0]+t[S]).join(","),l=za("rc",i),c=za("source",i),h=`${l[i-1]} < ${this.outputShape[i-1]}`,f=i===1?"source":`vec2(${c.slice(-2).join()})`,p=[`${r} rc = outputLoc;`,`${l[i-1]} += 1;
       if(${h}) {
      `,i===1?"":`}
       rc = outputLoc;
       ${l[i-2]} += 1;
       if(${l[i-2]} < ${this.outputShape[i-2]}) {`,i===1?"":`  ${l[i-1]} += 1;
         if(${h}) {`],g=i===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let v="";for(let _=0,S=i===1?2:4;_<S;_++)v+=`
        ${p[_]}
        if (${g}) {
          result[${_}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${_}] = getChannel(getX(${c.join()}), ${f});
        }
      `;v+=i===1?"} ":"}}",this.userCode=`
      const ${r} start = ${r}(${a});
      const ${r} end = ${r}(${o});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${v}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yq=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{paddings:r,constantValue:a}=s;if(Zt(i.shape)===0){const c=r.map((h,f)=>h[0]+i.shape[f]+h[1]);return C_({backend:e,attrs:{shape:c,value:a,dtype:i.dtype}})}const o=Bt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rNt(i.shape,r,a):new iNt(i.shape,r,a),l=[[a]];return e.runWebGLProgram(o,[i],i.dtype,l)},aNt={kernelName:AA,backendName:"webgl",kernelFunc:yq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oNt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,lNt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Xg+`
  return result;
`,cNt=na({opSnippet:oNt,packedOpSnippet:lNt}),uNt={kernelName:PS,backendName:"webgl",kernelFunc:cNt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hNt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:a}=s,o=i.shape.length,l=[],c=Wn(r,i.shape);let h=c;const f=Ti(h,o);let p=i;f!=null&&(p=Xa({inputs:{x:i},backend:e,attrs:{perm:f}}),h=ji(h.length,o),l.push(p)),ea("prod",h,o);let g;if(e.shouldExecuteOnCPU([p])){const v=e.texData.get(p.dataId).values,{outVals:_,outShape:S,outDtype:b}=c_t(p.shape,p.dtype,v,h);g=e.makeTensorInfo(S,b,_)}else{const[v,_]=zr(p.shape,h),S=Zt(_),b=Ie({inputs:{x:p},backend:e,attrs:{shape:[-1,S]}}),T=Tk(i.dtype),C=jg(b,T,"prod",e);g=Ie({inputs:{x:C},backend:e,attrs:{shape:v}}),l.push(b),l.push(C)}if(a){l.push(g);const v=or(g.shape,c);g=Ie({inputs:{x:g},backend:e,attrs:{shape:v}})}return l.forEach(v=>e.disposeIntermediateTensorInfo(v)),g}const fNt={kernelName:MA,backendName:"webgl",kernelFunc:hNt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dNt(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:r,indices:a}=t,{outputRaggedRank:o}=s,l=i.map(b=>e.readSync(b.dataId)),c=i.map(b=>b.shape),h=e.readSync(r.dataId),f=e.readSync(a.dataId),[p,g,v]=u_t(l,c,h,r.shape,r.dtype,f,a.shape,o),_=p.map(b=>e.makeTensorInfo([b.length],"int32",b)),S=e.makeTensorInfo(v,r.dtype,g);return _.concat([S])}const pNt={kernelName:JV,backendName:"webgl",kernelFunc:dNt};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mNt(n){const{inputs:t,backend:e}=n,{starts:s,limits:i,deltas:r}=t,a=e.readSync(s.dataId),o=e.readSync(i.dataId),l=e.readSync(r.dataId),[c,h]=h_t(a,s.shape,s.dtype,o,i.shape,l,r.shape),f=e.makeTensorInfo([c.length],"int32",c),p=e.makeTensorInfo([h.length],s.dtype,h);return[f,p]}const gNt={kernelName:tG,backendName:"webgl",kernelFunc:mNt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yNt(n){const{inputs:t,backend:e,attrs:s}=n,{shape:i,values:r,defaultValue:a,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=s,c=e.readSync(i.dataId),h=e.readSync(r.dataId),f=e.readSync(a.dataId),p=o.map(S=>e.readSync(S.dataId)),g=o.map(S=>S.shape),[v,_]=f_t(c,i.shape,h,r.shape,r.dtype,f,a.shape,p,g,l);return e.makeTensorInfo(v,r.dtype,_)}const xNt={kernelName:eG,backendName:"webgl",kernelFunc:yNt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xq=n=>{const{backend:t,attrs:e}=n,{start:s,stop:i,step:r,dtype:a}=e,o=d_t(s,i,r,a);return t.makeTensorInfo([o.length],a,o)},vNt={kernelName:dk,backendName:"webgl",kernelFunc:xq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bNt="return 1.0 / x;",SNt=fs({opSnippet:bNt}),_Nt={kernelName:VS,backendName:"webgl",kernelFunc:SNt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wNt=mc+`
  return (x < 0.0) ? 0.0 : x;
`,TNt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ENt=fs({opSnippet:wNt,packedOpSnippet:TNt}),CNt={kernelName:GS,backendName:"webgl",kernelFunc:ENt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ANt=mc+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,NNt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,MNt=fs({opSnippet:ANt,packedOpSnippet:NNt}),INt={kernelName:HS,backendName:"webgl",kernelFunc:MNt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RNt{constructor(t,e,s,i,r){this.variableNames=["A"],this.outputShape=[];const[a,o,l,c]=t;this.outputShape=[a,e,s,c];const h=[i&&e>1?o-1:o,i&&s>1?l-1:l],f=[i&&e>1?e-1:e,i&&s>1?s-1:s];let p;r?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/f[0]},
          ${h[1]/f[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DNt{constructor(t,e,s,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,l,c]=t;this.outputShape=[a,e,s,c];const h=[i&&e>1?o-1:o,i&&s>1?l-1:l],f=[i&&e>1?e-1:e,i&&s>1?s-1:s];let p;r?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/f[0]},
          ${h[1]/f[1]},
          ${h[1]/f[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kNt(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:r,halfPixelCenters:a,size:o}=s,[l,c]=o,h=Bt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new DNt(i.shape,l,c,r,a):new RNt(i.shape,l,c,r,a);return e.runWebGLProgram(h,[i],"float32")}const ONt={kernelName:DA,backendName:"webgl",kernelFunc:kNt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $Nt{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,r]=e,[,a,o]=t,l=[s&&a>1?i-1:i,s&&o>1?r-1:r],c=[s&&a>1?a-1:a,s&&o>1?o-1:o],h=l[0]/c[0],f=l[1]/c[1],p=1/h,g=1/f,v=Math.ceil(p)*2+2,_=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${f});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${g});

        const int winHeight = int(${v});
        const int winWidth = int(${_});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LNt(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:r}=t,{alignCorners:a}=s,o=new $Nt(r.shape,i.shape,a);return e.runWebGLProgram(o,[r],r.dtype)}const FNt={kernelName:gk,backendName:"webgl",kernelFunc:LNt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zNt{constructor(t,e,s,i,r){this.variableNames=["A"],this.outputShape=[];const[a,o,l,c]=t;this.outputShape=[a,e,s,c];const h=[i&&e>1?o-1:o,i&&s>1?l-1:l],f=[i&&e>1?e-1:e,i&&s>1?s-1:s],p=i?"0.5":"0.0";let g;r?g="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":g="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/f[0]},
          ${h[1]/f[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UNt{constructor(t,e,s,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,l,c]=t;this.outputShape=[a,e,s,c];const h=[i&&e>1?o-1:o,i&&s>1?l-1:l],f=[i&&e>1?e-1:e,i&&s>1?s-1:s],p=i?"0.5":"0.0";let g;r?g="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":g="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/f[0]},
          ${h[1]/f[1]},
          ${h[1]/f[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BNt(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:r,halfPixelCenters:a,size:o}=s,[l,c]=o,h=Bt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new UNt(i.shape,l,c,r,a):new zNt(i.shape,l,c,r,a);return e.runWebGLProgram(h,[i],i.dtype)}const PNt={kernelName:RA,backendName:"webgl",kernelFunc:BNt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VNt{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,r]=e,[,a,o]=t,l=[s&&a>1?i-1:i,s&&o>1?r-1:r],c=[s&&a>1?a-1:a,s&&o>1?o-1:o],h=l[0]/c[0],f=l[1]/c[1],p=1/h,g=1/f,v=Math.ceil(p)*2+2,_=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${f});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${g});

        const int winHeight = int(${v});
        const int winWidth = int(${_});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GNt(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:r}=t,{alignCorners:a}=s,o=new VNt(r.shape,i.shape,a);return e.runWebGLProgram(o,[r],r.dtype)}const HNt={kernelName:mk,backendName:"webgl",kernelFunc:GNt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WNt{constructor(t,e){this.variableNames=["x"];const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=t,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const i=o=>e.indexOf(o)!==-1&&t[o]!==1?`${t[o]} - coords[${o}] - 1`:`coords[${o}]`,r=t.map((o,l)=>i(l)).join(","),a=Ws(s);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qNt{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=t;const i=za("rc",s),r=`${i[s-1]} + 1 < ${this.outputShape[s-1]}`,a=`${i[s-2]} + 1 < ${this.outputShape[s-2]}`,o=Ws(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(i.slice())};
          if(${r}){
            result.g = ${c(i.slice())};
          }
          if(${a}) {
            result.b = ${h(i.slice())};
            if(${r}) {
              result.a = ${f(i.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(v){return p(v)}function c(v){return v[s-1]="("+v[s-1]+" + 1)",p(v)}function h(v){return v[s-2]="("+v[s-2]+" + 1)",p(v)}function f(v){return v[s-1]="("+v[s-1]+" + 1)",v[s-2]="("+v[s-2]+" + 1)",p(v)}function p(v){const _=t.map((T,C)=>g(C,v)),S=_.join(","),b=_.slice(-2).join(",");return`getChannel(getX(${S}), vec2(${b}))`}function g(v,_){return e.indexOf(v)!==-1&&t[v]!==1?`${t[v]} - ${_[v]} - 1`:`${_[v]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XNt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dims:r}=s,a=i.shape.length,o=Wn(r,i.shape);if(a===0)return el({inputs:{x:i},backend:e});const l=Bt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qNt(i.shape,o):new WNt(i.shape,o);return e.runWebGLProgram(l,[i],i.dtype)}const jNt={kernelName:kA,backendName:"webgl",kernelFunc:XNt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KNt{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=t[1],i=t[2];this.outputShape=t;let r="";typeof e=="number"?r=`float outputValue = ${e.toFixed(2)};`:r=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YNt={kernelName:wk,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:i,fillValue:r,center:a}=t,o=e,l=new KNt(s.shape,r),[c,h]=hO(a,s.shape[1],s.shape[2]),f=[[c,h,Math.sin(i),Math.cos(i)]];return o.runWebGLProgram(l,[s],s.dtype,f)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZNt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,QNt=fs({opSnippet:ZNt}),JNt={kernelName:WS,backendName:"webgl",kernelFunc:QNt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tMt="return inversesqrt(x);",eMt=fs({opSnippet:tMt,cpuKernelImpl:p_t}),nMt={kernelName:qS,backendName:"webgl",kernelFunc:eMt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m${constructor(t,e,s,i,r,a,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const c=Ws(r.length),h=Ws(a.length);let f="";s===1?f="i":s===2&&(f="i, j");const p=`getIndices(${f})`;let g="";i===1?g="i":i===2&&(g="i, coords[1]");const v=`getUpdates(${g})`;let _="";l&&(_="coords[0], coords[1]");const S=`getDefaultValue(${_})`,b=e>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${r});

        void main() {
          ${h} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${b};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${v};
              found = true;
            }
          }
          setOutput(mix(${S}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sMt{constructor(t,e,s,i,r,a,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const c=Ws(r.length),h=Ws(a.length);let f="";s===1?f="i":s===2&&(f="i, j");const p=`getIndices(${f})`;let g="";i===1?g="i":i===2&&(g="i, coords[1]");const v=`getUpdates(${g})`;let _="";l&&(_="coords[0], coords[1]");const S=`getDefaultValue(${_})`,b=e>1?"strides[j]":"strides",T=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${r});

        void main() {
          ${h} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${b};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${T};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${v};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${S}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iMt(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i,updates:r}=t,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:c,strides:h,outputSize:f}=Vg(r,i,a),p=[f/c,c];if(f===0)return e.makeTensorInfo(a,i.dtype);const g=Ie({inputs:{x:i},backend:e,attrs:{shape:[l,o]}}),v=Ie({inputs:{x:r},backend:e,attrs:{shape:[l,c]}}),_=e.makeTensorInfo([],"float32",new Float32Array([0]));let S;Bt().getBool("WEBGL_PACK")?S=new sMt(l,o,g.shape.length,v.shape.length,h,p):S=new m$(l,o,g.shape.length,v.shape.length,h,p);const b=e.runWebGLProgram(S,[v,g,_],v.dtype),T=Ie({inputs:{x:b},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(_),T}const rMt={kernelName:nG,backendName:"webgl",kernelFunc:iMt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aMt{constructor(t,e,s,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,s];const r="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,o=Bt().getNumber("WEBGL_VERSION")===2?r:a,l=i==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oMt(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:i,values:r}=t,{side:a}=s,o=new aMt(i.shape[0],i.shape[1],r.shape[1],a),l=[[i.shape[1]]];return e.runWebGLProgram(o,[i,r],"int32",l)}const lMt={kernelName:iG,backendName:"webgl",kernelFunc:oMt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cMt{constructor(t,e,s){this.variableNames=["c","a","b"],this.outputShape=e;let i,r;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)r="resRC",i="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let h=0;h<e.length;h++)c.push(`${o[h]}`),h<t&&l.push(`${o[h]}`);i=l.join(),r=c.join()}const a=Ws(s);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uMt(n){const{inputs:t,backend:e}=n,{condition:s,t:i,e:r}=t,a=new cMt(s.shape.length,i.shape,i.shape.length);return e.runWebGLProgram(a,[s,i,r],Jo(i.dtype,r.dtype))}const hMt={kernelName:OA,backendName:"webgl",kernelFunc:uMt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fMt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${tN};
  float scale = ${eN};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,dMt=fs({opSnippet:fMt}),pMt={kernelName:XS,backendName:"webgl",kernelFunc:dMt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mMt=Hx+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,gMt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,yMt=fs({opSnippet:mMt,packedOpSnippet:gMt,cpuKernelImpl:g_t}),xMt={kernelName:ZS,backendName:"webgl",kernelFunc:yMt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vMt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,bMt=fs({opSnippet:vMt}),SMt={kernelName:YS,backendName:"webgl",kernelFunc:bMt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Mt=Hx+`
  return sin(x);
`,wMt=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Xg}
  return result;
`,TMt=fs({opSnippet:_Mt,packedOpSnippet:wMt}),EMt={kernelName:jS,backendName:"webgl",kernelFunc:TMt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CMt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,AMt=fs({opSnippet:CMt}),NMt={kernelName:KS,backendName:"webgl",kernelFunc:AMt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MMt=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,IMt=fs({opSnippet:MMt}),RMt={kernelName:QS,backendName:"webgl",kernelFunc:IMt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DMt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:r,paddings:a}=s;et(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=r.reduce((b,T)=>b*T),l=[[0,0]];l.push(...a);for(let b=1+r.length;b<i.shape.length;++b)l.push([0,0]);const c=[],h=yq({inputs:{x:i},backend:e,attrs:{paddings:l,constantValue:0}}),f=f_(h.shape,r,o,!1),p=d_(f.length,r.length,!1),g=p_(h.shape,r,o,!1),v=Ie({inputs:{x:h},backend:e,attrs:{shape:f}}),_=Xa({inputs:{x:v},backend:e,attrs:{perm:p}}),S=Ie({inputs:{x:_},backend:e,attrs:{shape:g}});return c.push(h),c.push(v),c.push(_),c.forEach(b=>e.disposeIntermediateTensorInfo(b)),S},kMt={kernelName:FA,backendName:"webgl",kernelFunc:DMt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OMt(n){const{inputs:t,backend:e}=n,{indices:s,values:i,denseShape:r,defaultValue:a}=t;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${r.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=e.readSync(s.dataId),l=e.readSync(i.dataId),c=e.readSync(r.dataId),h=e.readSync(a.dataId)[0],[f,p,g,v,_]=x_t(o,s.shape,s.dtype,l,i.dtype,c,h);return[e.makeTensorInfo(p,s.dtype,f),e.makeTensorInfo([p[0]],i.dtype,g),e.makeTensorInfo([v.length],"bool",new Uint8Array(v.map(S=>Number(S)))),e.makeTensorInfo([_.length],s.dtype,new Int32Array(_))]}const $Mt={kernelName:rG,backendName:"webgl",kernelFunc:OMt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LMt(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:i,newShape:r}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const a=Array.from(e.readSync(i.dataId)),o=e.readSync(s.dataId),l=Array.from(e.readSync(r.dataId)),[c,h,f]=v_t(o,s.shape,s.dtype,a,l);return[e.makeTensorInfo(h,s.dtype,c),e.makeTensorInfo([f.length],r.dtype,new Int32Array(f))]}const FMt={kernelName:aG,backendName:"webgl",kernelFunc:LMt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zMt(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:r}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${r.shape}`);const a=e.readSync(s.dataId),o=e.readSync(i.dataId),l=e.readSync(r.dataId),[c,h]=V8(a,s.shape,s.dtype,o,l,!0);return e.makeTensorInfo(h,s.dtype,c)}const UMt={kernelName:oG,backendName:"webgl",kernelFunc:zMt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BMt(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:r}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${r.shape}`);const a=e.readSync(s.dataId),o=e.readSync(i.dataId),l=e.readSync(r.dataId),[c,h]=V8(a,s.shape,s.dtype,o,l);return e.makeTensorInfo(h,s.dtype,c)}const PMt={kernelName:lG,backendName:"webgl",kernelFunc:BMt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VMt(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:a}=t,{outputShape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:f,outputSize:p}=Vg(r,i,o),g=!1;if(r.dtype==="string"){const b=e.bufferSync(i),T=e.bufferSync(r),C=Yd(e.readSync(a.dataId)[0]),A=m_t(b,T,o,p,h,c,l,f,C,g);return e.makeTensorInfo(o,A.dtype,A.values)}const v=new m$(c,l,i.shape.length,r.shape.length,f,[p,1],g),_=e.runWebGLProgram(v,[r,i,a],r.dtype),S=Ie({inputs:{x:_},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(_),S}const GMt={kernelName:cG,backendName:"webgl",kernelFunc:VMt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HMt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{numOrSizeSplits:r,axis:a}=s,o=Wn(a,i.shape)[0],l=CO(i,r,o),c=i.shape.length,h=new Array(c).fill(0),f=i.shape.slice();return l.map(p=>{const g=[...f];g[o]=p;const v=Wx({inputs:{x:i},backend:e,attrs:{begin:h,size:g}});return h[o]+=p,v})}const WMt={kernelName:zA,backendName:"webgl",kernelFunc:HMt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $B="return sqrt(x);",qMt=fs({opSnippet:$B,packedOpSnippet:$B,cpuKernelImpl:b_t}),XMt={kernelName:JS,backendName:"webgl",kernelFunc:qMt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jMt="return x * x;",KMt=fs({opSnippet:jMt}),YMt={kernelName:yk,backendName:"webgl",kernelFunc:KMt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LB="return (a - b) * (a - b);",ZMt=na({opSnippet:LB,packedOpSnippet:LB}),QMt={kernelName:t_,backendName:"webgl",kernelFunc:ZMt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JMt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");const r=e.readSync(i.dataId),a=Af(r),o=S_t(a,"string",s);return e.makeTensorInfo(i.shape,"string",o)}const tIt={kernelName:xk,backendName:"webgl",kernelFunc:JMt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eIt({inputs:n,attrs:t,backend:e}){const{x:s}=n,i=mc+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,r=new sh(s.shape,i);return e.runWebGLProgram(r,[s],s.dtype)}const nIt={kernelName:r_,backendName:"webgl",kernelFunc:eIt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sIt{constructor(t,e,s){this.variableNames=["x"],this.outputShape=s;const i=s.length,r=Ws(s.length),a=Ws(s.length);let o="";if(i===1)o="coords * strides + begin";else{let l=0;o=s.map((c,h)=>(l++,s.length===1?`coords * strides[${h}] + begin[${h}]`:`coords[${l-1}] * strides[${h}] + begin[${h}]`)).join(",")}this.userCode=`
      ${r} begin = ${r}(${t});
      ${r} strides = ${r}(${e});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iIt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:r,end:a,strides:o,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:f,shrinkAxisMask:p}=s,{finalShapeSparse:g,finalShape:v,isIdentity:_,sliceDim0:S,isSimpleSlice:b,begin:T,end:C,strides:A}=lO(i.shape,r,a,o,l,c,h,f,p);let I;if(_)I=Ie({inputs:{x:i},backend:e,attrs:{shape:v}});else if(S||b){et(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const F=rO(T,C,A),z=Wx({inputs:{x:i},backend:e,attrs:{begin:T,size:F}});I=Ie({inputs:{x:z},backend:e,attrs:{shape:v}}),e.disposeIntermediateTensorInfo(z)}else if(e.shouldExecuteOnCPU([i])){const z=e.readSync(i.dataId),k=Hn(i.shape,i.dtype,z),O=__t(g,k,A,T);I=e.makeTensorInfo(v,i.dtype,O.values)}else{const z=new sIt(T,A,g);I=e.runWebGLProgram(z,[i],i.dtype)}const D=Ie({inputs:{x:I},backend:e,attrs:{shape:v}});return e.disposeIntermediateTensorInfo(I),D}const rIt={kernelName:vk,backendName:"webgl",kernelFunc:iIt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aIt(n){const{inputs:t,backend:e,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:c}=s,{data:h,dataSplits:f}=t,p=e.readSync(h.dataId),g=e.readSync(f.dataId),[v,_]=w_t(p,g,i,r,a,o,l,c);return[e.makeTensorInfo([v.length],"string",v),e.makeTensorInfo(f.shape,"int32",_)]}const oIt={kernelName:uG,backendName:"webgl",kernelFunc:aIt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lIt(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:i}=s,{input:r,delimiter:a}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=e.readSync(r.dataId),l=e.readSync(a.dataId)[0],[c,h,f]=T_t(o,l,i),p=h.length;return[e.makeTensorInfo([p,2],"int32",c),e.makeTensorInfo([p],"string",h),e.makeTensorInfo([2],"int32",new Int32Array(f))]}const cIt={kernelName:hG,backendName:"webgl",kernelFunc:lIt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uIt(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:i}=s,{input:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=e.readSync(r.dataId),o=E_t(a,i);return e.makeTensorInfo(r.shape,"int32",o)}const hIt={kernelName:fG,backendName:"webgl",kernelFunc:uIt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fIt="return tan(x);",dIt=fs({opSnippet:fIt}),pIt={kernelName:n_,backendName:"webgl",kernelFunc:dIt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mIt=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,gIt=fs({opSnippet:mIt}),yIt={kernelName:s_,backendName:"webgl",kernelFunc:gIt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xIt(n){const{inputs:t,backend:e,attrs:s}=n,{tensor:i,indices:r,updates:a}=t,{sliceRank:o,numUpdates:l,sliceSize:c,strides:h,outputSize:f}=Vg(a,r,i.shape),p=[f/c,c];if(f===0)return e.makeTensorInfo(i.shape,r.dtype);const g=Ie({inputs:{x:r},backend:e,attrs:{shape:[l,o]}}),v=Ie({inputs:{x:a},backend:e,attrs:{shape:[l,c]}}),_=Ie({inputs:{x:i},backend:e,attrs:{shape:p}}),S=new m$(l,o,g.shape.length,v.shape.length,h,p,!1,!0),b=e.runWebGLProgram(S,[v,g,_],_.dtype),T=Ie({inputs:{x:b},backend:e,attrs:{shape:i.shape}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(b),T}const vIt={kernelName:sG,backendName:"webgl",kernelFunc:xIt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bIt{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let a=0;a<s.length;a++)s[a]=t[a]*e[a];this.outputShape=s,this.rank=s.length;const i=Ws(this.rank),r=SIt(t);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}}function SIt(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let i=0;i<n.length;i++)s.push(`imod(${e[i]}, ${n[i]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vq(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reps:r}=s;if(i.dtype==="string"||i.shape.length>5){const l=e.readSync(i.dataId),c=i.dtype==="string"?l.map(p=>Yd(p)):l,h=Hn(i.shape,i.dtype,c),f=A_t(h,r);return e.makeTensorInfo(f.shape,f.dtype,f.values)}const a=new bIt(i.shape,r);return e.runWebGLProgram(a,[i],i.dtype)}const _It={kernelName:i_,backendName:"webgl",kernelFunc:vq};class wIt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class TIt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Im(n,t){t!==null&&n.disposeIntermediateTensorInfo(t)}function FB(n){let t=1;for(;t<n;)t*=2;return t}function EIt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{k:r,sorted:a}=s,o=Bt().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Bt().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=i.shape,h=c[c.length-1];if(e.shouldExecuteOnCPU([i])||h<o||r>l){const O=e.readSync(i.dataId),[L,H]=N_t(O,c,i.dtype,r,a);return[e.makeTensorInfo(L.shape,L.dtype,L.values),e.makeTensorInfo(H.shape,H.dtype,H.values)]}if(r===0)return c[c.length-1]=0,[e.makeTensorInfo(c,i.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(h===1)return[i,C_({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const f=e.texData.get(i.dataId),p=f!==null&&f.isPacked,g=p?e.unpackTensor(i):i,_=Zt(c)/h,S=Ie({inputs:{x:g},attrs:{shape:[_,h]},backend:e});p&&Im(e,g);const b=FB(r),T=FB(h);let C=null;const A=()=>C===null?[S,S]:[S,C],I=(O,L,H)=>{const q=A(),K=new wIt(H),P=[[h],[C===null?1:0],[Number.NEGATIVE_INFINITY],[O],[L]],W=C;C=e.runWebGLProgram(K,q,"int32",P),Im(e,W)};for(let O=1;O<b;O*=2){const L=O*2;for(let H=O;H>=1;H/=2)I(L,H,[_,T])}for(let O=T;O>b;O/=2){const L=A(),H=new TIt([_,O/2]),K=[[h],[C===null?1:0],[b]],Y=C;C=e.runWebGLProgram(H,L,"int32",K),Im(e,Y);const P=b/2,W=P*2;for(let j=P;j>=1;j/=2)I(W,j,C.shape)}let D=C;C=Wx({inputs:{x:C},backend:e,attrs:{begin:0,size:[_,r]}}),Im(e,D);let F=hq({inputs:{x:S,indices:C},backend:e,attrs:{axis:1,batchDims:1}});Im(e,S);const z=c.slice(0,-1);z.push(r),D=C,C=Ie({inputs:{x:C},attrs:{shape:z},backend:e}),Im(e,D);const k=F;return F=Ie({inputs:{x:F},attrs:{shape:z},backend:e}),Im(e,k),[F,C]}const CIt={kernelName:bk,backendName:"webgl",kernelFunc:EIt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AIt{constructor(t,e,s,i,r,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const o=s==="nearest"?1:2;let l;switch(i){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NIt(n){const{inputs:t,backend:e,attrs:s}=n,{image:i,transforms:r}=t,{interpolation:a,fillMode:o,fillValue:l,outputShape:c}=s,[h,f,p,g]=i.shape,[v,_]=c??[f,p],S=[h,v,_,g],b=new AIt(f,p,a,o,l,S);return e.runWebGLProgram(b,[i,r],"float32")}const MIt={kernelName:Sk,backendName:"webgl",kernelFunc:NIt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IIt(n){const{inputs:t,attrs:e,backend:s}=n,{axis:i}=e,{x:r}=t;w_(r,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(r.dataId),{outputValues:o,outputShape:l,indices:c}=M_t(a,i,r.shape,r.dtype);return[s.makeTensorInfo(l,r.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}const RIt={kernelName:_k,backendName:"webgl",kernelFunc:IIt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DIt(n){const{inputs:t,backend:e,attrs:s}=n,{value:i}=t;let{axis:r}=s;r<0&&(r+=i.shape.length);const a=i,o=a.shape.length,l=i.shape[r],c=new Array(o-1);let h=0;for(let _=0;_<o;_++)_!==r&&(c[h++]=a.shape[_]);const f=[],p=new Array(o).fill(0),g=a.shape.slice();g[r]=1;const v=new Array(l);for(let _=0;_<v.length;_++){p[r]=_;const S=Wx({inputs:{x:a},backend:e,attrs:{begin:p,size:g}}),b=Ie({inputs:{x:S},backend:e,attrs:{shape:c}});v[_]=b,f.push(S)}return f.forEach(_=>e.disposeIntermediateTensorInfo(_)),v}const kIt={kernelName:BA,backendName:"webgl",kernelFunc:DIt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OIt{constructor(t,e){this.variableNames=["x","segmentIds"];const s=t.windowSize,i=t.batchSize,r=t.inSize,a=t.numSegments,o=a*Math.ceil(r/s);this.outputShape=[i,o];const l="0.0",c="sumValue",h=Math.floor(s/4)*4,f=s%4,p=`
        sumValue += dot(values, segFilter);
    `;let g="";r%s>0&&(g=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);let v="";r%s>0&&(v=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${v}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${h};
        if (${f===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${f===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${f===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $It(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,segmentIds:r}=t,{numSegments:a}=s,o=i.shape.length,l=[];let c=0;const h=Ti([c],o);let f=i;h!=null&&(f=Xa({inputs:{x:i},backend:e,attrs:{perm:h}}),l.push(f),c=ji(1,o)[0]);const p=t5(f.shape,c,a),g=Zt([f.shape[c]]),v=Ie({inputs:{x:f},backend:e,attrs:{shape:[-1,g]}});l.push(v);const _=Tk(i.dtype),S=(A,I,D,F,z)=>{const k=A.shape[0],O=A.shape[1],L=JH(O,z),H={windowSize:L,inSize:O,batchSize:k,numSegments:z},q=new OIt(H,I),K=e.compileAndRun(q,[A,D],F);if(l.push(K),K.shape[1]===z)return K;const Y=xq({backend:e,attrs:{start:0,stop:z,step:1,dtype:"float32"}}),P=vq({inputs:{x:Y},backend:e,attrs:{reps:[O/L]}});return l.push(Y),l.push(P),S(K,I,P,F,z)},b=S(v,"unsortedSegmentSum",r,_,a),T=Ie({inputs:{x:b},backend:e,attrs:{shape:p}});let C=T;if(h!=null){l.push(T);const A=gp(h);C=Xa({inputs:{x:C},backend:e,attrs:{perm:A}})}return l.forEach(A=>e.disposeIntermediateTensorInfo(A)),C}const LIt={kernelName:PA,backendName:"webgl",kernelFunc:$It};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FIt=[bwt,_wt,Ewt,Nwt,Iwt,kwt,$wt,Fwt,Pwt,Gwt,qwt,Kwt,Qwt,nTt,rTt,oTt,cTt,dTt,mTt,yTt,STt,NTt,ITt,OTt,LTt,VTt,HTt,jTt,swt,ZTt,nEt,aEt,fEt,mEt,yEt,vEt,SEt,EEt,NEt,REt,kEt,$Et,FEt,BEt,VEt,qEt,jEt,ZEt,t2t,n2t,a2t,u2t,p2t,y2t,b2t,S2t,w2t,E2t,A2t,M2t,R2t,$2t,z2t,P2t,G2t,q2t,K2t,J2t,sCt,nwt,rCt,tEt,lCt,hCt,pCt,rwt,xCt,_Ct,TCt,NCt,RCt,$Ct,zCt,VCt,qCt,KCt,ZCt,eAt,sAt,rAt,cAt,hAt,dAt,mAt,yAt,SAt,EAt,MAt,FAt,lwt,PAt,HAt,XAt,YAt,zTt,JAt,eNt,sNt,aNt,uNt,owt,fNt,pNt,gNt,xNt,vNt,UTt,kAt,_Nt,CNt,INt,uwt,ONt,FNt,PNt,HNt,jNt,YNt,JNt,nMt,rMt,lMt,hMt,pMt,xMt,SMt,EMt,NMt,CTt,$At,RMt,kMt,$Mt,FMt,UMt,PMt,GMt,WMt,XMt,YMt,QMt,tIt,nIt,rIt,oIt,cIt,hIt,OAt,ywt,pIt,yIt,vIt,_It,CIt,MIt,xwt,RIt,kIt,LIt,tNt];for(const n of FIt)pG(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zIt=1e-7,UIt=1e-4;class BIt{refCount(t){return Go("refCount")}incRef(t){return Go("incRef")}timerAvailable(){return!0}time(t){return Go("time")}read(t){return Go("read")}readSync(t){return Go("readSync")}readToGPU(t,e){return Go("readToGPU")}numDataIds(){return Go("numDataIds")}disposeData(t,e){return Go("disposeData")}write(t,e,s){return Go("write")}move(t,e,s,i,r){return Go("move")}createTensorFromGPUData(t,e,s){return Go("createTensorFromGPUData")}memory(){return Go("memory")}floatPrecision(){return Go("floatPrecision")}epsilon(){return this.floatPrecision()===32?zIt:UIt}dispose(){return Go("dispose")}}function Go(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lt(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function gc(n,t,e=""){lt(Nf(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function qx(n){lt(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ir(n){if(n.length===0)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function PIt(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==null&&t[e]!==null&&n[e]!==t[e])return!1;return!0}function Nf(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function H1(n){return n%1===0}function xE(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function vN(n,t){const e=t.length;return n=n==null?t.map((s,i)=>i):[].concat(n),lt(n.every(s=>s>=-e&&s<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),lt(n.every(s=>H1(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?e+s:s)}function VIt(n,t){const e=[],s=[],i=t!=null&&Array.isArray(t)&&t.length===0,r=t==null||i?null:vN(t,n).sort();let a=0;for(let o=0;o<n.length;++o){if(r!=null){if(r[a]===o&&n[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);(r[a]==null||r[a]>o)&&n[o]===1&&(e.push(n[o]),s.push(o)),r[a]<=o&&a++}n[o]!==1&&(e.push(n[o]),s.push(o))}return{newShape:e,keptDims:s}}function GIt(n,t){return bq(n,t)}function bq(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else if(n==="string")e=new Array(t);else throw new Error(`Unknown data type ${n}`);return e}function HIt(n,t){for(let e=0;e<n.length;e++){const s=n[e];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function WIt(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function iD(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function qIt(n){if(n==null)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function g$(n){return typeof n=="string"||n instanceof String}function XIt(n){return typeof n=="boolean"}function jIt(n){return typeof n=="number"}function bN(n){return Array.isArray(n)?bN(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":jIt(n)?"float32":g$(n)?"string":XIt(n)?"bool":"float32"}function rD(n){return!!(n&&n.constructor&&n.call&&n.apply)}function y$(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let s=t-3;s>=0;--s)e[s]=e[s+1]*n[s+1];return e}function Sq(n,t,e,s=!1){const i=new Array;if(t.length===1){const r=t[0]*(s?2:1);for(let a=0;a<r;a++)i[a]=e[n+a]}else{const r=t[0],a=t.slice(1),o=a.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<r;l++)i[l]=Sq(n+l*o,a,e,s)}return i}function aD(n,t,e=!1){if(n.length===0)return t[0];const s=n.reduce((i,r)=>i*r)*(e?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return Sq(0,n,t,e)}function _q(n,t){const e=x$(n,t);for(let s=0;s<e.length;s++)e[s]=1;return e}function x$(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function Ol(n){n.forEach(t=>{lt(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Tg(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zB="tfjsflags";class KIt{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=YIt,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(An().getBool("IS_TEST")||An().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,s){if(this.flagRegistry[t]={evaluationFn:e,setHook:s},this.urlFlags[t]!=null){const i=this.urlFlags[t];An().getBool("IS_TEST")||An().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${i}.`),this.set(t,i)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Tg(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);zB in t&&t[zB].split(",").forEach(s=>{const[i,r]=s.split(":");this.urlFlags[i]=QIt(i,r)})}}function YIt(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...s)=>(ZIt(t,s[0],s[1]),s.join("="))),t}function ZIt(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function QIt(n,t){const e=t.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:t}function An(){return wq}let wq=null;function JIt(n){wq=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let VI;function Tq(){if(VI==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");VI=n}return VI}function tRt(){const n=Tq();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function v$(n,t){const e=tRt();if(e.has(n))return e.get(n);{const s=t();return e.set(n,s),e.get(n)}}const eRt="Abs",nRt="Acos",sRt="Acosh",Eq="Add",iRt="AddN",rRt="All",aRt="Any",oRt="ArgMax",lRt="ArgMin",cRt="Asin",uRt="Asinh",hRt="Atan",fRt="Atanh",dRt="Atan2",pRt="AvgPool",mRt="AvgPool3D",gRt="BatchMatMul",yRt="BatchToSpaceND",xRt="Bincount",vRt="BitwiseAnd",bRt="BroadcastArgs",Cq="Cast",SRt="Ceil",_Rt="ClipByValue",wRt="Complex",TRt="ComplexAbs",ERt="Concat",CRt="Conv2D",ARt="Conv2DBackpropFilter",NRt="Conv2DBackpropInput",MRt="Conv3D",IRt="Conv3DBackpropInputV2",RRt="Cos",DRt="Cosh",kRt="Cumprod",ORt="Cumsum",$Rt="CropAndResize",LRt="DenseBincount",FRt="DepthToSpace",zRt="DepthwiseConv2dNative",URt="DepthwiseConv2dNativeBackpropFilter",BRt="DepthwiseConv2dNativeBackpropInput",PRt="Diag",VRt="Dilation2D",GRt="RealDiv",HRt="Einsum",WRt="Elu",qRt="Erf",XRt="Equal",jRt="Exp",KRt="ExpandDims",YRt="Expm1",ZRt="FFT",QRt="Fill",JRt="FlipLeftRight",tDt="Floor",eDt="FloorDiv",nDt="FusedBatchNorm",sDt="GatherV2",iDt="GatherNd",rDt="Greater",aDt="GreaterEqual",Aq="Identity",oDt="IFFT",lDt="Imag",cDt="IsFinite",uDt="IsInf",hDt="IsNan",fDt="LeakyRelu",dDt="Less",pDt="LessEqual",mDt="LinSpace",gDt="Log",yDt="Log1p",xDt="LogicalAnd",vDt="LogicalNot",bDt="LogicalOr",SDt="LRN",_Dt="Max",wDt="Maximum",TDt="MaxPool",EDt="MaxPool3D",CDt="MaxPoolWithArgmax",ADt="Mean",NDt="Min",MDt="Minimum",IDt="MirrorPad",RDt="Mod",DDt="Multinomial",kDt="Multiply",ODt="Neg",$Dt="NotEqual",LDt="NonMaxSuppressionV3",FDt="NonMaxSuppressionV4",zDt="NonMaxSuppressionV5",UDt="OnesLike",BDt="OneHot",PDt="Pack",VDt="PadV2",GDt="Pow",HDt="Prelu",WDt="Prod",qDt="RaggedGather",XDt="RaggedRange",jDt="RaggedTensorToTensor",KDt="Range",YDt="Real",ZDt="Reciprocal",QDt="Relu",JDt="Reshape",t3t="ResizeNearestNeighbor",e3t="ResizeBilinear",n3t="Relu6",s3t="Reverse",i3t="Round",r3t="Rsqrt",a3t="ScatterNd",o3t="TensorScatterUpdate",l3t="SearchSorted",c3t="Select",u3t="Selu",h3t="Slice",f3t="Sin",d3t="Sinh",p3t="Sign",m3t="Sigmoid",g3t="Softplus",y3t="Sqrt",x3t="Sum",v3t="SpaceToBatchND",b3t="SplitV",S3t="Softmax",_3t="SparseFillEmptyRows",w3t="SparseReshape",T3t="SparseSegmentMean",E3t="SparseSegmentSum",C3t="SparseToDense",A3t="SquaredDifference",N3t="StaticRegexReplace",M3t="StridedSlice",I3t="StringNGrams",R3t="StringSplit",D3t="StringToHashBucketFast",k3t="Sub",O3t="Tan",$3t="Tanh",Nq="Tile",L3t="TopK",F3t="Transform",GI="Transpose",z3t="Unique",U3t="Unpack",B3t="UnsortedSegmentSum",P3t="ZerosLike",V3t="Step",UB="FromPixels",G3t="RotateWithOffset",BB="_FusedMatMul",PB="FusedConv2D",VB="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fb(...n){An().getBool("IS_TEST")||An().getBool("PROD")||console.warn(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mq=v$("kernelRegistry",()=>new Map),H3t=v$("gradRegistry",()=>new Map);function oD(n,t){const e=W3t(n,t);return Mq.get(e)}function GB(n){return H3t.get(n)}function HB(n){const t=Mq.entries(),e=[];for(;;){const{done:s,value:i}=t.next();if(s)break;const[r,a]=i,[o]=r.split("_");o===n&&e.push(a)}return e}function W3t(n,t){return`${t}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iq(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q3t(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function Rq(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=W1(n)),An().getBool("DEBUG")&&HIt(n,t),q3t(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){const e=new Uint8Array(n.length);for(let s=0;s<e.length;++s)Math.round(n[s])!==0&&(e[s]=1);return e}else throw new Error(`Unknown data type ${t}`)}function j2(){return An().platform.now()}function X3t(n,t){return An().platform.fetch(n,t)}function j3t(n,t="utf-8"){return t=t||"utf-8",An().platform.encode(n,t)}function WB(n,t="utf-8"){return t=t||"utf-8",An().platform.decode(n,t)}function hc(n){return An().platform.isTypedArray!=null?An().platform.isTypedArray(n):Iq(n)}function W1(n,t=[],e=!1){if(t==null&&(t=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Tg(n)||n==null||hc(n)&&e)t.push(n);else if(Array.isArray(n)||hc(n))for(let s=0;s<n.length;++s)W1(n[s],t,e);else{let s=-1;for(const i of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(i)&&(s=Math.max(s,Number(i)));for(let i=0;i<=s;i++)W1(n[i],t,e)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K3t{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new Z3t)}profileKernel(t,e,s){let i;const r=()=>{i=s()};let a;const o=j2();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(r);else{r();for(const c of i)c.dataSync();a=Promise.resolve({kernelMs:j2()-o})}if(An().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<i.length;c++){const h=i[c];h.data().then(f=>{Y3t(f,h.dtype,t)})}return{kernelName:t,outputs:i,inputs:e,timeMs:a.then(c=>c.kernelMs),extraInfo:a.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:s,timeMs:i,inputs:r,extraInfo:a}=t;s.forEach(o=>{Promise.all([o.data(),i,a]).then(l=>{this.logger.logKernelProfile(e,o,l[0],l[1],r,l[2])})})}}function Y3t(n,t,e){if(t!=="float32")return!1;for(let s=0;s<n.length;s++){const i=n[s];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${e}'`),!0}return!1}class Z3t{logKernelProfile(t,e,s,i,r,a){const o=typeof i=="number"?xE(`${i}ms`,9):i.error,l=xE(t,25),c=e.rank,h=e.size,f=xE(e.shape.toString(),14);let p="";for(const g in r){const v=r[g];if(v!=null){const _=v.shape||e.shape,S=_.length;p+=`${g}: ${S}D ${S>0?_:""} `}}console.log(`%c${l}	%c${o}	%c${c}D ${f}	%c${h}	%c${p}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q3t(n,t,e){const s={},i={};for(let l=0;l<t.length;l++)s[t[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],h=c.inputs;for(const f in h){const p=h[f];let g=!1;for(let v=0;v<t.length;v++)if(s[p.id]){c.outputs.forEach(_=>s[_.id]=!0),g=!0,i[c.id]=!0;break}if(g)break}}const r={};r[e.id]=!0;const a={};for(let l=n.length-1;l>=0;l--){const c=n[l],h=c.inputs;for(let f=0;f<c.outputs.length;f++)if(r[c.outputs[f].id]){for(const p in h)r[h[p].id]=!0,a[c.id]=!0;break}}const o=[];for(let l=0;l<n.length;l++){const c=n[l];if(i[c.id]&&a[c.id]){const h={};for(const p in c.inputs){const g=c.inputs[p];s[g.id]&&(h[p]=g)}const f=Object.assign({},c);f.inputs=h,f.outputs=c.outputs,o.push(f)}}return o}function J3t(n,t,e,s){for(let i=t.length-1;i>=0;i--){const r=t[i],a=[];if(r.outputs.forEach(l=>{const c=n[l.id];c!=null?a.push(c):a.push(null)}),r.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${r.kernelName}.`);const o=r.gradient(a);for(const l in r.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const c=e(()=>o[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const h=r.inputs[l];if(!Nf(c.shape,h.shape))throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${h.shape}'`);if(n[h.id]==null)n[h.id]=c;else{const f=n[h.id];n[h.id]=s(f,c),f.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qB=20,zb=3,HI=7;function tkt(n,t,e,s){const i=y$(t),r=ekt(n,t,e,i),a=t.length,o=vE(n,t,e,i,r),l=["Tensor"];return s&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${a}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(c=>"    "+c).join(`
`)),l.join(`
`)}function ekt(n,t,e,s){const i=ir(t),r=s[s.length-1],a=new Array(r).fill(0),o=t.length,l=e==="complex64"?Yb(n):n;if(o>1)for(let c=0;c<i/r;c++){const h=c*r;for(let f=0;f<r;f++)a[f]=Math.max(a[f],Kb(l[h+f],0,e).length)}return a}function Kb(n,t,e){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(HI))} + ${parseFloat(n[1].toFixed(HI))}j`:g$(n)?s=`'${n}'`:e==="bool"?s=Dq(n):s=parseFloat(n.toFixed(HI)).toString(),xE(s,t)}function Dq(n){return n===0?"false":"true"}function vE(n,t,e,s,i,r=!0){const a=e==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(e==="complex64"){const _=Yb(n);return[Kb(_[0],0,e)]}return e==="bool"?[Dq(n[0])]:[n[0].toString()]}if(l===1){if(o>qB){const S=zb*a;let b=Array.from(n.slice(0,S)),T=Array.from(n.slice((o-zb)*a,o*a));return e==="complex64"&&(b=Yb(b),T=Yb(T)),["["+b.map((C,A)=>Kb(C,i[A],e)).join(", ")+", ..., "+T.map((C,A)=>Kb(C,i[o-zb+A],e)).join(", ")+"]"]}return["["+(e==="complex64"?Yb(n):Array.from(n)).map((S,b)=>Kb(S,i[b],e)).join(", ")+"]"]}const c=t.slice(1),h=s.slice(1),f=s[0]*a,p=[];if(o>qB){for(let _=0;_<zb;_++){const S=_*f,b=S+f;p.push(...vE(n.slice(S,b),c,e,h,i,!1))}p.push("...");for(let _=o-zb;_<o;_++){const S=_*f,b=S+f;p.push(...vE(n.slice(S,b),c,e,h,i,_===o-1))}}else for(let _=0;_<o;_++){const S=_*f,b=S+f;p.push(...vE(n.slice(S,b),c,e,h,i,_===o-1))}const g=l===2?",":"";p[0]="["+(o>0?p[0]+g:"");for(let _=1;_<p.length-1;_++)p[_]=" "+p[_]+g;let v=`,
`;for(let _=2;_<l;_++)v+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(r?"":v),p}function Yb(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lD{constructor(t,e,s){if(this.dtype=e,this.shape=t.slice(),this.size=ir(t),s!=null){const i=s.length;lt(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||bq(e,this.size),this.strides=y$(t)}set(t,...e){e.length===0&&(e=[0]),lt(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const s=this.locToIndex(e);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(const i of t){if(i<0||i>=this.shape[e]){const r=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(r)}e++}let s=t[t.length-1];for(let i=0;i<t.length-1;++i)s+=this.strides[i]*t[i];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let s=0;s<t.length-1;++s)e+=this.strides[s]*t[s];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const e=new Array(this.shape.length);for(let s=0;s<e.length-1;++s)e[s]=Math.floor(t/this.strides[s]),t-=e[s]*this.strides[s];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Kc().makeTensor(this.values,this.shape,this.dtype)}}let Kc=null,$y=null;function nkt(n){Kc=n}function skt(n){$y=n}class Kr{constructor(t,e,s,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=ir(t),this.strides=y$(t),this.dataId=s,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return $y.buffer(this.shape,this.dtype,t)}bufferSync(){return $y.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return aD(this.shape,t,this.dtype==="complex64")}arraySync(){return aD(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Kc().read(this.dataId);if(this.dtype==="string"){const e=await t;try{return e.map(s=>WB(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Kc().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Kc().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>WB(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Kc().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Kc().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return $y.print(this,t)}clone(){return this.throwIfDisposed(),$y.clone(this)}toString(t=!1){const e=this.dataSync();return tkt(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),$y.cast(this,t)}variable(t=!0,e,s){return this.throwIfDisposed(),Kc().makeVariable(this,t,e,s)}}Object.defineProperty(Kr,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function kq(){return v$("Tensor",()=>Kr)}kq();class K2 extends Kr{constructor(t,e,s,i){super(t.shape,t.dtype,t.dataId,i),this.trainable=e,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Nf(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Kc().disposeTensor(this),this.dataId=t.dataId,Kc().incRef(this,null)}dispose(){Kc().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(K2,Symbol.hasInstance,{value:n=>n instanceof Kr&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var XB;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(XB||(XB={}));var cD;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(cD||(cD={}));var uD;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(uD||(uD={}));var hD;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(hD||(hD={}));var fD;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(fD||(fD={}));const ikt={float32:hD,int32:cD,bool:uD,complex64:fD};function rkt(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return ikt[n][t]}function Oq(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function $q(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oi(n,t){if(n.dtype===t.dtype)return[n,t];const e=rkt(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function akt(n,t){lt(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)}function Lq(n){const t=[];return Fq(n,t,new Set),t}function Fq(n,t,e){if(n==null)return;if(n instanceof Kr){t.push(n);return}if(!okt(n))return;const s=n;for(const i in s){const r=s[i];e.has(r)||(e.add(r),Fq(r,t,e))}}function okt(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WI(n){return n.kernelName!=null}class jB{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class vx{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new jB}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,s=1){return t in this.registryFactory?(Fb(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:e,asyncInit:s}=this.initializeBackend(t);if(!(s?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new K3t(this.backendInstance),!0}setupRegisteredKernels(){HB(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){HB(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=e.factory();if(s&&!(s instanceof BIt)&&typeof s.then=="function"){const i=++this.pendingBackendInitId,r=s.then(a=>i<this.pendingBackendInitId?!1:(this.registry[t]=a,this.pendingBackendInit=null,!0)).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,Fb(`Initialization of backend ${t} failed`),Fb(a.stack||a.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return Fb(`Initialization of backend ${t} failed`),Fb(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e],{success:i,asyncInit:r}=this.initializeBackend(s);if(r||i)return{name:s,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const s=this.state.tensorInfo.get(e),i=s.backend,r=this.readSync(e),a=i.refCount(e);i.disposeData(e,!0),s.backend=t,t.move(e,r,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let s=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let i;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=e(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(t,e,s){t();try{const i=s();return e(),i}catch(i){throw e(),i}}nextTensorId(){return vx.nextTensorId++}nextVariableId(){return vx.nextVariableId++}clone(t){const e=xt.runKernel(Aq,{x:t}),s={x:t},i=a=>({x:()=>{const o="float32",l={x:a},c={dtype:o};return xt.runKernel(Cq,l,c)}}),r=[];return this.addTapeNode(this.state.activeScope.name,s,[e],i,r,{}),e}runKernel(t,e,s){if(this.backendName==null&&this.backend,!(oD(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,s){const i=this.backend.numDataIds();let r=0;s.forEach(l=>{r+=l.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=i-e-r-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let e,s=[];const i=this.isTapeOn(),r=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const c=WI(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(WI(t)){const{kernelName:v,inputs:_,attrs:S}=t;this.backendName==null&&this.backend;const b=oD(v,this.backendName);lt(b!=null,()=>`Cannot find registered kernel '${v}' for backend '${this.backendName}'`),o=()=>{const T=this.backend.numDataIds();l=b.kernelFunc({inputs:_,attrs:S,backend:this.backend});const C=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(v,T,C);const A=C.map(I=>I.rank!=null?I:this.makeTensorFromTensorInfo(I));if(i){const I=this.getTensorsForGradient(v,_,A);s=this.saveTensorsForBackwardMode(I)}return A}}else{const{forwardFunc:v}=t,_=S=>{i&&(s=S.map(b=>this.keep(this.clone(b))))};o=()=>{const S=this.backend.numDataIds();l=this.tidy(()=>v(this.backend,_));const b=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,S,b),b}}const{inputs:h,attrs:f}=t,p=WI(t)?null:t.backwardsFunc;let g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=o():(g=this.profiler.profileKernel(c,h,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),e=g.outputs)}),i&&this.addTapeNode(c,h,e,p,s,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(v=>h[v]!=null?h[v].shape:null),outputShapes:e.map(v=>v.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(l)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,e,s){const i=GB(t);if(i!=null){const r=i.inputsToSave||[],a=i.outputsToSave||[];let o;i.saveAllInputs?(lt(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(e).map(c=>e[c])):o=r.map(c=>e[c]);const l=s.filter((c,h)=>a[h]);return o.concat(l)}return[]}makeTensor(t,e,s,i){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",i=i||this.backend;let r=t;s==="string"&&g$(t[0])&&(r=t.map(l=>j3t(l)));const a=i.write(r,e,s),o=new Kr(e,s,a,this.nextTensorId());if(this.trackTensor(o,i),s==="string"){const l=this.state.tensorInfo.get(a),c=qIt(r);this.state.numBytes+=c-l.bytes,l.bytes=c}return o}makeTensorFromDataId(t,e,s,i){s=s||"float32";const r={dataId:t,shape:e,dtype:s};return this.makeTensorFromTensorInfo(r,i)}makeTensorFromTensorInfo(t,e){const{dataId:s,shape:i,dtype:r}=t,a=new Kr(i,r,s,this.nextTensorId());return this.trackTensor(a,e),a}makeVariable(t,e=!0,s,i){s=s||this.nextVariableId().toString(),i!=null&&i!==t.dtype&&(t=t.cast(i));const r=new K2(t,e,s,this.nextTensorId());if(this.state.registeredVariables[r.name]!=null)throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*iD(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof K2||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*iD(t.dtype);this.state.numBytes-=s}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,s,i,r,a){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:s,saved:r},l=GB(t);l!=null&&(i=l.gradFunc),i!=null&&(o.gradient=c=>(c=c.map((h,f)=>{if(h==null){const p=s[f],g=x$(p.size,p.dtype);return this.makeTensor(g,p.shape,p.dtype)}return h}),i(c.length>1?c:c[0],r,a))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Lq(t),s=new Set(e.map(r=>r.id));for(let r=0;r<this.state.activeScope.track.length;r++){const a=this.state.activeScope.track[r];!a.kept&&!s.has(a.id)&&a.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(r=>{!r.kept&&r.scopeId===i.id&&this.track(r)})}gradients(t,e,s,i=!1){if(lt(e.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));lt(r instanceof Kr,()=>"The result y returned by f() must be a tensor.");const a=Q3t(this.state.activeTape,e,r);if(!i&&a.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[r.id]=s??lkt(r.shape),J3t(o,a,c=>this.tidy(c),ckt);const l=e.map(c=>o[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const h of c.saved)h.dispose()}),this.state.activeTape=null),{value:r,grads:l}})}customGrad(t){return lt(rD(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{lt(e.every(o=>o instanceof Kr),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const i={};e.forEach((o,l)=>{i[l]=o});const r=(o,l)=>(s=t(...e,l),lt(s.value instanceof Kr,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),lt(rD(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(o,l)=>{const c=s.gradFunc(o,l),h=Array.isArray(c)?c:[c];lt(h.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),lt(h.every(p=>p instanceof Kr),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};return h.forEach((p,g)=>{f[g]=()=>p}),f};return this.runKernelFunc({forwardFunc:r,backwardsFunc:a,inputs:i})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=j2(),s=await this.backend.time(t);return s.wallMs=j2()-e,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new jB;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}vx.nextTensorId=0;vx.nextVariableId=0;function lkt(n){const t=_q(ir(n),"float32");return xt.makeTensor(t,n,"float32")}function zq(){const n=Tq();if(n._tfengine==null){const t=new KIt(n);n._tfengine=new vx(t)}return JIt(n._tfengine.ENV),nkt(()=>n._tfengine),n._tfengine}const xt=zq();function ckt(n,t){const e={a:n,b:t};return xt.runKernel(Eq,e)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ukt(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Co=An();Co.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Co.registerFlag("IS_BROWSER",()=>ukt());Co.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Co.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Co.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Co.registerFlag("PROD",()=>!1);Co.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Co.getBool("DEBUG"));Co.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Co.registerFlag("IS_TEST",()=>!1);Co.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Co.getBool("DEBUG"));Co.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Co.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Co.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _p(n,t){let e=n;if(hc(n))return t==="string"?[]:[n.length];if(Oq(n)){const i=n.channels||"RGBA";return[n.height,n.width*i.length]}else if($q(n))return[n.buffer.size/(t==null?4:iD(t))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(e)||hc(e)&&t!=="string";)s.push(e.length),e=e[0];return Array.isArray(n)&&An().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Uq(n,s,[]),s}function Uq(n,t,e){if(e=e||[],!Array.isArray(n)&&!hc(n)){lt(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}lt(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),lt(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const s=t.slice(1);for(let i=0;i<n.length;++i)Uq(n[i],s,e.concat(i))}function KB(n,t,e,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`)}}function J(n,t,e,s="numeric"){if(n instanceof kq())return KB(s,n.dtype,t,e),n;let i=bN(n);if(i!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(i=s),KB(s,i,t,e),n==null||!hc(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${l}'`)}const r=_p(n,i);!hc(n)&&!Array.isArray(n)&&(n=[n]);const o=i!=="string"?Rq(n,i):W1(n,[],!0);return xt.makeTensor(o,r,i)}function Y2(n,t,e,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((r,a)=>J(r,`${t}[${a}]`,e,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bq="__op";function pt(n){const t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const s=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+Bq;const i=(...r)=>{xt.startScope(e);try{const a=s(...r);return Tg(a)&&console.error("Cannot return a Promise inside of tidy."),xt.endScope(a),a}catch(a){throw xt.endScope(null),a}};return Object.defineProperty(i,"name",{value:e,configurable:!0}),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hkt(n,t){const e=J(n,"real","complex"),s=J(t,"imag","complex");gc(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`);const i={real:e,imag:s};return xt.runKernel(wRt,i)}const sp=pt({complex_:hkt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wp(n,t,e,s){if(s==null)s=bN(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if($q(n)||Oq(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return xt.backend.createTensorFromGPUData(n,t||e,s)}if(!hc(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Ol(t);const i=ir(t),r=ir(e);lt(i===r,()=>`Based on the provided shape, [${t}], the tensor should have ${i} values but has ${r}`);for(let a=0;a<e.length;++a){const o=e[a],l=a===e.length-1?o!==ir(t.slice(a)):!0;lt(e[a]===t[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!hc(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n=s!=="string"?Rq(n,s):W1(n,[],!0),xt.makeTensor(n,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hh(n,t,e){const s=_p(n,e);return wp(n,t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eg={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class hu{static join(t){return new hu(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(s=>hc(s)?s.buffer:s),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let s=0;s<t.length;s++){const i=t[s];s!==t.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=e+i.byteLength;this.shards.push({buffer:i,start:e,end:r}),e=r}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(s===-1)throw new Error(`Could not find start shard for byte ${t}`);const i=e-t,r=new ArrayBuffer(i),a=new Uint8Array(r);let o=0;for(let l=s;l<this.shards.length;l++){const c=this.shards[l],f=t+o-c.start,p=o,v=Math.min(e,c.end)-c.start,_=new Uint8Array(c.buffer,f,v-f);if(a.set(_,p),o+=_.length,e<c.end)break}return r}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(i){return t<i.start?-1:t>=i.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=fkt(this.shards,e);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function fkt(n,t){let e=0,s=n.length;for(;e<=s;){const i=Math.floor((s-e)/2)+e,r=t(n[i]);if(r===0)return i;r<0?s=i:e=i+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jn(n,t){return xt.tidy(n,t)}function wo(n){Lq(n).forEach(e=>e.dispose())}function ih(n){return xt.keep(n)}function b$(){return xt.backendName}function dkt(){return xt.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ip=4;async function pkt(n,t){const e=[],s=[],i=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<i.length;++a){const o=i[a],l=Array.isArray(n)?n[a].tensor:n[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const c={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const h=new Promise(async f=>{const p=await l.bytes(),g=p.reduce((S,b)=>S+b.length,0)+ip*p.length,v=new Uint8Array(g);let _=0;for(let S=0;S<p.length;S++){const b=p[S],T=new Uint8Array(new Uint32Array([b.length]).buffer);v.set(T,_),_+=ip,v.set(b,_),_+=b.length}f(v)});s.push(h)}else s.push(l.data());t!=null&&(c.group=t),e.push(c)}const r=await Promise.all(s);return{data:ykt(r),specs:e}}function Pq(n,t){const e=new hu(n),s={};let i=0;for(const r of t){const a=mkt(r,(o,l)=>e.slice(i+o,i+l));s[r.name]=Vq(r,e.slice(i,i+a)),i+=a}return s}function mkt(n,t){const e=ir(n.shape);let s;if("quantization"in n){const i=n.quantization;s=Eg[i.dtype]}else if(n.dtype==="string"){let i=0;for(let r=0;r<e;r++)i+=ip+new Uint32Array(t(i,i+ip))[0];return i}else s=Eg[n.dtype];return e*s}async function gkt(n,t){const e=ir(n.shape);let s;if("quantization"in n){const i=n.quantization;s=Eg[i.dtype]}else if(n.dtype==="string"){let i=0;for(let r=0;r<e;r++)i+=ip+new Uint32Array(await t(i,i+ip))[0];return i}else s=Eg[n.dtype];return e*s}function Vq(n,t){const e=n.name,s=n.dtype,i=n.shape,r=ir(i);let a,o=0;if("quantization"in n){const l=n.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${n.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=Eg[l.dtype],h=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(s==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){a=new Float32Array(h.length);for(let f=0;f<h.length;f++){const p=h[f];a[f]=p*l.scale+l.min}}else if(l.dtype==="float16")a=Tkt()(h);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(s==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);a=new Int32Array(h.length);for(let f=0;f<h.length;f++){const p=h[f];a[f]=Math.round(p*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${e}': ${s}`);o+=r*c}else if(s==="string"){const l=ir(n.shape);a=[];for(let c=0;c<l;c++){const h=new Uint32Array(t.slice(o,o+ip))[0];o+=ip;const f=new Uint8Array(t.slice(o,o+h));a.push(f),o+=h}}else{const l=Eg[s];if(s==="float32")a=new Float32Array(t);else if(s==="int32")a=new Int32Array(t);else if(s==="bool")a=new Uint8Array(t);else if(s==="complex64"){a=new Float32Array(t);const c=new Float32Array(a.length/2),h=new Float32Array(a.length/2);for(let v=0;v<c.length;v++)c[v]=a[v*2],h[v]=a[v*2+1];const f=hh(c,i,"float32"),p=hh(h,i,"float32"),g=sp(f,p);return f.dispose(),p.dispose(),g}else throw new Error(`Unsupported dtype in weight '${e}': ${s}`);o+=r*l}return hh(a,i,s)}async function YB(n,t,e){let s=new Uint8Array(t);for(;s.byteLength<e;){const{done:i,value:r}=await n.read();if(i&&r==null){const o=e-s.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const a=new Uint8Array(s.length+r.byteLength);a.set(s,0),a.set(new Uint8Array(r),s.length),s=a}return s.buffer}async function Gq(n,t){const e={},s=n.getReader();let i=new ArrayBuffer(0);for(const r of t){const a=await gkt(r,async(c,h)=>(i=await YB(s,i,h),i.slice(c,h)));i=await YB(s,i,a);const o=i.slice(0,a);i=i.slice(a);const l=Vq(r,o);if(e[r.name]=l,b$()==="webgpu"){const c=dkt();"uploadToGPU"in c&&ir(l.shape)>=An().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return e}function ykt(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(r=>{if(t+=r.byteLength,e.push(r.byteLength===r.buffer.byteLength?r:new r.constructor(r)),!(r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${r.constructor.name}`)});const s=new Uint8Array(t);let i=0;return e.forEach(r=>{s.set(new Uint8Array(r.buffer),i),i+=r.byteLength}),s.buffer}const S$=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function ZB(n){return S$?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function xkt(n){if(S$)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let s=0,i=t.length;s<i;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function vkt(n){if(S$){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let s=0;s<t.length;++s)e.set([t.charCodeAt(s)],s);return e.buffer}function bkt(n){return hu.join(n)}function QB(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const e=n.split("/");return e[e.length-1]}function Hq(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return n.signature!=null&&(e.signature=n.signature),n.userDefinedMetadata!=null&&(e.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(e.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(e.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(e.trainingConfig=n.trainingConfig),e}function Wq(n,t,e){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=e}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function _$(n,t){let e,s;return n.weightsManifest!=null&&([e,s]=await t(n.weightsManifest)),Wq(n,e,s)}function A_(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:ZB(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:ZB(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new hu(n.weightData).byteLength}}function dD(n){const t=[];for(const e of n)t.push(...e.weights);return t}function Skt(){const n=e=>{let s=e<<13,i=0;for(;(s&8388608)===0;)i-=8388608,s<<=1;return s&=-8388609,i+=947912704,s|i},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function _kt(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}function wkt(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}function Tkt(){const n=Skt(),t=_kt(),e=wkt();return s=>{const i=new ArrayBuffer(4*s.length),r=new Uint32Array(i);for(let a=0;a<s.length;a++){const o=s[a],l=n[e[o>>10]+(o&1023)]+t[o>>10];r[a]=l}return new Float32Array(i)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Si{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Si.instance==null&&(Si.instance=new Si),Si.instance}static registerSaveRouter(t){Si.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Si.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Si.getHandlers(t,"save")}static getLoadHandlers(t,e){return Si.getHandlers(t,"load",e)}static getHandlers(t,e,s){const i=[];return(e==="load"?Si.getInstance().loadRouters:Si.getInstance().saveRouters).forEach(a=>{const o=a(t,s);o!==null&&i.push(o)}),i}}const Ekt=n=>Si.registerSaveRouter(n),Ckt=n=>Si.registerLoadRouter(n),Akt=n=>Si.getSaveHandlers(n),Nkt=(n,t)=>Si.getLoadHandlers(n,t);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pD="tensorflowjs",mD=1,jm="models_store",Ud="model_info_store";function qq(){if(!An().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function gD(n){const t=n.result;t.createObjectStore(jm,{keyPath:"modelPath"}),t.createObjectStore(Ud,{keyPath:"modelPath"})}class Cg{constructor(t){if(this.indexedDB=qq(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((s,i)=>{const r=this.indexedDB.open(pD,mD);r.onupgradeneeded=()=>gD(r),r.onsuccess=()=>{const a=r.result;if(e==null){const o=a.transaction(jm,"readonly"),c=o.objectStore(jm).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return a.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=h=>(a.close(),i(c.error)),o.oncomplete=()=>a.close()}else{e.weightData=hu.join(e.weightData);const o=A_(e),l=a.transaction(Ud,"readwrite");let c=l.objectStore(Ud),h;try{h=c.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(p){return i(p)}let f;h.onsuccess=()=>{f=a.transaction(jm,"readwrite");const p=f.objectStore(jm);let g;try{g=p.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:o})}catch(v){return i(v)}g.onsuccess=()=>s({modelArtifactsInfo:o}),g.onerror=v=>{c=l.objectStore(Ud);const _=c.delete(this.modelPath);_.onsuccess=()=>(a.close(),i(g.error)),_.onerror=S=>(a.close(),i(g.error))}},h.onerror=p=>(a.close(),i(h.error)),l.oncomplete=()=>{f==null?a.close():f.oncomplete=()=>a.close()}}},r.onerror=a=>i(r.error)})}}Cg.URL_SCHEME="indexeddb://";const Xq=n=>An().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Cg.URL_SCHEME)?Mkt(n.slice(Cg.URL_SCHEME.length)):null;Si.registerSaveRouter(Xq);Si.registerLoadRouter(Xq);function Mkt(n){return new Cg(n)}function Ikt(n){return n.startsWith(Cg.URL_SCHEME)?n.slice(Cg.URL_SCHEME.length):n}class Rkt{constructor(){this.indexedDB=qq()}async listModels(){return new Promise((t,e)=>{const s=this.indexedDB.open(pD,mD);s.onupgradeneeded=()=>gD(s),s.onsuccess=()=>{const i=s.result,r=i.transaction(Ud,"readonly"),o=r.objectStore(Ud).getAll();o.onsuccess=()=>{const l={};for(const c of o.result)l[c.modelPath]=c.modelArtifactsInfo;t(l)},o.onerror=l=>(i.close(),e(o.error)),r.oncomplete=()=>i.close()},s.onerror=i=>e(s.error)})}async removeModel(t){return t=Ikt(t),new Promise((e,s)=>{const i=this.indexedDB.open(pD,mD);i.onupgradeneeded=()=>gD(i),i.onsuccess=()=>{const r=i.result,a=r.transaction(Ud,"readwrite"),o=a.objectStore(Ud),l=o.get(t);let c;l.onsuccess=()=>{if(l.result==null)return r.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const h=o.delete(t),f=()=>{c=r.transaction(jm,"readwrite");const g=c.objectStore(jm).delete(t);g.onsuccess=()=>e(l.result.modelArtifactsInfo),g.onerror=v=>s(l.error)};h.onsuccess=f,h.onerror=p=>(f(),r.close(),s(l.error))}},l.onerror=h=>(r.close(),s(l.error)),a.oncomplete=()=>{c==null?r.close():c.oncomplete=()=>r.close()}},i.onerror=r=>s(i.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xf="/",Ly="tensorflowjs_models",jq="info",Dkt="model_topology",kkt="weight_specs",Okt="weight_data",$kt="model_metadata";function Kq(n){return{info:[Ly,n,jq].join(xf),topology:[Ly,n,Dkt].join(xf),weightSpecs:[Ly,n,kkt].join(xf),weightData:[Ly,n,Okt].join(xf),modelMetadata:[Ly,n,$kt].join(xf)}}function Yq(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function Lkt(n){const t=n.split(xf);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(xf)}function Fkt(n){return n.startsWith(Ag.URL_SCHEME)?n.slice(Ag.URL_SCHEME.length):n}class Ag{constructor(t){if(!An().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Kq(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),i=A_(t),r=hu.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,xkt(r));const a={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:i}}catch{throw Yq(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=s;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=i;const r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){const o=JSON.parse(r);e.format=o.format,e.generatedBy=o.generatedBy,e.convertedBy=o.convertedBy,o.signature!=null&&(e.signature=o.signature),o.userDefinedMetadata!=null&&(e.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(e.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(e.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(e.trainingConfig=o.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=vkt(a),e}}Ag.URL_SCHEME="localstorage://";const Zq=n=>An().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ag.URL_SCHEME)?zkt(n.slice(Ag.URL_SCHEME.length)):null;Si.registerSaveRouter(Zq);Si.registerLoadRouter(Zq);function zkt(n){return new Ag(n)}class Ukt{constructor(){lt(An().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),lt(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=Ly+xf,s=xf+jq;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);if(r.startsWith(e)&&r.endsWith(s)){const a=Lkt(r);t[a]=JSON.parse(this.LS.getItem(r))}}return t}async removeModel(t){t=Fkt(t);const e=Kq(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(e.info));return Yq(e),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jy="://";class $a{constructor(){this.managers={}}static getInstance(){return $a.instance==null&&($a.instance=new $a),$a.instance}static registerManager(t,e){lt(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(jy)&&(t=t.slice(0,t.indexOf(jy))),lt(t.length>0,()=>"scheme must not be an empty string.");const s=$a.getInstance();lt(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=e}static getManager(t){const e=$a.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys($a.getInstance().managers)}}function bE(n){if(n.indexOf(jy)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${$a.getSchemes().join(",")}`);return{scheme:n.split(jy)[0],path:n.split(jy)[1]}}async function Qq(n,t,e=!1){lt(n!==t,()=>`Old path and new path are the same: '${n}'`);const s=Si.getLoadHandlers(n);lt(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),lt(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const i=s[0],r=Si.getSaveHandlers(t);lt(r.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),lt(r.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${t}.`);const a=r[0],o=bE(n).scheme,l=bE(n).path,c=o===bE(n).scheme,h=await i.load();e&&c&&await $a.getManager(o).removeModel(l);const f=await a.save(h);return e&&!c&&await $a.getManager(o).removeModel(l),f.modelArtifactsInfo}async function Bkt(){const n=$a.getSchemes(),t={};for(const e of n){const s=await $a.getManager(e).listModels();for(const i in s){const r=e+jy+i;t[r]=s[i]}}return t}async function Pkt(n){const t=bE(n);return $a.getManager(t.scheme).removeModel(t.path)}async function Vkt(n,t){return Qq(n,t,!1)}async function Gkt(n,t){return Qq(n,t,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hkt{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window>"u"||!An().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const i=this.functionRefs[s.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return Iq(t)}}if(An().get("IS_BROWSER")){An().setPlatform("browser",new Hkt);try{$a.registerManager(Ag.URL_SCHEME,new Ukt)}catch{}try{$a.registerManager(Cg.URL_SCHEME,new Rkt)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wkt={importFetch:()=>require("node-fetch")};let qI;class qkt{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return An().global.fetch!=null?An().global.fetch(t,e):(qI==null&&(qI=Wkt.importFetch()),qI(t,e))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}An().get("IS_NODE")&&!An().get("IS_BROWSER")&&An().setPlatform("node",new qkt);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mf(n,t="float32",e){return t=t||"float32",Ol(n),new lD(n,t,e)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xkt(n,t){const e=J(n,"x","cast");if(!WIt(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:e},i={dtype:t};return xt.runKernel(Cq,s,i)}const qi=pt({cast_:Xkt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jkt(n){const e={x:J(n,"x","clone","string_or_numeric")};return xt.runKernel(Aq,e)}const Wd=pt({clone_:jkt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jq(n,t=!1){console.log(n.toString(t))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zq();const Kkt={buffer:Mf,cast:qi,clone:Wd,print:Jq};skt(Kkt);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ykt(n,t){let e=J(n,"a","add"),s=J(t,"b","add");[e,s]=Oi(e,s);const i={a:e,b:s};return xt.runKernel(Eq,i)}const yn=pt({add_:Ykt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zkt(n,t){let e=J(n,"a","floorDiv"),s=J(t,"b","floorDiv");[e,s]=Oi(e,s);const i={a:e,b:s};return xt.runKernel(eDt,i)}const tX=pt({floorDiv_:Zkt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qkt(n,t){let e=J(n,"a","div"),s=J(t,"b","div");if([e,s]=Oi(e,s),e.dtype==="int32"&&s.dtype==="int32")return tX(e,s);const i={a:e,b:s},r={};return xt.runKernel(GRt,i,r)}const ks=pt({div_:Qkt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jkt(n,t){let e=J(n,"a","mul"),s=J(t,"b","mul");[e,s]=Oi(e,s);const i={a:e,b:s};return xt.runKernel(kDt,i)}const Re=pt({mul_:Jkt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tOt(n){const t=J(n,"x","abs");if(t.dtype==="complex64"){const e={x:t};return xt.runKernel(TRt,e)}else{const e={x:t};return xt.runKernel(eRt,e)}}const vl=pt({abs_:tOt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eOt(n){const e={x:J(n,"x","acos")};return xt.runKernel(nRt,e)}const nOt=pt({acos_:eOt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sOt(n){const e={x:J(n,"x","acosh")};return xt.runKernel(sRt,e)}const iOt=pt({acosh_:sOt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rOt(n){lt(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),lt(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const t=n.map((i,r)=>J(i,`tensors${r}`,"addN")),e=t[0];t.forEach(i=>{if(i.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(i=>{if(!Nf(i.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=t;return xt.runKernel(iRt,s)}const aOt=pt({addN_:rOt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oOt(n,t=null,e=!1){const i={x:J(n,"x","all","bool")},r={axis:t,keepDims:e};return xt.runKernel(rRt,i,r)}const lOt=pt({all_:oOt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cOt(n,t=null,e=!1){const i={x:J(n,"x","any","bool")},r={axis:t,keepDims:e};return xt.runKernel(aRt,i,r)}const uOt=pt({any_:cOt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hOt(n,t=0){const s={x:J(n,"x","argMax")},i={axis:t};return xt.runKernel(oRt,s,i)}const fOt=pt({argMax_:hOt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dOt(n,t=0){const s={x:J(n,"x","argMin")},i={axis:t};return xt.runKernel(lRt,s,i)}const pOt=pt({argMin_:dOt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mOt(n){const e={x:J(n,"x","asin")};return xt.runKernel(cRt,e)}const gOt=pt({asin_:mOt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yOt(n){const e={x:J(n,"x","asinh")};return xt.runKernel(uRt,e)}const xOt=pt({asinh_:yOt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vOt(n){const e={x:J(n,"x","atan")};return xt.runKernel(hRt,e)}const bOt=pt({atan_:vOt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SOt(n,t){let e=J(n,"a","atan2"),s=J(t,"b","atan2");[e,s]=Oi(e,s);const i={a:e,b:s};return xt.runKernel(dRt,i)}const _Ot=pt({atan2_:SOt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wOt(n){const e={x:J(n,"x","atanh")};return xt.runKernel(fRt,e)}const TOt=pt({atanh_:wOt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EOt(n,t,e,s,i,r,a="channelsLast"){const[o,l]=q1(t);let c;if(a==="channelsLast")c=[o,l,n[3],n[3]];else if(a==="channelsFirst")c=[o,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return w$(n,c,e,s,i,r,!1,a)}function w$(n,t,e,s,i,r,a=!1,o="channelsLast"){let[l,c,h,f]=[-1,-1,-1,-1];if(o==="channelsLast")[l,c,h,f]=n;else if(o==="channelsFirst")[l,f,c,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[p,g,,v]=t,[_,S]=q1(e),[b,T]=q1(s),C=yD(p,b),A=yD(g,T),{padInfo:I,outHeight:D,outWidth:F}=NOt(i,c,h,_,S,C,A,r,o),z=a?v*f:v;let k;return o==="channelsFirst"?k=[l,z,D,F]:o==="channelsLast"&&(k=[l,D,F,z]),{batchSize:l,dataFormat:o,inHeight:c,inWidth:h,inChannels:f,outHeight:D,outWidth:F,outChannels:z,padInfo:I,strideHeight:_,strideWidth:S,filterHeight:p,filterWidth:g,effectiveFilterHeight:C,effectiveFilterWidth:A,dilationHeight:b,dilationWidth:T,inShape:n,outShape:k,filterShape:t}}function COt(n,t,e,s,i){s==null&&(s=AOt(n,t,e));const r=n[0],a=n[1],o=Z2((r-t+2*s)/e+1,i),l=Z2((a-t+2*s)/e+1,i);return[o,l]}function AOt(n,t,e,s=1){const i=yD(t,s);return Math.floor((n[0]*(e-1)-e+i)/2)}function q1(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function yD(n,t){return t<=1?n:n+(n-1)*(t-1)}function NOt(n,t,e,s,i,r,a,o,l){let c,h,f;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const g=COt([t,e],r,s,n,o);h=g[0],f=g[1]}else if(n==="same"){h=Math.ceil(t/s),f=Math.ceil(e/i);const p=Math.max(0,(h-1)*s+r-t),g=Math.max(0,(f-1)*i+a-e),v=Math.floor(p/2),_=p-v,S=Math.floor(g/2),b=g-S;c={top:v,bottom:_,left:S,right:b,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((t-r+1)/s),f=Math.ceil((e-a+1)/i);else if(typeof n=="object"){const p=l==="channelsLast"?n[1][0]:n[2][0],g=l==="channelsLast"?n[1][1]:n[2][1],v=l==="channelsLast"?n[2][0]:n[3][0],_=l==="channelsLast"?n[2][1]:n[3][1];c={top:p,bottom:g,left:v,right:_,type:p===0&&g===0&&v===0&&_===0?"VALID":"EXPLICIT"},h=Z2((t-r+p+g)/s+1,o),f=Z2((e-a+v+_)/i+1,o)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:h,outWidth:f}}function Z2(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function Q2(n){const[t,e,s]=q1(n);return t===1&&e===1&&s===1}function Tp(n,t){return Q2(n)||Q2(t)}function bx(n){return q1(n).every(t=>t>0)}function fu(n,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")lt(H1(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(i=>{lt(H1(i),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${i}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${t}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MOt(n,t){const s={x:J(n,"x","reshape","string_or_numeric")},i={shape:t};return xt.runKernel(JDt,s,i)}const oe=pt({reshape_:MOt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IOt(n,t,e,s,i){const r=J(n,"x","avgPool","float32"),a=1;lt(Tp(e,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`);let o=r,l=!1;r.rank===3&&(l=!0,o=oe(r,[1,r.shape[0],r.shape[1],r.shape[2]])),lt(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),fu("avgPool",s,i);const c={x:o},h={filterSize:t,strides:e,pad:s,dimRoundingMode:i};let f=xt.runKernel(pRt,c,h);return f=qi(f,r.dtype),l?oe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const eX=pt({avgPool_:IOt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ROt(n,t,e,s,i,r="NDHWC"){const a=J(n,"x","avgPool3d","float32");let o=a,l=!1;a.rank===4&&(l=!0,o=oe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),lt(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),lt(r==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),lt(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),fu("avgPool3d",s,i);const c={x:o},h={filterSize:t,strides:e,pad:s,dimRoundingMode:i,dataFormat:r};let f=xt.runKernel(mRt,c,h);return f=qi(f,o.dtype),l?oe(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const DOt=pt({avgPool3d_:ROt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kOt(n,t=0){lt(n.length>=1,()=>"Pass at least one tensor to concat");const e=Y2(n,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(r=>{if(r.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${r.dtype}. `)}),e.length===1)return Wd(e[0]);const s=e,i={axis:t};return xt.runKernel(ERt,s,i)}const Wa=pt({concat_:kOt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OOt(n,t,e=!1,s=!1){let i=J(n,"a","matMul"),r=J(t,"b","matMul");[i,r]=Oi(i,r);const a={a:i,b:r},o={transposeA:e,transposeB:s};return xt.runKernel(gRt,a,o)}const Vs=pt({matMul_:OOt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ot(n){const e={x:J(n,"x","sigmoid","float32")};return xt.runKernel(m3t,e)}const sg=pt({sigmoid_:$Ot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LOt(n,t,e){const s=J(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const i={x:s},r={begin:t,size:e};return xt.runKernel(h3t,i,r)}const bs=pt({slice_:LOt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FOt(n){const e={x:J(n,"x","tanh","float32")};return xt.runKernel($3t,e)}const xD=pt({tanh_:FOt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zOt(n,t,e,s,i,r){const a=J(n,"forgetBias","basicLSTMCell"),o=J(t,"lstmKernel","basicLSTMCell"),l=J(e,"lstmBias","basicLSTMCell"),c=J(s,"data","basicLSTMCell"),h=J(i,"c","basicLSTMCell"),f=J(r,"h","basicLSTMCell"),p=Wa([c,f],1),g=Vs(p,o),v=yn(g,l),_=v.shape[0],S=v.shape[1]/4,b=[_,S],T=bs(v,[0,0],b),C=bs(v,[0,S],b),A=bs(v,[0,S*2],b),I=bs(v,[0,S*3],b),D=yn(Re(sg(T),xD(C)),Re(h,sg(yn(a,A)))),F=Re(xD(D),sg(I));return[D,F]}const UOt=pt({basicLSTMCell_:zOt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BOt(n,t,e){const s=J(n,"x","batchToSpaceND"),i=t.reduce((o,l)=>o*l);lt(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),lt(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),lt(s.shape[0]%i===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${i}`);const r={x:s},a={blockShape:t,crops:e};return xt.runKernel(yRt,r,a)}const nX=pt({batchToSpaceND_:BOt});function POt(n){let t;return n.rank===0||n.rank===1?t=oe(n,[1,1,1,n.size]):n.rank===2?t=oe(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?t=oe(n,[1,n.shape[0],n.shape[1],n.shape[2]]):t=n,t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VOt(n,t,e,s,i,r){r==null&&(r=.001);const a=J(n,"x","batchNorm"),o=J(t,"mean","batchNorm"),l=J(e,"variance","batchNorm");let c;i!=null&&(c=J(i,"scale","batchNorm"));let h;s!=null&&(h=J(s,"offset","batchNorm")),lt(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),lt(h==null||o.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),lt(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:POt(a),scale:c,offset:h,mean:o,variance:l},g={varianceEpsilon:r},v=xt.runKernel(nDt,p,g);return oe(v,a.shape)}const SN=pt({batchNorm_:VOt});function GOt(n,t,e,s,i,r){const a=J(n,"x","batchNorm"),o=J(t,"mean","batchNorm"),l=J(e,"variance","batchNorm");let c;i!=null&&(c=J(i,"scale","batchNorm"));let h;return s!=null&&(h=J(s,"offset","batchNorm")),lt(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),lt(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),lt(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&lt(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&lt(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),SN(a,o,l,h,c,r)}const HOt=pt({batchNorm2d_:GOt});function WOt(n,t,e,s,i,r){const a=J(n,"x","batchNorm"),o=J(t,"mean","batchNorm"),l=J(e,"variance","batchNorm");let c;i!=null&&(c=J(i,"scale","batchNorm"));let h;return s!=null&&(h=J(s,"offset","batchNorm")),lt(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),lt(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),lt(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&lt(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&lt(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),SN(a,o,l,h,c,r)}const qOt=pt({batchNorm3d_:WOt});function XOt(n,t,e,s,i,r){const a=J(n,"x","batchNorm"),o=J(t,"mean","batchNorm"),l=J(e,"variance","batchNorm");let c;i!=null&&(c=J(i,"scale","batchNorm"));let h;return s!=null&&(h=J(s,"offset","batchNorm")),lt(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),lt(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),lt(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&lt(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&lt(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),SN(a,o,l,h,c,r)}const jOt=pt({batchNorm4d_:XOt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KOt(n,t,e){const s=J(n,"x","bincount"),i=J(t,"weights","bincount");lt(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),lt(e>=0,()=>`size must be non-negative, but got ${e}.`),lt(i.size===s.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);const r={x:s,weights:i},a={size:e};return xt.runKernel(xRt,r,a)}const sX=pt({bincount_:KOt});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YOt(n,t){const e=J(n,"x","bitwiseAnd"),s=J(t,"y","bitwiseAnd");if(!Nf(e.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${s.shape}`);if(e.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${s.dtype}`);const i={a:e,b:s};return xt.runKernel(vRt,i)}const ZOt=pt({bitwiseAnd_:YOt});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QOt(n,t){const e=J(n,"s0","broadcastArgs","int32"),s=J(t,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const i={s0:e,s1:s};return xt.runKernel(bRt,i)}const JOt=pt({broadcastArgs_:QOt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t$t(n,t){let e=J(n,"broadcastTo","x");const s=e.shape;if(Ol(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const c=e.shape.slice();for(;c.length<t.length;)c.unshift(1);e=oe(e,c)}const i=e.shape,r=Array.from(t);for(let c=t.length-1;c>=0;c--)if(i[c]===t[c])r[c]=1;else if(e.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(r.map((c,h)=>c>1?h:-1).filter(c=>c>=0).length===0)return Wd(e);const o={x:e},l={reps:r};return xt.runKernel(Nq,o,l)}const SE=pt({broadcastTo_:t$t});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e$t(n){const e={x:J(n,"x","ceil","float32")};return xt.runKernel(SRt,e)}const n$t=pt({ceil_:e$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N_(n,t,e){Ol(n),e=e||bN(t);const s={shape:n,value:t,dtype:e};return xt.runKernel(QRt,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$t(n,t,e){const s=J(n,"x","clipByValue");if(lt(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return N_(s.shape,t,s.dtype);const i={x:s},r={clipValueMin:t,clipValueMax:e};return xt.runKernel(_Rt,i,r)}const i$t=pt({clipByValue_:s$t});function r$t(n){return Wa(n,0)}const a$t=pt({concat1d_:r$t});function o$t(n,t){return Wa(n,t)}const iX=pt({concat2d_:o$t});function l$t(n,t){return Wa(n,t)}const c$t=pt({concat3d_:l$t});function u$t(n,t){return Wa(n,t)}const h$t=pt({concat4d_:u$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$t(n,t,e,s,i="NHWC",r=[1,1],a){const o=J(n,"x","conv2d","float32"),l=J(t,"filter","conv2d","float32");let c=o,h=!1;o.rank===3&&(h=!0,c=oe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),lt(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),lt(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),fu("conv2d",s,a);const f=i==="NHWC"?c.shape[3]:c.shape[1];lt(f===l.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${l.shape[2]}.`),lt(Tp(e,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`),lt(bx(r),()=>"Error in conv2D: Dilated rates should be larger than 0."),lt(bx(e),()=>"Error in conv2D: Strides should be larger than 0.");const p={x:c,filter:l},g={strides:e,pad:s,dataFormat:i,dilations:r,dimRoundingMode:a},v=xt.runKernel(CRt,p,g);return h?oe(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const _N=pt({conv2d_:f$t});function d$t(n,t,e,s,i="NWC",r=1,a){const o=J(n,"x","conv1d"),l=J(t,"filter","conv1d");let c=o,h=!1;o.rank===2&&(h=!0,c=oe(o,[1,o.shape[0],o.shape[1]])),lt(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),lt(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),fu("conv1d",s,a),lt(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),lt(Tp(e,r),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${r}'`),lt(bx(r),()=>"Error in conv1D: Dilated rates should be larger than 0."),lt(bx(e),()=>"Error in conv1D: Stride should be larger than 0."),lt(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const f=oe(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=oe(c,[c.shape[0],1,c.shape[1],c.shape[2]]),S=_N(p,f,[1,e],s,"NHWC",[1,r],a);return h?oe(S,[S.shape[2],S.shape[3]]):oe(S,[S.shape[0],S.shape[2],S.shape[3]])}const p$t=pt({conv1d_:d$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m$t(n,t,e,s,i,r="NHWC",a){lt(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let o=n,l=t,c=!1;t.rank===3&&(c=!0,l=oe(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,n[0],n[1],n[2]]),lt(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),lt(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),lt(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const h=r==="NHWC"?o[3]:o[1],f=r==="NHWC"?l.shape[3]:l.shape[1];lt(h===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${e.shape[2]}.`),lt(f===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${e.shape[3]}.`),fu("conv2dDerInput",i,a);const p={dy:l,filter:e},g={strides:s,pad:i,dataFormat:r,dimRoundingMode:a,inputShape:o},v=xt.runKernel(NRt,p,g);return c?oe(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const rX=pt({conv2DBackpropInput_:m$t});function g$t(n,t,e,s,i,r){const a=J(n,"x","conv2dTranspose"),o=J(t,"filter","conv2dTranspose");return rX(e,a,o,s,i,"NHWC",r)}const y$t=pt({conv2dTranspose_:g$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x$t(n,t,e,s,i="NDHWC",r=[1,1,1]){const a=J(n,"x","conv3d"),o=J(t,"filter","conv3d");let l=a,c=!1;a.rank===4&&(c=!0,l=oe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),lt(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),lt(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),lt(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),lt(Tp(e,r),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`),lt(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),lt(bx(r),()=>"Error in conv3D: Dilated rates should be larger than 0."),lt(bx(e),()=>"Error in conv3D: Strides should be larger than 0.");const h={x:l,filter:o},f={strides:e,pad:s,dataFormat:i,dilations:r},p=xt.runKernel(MRt,h,f);return c?oe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const v$t=pt({conv3d_:x$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$t(n,t,e,s,i){lt(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let r=n,a=t,o=!1;t.rank===4&&(o=!0,a=oe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),r=[1,n[0],n[1],n[2],n[3]]);const l=r[4],c=a.shape[4];lt(r.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${r.length}.`),lt(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),lt(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),lt(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),lt(c===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);const h={dy:a,filter:e},f={pad:i,strides:s,inputShape:r},p=xt.runKernel(IRt,h,f);return o?oe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const S$t=pt({conv3DBackpropInput_:b$t});function _$t(n,t,e,s,i){const r=J(n,"x","conv3dTranspose"),a=J(t,"filter","conv3dTranspose");return S$t(e,r,a,s,i)}const w$t=pt({conv3dTranspose_:_$t});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T$t(n){const e={x:J(n,"x","cos","float32")};return xt.runKernel(RRt,e)}const E$t=pt({cos_:T$t});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C$t(n){const e={x:J(n,"x","cosh","float32")};return xt.runKernel(DRt,e)}const A$t=pt({cosh_:C$t});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N$t(n,t=0,e=!1,s=!1){const r={x:J(n,"x","cumprod")},a={axis:t,exclusive:e,reverse:s};return xt.runKernel(kRt,r,a)}const M$t=pt({cumprod_:N$t});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$t(n,t=0,e=!1,s=!1){const r={x:J(n,"x","cumsum")},a={axis:t,exclusive:e,reverse:s};return xt.runKernel(ORt,r,a)}const R$t=pt({cumsum_:I$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D$t(n,t,e,s=!1){const i=J(n,"x","denseBincount"),r=J(t,"weights","denseBincount");lt(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),lt(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),lt(e>=0,()=>`size must be non-negative, but got ${e}.`),lt(r.size===i.size||r.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${r.shape}.`);const a={x:i,weights:r},o={size:e,binaryOutput:s};return xt.runKernel(LRt,a,o)}const k$t=pt({denseBincount_:D$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O$t(n,t,e="NHWC"){const s=J(n,"x","depthToSpace","float32"),i=e==="NHWC"?s.shape[1]:s.shape[2],r=e==="NHWC"?s.shape[2]:s.shape[3],a=e==="NHWC"?s.shape[3]:s.shape[1];lt(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),lt(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t}  for depthToSpace with input shape
    ${s.shape}`),lt(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t} for depthToSpace with input shape
        ${s.shape}`),lt(a%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${a} for depthToSpace with input shape ${s.shape}`);const o={x:s},l={blockSize:t,dataFormat:e};return xt.runKernel(FRt,o,l)}const $$t=pt({depthToSpace_:O$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L$t(n,t,e,s,i="NHWC",r=[1,1],a){const o=J(n,"x","depthwiseConv2d","float32"),l=J(t,"filter","depthwiseConv2d","float32");let c=o,h=!1;o.rank===3&&(h=!0,c=oe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),lt(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),lt(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const f=i==="NHWC"?c.shape[3]:c.shape[1];lt(f===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${l.shape[2]}.`),fu("depthwiseConv2d",s,a);const p={x:c,filter:l},g={strides:e,pad:s,dataFormat:i,dilations:r,dimRoundingMode:a},v=xt.runKernel(zRt,p,g);return h?oe(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const T$=pt({depthwiseConv2d_:L$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F$t(n){const e={x:J(n,"x","diag")};return xt.runKernel(PRt,e)}const z$t=pt({diag_:F$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U$t(n,t,e,s,i=[1,1],r="NHWC"){const a=J(n,"x","dilation2d"),o=J(t,"filter","dilation2d");lt(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),lt(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),lt(r==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${r}`);let l=a,c=!1;a.rank===3&&(l=oe(a,[1,a.shape[0],a.shape[1],a.shape[2]]),c=!0),lt(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const h={x:l,filter:o},f={strides:e,pad:s,dilations:i},p=xt.runKernel(VRt,h,f);return c?oe(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const B$t=pt({dilation2d_:U$t});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P$t(n,t){const e=[];for(let s=0;s<t.length;s++){const i=n[n.length-s-1],r=t.length-s-1,a=t[r];(i==null||i===1&&a>1)&&e.unshift(r)}return e}function Fr(n,t){const e=Math.max(n.length,t.length),s=new Array(e);for(let i=0;i<e;i++){let r=n[n.length-i-1];r==null&&(r=1);let a=t[t.length-i-1];if(a==null&&(a=1),r===1)s[e-i-1]=a;else if(a===1)s[e-i-1]=r;else if(r!==a){const o=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(o)}else s[e-i-1]=r}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$t(n,t){let e=J(n,"a","equal","string_or_numeric"),s=J(t,"b","equal","string_or_numeric");[e,s]=Oi(e,s),Fr(e.shape,s.shape);const i={a:e,b:s};return xt.runKernel(XRt,i)}const aX=pt({equal_:V$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$t(n,t,e){const s=J(t,"a","where"),i=J(e,"b","where"),r=J(n,"condition","where","bool"),a=Fr(Fr(r.shape,s.shape),i.shape),o=SE(r,a),l=SE(s,a),c=SE(i,a),h={condition:o,t:l,e:c};return xt.runKernel(c3t,h)}const qd=pt({where_:G$t});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H$t(n){const e={x:J(n,"x","zerosLike")};return xt.runKernel(P3t,e)}const Al=pt({zerosLike_:H$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W$t(n,t){let e=J(n,"a","div"),s=J(t,"b","div");[e,s]=Oi(e,s);const i=ks(e,s),r=Al(i),a=aX(s,r);return qd(a,r,i)}const q$t=pt({divNoNan_:W$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$t(n,t){const e=J(n,"t1","dot"),s=J(t,"t2","dot");lt((e.rank===1||e.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${s.rank}.`);const i=e.rank===1?e.size:e.shape[1],r=s.rank===1?s.size:s.shape[0];if(lt(i===r,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${r}.`),e.rank===1&&s.rank===1){const a=oe(e,[1,-1]),o=oe(s,[-1,1]),l=Vs(a,o);return oe(l,[])}else if(e.rank===1&&s.rank===2){const a=oe(e,[1,-1]),o=oe(s,[s.shape[0],s.shape[1]]),l=Vs(a,o);return oe(l,[l.size])}else if(e.rank===2&&s.rank===1){const a=oe(s,[-1,1]),o=Vs(e,a);return oe(o,[o.size])}else{const a=oe(s,[s.shape[0],s.shape[1]]);return Vs(e,a)}}const j$t=pt({dot_:X$t});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K$t(n,...t){const e=t.map((i,r)=>J(i,`tensors${r}`,"einsum")),s={equation:n};return xt.runKernel(HRt,e,s)}const Fy=pt({einsum_:K$t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$t(n){const e={x:J(n,"x","elu","float32")};return xt.runKernel(WRt,e)}const oX=pt({elu_:Y$t});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z$t(n,t){const e=J(n,"x","ensureShape","string_or_numeric");if(!PIt(e.shape,t))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${t}`);return n}const Q$t=pt({ensureShape_:Z$t});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$t(n){let t=J(n,"x","erf");lt(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=qi(t,"float32"));const e={x:t};return xt.runKernel(qRt,e)}const tLt=pt({erf_:J$t});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eLt(n,t,e){const s=n.length+t.length,i=[];let r=0,a=0;for(let o=0;o<s;o++)e.indexOf(o)===-1?i.push(n[r++]):i.push(t[a++]);return i}function wN(n,t){const e=t.map(s=>1);return eLt(n,e,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nLt(n,t=null,e=!1){const i={x:J(n,"x","max")},r={reductionIndices:t,keepDims:e};return xt.runKernel(_Dt,i,r)}const Ky=pt({max_:nLt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sLt(n,t=null,e=!1){const i={x:J(n,"x","min")},r={axis:t,keepDims:e};return xt.runKernel(NDt,i,r)}const vD=pt({min_:sLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iLt(n,t){let e=J(n,"base","pow"),s=J(t,"exp","pow");[e,s]=Oi(e,s);const i={a:e,b:s};return xt.runKernel(GDt,i)}const X1=pt({pow_:iLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hs(n,t){if((hc(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&hc(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return wp(n,[],[],t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rLt(n){const e={x:J(n,"x","sqrt","float32")};return xt.runKernel(y3t,e)}const If=pt({sqrt_:rLt});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aLt(n){const t=J(n,"x","square"),e={};return xt.runKernel("Square",{x:t},e)}const iu=pt({square_:aLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oLt(n,t=null,e=!1){let s=J(n,"x","sum");s.dtype==="bool"&&(s=qi(s,"int32"));const i={x:s},r={axis:t,keepDims:e};return xt.runKernel(x3t,i,r)}const ai=pt({sum_:oLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lLt(n,t="euclidean",e=null,s=!1){n=J(n,"x","norm");const i=lX(n,t,e);let r=i.shape;if(s){const a=vN(e,n.shape);r=wN(i.shape,a)}return oe(i,r)}function lX(n,t,e=null){if(n.rank===0)return vl(n);if(n.rank!==1&&e===null)return lX(oe(n,[-1]),t,e);if(n.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return ai(vl(n),e);if(t===1/0)return Ky(vl(n),e);if(t===-1/0)return vD(vl(n),e);if(t==="euclidean"||t===2)return If(ai(X1(vl(n),hs(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return Ky(ai(vl(n),e[0]),e[1]-1);if(t===1/0)return Ky(ai(vl(n),e[1]),e[0]);if(t===-1/0)return vD(ai(vl(n),e[1]),e[0]);if(t==="fro"||t==="euclidean")return If(ai(iu(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const TN=pt({norm_:lLt});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cLt(n,t=null,e=!1){return TN(n,"euclidean",t,e)}const uLt=pt({euclideanNorm_:cLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hLt(n){const e={x:J(n,"x","exp")};return xt.runKernel(jRt,e)}const Ng=pt({exp_:hLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fLt(n,t=0){const e=J(n,"x","expandDims","string_or_numeric");lt(t<=e.rank,()=>"Axis must be <= rank of the tensor");const s={input:e},i={dim:t};return xt.runKernel(KRt,s,i)}const df=pt({expandDims_:fLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dLt(n){const e={x:J(n,"x","expm1")};return xt.runKernel(YRt,e)}const pLt=pt({expm1_:dLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mLt(n,t){const e=J(n,"x","tile","string_or_numeric");lt(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);const s={x:e},i={reps:t};return xt.runKernel(Nq,s,i)}const u1=pt({tile_:mLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gLt(n,t,e,s="float32"){t==null&&(t=n);const i=Mf([n,t],s),r=n<=t?n:t;for(let o=0;o<r;++o)i.set(1,o,o);const a=oe(i.toTensor(),[n,t]);if(e==null)return a;if(e.length===1)return u1(df(a,0),[e[0],1,1]);if(e.length===2)return u1(df(df(a,0),0),[e[0],e[1],1,1]);if(e.length===3)return u1(df(df(df(a,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}const cX=pt({eye_:gLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yLt(n){const e={x:J(n,"x","floor","float32")};return xt.runKernel(tDt,e)}const uX=pt({floor_:yLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xLt(n,t,e=0,s=0){const i=J(n,"x","gather"),r=J(t,"indices","gather","int32"),a={x:i,indices:r},o={axis:e,batchDims:s};return xt.runKernel(sDt,a,o)}const hX=pt({gather_:xLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vLt(n,t){let e=J(n,"a","greater","string_or_numeric"),s=J(t,"b","greater","string_or_numeric");[e,s]=Oi(e,s),Fr(e.shape,s.shape);const i={a:e,b:s};return xt.runKernel(rDt,i)}const EN=pt({greater_:vLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bLt(n,t){let e=J(n,"a","greaterEqual","string_or_numeric"),s=J(t,"b","greaterEqual","string_or_numeric");[e,s]=Oi(e,s),Fr(e.shape,s.shape);const i={a:e,b:s};return xt.runKernel(aDt,i)}const fX=pt({greaterEqual_:bLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SLt(n){const e={input:J(n,"input","imag")};return xt.runKernel(lDt,e)}const CN=pt({imag_:SLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Lt(n){const e={x:J(n,"x","isFinite")};return xt.runKernel(cDt,e)}const wLt=pt({isFinite_:_Lt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TLt(n){const e={x:J(n,"x","isInf")};return xt.runKernel(uDt,e)}const ELt=pt({isInf_:TLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CLt(n){const e={x:J(n,"x","isNaN")};return xt.runKernel(hDt,e)}const ALt=pt({isNaN_:CLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NLt(n,t=.2){const s={x:J(n,"x","leakyRelu")},i={alpha:t};return xt.runKernel(fDt,s,i)}const dX=pt({leakyRelu_:NLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MLt(n,t){let e=J(n,"a","less","string_or_numeric"),s=J(t,"b","less","string_or_numeric");[e,s]=Oi(e,s),Fr(e.shape,s.shape);const i={a:e,b:s};return xt.runKernel(dDt,i)}const bD=pt({less_:MLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ILt(n,t){let e=J(n,"a","lessEqual","string_or_numeric"),s=J(t,"b","lessEqual","string_or_numeric");[e,s]=Oi(e,s),Fr(e.shape,s.shape);const i={a:e,b:s};return xt.runKernel(pDt,i)}const E$=pt({lessEqual_:ILt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RLt(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:t,num:e};return xt.runKernel(mDt,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DLt(n,t=5,e=1,s=1,i=.5){const r=J(n,"x","localResponseNormalization");lt(r.rank===4||r.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${r.rank}.`),lt(H1(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let a=r,o=!1;r.rank===3&&(o=!0,a=oe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={x:a},c={depthRadius:t,bias:e,alpha:s,beta:i},h=xt.runKernel(SDt,l,c);return o?oe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const kLt=pt({localResponseNormalization_:DLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OLt(n){const e={x:J(n,"x","log","float32")};return xt.runKernel(gDt,e)}const j1=pt({log_:OLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Lt(n){const e={x:J(n,"x","log1p")};return xt.runKernel(yDt,e)}const pX=pt({log1p_:$Lt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LLt(n,t){lt(rD(n),()=>"The f passed in variableGrads(f) must be a function"),lt(t==null||Array.isArray(t)&&t.every(c=>c instanceof K2),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=t!=null;if(!e){t=[];for(const c in xt.registeredVariables)t.push(xt.registeredVariables[c])}const s=e?t.filter(c=>!c.trainable):null,i=t.length;t=t.filter(c=>c.trainable),lt(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const r=!0,{value:a,grads:o}=xt.gradients(n,t,null,r);lt(o.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),lt(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const l={};return t.forEach((c,h)=>{o[h]!=null&&(l[c.name]=o[h])}),s!=null&&s.forEach(c=>l[c.name]=null),{value:a,grads:l}}function Rf(n){return xt.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FLt(n){const e={x:J(n,"x","neg")};return xt.runKernel(ODt,e)}const fh=pt({neg_:FLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zLt(n){const e={x:J(n,"x","softplus")};return xt.runKernel(g3t,e)}const mX=pt({softplus_:zLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ULt(n){const t=J(n,"x","logSigmoid");return Rf(s=>({value:fh(mX(fh(s))),gradFunc:a=>Re(a,sg(fh(s)))}))(t)}const BLt=pt({logSigmoid_:ULt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PLt(n,t){let e=J(n,"a","sub"),s=J(t,"b","sub");[e,s]=Oi(e,s);const i={a:e,b:s};return xt.runKernel(k3t,i)}const Vn=pt({sub_:PLt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VLt(n,t=-1){const e=J(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Rf((i,r)=>{const o=Ky(i,t,!0),l=Vn(i,o),c=Vn(qi(l,"float32"),j1(ai(Ng(l),t,!0)));return r([c]),{value:c,gradFunc:(f,p)=>{const[g]=p,v=!0,_=Ng(g);return Vn(f,Re(ai(f,t,v),_))}}})(e)}const GLt=pt({logSoftmax_:VLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HLt(n,t=null,e=!1){const s=J(n,"x","logSumExp"),i=vN(t,s.shape),r=Ky(s,i,!0),a=Vn(s,r),o=Ng(a),l=ai(o,i),c=j1(l),h=yn(oe(r,c.shape),c);if(e){const f=wN(h.shape,i);return oe(h,f)}return h}const gX=pt({logSumExp_:HLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WLt(n,t){const e=J(n,"a","logicalAnd","bool"),s=J(t,"b","logicalAnd","bool");Fr(e.shape,s.shape);const i={a:e,b:s};return xt.runKernel(xDt,i)}const J2=pt({logicalAnd_:WLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qLt(n){const e={x:J(n,"x","logicalNot","bool")};return xt.runKernel(vDt,e)}const yX=pt({logicalNot_:qLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XLt(n,t){const e=J(n,"a","logicalOr","bool"),s=J(t,"b","logicalOr","bool");Fr(e.shape,s.shape);const i={a:e,b:s};return xt.runKernel(bDt,i)}const xX=pt({logicalOr_:XLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jLt(n,t){const e=J(n,"a","logicalXor","bool"),s=J(t,"b","logicalXor","bool");return Fr(e.shape,s.shape),J2(xX(n,t),yX(J2(n,t)))}const KLt=pt({logicalXor_:jLt});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eE=2147483648;function YLt(n,t,e="left"){const s=J(n,"sortedSequence","searchSorted"),i=J(t,"values","searchSorted"),r=s.shape[s.shape.length-1],a=i.shape[i.shape.length-1],o=oe(s,[-1,r]),l=oe(i,[-1,a]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ir(l.shape)>=eE)throw new Error(`values tensor size must less than ${eE}`);if(o.shape[1]>=eE)throw new Error(`trailing dim_size must less than ${eE} for int32 output type, was ${o.shape[1]}`);const c={sortedSequence:o,values:l},h={side:e};return xt.runKernel(l3t,c,h)}const C$=pt({searchSorted_:YLt});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZLt(n,t){return C$(n,t,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QLt(n,t,e,s,i){const r=J(n,"x","maxPool"),a=1;let o=r,l=!1;r.rank===3&&(l=!0,o=oe(r,[1,r.shape[0],r.shape[1],r.shape[2]])),lt(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),lt(Tp(e,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`),fu("maxPool",s,i);const c={x:o},h={filterSize:t,strides:e,pad:s,dimRoundingMode:i},f=xt.runKernel(TDt,c,h);return l?oe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const vX=pt({maxPool_:QLt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JLt(n,t=[1,1,1],e,s,i,r="NDHWC"){const a=J(n,"x","maxPool3d");let o=a,l=!1;a.rank===4&&(l=!0,o=oe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),lt(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),lt(r==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),fu("maxPool3d",s,i);const c={x:o},h={filterSize:t,strides:e,pad:s,dimRoundingMode:i,dataFormat:r},f=xt.runKernel(EDt,c,h);return l?oe(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const tFt=pt({maxPool3d_:JLt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eFt(n,t,e,s,i=!1){const a={x:J(n,"x","maxPoolWithArgmax")},o={filterSize:t,strides:e,pad:s,includeBatchInIndex:i},l=xt.runKernel(CDt,a,o);return{result:l[0],indexes:l[1]}}const nFt=pt({maxPoolWithArgmax_:eFt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sFt(n,t){let e=J(n,"a","maximum"),s=J(t,"b","maximum");[e,s]=Oi(e,s),e.dtype==="bool"&&(e=qi(e,"int32"),s=qi(s,"int32")),Fr(e.shape,s.shape);const i={a:e,b:s};return xt.runKernel(wDt,i)}const bX=pt({maximum_:sFt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iFt(n,t=null,e=!1){const i={x:J(n,"x","mean")},r={axis:t,keepDims:e};return xt.runKernel(ADt,i,r)}const tC=pt({mean_:iFt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sx(n,t="float32"){if(Ol(n),t==="complex64"){const s=Sx(n,"float32"),i=Sx(n,"float32");return sp(s,i)}const e=x$(ir(n),t);return xt.makeTensor(e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Km(n,t="float32"){if(Ol(n),t==="complex64"){const s=Km(n,"float32"),i=Sx(n,"float32");return sp(s,i)}const e=_q(ir(n),t);return xt.makeTensor(e,n,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rFt(n,t,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=J(n,"x","meshgrid",n instanceof Kr?n.dtype:"float32");if(t===void 0)return[s];let i=J(t,"y","meshgrid",t instanceof Kr?t.dtype:"float32");const r=ir(s.shape),a=ir(i.shape);return e==="xy"?(s=oe(s,[1,-1]),i=oe(i,[-1,1]),[Vs(Km([a,1],s.dtype),s),Vs(i,Km([1,r],i.dtype))]):(s=oe(s,[-1,1]),i=oe(i,[1,-1]),[Vs(s,Km([1,a],s.dtype)),Vs(Km([r,1],i.dtype),i)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aFt(n,t){let e=J(n,"a","minimum"),s=J(t,"b","minimum");[e,s]=Oi(e,s),e.dtype==="bool"&&(e=qi(e,"int32"),s=qi(s,"int32")),Fr(e.shape,s.shape);const i={a:e,b:s};return xt.runKernel(MDt,i)}const eC=pt({minimum_:aFt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oFt(n,t,e){lt(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const s=J(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");lt(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const i=e==="reflect"?1:0;for(let o=0;o<s.rank;o++)lt(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),lt(t[o][0]>=0&&t[o][0]<=s.shape[o]-i&&t[o][1]>=0&&t[o][1]<=s.shape[o]-i,()=>`Padding in dimension ${o} cannot be greater than or equal to ${s.shape[o]-i} or less than 0 for input of shape ${s.shape}`);const r={paddings:t,mode:e},a={x:s};return xt.runKernel(IDt,a,r)}const lFt=pt({mirrorPad_:oFt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cFt(n,t){let e=J(n,"a","mod"),s=J(t,"b","mod");[e,s]=Oi(e,s);const i={a:e,b:s};return xt.runKernel(RDt,i)}const uFt=pt({mod_:cFt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hFt(n,t=null,e=!1){n=J(n,"x","moments");const s=vN(t,n.shape),i=tC(n,s,e);let r=i.shape;e||(r=wN(i.shape,s));const a=iu(Vn(qi(n,"float32"),oe(i,r))),o=tC(a,s,e);return{mean:i,variance:o}}const fFt=pt({moments_:hFt});function dFt(n,t,e,s){const i=J(t,"data","multiRNNCell"),r=Y2(e,"c","multiRNNCell"),a=Y2(s,"h","multiRNNCell");let o=i;const l=[];for(let f=0;f<n.length;f++){const p=n[f](o,r[f],a[f]);l.push(p[0]),l.push(p[1]),o=p[1]}const c=[],h=[];for(let f=0;f<l.length;f+=2)c.push(l[f]),h.push(l[f+1]);return[c,h]}const pFt=pt({multiRNNCell_:dFt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mFt(n,t,e,s=!1){const i=J(n,"logits","multinomial"),r=i.size,a=i.rank;if(r<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${r}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);e=e||Math.random();const l={logits:a===1?oe(i,[1,-1]):i},c={numSamples:t,seed:e,normalized:s},h=xt.runKernel(DDt,l,c);return a===1?oe(h,[h.size]):h}const gFt=pt({multinomial_:mFt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yFt(n,t){let e=J(n,"a","notEqual","string_or_numeric"),s=J(t,"b","notEqual","string_or_numeric");[e,s]=Oi(e,s),Fr(e.shape,s.shape);const i={a:e,b:s};return xt.runKernel($Dt,i)}const SX=pt({notEqual_:yFt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xFt(n,t,e=1,s=0,i="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:J(n,"indices","oneHot","int32")},o={dtype:i,depth:t,onValue:e,offValue:s};return xt.runKernel(BDt,a,o)}const vFt=pt({oneHot_:xFt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bFt(n){const e={x:J(n,"x","onesLike")};return xt.runKernel(UDt,e)}const SFt=pt({onesLike_:bFt});function _Ft(n,t){const e=J(n,"v1","outerProduct"),s=J(t,"v2","outerProduct");lt(e.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${s.rank}.`);const i=oe(e,[-1,1]),r=oe(s,[1,-1]);return Vs(i,r)}const wFt=pt({outerProduct_:_Ft});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TFt(n,t,e=0){const s=J(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:t,constantValue:e},r={x:s};return xt.runKernel(VDt,r,i)}const M_=pt({pad_:TFt});function EFt(n,t,e=0){return lt(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),M_(n,[t],e)}const CFt=pt({pad1d_:EFt});function AFt(n,t,e=0){return lt(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),M_(n,t,e)}const NFt=pt({pad2d_:AFt});function MFt(n,t,e=0){return lt(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),M_(n,t,e)}const IFt=pt({pad3d_:MFt});function RFt(n,t,e=0){return lt(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),M_(n,t,e)}const DFt=pt({pad4d_:RFt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kFt(n,t,e){const s=J(n,"x","spaceToBatchND");lt(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),lt(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),lt(s.shape.reduce((a,o,l)=>l>0&&l<=t.length?a&&(o+e[l-1][0]+e[l-1][1])%t[l-1]===0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);const i={x:s},r={blockShape:t,paddings:e};return xt.runKernel(v3t,i,r)}const _X=pt({spaceToBatchND_:kFt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OFt(n,t,e,s,i,r,a){i==null&&(i=[1,1]),r==null&&(r=1),s===0&&(s="valid");const o=J(n,"x","maxPool");let l=o,c=!1;o.rank===3&&(c=!0,l=oe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),lt(Tp(r,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`);const h=EOt(l.shape,t,r,i,s),f=[h.dilationHeight,h.dilationWidth];let p;s==="same"?p=LFt([h.filterHeight,h.filterWidth],f):p=[[0,0],[0,0]];const g=f[0]===1&&f[1]===1,[v,_]=$Ft([h.inHeight,h.inWidth],f,p),S=g?s:"valid",b=g?l:_X(l,f,v),C=(e==="avg"?()=>eX(b,t,r,S,a):()=>vX(b,t,r,S,a))(),A=g?C:nX(C,f,_);return c?oe(A,[A.shape[1],A.shape[2],A.shape[3]]):A}function $Ft(n,t,e){const s=e.map(h=>h[0]),i=e.map(h=>h[1]),r=n.concat(s,i),a=t.map((h,f)=>(h-r[f]%h)%h),o=i.map((h,f)=>h+a[f]),l=t.map((h,f)=>[s[f],o[f]]),c=t.map((h,f)=>[0,a[f]]);return[l,c]}function LFt(n,t){const s=n.map((a,o)=>a+(a-1)*(t[o]-1)).map(a=>a-1),i=s.map(a=>Math.floor(a/2)),r=s.map((a,o)=>a-i[o]);return s.map((a,o)=>[i[o],r[o]])}const FFt=pt({pool_:OFt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zFt(n,t){const e=J(n,"x","prelu"),s=J(t,"alpha","prelu"),i={x:e,alpha:s};return xt.runKernel(HDt,i)}const wX=pt({prelu_:zFt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UFt(n,t=null,e=!1){let s=J(n,"x","prod");s.dtype==="bool"&&(s=qi(s,"int32"));const i={x:s},r={axis:t,keepDims:e};return xt.runKernel(WDt,i,r)}const BFt=pt({prod_:UFt});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PFt(n,t,e,s){const i=n.map((h,f)=>J(h,`tensors${f}`,"raggedGather","int32")),r=J(t,"paramsDenseValues","raggedGather"),a=J(e,"indices","raggedGather","int32"),o={paramsNestedSplits:i,paramsDenseValues:r,indices:a},l={outputRaggedRank:s},c=xt.runKernel(qDt,o,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const VFt=pt({raggedGather_:PFt});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GFt(n,t,e){const s=J(n,"starts","raggedRange"),i=J(t,"limits","raggedRange",s.dtype),r=J(e,"deltas","raggedRange",s.dtype),a={starts:s,limits:i,deltas:r},o=xt.runKernel(XDt,a);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const HFt=pt({raggedRange_:GFt});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WFt(n,t,e,s,i){const r=J(n,"shape","raggedTensorToTensor","int32"),a=J(t,"values","raggedTensorToTensor"),o=J(e,"defaultValue","raggedTensorToTensor",a.dtype),l=s.map((f,p)=>J(f,`tensors${p}`,"raggedTensorToTensor","int32")),c={shape:r,values:a,defaultValue:o,rowPartitionTensors:l},h={rowPartitionTypes:i};return xt.runKernel(jDt,c,h)}const qFt=pt({raggedTensorToTensor_:WFt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XFt(n,t,e){Ol(n);const s=ir(n);let i=null;if(e==null||e==="float32")i=new Float32Array(s);else if(e==="int32")i=new Int32Array(s);else if(e==="bool")i=new Uint8Array(s);else throw new Error(`Unknown data type ${e}`);for(let r=0;r<s;r++)i[r]=t();return xt.makeTensor(i,n,e)}const jFt=pt({rand_:XFt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A${constructor(t,e,s,i,r){this.mean=t,this.stdDev=e,this.dtype=s,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=r||Math.random();this.random=kx.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let t,e,s=!1;for(;!s;){let i,r,a;do i=2*this.random()-1,r=2*this.random()-1,a=i*i+r*r;while(a>=1||a===0);const o=Math.sqrt(-2*Math.log(a)/a);t=this.mean+this.stdDev*i*o,e=this.mean+this.stdDev*r*o,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class KFt{constructor(t,e,s,i){this.alpha=t,this.beta=1/e,this.dtype=s;const r=i||Math.random();this.randu=kx.alea(r.toString()),this.randn=new A$(0,1,s,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,s,i,r,a;for(;;){do i=this.randn.nextValue(),a=1+this.c*i;while(a<=0);if(a*=a*a,t=i*i,e=1-.331*t*t,s=.5*t+this.d*(1-a+Math.log(a)),r=this.randu(),r<e||Math.log(r)<s)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}}class YFt{constructor(t=0,e=1,s,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=s,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=kx.alea(i)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZFt(n,t,e=1,s="float32",i){if(Ol(n),e==null&&(e=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const r=new KFt(t,e,s,i),a=Mf(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=r.nextValue();return a.toTensor()}const QFt=pt({randomGamma_:ZFt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JFt(n,t=0,e=1,s,i){if(Ol(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const r=new A$(t,e,s,!1,i),a=Mf(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=r.nextValue();return a.toTensor()}const TX=pt({randomNormal_:JFt});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tzt(n,t,e){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return TX(n,0,1,t,e)}const ezt=pt({randomStandardNormal_:tzt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nzt(n,t=0,e=1,s="float32",i){Ol(n);const r=Mf(n,s),a=new YFt(t,e,null,i);for(let o=0;o<r.values.length;o++)r.values[o]=a.nextValue();return r.toTensor()}const N$=pt({randomUniform_:nzt});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function szt(n,t,e,s){return N$(n,t,e,"int32",s)}const izt=pt({randomUniformInt_:szt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K1(n,t,e=1,s="float32"){if(e===0)throw new Error("Cannot have a step of zero");const i={start:n,stop:t,step:e,dtype:s};return xt.runKernel(KDt,{},i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rzt(n){const e={input:J(n,"input","real")};return xt.runKernel(YDt,e)}const Y1=pt({real_:rzt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function azt(n){const e={x:J(n,"x","reciprocal")};return xt.runKernel(ZDt,e)}const ozt=pt({reciprocal_:azt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lzt(n){const e={x:J(n,"x","relu")};return xt.runKernel(QDt,e)}const AN=pt({relu_:lzt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function czt(n){const e={x:J(n,"x","relu6")};return xt.runKernel(n3t,e)}const EX=pt({relu6_:czt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uzt(n,t){const s={x:J(n,"x","reverse")},i={dims:t};return xt.runKernel(s3t,s,i)}const Mg=pt({reverse_:uzt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hzt(n){const t=J(n,"x","reverse");return lt(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Mg(t,0)}const fzt=pt({reverse1d_:hzt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dzt(n,t){const e=J(n,"x","reverse");return lt(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),Mg(e,t)}const pzt=pt({reverse2d_:dzt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mzt(n,t){const e=J(n,"x","reverse");return lt(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),Mg(e,t)}const gzt=pt({reverse3d_:mzt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yzt(n,t){const e=J(n,"x","reverse");return lt(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),Mg(e,t)}const xzt=pt({reverse4d_:yzt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vzt(n){const e={x:J(n,"x","round")};return xt.runKernel(i3t,e)}const CX=pt({round_:vzt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bzt(n){const e={x:J(n,"x","rsqrt","float32")};return xt.runKernel(r3t,e)}const Szt=pt({rsqrt_:bzt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _zt(n){const e={x:J(n,"x","selu")};return xt.runKernel(u3t,e)}const wzt=pt({selu_:_zt});function Tzt(n,t,e,s,i,r=[1,1],a="NHWC"){const o=J(n,"x","separableConv2d"),l=J(t,"depthwiseFilter","separableConv2d"),c=J(e,"pointwiseFilter","separableConv2d");let h=o,f=!1;if(o.rank===3&&(f=!0,h=oe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");lt(h.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),lt(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),lt(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),lt(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),lt(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const p=l.shape[2],g=l.shape[3];lt(c.shape[2]===p*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*g}, but got ${c.shape[2]}.`);const v=T$(h,l,s,i,a,r),S=_N(v,c,1,"valid",a);return f?oe(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const Ezt=pt({separableConv2d_:Tzt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Czt(n,t){const e=J(n,"x","setdiff1d"),s=J(t,"y","setdiff1d");lt(e.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${s.dtype}).`),lt(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),lt(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const i=await e.data(),r=await s.data(),a=new Set(r);let o=0;for(let h=0;h<i.length;h++)a.has(i[h])||o++;const l=new lD([o],e.dtype),c=new lD([o],"int32");for(let h=0,f=0;h<i.length;h++)a.has(i[h])||(l.values[f]=i[h],c.values[f]=h,f++);return[l.toTensor(),c.toTensor()]}const Azt=Czt;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nzt(n){const e={x:J(n,"x","sign")};return xt.runKernel(p3t,e)}const Mzt=pt({sign_:Nzt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Izt(n){const e={x:J(n,"x","sin","float32")};return xt.runKernel(f3t,e)}const Rzt=pt({sin_:Izt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dzt(n){const e={x:J(n,"x","sinh")};return xt.runKernel(d3t,e)}const kzt=pt({sinh_:Dzt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ozt(n,t,e){const s=J(n,"x","slice1d");return lt(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),bs(s,[t],[e])}const $zt=pt({slice1d_:Ozt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lzt(n,t,e){const s=J(n,"x","slice2d");return lt(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),bs(s,t,e)}const Fzt=pt({slice2d_:Lzt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zzt(n,t,e){const s=J(n,"x","slice3d");return lt(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),bs(s,t,e)}const Uzt=pt({slice3d_:zzt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bzt(n,t,e){const s=J(n,"x","slice4d");return lt(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),bs(s,t,e)}const Pzt=pt({slice4d_:Bzt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vzt(n,t=-1){const e=J(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);const s={logits:e},i={dim:t};return xt.runKernel(S3t,s,i)}const Gzt=pt({softmax_:Vzt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hzt(n){lt(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const t={input:n};return xt.runKernel(ZRt,t)}const M$=pt({fft_:Hzt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wzt(n){lt(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const t={input:n};return xt.runKernel(oDt,t)}const nC=pt({ifft_:Wzt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qzt(n){const t=n.shape[n.shape.length-1],e=n.size/t;let s;if(t<=2){const i=oe(n,[e,t]);s=nC(i)}else{const i=[e,2*(t-1)],r=oe(Y1(n),[e,t]),a=oe(CN(n),[e,t]),o=Mg(bs(r,[0,1],[e,t-2]),1),l=Re(Mg(bs(a,[0,1],[e,t-2]),1),hs(-1)),c=Wa([r,o],1),h=Wa([a,l],1),f=oe(sp(c,h),[i[0],i[1]]);s=nC(f)}if(s=Y1(s),n.rank===3&&n.shape[0]!==0){const i=s,r=n.shape[0];s=oe(s,[r,s.shape[0]/r,s.shape[1]]),i.dispose()}return s}const AX=pt({irfft_:qzt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xzt(n,t,e=0){const i={x:J(n,"x","split")},r={numOrSizeSplits:t,axis:e};return xt.runKernel(b3t,i,r)}const Z1=pt({split_:Xzt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jzt(n,t){lt(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const s=n.size/e;let i;if(t!=null&&t<e){const v=n.shape.map(S=>0),_=n.shape.map(S=>S);_[n.shape.length-1]=t,i=bs(n,v,_),e=t}else if(t!=null&&t>e){const v=n.shape.map(_=>_);v[n.shape.length-1]=t-e,i=Wa([n,Sx(v)],n.shape.length-1),e=t}else i=n;const r=Al(i),a=oe(sp(i,r),[s,e]),o=M$(a),l=Math.floor(e/2)+1,c=Y1(o),h=CN(o),f=Z1(c,[l,e-l],c.shape.length-1),p=Z1(h,[l,e-l],h.shape.length-1),g=i.shape.slice();return g[i.shape.length-1]=l,oe(sp(f[0],p[0]),g)}const I$=pt({rfft_:jzt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kzt(n,t){let e=J(n,"a","squaredDifference"),s=J(t,"b","squaredDifference");[e,s]=Oi(e,s),Fr(e.shape,s.shape);const i={a:e,b:s},r={};return xt.runKernel(A3t,i,r)}const NX=pt({squaredDifference_:Kzt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yzt(n,t){const e=J(n,"x","squeeze","string_or_numeric");return oe(e,VIt(e.shape,t).newShape)}const Q1=pt({squeeze_:Yzt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zzt(n,t=0){const e=Y2(n,"tensors","stack","string_or_numeric");lt(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&lt(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");const s=e,i={axis:t};return xt.runKernel(PDt,s,i)}const Df=pt({stack_:Zzt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qzt(n,t=0){const s={x:J(n,"x","step")},i={alpha:t};return xt.runKernel(V3t,s,i)}const MX=pt({step_:Qzt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jzt(n,t,e,s,i=0,r=0,a=0,o=0,l=0){const h={x:J(n,"x","stridedSlice","string_or_numeric")},f={begin:t,end:e,strides:s,beginMask:i,endMask:r,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};return xt.runKernel(M3t,h,f)}const tUt=pt({stridedSlice_:Jzt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eUt(n){const e={x:J(n,"x","tan","float32")};return xt.runKernel(O3t,e)}const nUt=pt({tan_:eUt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qo(n,t){qx(n);const e=_p(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return wp(n,null,e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yy(n,t,e){if(qx(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=_p(n,e);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return wp(n,t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IX(n,t,e){if(qx(n),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=_p(n,e);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return wp(n,t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sUt(n,t,e){if(qx(n),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=_p(n,e);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return wp(n,t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iUt(n,t,e){if(qx(n),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=_p(n,e);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return wp(n,t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rUt(n,t,e){if(qx(n),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=_p(n,e);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||s,wp(n,t,s,e)}function aUt(n,t,e){const s=t.rank>1?t.shape[t.rank-1]:1,i=t.rank>1?t.rank-1:1,r=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${i}.`;if(e.rank<i)throw new Error(r+` update.rank < ${i}. `);if(n.length<s+(e.rank-i))throw new Error(r+` Output shape length < ${s+(e.rank-i)}`);if(e.rank!==i+n.length-s)throw new Error(r+` update.rank != ${i+n.length-s}`);for(let a=0;a<i;++a)if(e.shape[a]!==t.shape[a])throw new Error(r+` updates.shape[${a}] (${e.shape[a]}) != indices.shape[${a}] (${t.shape[a]}).`);for(let a=0;a<e.rank-i;++a)if(e.shape[a+i]!==n[a+s])throw new Error(r+` updates.shape[${a+i}] (${e.shape[a+i]}) != shape[${a+i}] (${n[a+i]})`)}function RX(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}aUt(e,t,n)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oUt(n,t,e){const s=J(n,"tensor","tensorScatterupdate"),i=J(t,"indices","tensorScatterupdate","int32"),r=J(e,"updates","tensorScatterupdate");if(RX(r,i,s.shape),s.dtype!==r.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${r.dtype}.`);const a={tensor:s,indices:i,updates:r},o={};return xt.runKernel(o3t,a,o)}const lUt=pt({tensorScatterUpdate_:oUt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cUt(n,t=1,e=!0){const s=J(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${t}`);const r={x:s},a={k:t,sorted:e},[o,l]=xt.runKernel(L3t,r,a);return{values:o,indices:l}}const uUt=pt({topk_:cUt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hUt(n,t=0,e=1,s,i){if(Ol(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const r=new A$(t,e,s,!0,i),a=Mf(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=r.nextValue();return a.toTensor()}const fUt=pt({truncatedNormal_:hUt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dUt(n,t=0){const e=J(n,"x","unique","string_or_numeric");lt(e.rank>0,()=>"The input tensor must be at least 1D");const s={x:e},i={axis:t},[r,a]=xt.runKernel(z3t,s,i);return{values:r,indices:a}}const pUt=pt({unique_:dUt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mUt(n,t,e){const s=J(n,"x","unsortedSegmentSum"),i=J(t,"segmentIds","unsortedSegmentSum","int32");lt(H1(e),()=>"numSegments must be of dtype int");const r={x:s,segmentIds:i},a={numSegments:e};return xt.runKernel(B3t,r,a)}const gUt=pt({unsortedSegmentSum_:mUt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yUt(n,t=0){const e=J(n,"x","unstack","string_or_numeric");lt(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);const s={value:e},i={axis:t};return xt.runKernel(U3t,s,i)}const Kg=pt({unstack_:yUt});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xUt(n,t){return C$(n,t,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vUt(n,t=!0,e,s){return xt.makeVariable(n,t,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bUt(n,t){const e=[];for(let r=0;r<t.length;r++)t[r]&&e.push(r);const s=Mf(n,"int32"),i=Mf([e.length,n.length],"int32");for(let r=0;r<e.length;r++){const a=s.indexToLoc(e[r]),o=r*n.length;i.values.set(a,o)}return i.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function SUt(n){const t=J(n,"condition","whereAsync","bool"),e=await t.data(),s=bUt(t.shape,e);return n!==t&&t.dispose(),s}const DX=SUt;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function _Ut(n,t,e){const s=J(n,"tensor","boolMask"),i=J(t,"mask","boolMask","bool"),r=e??0,a=i.rank,o=s.shape;lt(a>0,()=>"mask cannot be scalar"),gc(o.slice(r,r+a),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let _=r;_<r+a;_++)l*=o[_];const c=o.slice(0,r).concat([l],o.slice(r+a)),h=oe(s,c),f=oe(i,[-1]),p=await DX(f),g=Q1(p,[1]),v=hX(h,g,r);return n!==s&&s.dispose(),t!==i&&i.dispose(),g.dispose(),h.dispose(),f.dispose(),p.dispose(),v}const wUt=_Ut;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TUt(n,t,e){const s=J(n,"x","transpose");if(t==null&&(t=s.shape.map((a,o)=>o).reverse()),lt(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(a=>{lt(a>=0&&a<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const i={x:s},r={perm:t};return s.dtype==="complex64"?Jn(()=>{let a=Y1(s),o=CN(s);return a=xt.runKernel(GI,{x:a},r),o=xt.runKernel(GI,{x:o},r),e&&(o=fh(o)),sp(a,o)}):xt.runKernel(GI,i,r)}const SD=pt({transpose_:TUt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EUt(n,t,e,s,i=!0){const r=J(n,"v","movingAverage"),a=J(t,"x","movingAverage"),o=J(e,"decay","movingAverage");akt(r,a),lt(Nf(r.shape,a.shape),()=>"Shape mismatch in v and x");const l=hs(1),c=Vn(l,o);let h=Re(Vn(a,r),c);if(i){lt(s!=null,()=>"When using zeroDebias: true, step is required.");const f=J(s,"step","movingAverage");h=ks(h,Vn(l,X1(o,f)))}return yn(r,h)}const CUt=pt({movingAverage_:EUt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AUt(n,t,e){Ol(e);const s=J(n,"indices","scatterND","int32"),i=J(t,"updates","scatterND");RX(i,s,e);const r={indices:s,updates:i},a={shape:e};return xt.runKernel(a3t,r,a)}const NUt=pt({scatterND_:AUt});function MUt(n,t,e,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const i=n.rank>0?n.shape[0]:1,r=n.rank>1?n.shape[1]:1;if(e.length!==r)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${r}.`);const a=t.size;if(!(t.rank===0||t.rank===1&&a===i))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${i}]`);if(t.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IUt(n,t,e,s=0){Ol(e);const i=J(n,"sparseIndices","sparseToDense","int32"),r=J(t,"sparseValues","sparseToDense","string_or_numeric"),a=J(s,"defaultValue","sparseToDense",r.dtype);MUt(i,r,e,a);const o={sparseIndices:i,sparseValues:r,defaultValue:a},l={outputShape:e};return xt.runKernel(C3t,o,l)}const RUt=pt({sparseToDense_:IUt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DUt(n,t){const e=J(t,"indices","gatherND","int32"),i={params:J(n,"x","gatherND","string_or_numeric"),indices:e};return xt.runKernel(iDt,i)}const kUt=pt({gatherND_:DUt});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OUt(n,t){if(t==null)return n.shape.slice();if(Nf(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let s=0;s<n.shape.length;s++)t[s]==null&&n.shape[s]!=null?e.push(n.shape[s]):e.push(t[s]);return e}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ut(n,t,e,s){const i=J(n,"x","dropout");if(lt(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),lt(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return n instanceof Kr?i.clone():i;const r=OUt(i,e),a=1-t,o=ks(uX(yn(N$(r,0,1,"float32",s),a)),a);return Re(i,o)}const LUt=pt({dropout_:$Ut});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kX(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function R$(n,t,e){const s=1-n%2,i=new Float32Array(n);for(let r=0;r<n;++r){const a=2*Math.PI*r/(n+s-1);i[r]=t-e*Math.cos(a)}return Qo(i,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function FUt(n,t,e=1){const s=J(n,"predictions","inTopK"),i=J(t,"targets","inTopK");lt(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),lt(s.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${i.rank}`),gc(s.shape.slice(0,s.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const r=s.shape[s.shape.length-1];lt(e>0&&e<=r,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${r}), but got ${e}`);const a=await s.data(),o=await i.data(),[l,c]=[a.length/r,r],h=GIt("bool",l);for(let f=0;f<l;f++){const p=f*c,g=a.subarray(p,p+c),v=[];for(let _=0;_<g.length;_++)v.push({value:g[_],index:_});v.sort((_,S)=>S.value-_.value),h[f]=0;for(let _=0;_<e;_++)if(v[_].index===o[f]){h[f]=1;break}}return n!==s&&s.dispose(),t!==i&&i.dispose(),hh(h,i.shape,"bool")}const zUt=FUt;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UUt(n,t,e,s,i,r="NHWC",a){let o=n;n.rank===3&&(o=oe(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;l.rank===3&&(l=oe(t,[1,t.shape[0],t.shape[1],t.shape[2]])),lt(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),lt(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),lt(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const c=r==="NHWC"?o.shape[3]:o.shape[1],h=r==="NHWC"?l.shape[3]:l.shape[1];lt(c===e[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`),lt(h===e[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${e[3]}).`),fu("conv2dDerFilter",i,a);const f={x:o,dy:l},p={strides:s,pad:i,dataFormat:r,dimRoundingMode:a,filterShape:e};return xt.runKernel(ARt,f,p)}const BUt=pt({conv2DBackpropFilter_:UUt});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D$(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return Re(n,MX(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function k$(n,t){let e=t;const s=P$t(n.shape,t.shape);return s.length>0&&(e=ai(e,s)),oe(e,n.shape)}function O$(n,t,e,s){if(t==="linear")return n;if(t==="relu")return AN(n);if(t==="elu")return oX(n);if(t==="relu6")return EX(n);if(t==="prelu")return wX(n,e);if(t==="leakyrelu")return dX(n,s);if(t==="sigmoid")return sg(n);throw new Error(`Unknown fused activation ${t}.`)}const $$=(n,t)=>!(n>0)||t==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PUt({x:n,filter:t,strides:e,pad:s,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(l=l||"linear",$$(xt.state.gradientDepth,l)===!1){lt(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let D=_N(n,t,e,s,i,r,a);return o!=null&&(D=yn(D,o)),O$(D,l,c,h)}const f=J(n,"x","conv2d","float32"),p=J(t,"filter","conv2d","float32");let g=f,v=!1;f.rank===3&&(v=!0,g=oe(f,[1,f.shape[0],f.shape[1],f.shape[2]])),lt(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),lt(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),fu("fused conv2d",s,a);const _=i==="NHWC"?g.shape[3]:g.shape[1];lt(p.shape[2]===_,()=>`Error in conv2d: depth of input (${_}) must match input depth for filter ${p.shape[2]}.`),lt(Tp(e,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`);const S=w$(g.shape,p.shape,e,r,s,a);let b;o!=null&&(b=J(o,"bias","fused conv2d"),[b]=Oi(b,f),i==="NHWC"?Fr(S.outShape,b.shape):(lt(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),lt(b.shape.length===0||b.shape[0]===S.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${S.outChannels})`)));let T;if(c!=null){const D=c.shape;if(lt(D.length<=1||D.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${D.length}.`),D.length===1)lt(D[0]===1||D[0]===S.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${D}) is not compatible with the number of output channels (${S.outChannels}).`);else if(D.length===3)try{Fr(D,S.outShape)}catch{const z=`Error in fused conv2d: PReLU activation weights (${D}) is not compatible with the output shape of the conv2d (${S.outShape}).`;throw Error(z)}T=J(c,"prelu weights","fused conv2d")}const C=(D,F)=>{lt(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[z,k,O,L]=F,H=D$(D,O,l);lt(Q2(r),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const q=rX(k.shape,H,z,e,s),K=BUt(k,H,z.shape,e,s),Y=[q,K];if(L!=null){const P=k$(L,H);Y.push(P)}return Y},A={x:g,filter:p,bias:b,preluActivationWeights:T},I={strides:e,pad:s,dataFormat:i,dilations:r,dimRoundingMode:a,activation:l,leakyreluAlpha:h};return o==null?Rf((F,z,k)=>{let O=xt.runKernel(PB,A,I);return k([z,F,O]),v&&(O=oe(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:C}})(g,p):Rf((F,z,k,O)=>{let L=xt.runKernel(PB,A,I);return O([z,F,L,k]),v&&(L=oe(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:C}})(g,p,b)}const VUt=pt({fusedConv2d_:PUt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GUt(n,t,e,s,i,r=[1,1],a){let o=n;n.rank===3&&(o=oe(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;l.rank===3&&(l=oe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={x:o,dy:l},h={strides:s,pad:i,dimRoundingMode:a,dilations:r,filterShape:e};return xt.runKernel(URt,c,h)}const HUt=pt({depthwiseConv2dNativeBackpropFilter_:GUt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WUt(n,t,e,s,i,r=[1,1],a){let o=t,l=!1;t.rank===3&&(l=!0,o=oe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={dy:o,filter:e},h={strides:s,pad:i,dimRoundingMode:a,dilations:r,inputShape:n},f=xt.runKernel(BRt,c,h);return l?oe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const qUt=pt({depthwiseConv2dNativeBackpropInput_:WUt});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XUt({x:n,filter:t,strides:e,pad:s,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if($$(xt.state.gradientDepth,l)===!1){let I=T$(n,t,e,s,i,r,a);return o!=null&&(I=yn(I,o)),O$(I,l,c,h)}const f=J(n,"x","depthwiseConv2d","float32"),p=J(t,"filter","depthwiseConv2d","float32");let g=f,v=!1;f.rank===3&&(v=!0,g=oe(f,[1,f.shape[0],f.shape[1],f.shape[2]])),lt(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),lt(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),lt(g.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),r==null&&(r=[1,1]),lt(Tp(e,r),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`),fu("fused depthwiseConv2d",s,a);const _=w$(g.shape,p.shape,e,r,s,a,!0);let S;o!=null&&(S=J(o,"bias","fused conv2d"),[S]=Oi(S,f),Fr(_.outShape,S.shape));let b;c!=null&&(b=J(c,"prelu weights","fused depthwiseConv2d"));const T=(I,D)=>{lt(Q2(r),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${r}'`);const[F,z,k,O]=D,L=D$(I,k,l),H=qUt(z.shape,L,F,e,s,r,a),q=HUt(z,L,F.shape,e,s,r,a);if(O!=null){const K=k$(S,L);return[H,q,K]}return[H,q]},C={x:g,filter:p,bias:S,preluActivationWeights:b},A={strides:e,pad:s,dataFormat:i,dilations:r,dimRoundingMode:a,activation:l,leakyreluAlpha:h};return o==null?Rf((D,F,z)=>{let k=xt.runKernel(VB,C,A);return z([F,D,k]),v&&(k=oe(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:T}})(g,p):Rf((D,F,z,k)=>{let O=xt.runKernel(VB,C,A);return k([F,D,O,z]),v&&(O=oe(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:T}})(g,p,S)}const jUt=pt({fusedDepthwiseConv2d_:XUt});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KUt({a:n,b:t,transposeA:e=!1,transposeB:s=!1,bias:i,activation:r="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if($$(xt.state.gradientDepth,r)===!1){let L=Vs(n,t,e,s);return i!=null&&(L=yn(L,i)),O$(L,r,a,o)}let l=J(n,"a","fused matMul"),c=J(t,"b","fused matMul");[l,c]=Oi(l,c);const h=e?l.shape[l.rank-2]:l.shape[l.rank-1],f=s?c.shape[c.rank-1]:c.shape[c.rank-2],p=e?l.shape[l.rank-1]:l.shape[l.rank-2],g=s?c.shape[c.rank-2]:c.shape[c.rank-1],v=l.shape.slice(0,-2),_=c.shape.slice(0,-2),S=ir(v),b=ir(_);lt(h===f,()=>`Error in fused matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${e} and transposeB=${s} must match.`);const C=Fr(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,g]),A=e?oe(l,[S,h,p]):oe(l,[S,p,h]),I=s?oe(c,[b,g,f]):oe(c,[b,f,g]);let D;i!=null&&(D=J(i,"bias","fused matMul"),[D]=Oi(D,l),Fr(C,D.shape));let F;a!=null&&(F=J(a,"prelu weights","fused matMul"));const z=(L,H)=>{const[q,K,Y,P]=H,W=D$(oe(L,Y.shape),Y,r);let j,st;if(!e&&!s?(j=Vs(W,K,!1,!0),st=Vs(q,W,!0,!1)):!e&&s?(j=Vs(W,K,!1,!1),st=Vs(W,q,!0,!1)):e&&!s?(j=Vs(K,W,!1,!0),st=Vs(q,W,!1,!1)):(j=Vs(K,W,!0,!0),st=Vs(W,q,!0,!0)),i!=null){const ot=k$(P,W);return[j,st,ot]}else return[j,st]},k={a:A,b:I,bias:D,preluActivationWeights:F},O={transposeA:e,transposeB:s,activation:r,leakyreluAlpha:o};return i==null?Rf((H,q,K)=>{const Y=xt.runKernel(BB,k,O);return K([H,q,Y]),{value:oe(Y,C),gradFunc:z}})(A,I):Rf((H,q,K,Y)=>{const P=xt.runKernel(BB,k,O);return Y([H,q,P,K]),{value:oe(P,C),gradFunc:z}})(A,I,D)}const YUt=pt({fusedMatMul_:KUt});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZUt=Object.freeze(Object.defineProperty({__proto__:null,conv2d:VUt,depthwiseConv2d:jUt,matMul:YUt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QUt(n){return R$(n,.54,.46)}const JUt=pt({hammingWindow_:QUt});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tBt(n){return R$(n,.5,.5)}const OX=pt({hannWindow_:tBt});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eBt(n,t,e,s=!1,i=0){let r=0;const a=[];for(;r+t<=n.size;)a.push(bs(n,r,t)),r+=e;if(s)for(;r<n.size;){const o=r+t-n.size,l=Wa([bs(n,r,t-o),N_([o],i)]);a.push(l),r+=e}return a.length===0?Yy([],[0,t]):oe(Wa(a),[a.length,t])}const $X=pt({frame_:eBt});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nBt(n,t,e,s,i=OX){s==null&&(s=kX(t));const r=$X(n,t,e),a=Re(r,i(t));return I$(a,s)}const sBt=pt({stft_:nBt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iBt(n,t,e,s,i="bilinear",r=0){const a=J(n,"image","cropAndResize"),o=J(t,"boxes","cropAndResize","float32"),l=J(e,"boxInd","cropAndResize","int32"),c=o.shape[0];lt(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),lt(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${o.shape}.`),lt(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${o.shape}.`),lt(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),lt(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),lt(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const h={image:a,boxes:o,boxInd:l},f={method:i,extrapolationValue:r,cropSize:s};return xt.runKernel($Rt,h,f)}const rBt=pt({cropAndResize_:iBt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aBt(n){const t=J(n,"image","flipLeftRight","float32");lt(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const e={image:t};return xt.runKernel(JRt,e,{})}const oBt=pt({flipLeftRight_:aBt});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lBt(n){const t=J(n,"image","grayscaleToRGB"),e=t.rank-1,s=t.shape[e];lt(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),lt(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const i=new Array(t.rank);return i.fill(1,0,e),i[e]=3,u1(t,i)}const cBt=pt({grayscaleToRGB_:lBt});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uBt(n){const t=J(n,"image","RGBToGrayscale"),e=t.rank-1,s=t.shape[e];lt(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),lt(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const i=t.dtype,r=qi(t,"float32"),a=Qo([.2989,.587,.114]);let o;switch(t.rank){case 2:o=Fy("ij,j->i",r,a);break;case 3:o=Fy("ijk,k->ij",r,a);break;case 4:o=Fy("ijkl,l->ijk",r,a);break;case 5:o=Fy("ijklm,m->ijkl",r,a);break;case 6:o=Fy("ijklmn,n->ijklm",r,a);break;default:throw new Error("Not a valid tensor rank.")}return o=df(o,-1),qi(o,i)}const hBt=pt({rgbToGrayscale_:uBt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fBt(n,t,e=0,s=.5){const i=J(n,"image","rotateWithOffset","float32");lt(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const r={image:i},a={radians:t,fillValue:e,center:s};return xt.runKernel(G3t,r,a)}const dBt=pt({rotateWithOffset_:fBt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xx(n,t,e,s,i,r){s==null&&(s=.5),i==null&&(i=Number.NEGATIVE_INFINITY),r==null&&(r=0);const a=n.shape[0];return e=Math.min(e,a),lt(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),lt(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),lt(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),lt(t.rank===1,()=>"scores must be a 1D tensor"),lt(t.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${t.shape[0]}`),lt(0<=r&&r<=1,()=>`softNmsSigma must be in [0, 1], but was '${r}'`),{maxOutputSize:e,iouThreshold:s,scoreThreshold:i,softNmsSigma:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pBt(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY){const r=J(n,"boxes","nonMaxSuppression","float32"),a=J(t,"scores","nonMaxSuppression","float32"),o=Xx(r,a,e,s,i);e=o.maxOutputSize,s=o.iouThreshold,i=o.scoreThreshold;const l={maxOutputSize:e,iouThreshold:s,scoreThreshold:i};return xt.runKernel(LDt,{boxes:r,scores:a},l)}const mBt=pt({nonMaxSuppression_:pBt});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gBt(n,t,e){const s=yBt(n,t,e),i=s<0?-(s+1):s;n.splice(i,0,t)}function yBt(n,t,e){return vBt(n,t,e||xBt)}function xBt(n,t){return n>t?1:n<t?-1:0}function vBt(n,t,e){let s=0,i=n.length,r=0,a=!1;for(;s<i;){r=s+(i-s>>>1);const o=e(t,n[r]);o>0?s=r+1:(i=r,a=!o)}return a?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bBt(n,t,e,s,i){return L$(n,t,e,s,i,0)}function SBt(n,t,e,s,i,r){return L$(n,t,e,s,i,0,!1,r,!0)}function _Bt(n,t,e,s,i,r){return L$(n,t,e,s,i,r,!0)}function L$(n,t,e,s,i,r,a=!1,o=!1,l=!1){const c=[];for(let S=0;S<t.length;S++)t[S]>i&&c.push({score:t[S],boxIndex:S,suppressBeginIndex:0});c.sort(JB);const h=r>0?-.5/r:0,f=[],p=[];for(;f.length<e&&c.length>0;){const S=c.pop(),{score:b,boxIndex:T,suppressBeginIndex:C}=S;if(b<i)break;let A=!1;for(let I=f.length-1;I>=C;--I){const D=wBt(n,T,f[I]);if(D>=s){A=!0;break}if(S.score=S.score*TBt(s,h,D),S.score<=i)break}S.suppressBeginIndex=f.length,A||(S.score===b?(f.push(T),p.push(S.score)):S.score>i&&gBt(c,S,JB))}const g=f.length,v=e-g;o&&v>0&&(f.push(...new Array(v).fill(0)),p.push(...new Array(v).fill(0)));const _={selectedIndices:f};return a&&(_.selectedScores=p),l&&(_.validOutputs=g),_}function wBt(n,t,e){const s=n.subarray(t*4,t*4+4),i=n.subarray(e*4,e*4+4),r=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(i[0],i[2]),h=Math.min(i[1],i[3]),f=Math.max(i[0],i[2]),p=Math.max(i[1],i[3]),g=(o-r)*(l-a),v=(f-c)*(p-h);if(g<=0||v<=0)return 0;const _=Math.max(r,c),S=Math.max(a,h),b=Math.min(o,f),T=Math.min(l,p),C=Math.max(b-_,0)*Math.max(T-S,0);return C/(g+v-C)}function TBt(n,t,e){const s=Math.exp(t*e*e);return e<=n?s:0}function JB(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function EBt(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY){const r=J(n,"boxes","nonMaxSuppressionAsync"),a=J(t,"scores","nonMaxSuppressionAsync"),o=Xx(r,a,e,s,i);e=o.maxOutputSize,s=o.iouThreshold,i=o.scoreThreshold;const l=await Promise.all([r.data(),a.data()]),c=l[0],h=l[1],{selectedIndices:f}=bBt(c,h,e,s,i);return r!==n&&r.dispose(),a!==t&&a.dispose(),Qo(f,"int32")}const CBt=EBt;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ABt(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const a=J(n,"boxes","nonMaxSuppression"),o=J(t,"scores","nonMaxSuppression"),l=Xx(a,o,e,s,i,r);e=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c={boxes:a,scores:o},h={maxOutputSize:e,iouThreshold:s,scoreThreshold:i,softNmsSigma:r},f=xt.runKernel(zDt,c,h);return{selectedIndices:f[0],selectedScores:f[1]}}const NBt=pt({nonMaxSuppressionWithScore_:ABt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function MBt(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const a=J(n,"boxes","nonMaxSuppressionAsync"),o=J(t,"scores","nonMaxSuppressionAsync"),l=Xx(a,o,e,s,i,r);e=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c=await Promise.all([a.data(),o.data()]),h=c[0],f=c[1],{selectedIndices:p,selectedScores:g}=_Bt(h,f,e,s,i,r);return a!==n&&a.dispose(),o!==t&&o.dispose(),{selectedIndices:Qo(p,"int32"),selectedScores:Qo(g)}}const IBt=MBt;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RBt(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const a=J(n,"boxes","nonMaxSuppression"),o=J(t,"scores","nonMaxSuppression"),l=Xx(a,o,e,s,i,null),c=l.maxOutputSize,h=l.iouThreshold,f=l.scoreThreshold,p={boxes:a,scores:o},g={maxOutputSize:c,iouThreshold:h,scoreThreshold:f,padToMaxOutputSize:r},v=xt.runKernel(FDt,p,g);return{selectedIndices:v[0],validOutputs:v[1]}}const DBt=pt({nonMaxSuppressionPadded_:RBt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function kBt(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const a=J(n,"boxes","nonMaxSuppressionAsync"),o=J(t,"scores","nonMaxSuppressionAsync"),l=Xx(a,o,e,s,i,null),c=l.maxOutputSize,h=l.iouThreshold,f=l.scoreThreshold,[p,g]=await Promise.all([a.data(),o.data()]),{selectedIndices:v,validOutputs:_}=SBt(p,g,c,h,f,r);return a!==n&&a.dispose(),o!==t&&o.dispose(),{selectedIndices:Qo(v,"int32"),validOutputs:hs(_,"int32")}}const OBt=kBt;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Bt(n,t,e=!1,s=!1){const i=J(n,"images","resizeBilinear");lt(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),lt(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),lt(s===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let r=i,a=!1;i.rank===3&&(a=!0,r=oe(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:r},l={alignCorners:e,halfPixelCenters:s,size:t},c=xt.runKernel(e3t,o,l);return a?oe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const LBt=pt({resizeBilinear_:$Bt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FBt(n,t,e=!1,s=!1){const i=J(n,"images","resizeNearestNeighbor");lt(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),lt(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),lt(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),lt(s===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let r=i,a=!1;i.rank===3&&(a=!0,r=oe(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:r},l={alignCorners:e,halfPixelCenters:s,size:t},c=xt.runKernel(t3t,o,l);return a?oe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const zBt=pt({resizeNearestNeighbor_:FBt});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UBt(n,t="binary",e=!1,s=.5){const i=J(n,"image","threshold"),r=.2989,a=.587,o=.114,l=i.shape[0]*i.shape[1];let c=Re(Qo([s]),255),h,f,p,g;if(lt(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),lt(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),lt(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),lt(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),i.shape[2]===3){[h,f,p]=Z1(i,[1,1,1],-1);const S=Re(h,r),b=Re(f,a),T=Re(p,o);g=yn(yn(S,b),T)}else g=n;if(t==="otsu"){const S=sX(qi(CX(g),"int32"),hh([]),256);c=BBt(S,l)}const v=e?E$(g,c):EN(g,c);return qi(Re(v,255),"int32")}function BBt(n,t){let e=Qo([-1]),s=Qo([0]),i=Qo([0]),r,a,o,l,c,h;for(let f=0;f<n.size-1;f++){r=bs(n,0,f+1),a=bs(n,f+1),c=ks(ai(r),t),h=ks(ai(a),t);const p=ai(Re(r,K1(0,r.size)));o=ks(p,ai(r));const g=N_(a.shape,r.size),v=yn(K1(0,a.size),g),_=Re(a,v);l=ks(ai(_),ai(a));const S=Vn(o,l),b=Vn(o,l),T=Re(c,h);i=Re(Re(T,S),b);const C=EN(i,s);s=qd(C,i,s),e=qd(C,Qo([f]),e)}return e}const PBt=pt({threshold_:UBt});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VBt(n,t,e="nearest",s="constant",i=0,r){const a=J(n,"image","transform","float32"),o=J(t,"transforms","transform","float32");lt(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),lt(o.rank===2&&(o.shape[0]===a.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),lt(r==null||r.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${r}.`);const l={image:a,transforms:o},c={interpolation:e,fillMode:s,fillValue:i,outputShape:r};return xt.runKernel(F3t,l,c)}const GBt=pt({transform_:VBt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HBt(n,t,e){const s=J(n,"a","bandPart");lt(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const i=s.shape,[r,a]=s.shape.slice(-2);let o,l;typeof t=="number"?(lt(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),lt(t<=r,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${r}).`),o=J(t<0?r:t,"numLower","bandPart")):(lt(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=qd(bD(t,0),r,eC(t,r))),typeof e=="number"?(lt(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),lt(e<=a,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${a}).`),l=J(e<0?a:e,"numUpper","bandPart")):(lt(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=qd(bD(e,0),a,eC(e,a)));const c=oe(K1(0,r,1,"int32"),[-1,1]),h=K1(0,a,1,"int32"),f=Vn(c,h),p=J2(E$(f,o),fX(f,fh(l))),g=Sx([r,a],s.dtype);return oe(Df(Kg(oe(s,[-1,r,a])).map(v=>qd(p,v,g))),i)}const WBt=pt({bandPart_:HBt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qBt(n){let t;if(Array.isArray(n)){t=!1,lt(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=n[0].shape[0];for(let r=1;r<n.length;++r)lt(n[r].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[r].shape[0]} vs. ${i})`)}else t=!0,n=Z1(n,n.shape[0],0).map(i=>Q1(i,[0]));lt(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],s=n;for(let i=0;i<n.length;++i)e.push(xt.tidy(()=>{let r=s[i];if(i>0)for(let a=0;a<i;++a){const o=Re(ai(Re(e[a],r)),e[a]);r=Vn(r,o)}return ks(r,TN(r,"euclidean"))}));return t?Df(e,0):e}const XBt=pt({gramSchmidt_:qBt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jBt(n,t=!1){if(lt(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return tP(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),s=Kg(oe(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),i=[],r=[];s.forEach(l=>{const[c,h]=tP(l,t);i.push(c),r.push(h)});const a=oe(Df(i,0),n.shape),o=oe(Df(r,0),n.shape);return[a,o]}}function tP(n,t=!1){return xt.tidy(()=>{lt(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],s=n.shape[1];let i=cX(e),r=Wd(n);const a=Yy([[1]],[1,1]);let o=Wd(a);const l=e>=s?s:e;for(let c=0;c<l;++c){const h=r,f=o,p=i;[o,r,i]=xt.tidy(()=>{const g=bs(r,[c,c],[e-c,1]),v=TN(g),_=bs(r,[c,c],[1,1]),S=qd(EN(_,0),Yy([[-1]]),Yy([[1]])),b=Vn(_,Re(S,v)),T=ks(g,b);T.shape[0]===1?o=Wd(a):o=Wa([a,bs(T,[1,0],[T.shape[0]-1,T.shape[1]])],0);const C=fh(ks(Vs(S,b),v)),A=bs(r,[c,0],[e-c,s]),I=Re(C,o),D=SD(o);if(c===0)r=Vn(A,Vs(I,Vs(D,A)));else{const k=Vn(A,Vs(I,Vs(D,A)));r=Wa([bs(r,[0,0],[c,s]),k],0)}const F=SD(I),z=bs(i,[0,c],[e,i.shape[1]-c]);if(c===0)i=Vn(z,Vs(Vs(z,o),F));else{const k=Vn(z,Vs(Vs(z,o),F));i=Wa([bs(i,[0,0],[e,c]),k],1)}return[o,r,i]}),wo([h,f,p])}return!t&&e>s&&(i=bs(i,[0,0],[e,s]),r=bs(r,[0,0],[s,s])),[i,r]})}const KBt=pt({qr_:jBt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var So;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(So||(So={}));function YBt(n,t,e=So.SUM_BY_NONZERO_WEIGHTS){const s=J(n,"losses","computeWeightedLoss");let i=null;t!=null&&(i=J(t,"weights","computeWeightedLoss"));const r=i==null?s:Re(s,i);if(e===So.NONE)return r;if(e===So.SUM)return ai(r);if(e===So.MEAN){if(i==null)return tC(r);{const a=s.size/i.size,o=ks(ai(r),ai(i));return a>1?ks(o,hs(a)):o}}if(e===So.SUM_BY_NONZERO_WEIGHTS){if(i==null)return ks(ai(r),hs(s.size));{const a=Re(i,Km(s.shape)),o=qi(ai(SX(a,hs(0))),"float32");return ks(ai(r),o)}}throw Error(`Unknown reduction: ${e}`)}const Ff=pt({computeWeightedLoss_:YBt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZBt(n,t,e,s=So.SUM_BY_NONZERO_WEIGHTS){const i=J(n,"labels","absoluteDifference"),r=J(t,"predictions","absoluteDifference");let a=null;e!=null&&(a=J(e,"weights","absoluteDifference")),gc(i.shape,r.shape,"Error in absoluteDifference: ");const o=vl(Vn(i,r));return Ff(o,a,s)}const QBt=pt({absoluteDifference_:ZBt});function JBt(n,t,e,s,i=So.SUM_BY_NONZERO_WEIGHTS){const r=J(n,"labels","cosineDistance"),a=J(t,"predictions","cosineDistance");let o=null;s!=null&&(o=J(s,"weights","cosineDistance")),gc(r.shape,a.shape,"Error in cosineDistance: ");const l=hs(1),c=Vn(l,ai(Re(r,a),e,!0));return Ff(c,o,i)}const tPt=pt({cosineDistance_:JBt});function ePt(n,t,e,s=So.SUM_BY_NONZERO_WEIGHTS){let i=J(n,"labels","hingeLoss");const r=J(t,"predictions","hingeLoss");let a=null;e!=null&&(a=J(e,"weights","hingeLoss")),gc(i.shape,r.shape,"Error in hingeLoss: ");const o=hs(1);i=Vn(Re(hs(2),i),o);const l=AN(Vn(o,Re(i,r)));return Ff(l,a,s)}const nPt=pt({hingeLoss_:ePt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sPt(n,t,e,s=1,i=So.SUM_BY_NONZERO_WEIGHTS){const r=J(n,"labels","huberLoss"),a=J(t,"predictions","huberLoss");let o=null;e!=null&&(o=J(e,"weights","huberLoss")),gc(r.shape,a.shape,"Error in huberLoss: ");const l=hs(s),c=vl(Vn(a,r)),h=eC(c,l),f=Vn(c,h),p=yn(Re(hs(.5),iu(h)),Re(l,f));return Ff(p,o,i)}const iPt=pt({huberLoss_:sPt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rPt(n,t,e,s=1e-7,i=So.SUM_BY_NONZERO_WEIGHTS){const r=J(n,"labels","logLoss"),a=J(t,"predictions","logLoss");let o=null;e!=null&&(o=J(e,"weights","logLoss")),gc(r.shape,a.shape,"Error in logLoss: ");const l=hs(1),c=hs(s),h=fh(Re(r,j1(yn(a,c)))),f=Re(Vn(l,r),j1(yn(Vn(l,a),c))),p=Vn(h,f);return Ff(p,o,i)}const aPt=pt({logLoss_:rPt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oPt(n,t,e,s=So.SUM_BY_NONZERO_WEIGHTS){const i=J(n,"labels","meanSquaredError"),r=J(t,"predictions","meanSquaredError");let a=null;e!=null&&(a=J(e,"weights","meanSquaredError")),gc(i.shape,r.shape,"Error in meanSquaredError: ");const o=NX(i,r);return Ff(o,a,s)}const lPt=pt({meanSquaredError_:oPt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cPt(n,t){const e=J(n,"labels","sigmoidCrossEntropyWithLogits"),s=J(t,"logits","sigmoidCrossEntropyWithLogits");gc(e.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=AN(s),r=Re(s,e),a=pX(Ng(fh(vl(s))));return yn(Vn(i,r),a)}function uPt(n,t,e,s=0,i=So.SUM_BY_NONZERO_WEIGHTS){let r=J(n,"multiClassLabels","sigmoidCrossEntropy");const a=J(t,"logits","sigmoidCrossEntropy");let o=null;if(e!=null&&(o=J(e,"weights","sigmoidCrossEntropy")),gc(r.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const c=hs(s),h=hs(1),f=hs(.5);r=yn(Re(r,Vn(h,c)),Re(f,c))}const l=cPt(r,a);return Ff(l,o,i)}const hPt=pt({sigmoidCrossEntropy_:uPt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fPt(n,t,e=-1){if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return Rf((i,r,a)=>{const l=gX(r,[e],!0),c=Vn(qi(r,"float32"),l);a([i,c]);const h=fh(Re(c,i));return{value:ai(h,[e]),gradFunc:(g,v)=>{const[_,S]=v,b=wN(g.shape,[e]);return[Re(oe(g,b),Vn(qi(_,"float32"),Ng(S))),Re(oe(g,b),Vn(Ng(S),qi(_,"float32")))]}}})(n,t)}function dPt(n,t,e,s=0,i=So.SUM_BY_NONZERO_WEIGHTS){let r=J(n,"onehotLabels","softmaxCrossEntropy");const a=J(t,"logits","softmaxCrossEntropy");let o=null;if(e!=null&&(o=J(e,"weights","softmaxCrossEntropy")),gc(r.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const c=hs(s),h=hs(1),f=hs(r.shape[1]);r=yn(Re(r,Vn(h,c)),ks(c,f))}const l=fPt(r,a);return Ff(l,o,i)}const pPt=pt({softmaxCrossEntropy_:dPt});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mPt(n,t,e,s){const i=J(n,"indices","sparseFillEmptyRows","int32"),r=J(t,"values","sparseFillEmptyRows"),a=J(e,"denseShape","sparseFillEmptyRows","int32"),o=J(s,"defaultValue","sparseFillEmptyRows",r.dtype);if(i.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(r.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${r.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:i,values:r,denseShape:a,defaultValue:o},c=xt.runKernel(_3t,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const gPt=pt({sparseFillEmptyRows_:mPt});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yPt(n,t,e){const s=J(n,"inputIndices","sparseReshape","int32"),i=J(t,"inputShape","sparseReshape","int32"),r=J(e,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(i.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(r.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${r.shape}`);const a={inputIndices:s,inputShape:i,newShape:r},o=xt.runKernel(w3t,a);return{outputIndices:o[0],outputShape:o[1]}}const xPt=pt({sparseReshape_:yPt});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vPt(n,t,e){const s=J(n,"data","sparseSegmentMean"),i=J(t,"indices","sparseSegmentMean","int32"),r=J(e,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(r.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${r.shape}`);const a={data:s,indices:i,segmentIds:r};return xt.runKernel(T3t,a)}const bPt=pt({sparseSegmentMean_:vPt});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SPt(n,t,e){const s=J(n,"data","sparseSegmentSum"),i=J(t,"indices","sparseSegmentSum","int32"),r=J(e,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(r.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${r.shape}`);const a={data:s,indices:i,segmentIds:r};return xt.runKernel(E3t,a)}const _Pt=pt({sparseSegmentSum_:SPt});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wPt(n,t,e,s,i,r,a,o){const l=J(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=J(t,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const h={separator:e,nGramWidths:s,leftPad:i,rightPad:r,padWidth:a,preserveShortSequences:o},f={data:l,dataSplits:c},p=xt.runKernel(I3t,f,h);return{nGrams:p[0],nGramsSplits:p[1]}}const TPt=pt({stringNGrams_:wPt});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EPt(n,t,e=!0){const s=J(n,"input","stringSplit","string"),i=J(t,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(i.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const r={skipEmpty:e},a={input:s,delimiter:i},o=xt.runKernel(R3t,a,r);return{indices:o[0],values:o[1],shape:o[2]}}const CPt=pt({stringSplit_:EPt});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function APt(n,t){const e=J(n,"input","stringToHashBucketFast","string"),s={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const i={input:e};return xt.runKernel(D3t,i,s)}const NPt=pt({stringToHashBucketFast_:APt});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MPt(n,t,e,s=!0){const i=J(n,"input","staticRegexReplace","string"),r={pattern:t,rewrite:e,replaceGlobal:s};return xt.runKernel(N3t,{x:i},r)}const IPt=pt({staticRegexReplace_:MPt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RPt={fft:M$,ifft:nC,rfft:I$,irfft:AX},DPt={hammingWindow:JUt,hannWindow:OX,frame:$X,stft:sBt},J1={flipLeftRight:oBt,grayscaleToRGB:cBt,resizeNearestNeighbor:zBt,resizeBilinear:LBt,rgbToGrayscale:hBt,rotateWithOffset:dBt,cropAndResize:rBt,nonMaxSuppression:mBt,nonMaxSuppressionAsync:CBt,nonMaxSuppressionWithScore:NBt,nonMaxSuppressionWithScoreAsync:IBt,nonMaxSuppressionPadded:DBt,nonMaxSuppressionPaddedAsync:OBt,threshold:PBt,transform:GBt},kPt={bandPart:WBt,gramSchmidt:XBt,qr:KBt},OPt={absoluteDifference:QBt,computeWeightedLoss:Ff,cosineDistance:tPt,hingeLoss:nPt,huberLoss:iPt,logLoss:aPt,meanSquaredError:lPt,sigmoidCrossEntropy:hPt,softmaxCrossEntropy:pPt},$Pt={sparseFillEmptyRows:gPt,sparseReshape:xPt,sparseSegmentMean:bPt,sparseSegmentSum:_Pt},LPt={stringNGrams:TPt,stringSplit:CPt,stringToHashBucketFast:NPt,staticRegexReplace:IPt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FPt=new Map,zPt=new Map;class UPt{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Bm{constructor(){this.classNameMap={}}static getMap(){return Bm.instance==null&&(Bm.instance=new Bm),Bm.instance}static register(t){Bm.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function BPt(n,t,e){lt(n.className!=null,()=>"Class being registered does not have the static className property defined."),lt(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),lt(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof e>"u"&&(e=n.className);const s=e,i=t+">"+s;return Bm.register(n),FPt.set(i,n),zPt.set(n,i),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yg extends UPt{minimize(t,e=!1,s){const{value:i,grads:r}=this.computeGradients(t,s);if(s!=null){const a=s.map(o=>({name:o.name,tensor:r[o.name]}));this.applyGradients(a)}else this.applyGradients(r);return wo(r),e?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return LLt(t,e)}dispose(){this.iterations_!=null&&wo(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:hs(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Yg,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PPt extends Yg{static get className(){return"Adadelta"}constructor(t,e,s=null){super(),this.learningRate=t,this.rho=e,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=xt.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=xt.registeredVariables[s],a=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accum_grad`,variable:Jn(()=>Al(r).variable(a))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${s}/accum_var`,variable:Jn(()=>Al(r).variable(a))});const o=Array.isArray(t)?t[i].tensor:t[s];if(o==null)return;const l=this.accumulatedGrads[i].variable,c=this.accumulatedUpdates[i].variable;Jn(()=>{const h=yn(Re(l,this.rho),Re(iu(o),1-this.rho)),f=Re(ks(If(yn(c,this.epsilon)),If(yn(l,this.epsilon))),o),p=yn(Re(c,this.rho),Re(iu(f),1-this.rho));l.assign(h),c.assign(p);const g=yn(Re(f,-this.learningRate),r);r.assign(g)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(wo(this.accumulatedGrads.map(t=>t.variable)),wo(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,e).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedUpdates=t.slice(e,e*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VPt extends Yg{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=xt.registeredVariables[s];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accumulator`,variable:Jn(()=>N_(r.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(t)?t[i].tensor:t[s];if(a==null)return;const o=this.accumulatedGrads[i].variable;Jn(()=>{const l=yn(o,iu(a));o.assign(l);const c=yn(Re(ks(a,If(yn(l,xt.backend.epsilon()))),-this.learningRate),r);r.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&wo(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GPt extends Yg{static get className(){return"Adam"}constructor(t,e,s,i=null){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Jn(()=>{this.accBeta1=hs(e).variable(),this.accBeta2=hs(s).variable()}),i==null&&(this.epsilon=xt.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);Jn(()=>{const s=Vn(1,this.accBeta1),i=Vn(1,this.accBeta2);e.forEach((r,a)=>{const o=xt.registeredVariables[r],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${r}/m`,variable:Jn(()=>Al(o).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${r}/v`,variable:Jn(()=>Al(o).variable(l))});const c=Array.isArray(t)?t[a].tensor:t[r];if(c==null)return;const h=this.accumulatedFirstMoment[a].variable,f=this.accumulatedSecondMoment[a].variable,p=yn(Re(h,this.beta1),Re(c,1-this.beta1)),g=yn(Re(f,this.beta2),Re(iu(c),1-this.beta2)),v=ks(p,s),_=ks(g,i);h.assign(p),f.assign(g);const S=yn(Re(ks(v,yn(If(_),this.epsilon)),-this.learningRate),o);o.assign(S)}),this.accBeta1.assign(Re(this.accBeta1,this.beta1)),this.accBeta2.assign(Re(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&wo(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&wo(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),Jn(()=>{this.accBeta1.assign(X1(this.beta1,this.iterations_+1)),this.accBeta2.assign(X1(this.beta2,this.iterations_+1))});const e=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,e).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HPt extends Yg{static get className(){return"Adamax"}constructor(t,e,s,i=null,r=0){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=i,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Jn(()=>{this.iteration=hs(0).variable(),this.accBeta1=hs(e).variable()}),i==null&&(this.epsilon=xt.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);Jn(()=>{const s=Vn(1,this.accBeta1),i=ks(-this.learningRate,yn(Re(this.iteration,this.decay),1));e.forEach((r,a)=>{const o=xt.registeredVariables[r],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${r}/m`,variable:Al(o).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${r}/v`,variable:Al(o).variable(l)});const c=Array.isArray(t)?t[a].tensor:t[r];if(c==null)return;const h=this.accumulatedFirstMoment[a].variable,f=this.accumulatedWeightedInfNorm[a].variable,p=yn(Re(h,this.beta1),Re(c,1-this.beta1)),g=Re(f,this.beta2),v=vl(c),_=bX(g,v);h.assign(p),f.assign(_);const S=yn(Re(ks(i,s),ks(p,yn(_,this.epsilon))),o);o.assign(S)}),this.iteration.assign(yn(this.iteration,1)),this.accBeta1.assign(Re(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&wo(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&wo(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LX extends Yg{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=Array.isArray(t)?t[i].tensor:t[s];if(r==null)return;const a=xt.registeredVariables[s];Jn(()=>{const o=yn(Re(this.c,r),a);a.assign(o)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=ih(hs(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WPt extends LX{static get className(){return"Momentum"}constructor(t,e,s=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=s,this.accumulations=[],this.m=hs(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=xt.registeredVariables[s];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${s}/momentum`,variable:Jn(()=>Al(r).variable(!1))});const a=this.accumulations[i].variable,o=Array.isArray(t)?t[i].tensor:t[s];o!=null&&Jn(()=>{let l;const c=yn(Re(this.m,a),o);this.useNesterov?l=yn(Re(this.c,yn(o,Re(c,this.m))),r):l=yn(Re(this.c,c),r),a.assign(c),r.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&wo(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qPt extends Yg{static get className(){return"RMSProp"}constructor(t,e=.9,s=0,i=null,r=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=s,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,i==null&&(this.epsilon=xt.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=xt.registeredVariables[s],a=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${s}/rms`,variable:Jn(()=>Al(r).variable(a))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${s}/momentum`,variable:Jn(()=>Al(r).variable(a))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${s}/mg`,variable:Jn(()=>Al(r).variable(a))});const o=Array.isArray(t)?t[i].tensor:t[s];if(o==null)return;const l=this.accumulatedMeanSquares[i].variable,c=this.accumulatedMoments[i].variable;Jn(()=>{const h=yn(Re(l,this.decay),Re(iu(o),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[i].variable,p=yn(Re(f,this.decay),Re(o,1-this.decay)),g=ks(Re(o,this.learningRate),If(Vn(h,yn(iu(p),this.epsilon)))),v=yn(Re(c,this.momentum),g);l.assign(h),f.assign(p),c.assign(v);const _=Vn(r,v);r.assign(_)}else{const f=yn(Re(l,this.decay),Re(iu(o),1-this.decay)),p=yn(Re(c,this.momentum),ks(Re(o,this.learningRate),If(yn(f,this.epsilon))));l.assign(f),c.assign(p);const g=Vn(r,p);r.assign(g)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&wo(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&wo(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&wo(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,e).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedMoments=t.slice(e,e*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XPt=[PPt,VPt,GPt,HPt,WPt,qPt,LX];function jPt(){for(const n of XPt)BPt(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KPt="model",YPt=".json",ZPt=".weights.bin";function eP(n){return new Promise(t=>setTimeout(t)).then(n)}class Ig{constructor(t){if(!An().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Ig.URL_SCHEME)&&(t=t.slice(Ig.URL_SCHEME.length)),(t==null||t.length===0)&&(t=KPt),this.modelJsonFileName=t+YPt,this.weightDataFileName=t+ZPt}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=hu.join(t.weightData),s=window.URL.createObjectURL(new Blob([e],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],r=Hq(t,i),a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await eP(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await eP(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:A_(t)}}}}Ig.URL_SCHEME="downloads://";class QPt{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,e)=>{const s=new FileReader;s.onload=i=>{const r=JSON.parse(i.target.result),a=r.modelTopology;if(a==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(r.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:a});return}const l=_$(r,c=>this.loadWeights(c));t(l)},s.onerror=i=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(t){const e=[],s=[];for(const a of t)e.push(...a.weights),s.push(...a.paths);const i=this.checkManifestAndWeightFiles(t),r=s.map(a=>this.loadWeightsFile(a,i[a]));return Promise.all(r).then(a=>[e,a])}loadWeightsFile(t,e){return new Promise((s,i)=>{const r=new FileReader;r.onload=a=>{const o=a.target.result;s(o)},r.onerror=a=>i(`Failed to weights data from file of path '${t}'.`),r.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],s=this.weightsFiles.map(r=>QB(r.name)),i={};for(const r of t)r.paths.forEach(a=>{const o=QB(a);if(e.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(e.push(o),s.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);i[a]=this.weightsFiles[s.indexOf(o)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}const JPt=n=>An().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ig.URL_SCHEME)?t4t(n.slice(Ig.URL_SCHEME.length)):null;Si.registerSaveRouter(JPt);function t4t(n="model"){return new Ig(n)}function e4t(n){return new QPt(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nP(n,t,e,s){a(n),e=e??0,s=s??1,o(e,s);let i=0;const r=l=>(l.then(c=>{const h=e+ ++i/n.length*(s-e);return t(h),c}),l);function a(l){lt(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,c){lt(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),lt(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),lt(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function FX(n,t){t==null&&(t={});const e=t.fetchFunc==null?An().platform.fetch:t.fetchFunc,s=n.map(f=>e(f,t.requestInit,{isBinary:!0})),o=(t.onProgress==null?await Promise.all(s):await nP(s,t.onProgress,0,.5)).map(f=>f.arrayBuffer());return t.onProgress==null?await Promise.all(o):await nP(o,t.onProgress,.5,1)}function n4t(n,t){var e;const s=t.fetchFunc==null?An().platform.fetch:t.fetchFunc;let i=0,r;return(e=t.onProgress)===null||e===void 0||e.call(t,0),new ReadableStream({pull:async a=>{for(var o;i<n.length;){r||(r=(await s(n[i],t.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:c}=await r.read();if(l){i++,r=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,i/n.length);continue}a.enqueue(c);return}a.close()}})}async function s4t(n,t="",e,s){return zX(a=>FX(a,{requestInit:s}))(n,t,e)}function zX(n){return async(t,e="",s)=>{const i=t.map(()=>!1),r={},a=s!=null?s.map(()=>!1):[],o=[];if(t.forEach((g,v)=>{let _=0;g.weights.forEach(S=>{const b="quantization"in S?S.quantization.dtype:S.dtype,T=Eg[b]*ir(S.shape),C=()=>{i[v]=!0,r[v]==null&&(r[v]=[]),r[v].push({manifestEntry:S,groupOffset:_,sizeBytes:T})};s!=null?s.forEach((A,I)=>{A===S.name&&(C(),a[I]=!0)}):C(),o.push(S.name),_+=T})}),!a.every(g=>g)){const g=s.filter((v,_)=>!a[_]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const l=i.reduce((g,v,_)=>(v&&g.push(_),g),[]),c=[];l.forEach(g=>{t[g].paths.forEach(v=>{const _=e+(e.endsWith("/")?"":"/")+v;c.push(_)})});const h=await n(c),f={};let p=0;return l.forEach(g=>{const v=t[g].paths.length,_=new hu(h.slice(p,p+v));r[g].forEach(b=>{const T=_.slice(b.groupOffset,b.groupOffset+b.sizeBytes),C=Pq(T,[b.manifestEntry]);for(const A in C)f[A]=C[A]}),p+=v}),f}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i4t="application/octet-stream",r4t="application/json";class F${constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(lt(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=An().platform.fetch,lt(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&lt(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],i=Hq(t,s);if(e.body.append("model.json",new Blob([JSON.stringify(i)],{type:r4t}),"model.json"),t.weightData!=null){const a=hu.join(t.weightData);e.body.append("model.weights.bin",new Blob([a],{type:i4t}),"model.weights.bin")}const r=await this.fetch(this.path,e);if(r.ok)return{modelArtifactsInfo:A_(t),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const s=e.modelTopology,i=e.weightsManifest;if(s==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return _$(t,e=>this.loadWeights(e))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),s=dD(t.weightsManifest),i=()=>n4t(e,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:s,getWeightStream:i})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[s,i]=a4t(e),r=this.weightPathPrefix||s,a=[],o=[];for(const l of t)for(const c of l.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(c)):a.push(r+c+i);return this.weightUrlConverter&&a.push(...await Promise.all(o)),a}async loadWeights(t){const e=await this.getWeightUrls(t),s=dD(t),i=await FX(e,this.loadOptions);return[s,i]}}F$.URL_SCHEME_REGEX=/^https?:\/\//;function a4t(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?"),s=n.substring(0,t),i=e>t?n.substring(e):"";return[s+"/",i]}function _D(n){return n.match(F$.URL_SCHEME_REGEX)!=null}const UX=(n,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(n)?e=n.every(s=>_D(s)):e=_D(n),e)return z$(n,t)}return null};Si.registerSaveRouter(UX);Si.registerLoadRouter(UX);function z$(n,t){return new F$(n,t)}function o4t(n,t){return z$(n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XI{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class BX{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class l4t{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function c4t(n,t,e,s){const i=arguments;return new l4t(PX(...i))}function PX(n,t,e,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new XI(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new XI({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new XI({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:s}))}function u4t(n){return new BX(n)}function h4t(n){return new BX(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VX=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:hu,browserFiles:e4t,browserHTTPRequest:o4t,concatenateArrayBuffers:bkt,copyModel:Vkt,decodeWeights:Pq,decodeWeightsStream:Gq,encodeWeights:pkt,fromMemory:c4t,fromMemorySync:PX,getLoadHandlers:Nkt,getModelArtifactsForJSON:_$,getModelArtifactsForJSONSync:Wq,getModelArtifactsInfoForJSON:A_,getSaveHandlers:Akt,getWeightSpecs:dD,http:z$,isHTTPScheme:_D,listModels:Bkt,loadWeights:s4t,moveModel:Gkt,registerLoadRouter:Ckt,registerSaveRouter:Ekt,removeModel:Pkt,weightsLoaderFactory:zX,withSaveHandler:u4t,withSaveHandlerSync:h4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Rm;function f4t(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,s=!1,i=!1,r=!1,a=!1,o=!1;if(n.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)r=!0;else if(n.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(oD(UB,xt.backendName)!=null){const v={pixels:n},_={numChannels:t};return xt.runKernel(UB,v,_)}const[c,h]=i?[n.videoWidth,n.videoHeight]:[n.width,n.height];let f;if(a)f=n.getContext("2d").getImageData(0,0,c,h).data;else if(s||e)f=n.data;else if(r||i||o){if(Rm==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Rm=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Rm=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Rm.canvas.width=c,Rm.canvas.height=h,Rm.drawImage(n,0,0,c,h),f=Rm.getImageData(0,0,c,h).data}let p;if(t===4)p=new Int32Array(f);else{const v=c*h;p=new Int32Array(v*t);for(let _=0;_<v;_++)for(let S=0;S<t;++S)p[_*t+S]=f[_*4+S]}return IX(p,[h,c,t],"int32")}const d4t=pt({fromPixels_:f4t});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */jPt();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p4t=An();p4t.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Wo;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Wo||(Wo={}));var sP;(function(n){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(sP||(sP={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m4t={};function GX(n){return m4t[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B(n,t,e,s,i){const r=t.inputParams[n];if(r&&r.inputIndexStart!==void 0){const o=r.inputIndexStart,l=r.inputIndexEnd===0?void 0:r.inputIndexEnd===void 0?o+1:r.inputIndexEnd,c=o<0?t.inputNames.length+o:o;if(r.type==="tensor")return Zr(t.inputNames[c],e,s,i);if(r.type==="tensors"){const p=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((v,_)=>{var S;return((S=p[_])===null||S===void 0?void 0:S.op)!=="NoOp"}).map(v=>Zr(v,e,s,i))}const h=Zr(t.inputNames[c],e,s,i),f=h.dataSync();return r.type==="number"?f[0]:aD(h.shape,f)}const a=t.attrParams[n];return a&&a.value}function Zr(n,t,e,s){const[i,r]=qo(n,e);if(s!=null){const o=s.getHashTableHandleByName(i);if(o!=null)return o}const a=e.currentContextIds.find(o=>!!t[sC(i,o)]);return a!==void 0?t[sC(i,a)][r]:void 0}function iP(n,t,e){return t[sC(n,e.currentContextId)]}function pf(n,t){const[e,s,i]=qo(n,t);return[sC(e,t&&t.currentContextId),s,i]}function sC(n,t){return t?`${n}-${t}`:n}function qo(n,t){if(n==="")return["",0,void 0];const e=t!=null&&t.parseNodeNameCache!=null;if(e){const r=t.parseNodeNameCache.get(n);if(r!=null)return r}const s=n.split(":");let i;if(s.length===1)i=[n,0,void 0];else{const r=s[0],a=s.length===3?s[1]:void 0,o=Number(s[s.length-1]);i=[r,o,a]}return e&&t.parseNodeNameCache.set(n,i),i}function _E(n,t,e){let s=B("pad",n,t,e);if(s==="explicit"){s=B("explicitPaddings",n,t,e);const i=[[0,0],[0,0],[0,0],[0,0]];for(let r=0;r<4;r++)i[r][0]=s[r*2],i[r][1]=s[r*2+1];return i}return s}function mf(n){return n.kept?n:Wd(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g4t=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],y4t=Object.freeze(Object.defineProperty({__proto__:null,json:g4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x4t=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],v4t=Object.freeze(Object.defineProperty({__proto__:null,json:x4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b4t=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],S4t=Object.freeze(Object.defineProperty({__proto__:null,json:b4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _4t=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],w4t=Object.freeze(Object.defineProperty({__proto__:null,json:_4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T4t=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],E4t=Object.freeze(Object.defineProperty({__proto__:null,json:T4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C4t=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],A4t=Object.freeze(Object.defineProperty({__proto__:null,json:C4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N4t=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],M4t=Object.freeze(Object.defineProperty({__proto__:null,json:N4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I4t=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],R4t=Object.freeze(Object.defineProperty({__proto__:null,json:I4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D4t=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],k4t=Object.freeze(Object.defineProperty({__proto__:null,json:D4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O4t=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],$4t=Object.freeze(Object.defineProperty({__proto__:null,json:O4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L4t=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],F4t=Object.freeze(Object.defineProperty({__proto__:null,json:L4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z4t=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],U4t=Object.freeze(Object.defineProperty({__proto__:null,json:z4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B4t=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],P4t=Object.freeze(Object.defineProperty({__proto__:null,json:B4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V4t=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],G4t=Object.freeze(Object.defineProperty({__proto__:null,json:V4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H4t=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],W4t=Object.freeze(Object.defineProperty({__proto__:null,json:H4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q4t=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],X4t=Object.freeze(Object.defineProperty({__proto__:null,json:q4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j4t=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],K4t=Object.freeze(Object.defineProperty({__proto__:null,json:j4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y4t=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Z4t=Object.freeze(Object.defineProperty({__proto__:null,json:Y4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q4t=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],J4t=Object.freeze(Object.defineProperty({__proto__:null,json:Q4t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rP{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[y4t,v4t,S4t,w4t,E4t,A4t,M4t,R4t,k4t,$4t,F4t,U4t,P4t,G4t,W4t,X4t,K4t,Z4t,J4t],e=[].concat(...t.map(s=>s.json));this.opMappers=e.reduce((s,i)=>(s[i.tfOpName]=i,s),{})}transformGraph(t,e={}){const s=t.node,i=[],r=[],a=[],o=s.reduce((_,S)=>(_[S.name]=this.mapNode(S),S.op.startsWith("Placeholder")?i.push(_[S.name]):S.op==="Const"?r.push(_[S.name]):(S.input==null||S.input.length===0)&&a.push(_[S.name]),_),{});let l=[];const c=[];let h={},f={};e!=null&&(h=this.mapSignatureEntries(e.inputs),f=this.mapSignatureEntries(e.outputs));const p=Object.keys(o);p.forEach(_=>{const S=o[_];S.inputNames.forEach((b,T)=>{const[C,,A]=pf(b),I=o[C];if(I.outputs!=null){const D=I.outputs.indexOf(A);if(D!==-1){const F=`${C}:${D}`;S.inputNames[T]=F}}S.inputs.push(I),I.children.push(S)})}),Object.keys(f).length===0?p.forEach(_=>{const S=o[_];S.children.length===0&&c.push(S)}):Object.keys(f).forEach(_=>{const[S]=pf(_),b=o[S];b!=null&&(b.signatureKey=f[_],c.push(b))}),Object.keys(h).length>0?Object.keys(h).forEach(_=>{const[S]=pf(_),b=o[S];b&&(b.signatureKey=h[_],l.push(b))}):l=i;let g={};t.library!=null&&t.library.function!=null&&(g=t.library.function.reduce((_,S)=>(_[S.signature.name]=this.mapFunction(S),_),{}));const v={nodes:o,inputs:l,outputs:c,weights:r,placeholders:i,signature:e,functions:g};return a.length>0&&(v.initNodes=a),v}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,s)=>(e[t[s].name]=s,e),{})}mapNode(t){const e=GX(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});const s={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return e.inputs!=null&&(s.inputParams=e.inputs.reduce((i,r)=>(i[r.name]={type:r.type,inputIndexStart:r.start,inputIndexEnd:r.end},i),{})),e.attrs!=null&&(s.attrParams=e.attrs.reduce((i,r)=>{const a=r.type;let o;switch(r.type){case"string":o=wD(t.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=wD(t.attr,r.tfDeprecatedName,r.defaultValue));break;case"string[]":o=ID(t.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=ID(t.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":o=ED(t.attr,r.tfName,r.defaultValue||0),o===void 0&&r.tfDeprecatedName&&(o=ED(t.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":o=MD(t.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=MD(t.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":o=TD(t.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=TD(t.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool[]":o=DD(t.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=DD(t.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":o=ND(t.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=ND(t.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape[]":o=RD(t.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=RD(t.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":o=CD(t.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=CD(t.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype[]":o=AD(t.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=AD(t.attr,r.tfDeprecatedName,r.defaultValue));break;case"func":o=aP(t.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=aP(t.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${r.type} for op: ${t.op}`)}return i[r.name]={value:o,type:a},i},{})),s}mapFunction(t){const e=t.nodeDef,s=[],i=[];let r={};e!=null&&(r=e.reduce((f,p)=>(f[p.name]=this.mapNode(p),p.op==="Const"&&i.push(f[p.name]),f),{}));const a=[],o=[];t.signature.inputArg.forEach(f=>{const[p]=pf(f.name),g={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:U$(f.type),type:"dtype"}},children:[]};g.signatureKey=f.name,a.push(g),r[p]=g}),Object.keys(r).forEach(f=>{const p=r[f];p.inputNames.forEach((g,v)=>{const[_,,S]=pf(g),b=r[_];if(b.outputs!=null){const T=b.outputs.indexOf(S);if(T!==-1){const C=`${_}:${T}`;p.inputNames[v]=C}}p.inputs.push(b),b.children.push(p)})});const c=t.ret;t.signature.outputArg.forEach(f=>{const[p,g]=pf(c[f.name]),v=r[p];v!=null&&(v.defaultOutput=g,o.push(v))});const h=this.mapArgsToSignature(t);return{nodes:r,inputs:a,outputs:o,weights:i,placeholders:s,signature:h}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,s)=>(e[s.name]=this.mapArgToTensorInfo(s),e),{}),outputs:t.signature.outputArg.reduce((e,s)=>(e[s.name]=this.mapArgToTensorInfo(s,t.ret),e),{})}}mapArgToTensorInfo(t,e){let s=t.name;return e!=null&&(s=e[s]),{name:s,dtype:t.type}}}function tVt(n){const t=An().global;if(typeof t.atob<"u")return t.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function HX(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):tVt(n);return t?e:e.toLowerCase()}function wD(n,t,e,s=!1){const i=n[t];return i!=null?HX(i.s,s):e}function TD(n,t,e){const s=n[t];return s?s.b:e}function ED(n,t,e){const s=n[t]||{},i=s.i!=null?s.i:s.f!=null?s.f:e;return typeof i=="number"?i:parseInt(i,10)}function U$(n){switch(typeof n=="string"&&(n=Wo[n]),n){case Wo.DT_FLOAT:case Wo.DT_HALF:return"float32";case Wo.DT_INT32:case Wo.DT_INT64:case Wo.DT_INT8:case Wo.DT_UINT8:return"int32";case Wo.DT_BOOL:return"bool";case Wo.DT_DOUBLE:return"float32";case Wo.DT_STRING:return"string";case Wo.DT_COMPLEX64:case Wo.DT_COMPLEX128:return"complex64";default:return null}}function aP(n,t,e){const s=n[t];return s&&s.func?s.func.name:e}function CD(n,t,e){const s=n[t];return s&&s.type?U$(s.type):e}function AD(n,t,e){const s=n[t];return s&&s.list&&s.list.type?s.list.type.map(i=>U$(i)):e}function WX(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function ND(n,t,e){const s=n[t];return s&&s.shape?WX(s.shape):e}function MD(n,t,e){const s=n[t];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):e}function ID(n,t,e,s=!1){const i=n[t];return i&&i.list&&i.list.s?i.list.s.map(r=>HX(r,s)):e}function RD(n,t,e){const s=n[t];return s&&s.list&&s.list.shape?s.list.shape.map(i=>WX(i)):e}function DD(n,t,e){const s=n[t];return s&&s.list&&s.list.b?s.list.b:e}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eVt{constructor(t,e,s){this.node=t,this.tensorMap=e,this.context=s,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(i=>this.getInput(i)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((i,r)=>(i[r]=this.getAttr(r),i),{}))}getInput(t){return Zr(t,this.tensorMap,this.context)}getAttr(t,e){const s=this.node.rawAttrs[t];if(s.tensor!=null)return Zr(t,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return ED(this.node.rawAttrs,t,e);if(s.s!=null)return wD(this.node.rawAttrs,t,e);if(s.b!=null)return TD(this.node.rawAttrs,t,e);if(s.shape!=null)return ND(this.node.rawAttrs,t,e);if(s.type!=null)return CD(this.node.rawAttrs,t,e);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return MD(this.node.rawAttrs,t,e);if(s.list.s!=null)return ID(this.node.rawAttrs,t,e);if(s.list.shape!=null)return RD(this.node.rawAttrs,t,e);if(s.list.b!=null)return DD(this.node.rawAttrs,t,e);if(s.list.type!=null)return AD(this.node.rawAttrs,t,e)}return e}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sa=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:Bq,abs:vl,acos:nOt,acosh:iOt,add:yn,addN:aOt,all:lOt,any:uOt,argMax:fOt,argMin:pOt,asin:gOt,asinh:xOt,atan:bOt,atan2:_Ot,atanh:TOt,avgPool:eX,avgPool3d:DOt,basicLSTMCell:UOt,batchNorm:SN,batchNorm2d:HOt,batchNorm3d:qOt,batchNorm4d:jOt,batchToSpaceND:nX,bincount:sX,bitwiseAnd:ZOt,booleanMaskAsync:wUt,broadcastArgs:JOt,broadcastTo:SE,buffer:Mf,cast:qi,ceil:n$t,clipByValue:i$t,clone:Wd,complex:sp,concat:Wa,concat1d:a$t,concat2d:iX,concat3d:c$t,concat4d:h$t,conv1d:p$t,conv2d:_N,conv2dTranspose:y$t,conv3d:v$t,conv3dTranspose:w$t,cos:E$t,cosh:A$t,cosineWindow:R$,cumprod:M$t,cumsum:R$t,denseBincount:k$t,depthToSpace:$$t,depthwiseConv2d:T$,diag:z$t,dilation2d:B$t,div:ks,divNoNan:q$t,dot:j$t,dropout:LUt,einsum:Fy,elu:oX,enclosingPowerOfTwo:kX,ensureShape:Q$t,equal:aX,erf:tLt,euclideanNorm:uLt,exp:Ng,expandDims:df,expm1:pLt,eye:cX,fft:M$,fill:N_,floor:uX,floorDiv:tX,fused:ZUt,gather:hX,gatherND:kUt,greater:EN,greaterEqual:fX,ifft:nC,imag:CN,image:J1,inTopKAsync:zUt,irfft:AX,isFinite:wLt,isInf:ELt,isNaN:ALt,leakyRelu:dX,less:bD,lessEqual:E$,linalg:kPt,linspace:RLt,localResponseNormalization:kLt,log:j1,log1p:pX,logSigmoid:BLt,logSoftmax:GLt,logSumExp:gX,logicalAnd:J2,logicalNot:yX,logicalOr:xX,logicalXor:KLt,losses:OPt,lowerBound:ZLt,matMul:Vs,max:Ky,maxPool:vX,maxPool3d:tFt,maxPoolWithArgmax:nFt,maximum:bX,mean:tC,meshgrid:rFt,min:vD,minimum:eC,mirrorPad:lFt,mod:uFt,moments:fFt,movingAverage:CUt,mul:Re,multiRNNCell:pFt,multinomial:gFt,neg:fh,norm:TN,notEqual:SX,oneHot:vFt,ones:Km,onesLike:SFt,op:pt,outerProduct:wFt,pad:M_,pad1d:CFt,pad2d:NFt,pad3d:IFt,pad4d:DFt,pool:FFt,pow:X1,prelu:wX,print:Jq,prod:BFt,raggedGather:VFt,raggedRange:HFt,raggedTensorToTensor:qFt,rand:jFt,randomGamma:QFt,randomNormal:TX,randomStandardNormal:ezt,randomUniform:N$,randomUniformInt:izt,range:K1,real:Y1,reciprocal:ozt,relu:AN,relu6:EX,reshape:oe,reverse:Mg,reverse1d:fzt,reverse2d:pzt,reverse3d:gzt,reverse4d:xzt,rfft:I$,round:CX,rsqrt:Szt,scalar:hs,scatterND:NUt,searchSorted:C$,selu:wzt,separableConv2d:Ezt,setdiff1dAsync:Azt,sigmoid:sg,sign:Mzt,signal:DPt,sin:Rzt,sinh:kzt,slice:bs,slice1d:$zt,slice2d:Fzt,slice3d:Uzt,slice4d:Pzt,softmax:Gzt,softplus:mX,spaceToBatchND:_X,sparse:$Pt,sparseToDense:RUt,spectral:RPt,split:Z1,sqrt:If,square:iu,squaredDifference:NX,squeeze:Q1,stack:Df,step:MX,stridedSlice:tUt,string:LPt,sub:Vn,sum:ai,tan:nUt,tanh:xD,tensor:hh,tensor1d:Qo,tensor2d:Yy,tensor3d:IX,tensor4d:sUt,tensor5d:iUt,tensor6d:rUt,tensorScatterUpdate:lUt,tile:u1,topk:uUt,transpose:SD,truncatedNormal:fUt,unique:pUt,unsortedSegmentSum:gUt,unstack:Kg,upperBound:xUt,variable:vUt,where:qd,whereAsync:DX,zeros:Sx,zerosLike:Al},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nVt=(n,t,e,s=sa)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(B("a",n,t,e),B("b",n,t,e))];case"AddN":return[s.addN(B("tensors",n,t,e))];case"FloorMod":case"Mod":return[s.mod(B("a",n,t,e),B("b",n,t,e))];case"Mul":return[s.mul(B("a",n,t,e),B("b",n,t,e))];case"RealDiv":case"Div":return[s.div(B("a",n,t,e),B("b",n,t,e))];case"DivNoNan":return[s.divNoNan(B("a",n,t,e),B("b",n,t,e))];case"FloorDiv":return[s.floorDiv(B("a",n,t,e),B("b",n,t,e))];case"Sub":return[s.sub(B("a",n,t,e),B("b",n,t,e))];case"Minimum":return[s.minimum(B("a",n,t,e),B("b",n,t,e))];case"Maximum":return[s.maximum(B("a",n,t,e),B("b",n,t,e))];case"Pow":return[s.pow(B("a",n,t,e),B("b",n,t,e))];case"SquaredDifference":return[s.squaredDifference(B("a",n,t,e),B("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sVt=(n,t,e,s=sa)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(B("x",n,t,e))];case"Acos":return[s.acos(B("x",n,t,e))];case"Acosh":return[s.acosh(B("x",n,t,e))];case"Asin":return[s.asin(B("x",n,t,e))];case"Asinh":return[s.asinh(B("x",n,t,e))];case"Atan":return[s.atan(B("x",n,t,e))];case"Atan2":return[s.atan2(B("x",n,t,e),B("y",n,t,e))];case"Atanh":return[s.atanh(B("x",n,t,e))];case"Ceil":return[s.ceil(B("x",n,t,e))];case"Complex":return[s.complex(B("real",n,t,e),B("imag",n,t,e))];case"Cos":return[s.cos(B("x",n,t,e))];case"Cosh":return[s.cosh(B("x",n,t,e))];case"Elu":return[s.elu(B("x",n,t,e))];case"Erf":return[s.erf(B("x",n,t,e))];case"Exp":return[s.exp(B("x",n,t,e))];case"Expm1":return[s.expm1(B("x",n,t,e))];case"Floor":return[s.floor(B("x",n,t,e))];case"Log":return[s.log(B("x",n,t,e))];case"Log1p":return[s.log1p(B("x",n,t,e))];case"Imag":return[s.imag(B("x",n,t,e))];case"Neg":return[s.neg(B("x",n,t,e))];case"Reciprocal":return[s.reciprocal(B("x",n,t,e))];case"Real":return[s.real(B("x",n,t,e))];case"Relu":return[s.relu(B("x",n,t,e))];case"Round":return[s.round(B("x",n,t,e))];case"Selu":return[s.selu(B("x",n,t,e))];case"Sigmoid":return[s.sigmoid(B("x",n,t,e))];case"Sin":return[s.sin(B("x",n,t,e))];case"Sign":return[s.sign(B("x",n,t,e))];case"Sinh":return[s.sinh(B("x",n,t,e))];case"Softplus":return[s.softplus(B("x",n,t,e))];case"Sqrt":return[s.sqrt(B("x",n,t,e))];case"Square":return[s.square(B("x",n,t,e))];case"Tanh":return[s.tanh(B("x",n,t,e))];case"Tan":return[s.tan(B("x",n,t,e))];case"ClipByValue":return[s.clipByValue(B("x",n,t,e),B("clipValueMin",n,t,e),B("clipValueMax",n,t,e))];case"Relu6":return[s.relu6(B("x",n,t,e))];case"Rsqrt":return[s.rsqrt(Zr(n.inputNames[0],t,e))];case"LeakyRelu":return[s.leakyRelu(B("x",n,t,e),B("alpha",n,t,e))];case"Prelu":return[s.prelu(B("x",n,t,e),B("alpha",n,t,e))];case"IsNan":return[s.isNaN(Zr(n.inputNames[0],t,e))];case"IsInf":return[s.isInf(Zr(n.inputNames[0],t,e))];case"IsFinite":return[s.isFinite(Zr(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ac(n,t,e=""){if(!(typeof n=="number"||typeof t=="number")){lt(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let s=0;s<n.length;s++){const i=n[s],r=t[s];lt(i<0||r<0||i===r,()=>e+` Shapes ${n} and ${t} must match`)}}}function oP(n){return!(typeof n=="number"||n.some(t=>t<0))}function Ub(n,t,e){let s=kD(n,e);const i=!oP(s);if(i&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(i&&t.forEach(r=>{s=kD(r.shape,s)}),!oP(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function kD(n,t){if(typeof n=="number")return t;if(typeof t=="number")return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let s=0;s<n.length;++s){const i=n[s],r=t[s];if(i>=0&&r>=0&&i!==r)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[s]=i>=0?i:r}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iVt{constructor(t,e,s,i,r,a,o){this.name=t,this.dtype=e,this.maxSize=s,this.elementShape=i,this.identicalElementShapes=r,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=hs(0),ih(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),ac(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);s.tensor=e,ih(e),s.written=!0,this.tensors[t]=s}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((s,i)=>this.write(s,e[i]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let i=0;i<this.size();i++)t.push(i)}if(t.length===0)return hh([],[0].concat(this.elementShape));const s=this.readMany(t);return ac(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Df(s,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return hh([],[0].concat(this.elementShape));const e=[];for(let i=0;i<this.size();i++)e.push(i);const s=this.readMany(e);return ac(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),Wa(s,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(t,Kg(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let s=0;const i=t.map(l=>(s+=l,s));if(s!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const r=s===0?0:e.size/s,a=[];Jn(()=>{e=oe(e,[1,s,r]);for(let l=0;l<t.length;++l){const h=[0,l===0?0:i[l-1],0],f=[1,t[l],r];a[l]=oe(bs(e,h,f),this.elementShape)}return a});const o=[];for(let l=0;l<t.length;l++)o[l]=l;this.writeMany(o,a)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rg{get id(){return this.idTensor.id}constructor(t,e,s,i=-1){this.tensors=t,this.elementShape=e,this.elementDtype=s,t!=null&&t.forEach(r=>{if(s!==r.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${r.dtype}`);ac(e,r.shape,"TensorList shape mismatch: "),ih(r)}),this.idTensor=hs(0),this.maxNumElements=i,ih(this.idTensor)}copy(){return new Rg([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,s=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);ac(t,this.elementShape,"TensorList shape mismatch: ");const i=Ub(this.elementShape,this.tensors,t);return Jn(()=>{const r=this.tensors.map(a=>oe(a,i));return Df(r,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Ub(this.elementShape,this.tensors,t),i=this.tensors.pop();return i.kept=!1,ac(i.shape,t,"TensorList shape mismatch: "),oe(i,s)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(ac(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ih(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new Rg([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let s=0;s<Math.min(this.tensors.length,t);++s)e.tensors[s]=this.tensors[s];return e}getItem(t,e,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);ac(this.tensors[t].shape,e,"TensorList shape mismatch: ");const i=Ub(this.elementShape,this.tensors,e);return oe(this.tensors[t],i)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);ac(this.elementShape,e.shape,"TensorList shape mismatch: "),ih(e),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,s){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);ac(this.elementShape,s,"TensorList shape mismatch: "),t=t.slice(0,this.size());const i=Ub(this.elementShape,this.tensors,s);return t.length===0?hh([],[0].concat(i)):Jn(()=>{const r=t.map(a=>oe(this.tensors[a],i));return Df(r,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);ac(this.elementShape,e,"TensorList shape mismatch: ");const s=Ub(this.elementShape,this.tensors,e);return this.size()===0?hh([],[0].concat(s)):Jn(()=>{const i=this.tensors.map(r=>oe(r,s));return Wa(i,0)})}}function rVt(n,t,e){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);const i=n.shape.slice(1);ac(i,t,"TensorList shape mismatch: ");const r=Kg(n);return new Rg(r,t,s)}function aVt(n,t,e,s){return new Rg([],n,t,s)}function oVt(n,t,e,s){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const i=Math.max(...t);if(s!=null&&s!==-1&&i>=s)throw new Error(`Max index must be < array size (${i}  vs. ${s})`);const r=new Rg([],e,n.dtype,s),a=Kg(n,0);return t.forEach((o,l)=>{r.setItem(o,a[l])}),r}function lVt(n,t,e){let s=0;const i=t.map(h=>(s+=h,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const r=n.shape.slice(1),a=kD(r,e),o=s===0?0:n.size/s,l=Jn(()=>{const h=[];n=oe(n,[1,s,o]);for(let f=0;f<t.length;++f){const g=[0,f===0?0:i[f-1],0],v=[1,t[f],o];h[f]=oe(bs(n,g,v),a)}return n.dispose(),h}),c=new Rg([],e,n.dtype,t.length);for(let h=0;h<l.length;h++)c.setItem(h,l[h]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cVt=async(n,t,e)=>{switch(n.op){case"If":case"StatelessIf":{const s=B("thenBranch",n,t,e),i=B("elseBranch",n,t,e),r=B("cond",n,t,e),a=B("args",n,t,e);return(await r.data())[0]?e.functionMap[s].executeFunctionAsync(a,e.tensorArrayMap,e.tensorListMap):e.functionMap[i].executeFunctionAsync(a,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{const s=B("body",n,t,e),i=B("cond",n,t,e),r=B("args",n,t,e),a=await e.functionMap[i].executeFunctionAsync(r,e.tensorArrayMap,e.tensorListMap),o=r.map(h=>h.id);let l=await a[0].data();a.forEach(h=>{!h.kept&&o.indexOf(h.id)===-1&&h.dispose()});let c=r;for(;l[0];){const h=c;c=await e.functionMap[s].executeFunctionAsync(c,e.tensorArrayMap,e.tensorListMap);const f=c.map(g=>g.id);h.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()});const p=await e.functionMap[i].executeFunctionAsync(c,e.tensorArrayMap,e.tensorListMap);l=await p[0].data(),p.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()})}return c}case"LoopCond":{const s=B("pred",n,t,e);return[mf(s)]}case"Switch":{const s=B("pred",n,t,e);let i=B("data",n,t,e);return i.kept||(i=mf(i)),(await s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const s=n.inputNames.find(i=>Zr(i,t,e)!==void 0);if(s){const i=Zr(s,t,e);return[mf(i)]}return}case"Enter":{const s=B("frameName",n,t,e),i=B("tensor",n,t,e);return e.enterFrame(s),[mf(i)]}case"Exit":{const s=B("tensor",n,t,e);return e.exitFrame(),[mf(s)]}case"NextIteration":{const s=B("tensor",n,t,e);return e.nextIteration(),[mf(s)]}case"TensorArrayV3":{const s=B("size",n,t,e),i=B("dtype",n,t,e),r=B("elementShape",n,t,e),a=B("dynamicSize",n,t,e),o=B("clearAfterRead",n,t,e),l=B("identicalElementShapes",n,t,e),c=B("name",n,t,e),h=new iVt(c,i,s,r,l,a,o);return e.addTensorArray(h),[h.idTensor,hs(1)]}case"TensorArrayWriteV3":{const s=B("tensorArrayId",n,t,e),i=B("index",n,t,e),r=B("tensor",n,t,e),a=e.getTensorArray(s.id);return a.write(i,r),[a.idTensor]}case"TensorArrayReadV3":{const s=B("tensorArrayId",n,t,e),i=B("index",n,t,e);return[e.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{const s=B("tensorArrayId",n,t,e),i=B("indices",n,t,e),r=B("dtype",n,t,e);return[e.getTensorArray(s.id).gather(i,r)]}case"TensorArrayScatterV3":{const s=B("tensorArrayId",n,t,e),i=B("indices",n,t,e),r=B("tensor",n,t,e),a=e.getTensorArray(s.id);return a.scatter(i,r),[a.idTensor]}case"TensorArrayConcatV3":{const s=B("tensorArrayId",n,t,e),i=e.getTensorArray(s.id),r=B("dtype",n,t,e);return[i.concat(r)]}case"TensorArraySplitV3":{const s=B("tensorArrayId",n,t,e),i=B("tensor",n,t,e),r=B("lengths",n,t,e),a=e.getTensorArray(s.id);return a.split(r,i),[a.idTensor]}case"TensorArraySizeV3":{const s=B("tensorArrayId",n,t,e),i=e.getTensorArray(s.id);return[hs(i.size(),"int32")]}case"TensorArrayCloseV3":{const s=B("tensorArrayId",n,t,e),i=e.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const s=B("tensorListId",n,t,e),i=B("index",n,t,e),r=B("tensor",n,t,e),a=e.getTensorList(s.id);return a.setItem(i,r),[a.idTensor]}case"TensorListGetItem":{const s=B("tensorListId",n,t,e),i=B("index",n,t,e),r=B("elementShape",n,t,e),a=B("elementDType",n,t,e);return[e.getTensorList(s.id).getItem(i,r,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=B("indices",n,t,e),i=B("tensor",n,t,e),r=B("elementShape",n,t,e),a=B("numElements",n,t,e),o=oVt(i,s,r,a);return e.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=B("elementShape",n,t,e),i=B("elementDType",n,t,e);let r;n.op==="TensorListReserve"?r="numElements":r="maxNumElements";const a=B(r,n,t,e),o=n.op==="TensorListReserve"?-1:a,l=aVt(s,i,a,o);return e.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=B("tensorListId",n,t,e),i=B("indices",n,t,e),r=B("elementShape",n,t,e),a=B("elementDType",n,t,e);return[e.getTensorList(s.id).gather(i,a,r)]}case"TensorListStack":{const s=B("tensorListId",n,t,e),i=B("elementShape",n,t,e),r=B("elementDType",n,t,e),a=B("numElements",n,t,e);return[e.getTensorList(s.id).stack(i,r,a)]}case"TensorListFromTensor":{const s=B("tensor",n,t,e),i=B("elementShape",n,t,e),r=B("elementDType",n,t,e),a=rVt(s,i,r);return e.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=B("tensorListId",n,t,e),i=e.getTensorList(s.id),r=B("dtype",n,t,e),a=B("elementShape",n,t,e);return[i.concat(r,a)]}case"TensorListPushBack":{const s=B("tensorListId",n,t,e),i=B("tensor",n,t,e),r=e.getTensorList(s.id);return r.pushBack(i),[r.idTensor]}case"TensorListPopBack":{const s=B("tensorListId",n,t,e),i=B("elementShape",n,t,e),r=B("elementDType",n,t,e);return[e.getTensorList(s.id).popBack(i,r)]}case"TensorListSplit":{const s=B("tensor",n,t,e),i=B("elementShape",n,t,e),r=B("lengths",n,t,e),a=lVt(s,r,i);return e.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=B("tensorListId",n,t,e),i=e.getTensorList(s.id);return[hs(i.size(),"int32")]}case"TensorListResize":{const s=B("tensorListId",n,t,e),i=B("size",n,t,e),a=e.getTensorList(s.id).resize(i);return e.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lP(n,t,e){const[s,i]=B("fusedOps",n,t,e),r=s==="biasadd",a=!r,o=i==="prelu",l=s==="fusedbatchnorm",c=B("numArgs",n,t,e);if(r){if(o&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&r&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const h=B("strides",n,t,e),f=_E(n,t,e),p=B("dataFormat",n,t,e).toUpperCase(),g=B("dilations",n,t,e);let[v,_]=B("args",n,t,e);a&&(_=v,v=void 0);const S=B("leakyreluAlpha",n,t,e);return{stride:h,pad:f,dataFormat:p,dilations:g,biasArg:v,preluArg:_,activationFunc:i,leakyreluAlpha:S}}const uVt=(n,t,e,s=sa)=>{switch(n.op){case"Conv1D":{const i=B("stride",n,t,e),r=B("pad",n,t,e),a=B("dataFormat",n,t,e).toUpperCase(),o=B("dilation",n,t,e);return[s.conv1d(B("x",n,t,e),B("filter",n,t,e),i,r,a,o)]}case"Conv2D":{const i=B("strides",n,t,e),r=_E(n,t,e),a=B("dataFormat",n,t,e).toUpperCase(),o=B("dilations",n,t,e);return[s.conv2d(B("x",n,t,e),B("filter",n,t,e),[i[1],i[2]],r,a,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:i,pad:r,dataFormat:a,dilations:o,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:f}=lP(n,t,e);return[s.fused.conv2d({x:B("x",n,t,e),filter:B("filter",n,t,e),strides:[i[1],i[2]],pad:r,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:f})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:r,dataFormat:a,dilations:o,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:f}=lP(n,t,e);return[s.fused.depthwiseConv2d({x:B("x",n,t,e),filter:B("filter",n,t,e),strides:[i[1],i[2]],pad:r,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=B("outputShape",n,t,e),r=B("strides",n,t,e),a=_E(n,t,e);return[s.conv2dTranspose(B("x",n,t,e),B("filter",n,t,e),i,[r[1],r[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=B("strides",n,t,e),r=_E(n,t,e),a=B("dilations",n,t,e),o=B("dataFormat",n,t,e).toUpperCase();return[s.depthwiseConv2d(B("input",n,t,e),B("filter",n,t,e),[i[1],i[2]],r,o,[a[1],a[2]])]}case"Conv3D":{const i=B("strides",n,t,e),r=B("pad",n,t,e),a=B("dataFormat",n,t,e).toUpperCase(),o=B("dilations",n,t,e);return[s.conv3d(B("x",n,t,e),B("filter",n,t,e),[i[1],i[2],i[3]],r,a,[o[1],o[2],o[3]])]}case"AvgPool":{const i=B("strides",n,t,e),r=B("pad",n,t,e),a=B("kernelSize",n,t,e);return[s.avgPool(B("x",n,t,e),[a[1],a[2]],[i[1],i[2]],r)]}case"MaxPool":{const i=B("strides",n,t,e),r=B("pad",n,t,e),a=B("kernelSize",n,t,e);return[s.maxPool(B("x",n,t,e),[a[1],a[2]],[i[1],i[2]],r)]}case"MaxPoolWithArgmax":{const i=B("strides",n,t,e),r=B("pad",n,t,e),a=B("kernelSize",n,t,e),o=B("includeBatchInIndex",n,t,e),{result:l,indexes:c}=s.maxPoolWithArgmax(B("x",n,t,e),[a[1],a[2]],[i[1],i[2]],r,o);return[l,c]}case"AvgPool3D":{const i=B("strides",n,t,e),r=B("pad",n,t,e),a=B("kernelSize",n,t,e);return[s.avgPool3d(B("x",n,t,e),[a[1],a[2],a[3]],[i[1],i[2],i[3]],r)]}case"MaxPool3D":{const i=B("strides",n,t,e),r=B("pad",n,t,e),a=B("kernelSize",n,t,e);return[s.maxPool3d(B("x",n,t,e),[a[1],a[2],a[3]],[i[1],i[2],i[3]],r)]}case"Dilation2D":{const i=B("strides",n,t,e),r=B("pad",n,t,e),a=B("dilations",n,t,e),o=i[1],l=i[2],c=a[1],h=a[2];return[s.dilation2d(B("x",n,t,e),B("filter",n,t,e),[o,l],r,[c,h],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hVt=(n,t,e,s=sa)=>{switch(n.op){case"Fill":{const i=B("shape",n,t,e),r=B("dtype",n,t,e),a=B("value",n,t,e);return[s.fill(i,a,r)]}case"LinSpace":{const i=B("start",n,t,e),r=B("stop",n,t,e),a=B("num",n,t,e);return[s.linspace(i,r,a)]}case"Multinomial":{const i=B("logits",n,t,e),r=B("numSamples",n,t,e),a=B("seed",n,t,e);return[s.multinomial(i,r,a)]}case"OneHot":{const i=B("indices",n,t,e),r=B("depth",n,t,e),a=B("onValue",n,t,e),o=B("offValue",n,t,e),l=B("dtype",n,t,e);return[s.oneHot(i,r,a,o,l)]}case"Ones":return[s.ones(B("shape",n,t,e),B("dtype",n,t,e))];case"OnesLike":return[s.onesLike(B("x",n,t,e))];case"RandomStandardNormal":return[s.randomStandardNormal(B("shape",n,t,e),B("dtype",n,t,e),B("seed",n,t,e))];case"RandomUniform":return[s.randomUniform(B("shape",n,t,e),B("minval",n,t,e),B("maxval",n,t,e),B("dtype",n,t,e))];case"RandomUniformInt":return[s.randomUniformInt(B("shape",n,t,e),B("minval",n,t,e),B("maxval",n,t,e),B("seed",n,t,e))];case"Range":{const i=B("start",n,t,e),r=B("stop",n,t,e),a=B("step",n,t,e);return[s.range(i,r,a,B("dtype",n,t,e))]}case"TruncatedNormal":{const i=B("shape",n,t,e),r=B("mean",n,t,e),a=B("stdDev",n,t,e),o=B("seed",n,t,e);return[s.truncatedNormal(i,r,a,B("dtype",n,t,e),o)]}case"Zeros":return[s.zeros(B("shape",n,t,e),B("dtype",n,t,e))];case"ZerosLike":return[s.zerosLike(B("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jI(n,t,e){const s=B("boxes",n,t,e),i=B("scores",n,t,e),r=B("maxOutputSize",n,t,e),a=B("iouThreshold",n,t,e),o=B("scoreThreshold",n,t,e),l=B("softNmsSigma",n,t,e);return{boxes:s,scores:i,maxOutputSize:r,iouThreshold:a,scoreThreshold:o,softNmsSigma:l}}const fVt=async(n,t,e,s,i=sa)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=jI(n,t,e),f=await i.image.nonMaxSuppressionWithScoreAsync(r,a,o,l,c,h);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=jI(n,t,e),h=B("padToMaxOutputSize",n,t,e),f=await i.image.nonMaxSuppressionPaddedAsync(r,a,o,l,c,h);return[f.selectedIndices,f.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=jI(n,t,e);return[await i.image.nonMaxSuppressionAsync(r,a,o,l,c)]}case"Where":{const r=i.cast(B("condition",n,t,e),"bool"),a=[await i.whereAsync(r)];return r.dispose(),a}case"ListDiff":return i.setdiff1dAsync(B("x",n,t,e),B("y",n,t,e));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dVt=(n,t,e,s=sa)=>{switch(n.op){case"LowerBound":{const i=B("sortedSequence",n,t,e),r=B("values",n,t,e);return[s.lowerBound(i,r)]}case"TopKV2":{const i=B("x",n,t,e),r=B("k",n,t,e),a=B("sorted",n,t,e),o=s.topk(i,r,a);return[o.values,o.indices]}case"UpperBound":{const i=B("sortedSequence",n,t,e),r=B("values",n,t,e);return[s.upperBound(i,r)]}case"Unique":{const i=B("x",n,t,e),r=s.unique(i);return[r.values,r.indices]}case"UniqueV2":{const i=B("x",n,t,e),r=B("axis",n,t,e),a=s.unique(i,r);return[a.values,a.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pVt=(n,t,e,s=sa)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const i=B("default",n,t,e);return[Zr(n.name,t,e)||i];case"Placeholder":return[Zr(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const h=B("x",n,t,e);return[mf(h)]}case"IdentityN":return B("x",n,t,e).map(h=>mf(h));case"Snapshot":const r=B("x",n,t,e);return[mf(r)];case"Shape":return[s.tensor1d(B("x",n,t,e).shape,"int32")];case"ShapeN":return B("x",n,t,e).map(h=>s.tensor1d(h.shape));case"Size":return[s.scalar(B("x",n,t,e).size,"int32")];case"Rank":return[s.scalar(B("x",n,t,e).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const a=B("x",n,t,e),o=B("data",n,t,e),l=B("message",n,t,e),c=B("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let h=0;h<o.length;h++)console.log(Array.prototype.slice.call(o[h].dataSync()).slice(0,c));return[a];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mVt{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=hs(0),this.tensorMap=new Map,ih(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return hs(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);const s=await t.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),Jn(()=>{const i=Kg(e),r=s.length,a=i.length;lt(r===a,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`);for(let o=0;o<r;o++){const l=s[o],c=i[o];ih(c),this.tensorMap.set(l,c)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);const s=await t.data();return Jn(()=>{const i=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.findWithDefault(a,e);i.push(o)}return Df(i)})}findWithDefault(t,e){const s=this.tensorMap.get(t);return s??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gVt=async(n,t,e,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const i=s.getHashTableHandleByName(n.name);if(i!=null)return[i];{const r=B("keyDType",n,t,e),a=B("valueDType",n,t,e),o=new mVt(r,a);return s.addHashTable(n.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=B("tableHandle",n,t,e,s),r=B("keys",n,t,e),a=B("values",n,t,e);return[await s.getHashTableById(i.id).import(r,a)]}case"LookupTableFind":case"LookupTableFindV2":{const i=B("tableHandle",n,t,e,s),r=B("keys",n,t,e),a=B("defaultValue",n,t,e);return[await s.getHashTableById(i.id).find(r,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=B("tableHandle",n,t,e,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yVt=(n,t,e,s=sa)=>{switch(n.op){case"ResizeBilinear":{const i=B("images",n,t,e),r=B("size",n,t,e),a=B("alignCorners",n,t,e),o=B("halfPixelCenters",n,t,e);return[s.image.resizeBilinear(i,[r[0],r[1]],a,o)]}case"ResizeNearestNeighbor":{const i=B("images",n,t,e),r=B("size",n,t,e),a=B("alignCorners",n,t,e),o=B("halfPixelCenters",n,t,e);return[s.image.resizeNearestNeighbor(i,[r[0],r[1]],a,o)]}case"CropAndResize":{const i=B("image",n,t,e),r=B("boxes",n,t,e),a=B("boxInd",n,t,e),o=B("cropSize",n,t,e),l=B("method",n,t,e),c=B("extrapolationValue",n,t,e);return[s.image.cropAndResize(i,r,a,o,l,c)]}case"ImageProjectiveTransformV3":{const i=B("images",n,t,e),r=B("transforms",n,t,e),a=B("outputShape",n,t,e),o=B("fillValue",n,t,e),l=B("interpolation",n,t,e),c=B("fillMode",n,t,e);return[s.image.transform(i,r,l.toLowerCase(),c.toLowerCase(),o,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xVt=(n,t,e,s=sa)=>{switch(n.op){case"Equal":return[s.equal(B("a",n,t,e),B("b",n,t,e))];case"NotEqual":return[s.notEqual(B("a",n,t,e),B("b",n,t,e))];case"Greater":return[s.greater(B("a",n,t,e),B("b",n,t,e))];case"GreaterEqual":return[s.greaterEqual(B("a",n,t,e),B("b",n,t,e))];case"Less":return[s.less(B("a",n,t,e),B("b",n,t,e))];case"LessEqual":return[s.lessEqual(B("a",n,t,e),B("b",n,t,e))];case"LogicalAnd":return[s.logicalAnd(B("a",n,t,e),B("b",n,t,e))];case"LogicalNot":return[s.logicalNot(B("a",n,t,e))];case"LogicalOr":return[s.logicalOr(B("a",n,t,e),B("b",n,t,e))];case"Select":case"SelectV2":return[s.where(B("condition",n,t,e),B("a",n,t,e),B("b",n,t,e))];case"BitwiseAnd":return[s.bitwiseAnd(B("a",n,t,e),B("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vVt=(n,t,e,s=sa)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(B("a",n,t,e),B("b",n,t,e),B("transposeA",n,t,e),B("transposeB",n,t,e))];case"Einsum":return[s.einsum(B("equation",n,t,e),...B("tensors",n,t,e))];case"Transpose":return[s.transpose(B("x",n,t,e),B("perm",n,t,e))];case"_FusedMatMul":const[i,r]=B("fusedOps",n,t,e),a=i==="biasadd",o=r==="prelu",l=B("numArgs",n,t,e),c=B("leakyreluAlpha",n,t,e);if(a){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[h,f]=B("args",n,t,e);return[s.fused.matMul({a:B("a",n,t,e),b:B("b",n,t,e),transposeA:B("transposeA",n,t,e),transposeB:B("transposeB",n,t,e),bias:h,activation:r,preluActivationWeights:f,leakyreluAlpha:c})];case"MatrixBandPart":return[s.linalg.bandPart(B("a",n,t,e),B("numLower",n,t,e),B("numUpper",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bVt=(n,t,e,s=sa)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(B("x",n,t,e),B("axis",n,t,e),B("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(B("x",n,t,e),B("mean",n,t,e),B("variance",n,t,e),B("offset",n,t,e),B("scale",n,t,e),B("epsilon",n,t,e))];case"FusedBatchNormV3":return[s.batchNorm(B("x",n,t,e),B("mean",n,t,e),B("variance",n,t,e),B("offset",n,t,e),B("scale",n,t,e),B("epsilon",n,t,e))];case"LRN":return[s.localResponseNormalization(B("x",n,t,e),B("radius",n,t,e),B("bias",n,t,e),B("alpha",n,t,e),B("beta",n,t,e))];case"Softmax":return[s.softmax(B("x",n,t,e))];case"LogSoftmax":return[s.logSoftmax(B("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SVt=(n,t,e,s=sa)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:i,outputDenseValues:r}=s.raggedGather(B("paramsNestedSplits",n,t,e),B("paramsDenseValues",n,t,e),B("indices",n,t,e),B("outputRaggedRank",n,t,e));return i.concat(r)}case"RaggedRange":{const{rtNestedSplits:i,rtDenseValues:r}=s.raggedRange(B("starts",n,t,e),B("limits",n,t,e),B("splits",n,t,e));return[i,r]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(B("shape",n,t,e),B("values",n,t,e),B("defaultValue",n,t,e),B("rowPartitionTensors",n,t,e),B("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Vt=(n,t,e,s=sa)=>{switch(n.op){case"Max":{const o=B("axis",n,t,e),l=B("keepDims",n,t,e);return[s.max(B("x",n,t,e),o,l)]}case"Mean":{const o=B("axis",n,t,e),l=B("keepDims",n,t,e);return[s.mean(B("x",n,t,e),o,l)]}case"Min":{const o=B("axis",n,t,e),l=B("keepDims",n,t,e);return[s.min(B("x",n,t,e),o,l)]}case"Sum":{const o=B("axis",n,t,e),l=B("keepDims",n,t,e);return[s.sum(B("x",n,t,e),o,l)]}case"All":{const o=B("axis",n,t,e),l=B("keepDims",n,t,e);return[s.all(B("x",n,t,e),o,l)]}case"Any":{const o=B("axis",n,t,e),l=B("keepDims",n,t,e);return[s.any(B("x",n,t,e),o,l)]}case"ArgMax":{const o=B("axis",n,t,e);return[s.argMax(B("x",n,t,e),o)]}case"ArgMin":{const o=B("axis",n,t,e);return[s.argMin(B("x",n,t,e),o)]}case"Prod":{const o=B("axis",n,t,e),l=B("keepDims",n,t,e);return[s.prod(B("x",n,t,e),o,l)]}case"Cumprod":{const o=B("axis",n,t,e),l=B("exclusive",n,t,e),c=B("reverse",n,t,e);return[s.cumprod(B("x",n,t,e),o,l,c)]}case"Cumsum":{const o=B("axis",n,t,e),l=B("exclusive",n,t,e),c=B("reverse",n,t,e);return[s.cumsum(B("x",n,t,e),o,l,c)]}case"Bincount":const i=B("x",n,t,e),r=B("weights",n,t,e),a=B("size",n,t,e);return[s.bincount(i,r,a)];case"DenseBincount":{const o=B("x",n,t,e),l=B("weights",n,t,e),c=B("size",n,t,e),h=B("binaryOutput",n,t,e);return[s.denseBincount(o,l,c,h)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wVt=(n,t,e,s=sa)=>{switch(n.op){case"ConcatV2":case"Concat":{const i=B("n",n,t,e),r=B("axis",n,t,e);let a=B("tensors",n,t,e);return a=a.slice(0,i),[s.concat(a,r)]}case"Gather":{const i=B("x",n,t,e),r=B("indices",n,t,e);return[s.gather(i,s.cast(r,"int32"),0)]}case"GatherV2":{const i=B("axis",n,t,e),r=B("batchDims",n,t,e),a=B("x",n,t,e),o=B("indices",n,t,e);return[s.gather(a,s.cast(o,"int32"),i,r)]}case"Reverse":{const i=B("dims",n,t,e),r=[];for(let o=0;o<i.length;o++)i[o]&&r.push(o);const a=B("x",n,t,e);return[s.reverse(a,r)]}case"ReverseV2":{const i=B("axis",n,t,e),r=B("x",n,t,e);return[s.reverse(r,i)]}case"Slice":{const i=B("begin",n,t,e),r=B("size",n,t,e);return[s.slice(B("x",n,t,e),i,r)]}case"StridedSlice":{const i=B("begin",n,t,e),r=B("end",n,t,e),a=B("strides",n,t,e),o=B("beginMask",n,t,e),l=B("endMask",n,t,e),c=B("ellipsisMask",n,t,e),h=B("newAxisMask",n,t,e),f=B("shrinkAxisMask",n,t,e),p=B("x",n,t,e);return[s.stridedSlice(p,i,r,a,o,l,c,h,f)]}case"Pack":return Jn(()=>{const i=B("axis",n,t,e),r=B("tensors",n,t,e),a=r[0].shape,o=s.squeeze(r[0]).shape,l=r.map(c=>{const h=Nf(c.shape,a);if(!h&&!Nf(s.squeeze(c).shape,o))throw new Error("the input tensors shape does not match");return h?c:s.reshape(c,a)});return[s.stack(l,i)]});case"Unpack":{const i=B("axis",n,t,e),r=B("tensor",n,t,e);return s.unstack(r,i)}case"Tile":{const i=B("reps",n,t,e);return[s.tile(B("x",n,t,e),i)]}case"Split":case"SplitV":{const i=B("axis",n,t,e),r=B("numOrSizeSplits",n,t,e),a=B("x",n,t,e);return s.split(a,r,i)}case"ScatterNd":{const i=B("indices",n,t,e),r=B("values",n,t,e),a=B("shape",n,t,e);return[s.scatterND(i,r,a)]}case"GatherNd":{const i=B("x",n,t,e),r=B("indices",n,t,e);return[s.gatherND(i,r)]}case"SparseToDense":{const i=B("sparseIndices",n,t,e),r=B("outputShape",n,t,e),a=B("sparseValues",n,t,e),o=B("defaultValue",n,t,e);return[s.sparseToDense(i,a,r,a.dtype===o.dtype?o:s.cast(o,a.dtype))]}case"TensorScatterUpdate":{const i=B("indices",n,t,e),r=B("values",n,t,e),a=B("tensor",n,t,e);return[s.tensorScatterUpdate(a,i,r)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TVt=(n,t,e,s=sa)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:r,emptyRowIndicator:a,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows(B("indices",n,t,e),B("values",n,t,e),B("denseShape",n,t,e),B("defaultValue",n,t,e));return[i,r,a,o]}case"SparseReshape":{const{outputIndices:i,outputShape:r}=s.sparse.sparseReshape(B("inputIndices",n,t,e),B("inputShape",n,t,e),B("newShape",n,t,e));return[i,r]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(B("data",n,t,e),B("indices",n,t,e),B("segmentIds",n,t,e))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(B("data",n,t,e),B("indices",n,t,e),B("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EVt=(n,t,e,s=sa)=>{switch(n.op){case"FFT":return[s.fft(B("x",n,t,e))];case"IFFT":return[s.ifft(B("x",n,t,e))];case"RFFT":return[s.rfft(B("x",n,t,e))];case"IRFFT":return[s.irfft(B("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CVt=(n,t,e,s=sa)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(B("input",n,t,e),B("pattern",n,t,e),B("rewrite",n,t,e),B("replaceGlobal",n,t,e))];case"StringNGrams":{const{nGrams:i,nGramsSplits:r}=s.string.stringNGrams(B("data",n,t,e),B("dataSplits",n,t,e),B("separator",n,t,e),B("nGramWidths",n,t,e),B("leftPad",n,t,e),B("rightPad",n,t,e),B("padWidth",n,t,e),B("preserveShortSequences",n,t,e));return[i,r]}case"StringSplit":{const{indices:i,values:r,shape:a}=s.string.stringSplit(B("input",n,t,e),B("delimiter",n,t,e),B("skipEmpty",n,t,e));return[i,r,a]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(B("input",n,t,e),B("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AVt=(n,t,e,s=sa)=>{switch(n.op){case"Cast":return[s.cast(B("x",n,t,e),B("dtype",n,t,e))];case"ExpandDims":{const i=B("axis",n,t,e);return[s.expandDims(B("x",n,t,e),i)]}case"Squeeze":{const i=B("axis",n,t,e);return[s.squeeze(B("x",n,t,e),i)]}case"Reshape":return[s.reshape(B("x",n,t,e),B("shape",n,t,e))];case"EnsureShape":return[s.ensureShape(B("x",n,t,e),B("shape",n,t,e))];case"MirrorPad":return[s.mirrorPad(B("x",n,t,e),B("padding",n,t,e),B("mode",n,t,e))];case"PadV2":case"Pad":return[s.pad(B("x",n,t,e),B("padding",n,t,e),B("constantValue",n,t,e))];case"SpaceToBatchND":{const i=B("blockShape",n,t,e),r=B("paddings",n,t,e);return[s.spaceToBatchND(B("x",n,t,e),i,r)]}case"BatchToSpaceND":{const i=B("blockShape",n,t,e),r=B("crops",n,t,e);return[s.batchToSpaceND(B("x",n,t,e),i,r)]}case"DepthToSpace":{const i=B("blockSize",n,t,e),r=B("dataFormat",n,t,e).toUpperCase();return[s.depthToSpace(B("x",n,t,e),i,r)]}case"BroadcastTo":return[s.broadcastTo(B("x",n,t,e),B("shape",n,t,e))];case"BroadcastArgs":return[s.broadcastArgs(B("s0",n,t,e),B("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cP(n,t,e,s,i=Jn){const r=((a,o,l)=>{switch(a.category){case"arithmetic":return i(()=>nVt(a,o,l));case"basic_math":return i(()=>sVt(a,o,l));case"control":return cVt(a,o,l);case"convolution":return i(()=>uVt(a,o,l));case"creation":return i(()=>hVt(a,o,l));case"dynamic":return fVt(a,o,l);case"evaluation":return i(()=>dVt(a,o,l));case"image":return i(()=>yVt(a,o,l));case"graph":return i(()=>pVt(a,o,l));case"logical":return i(()=>xVt(a,o,l));case"matrices":return i(()=>vVt(a,o,l));case"normalization":return i(()=>bVt(a,o,l));case"ragged":return i(()=>SVt(a,o,l));case"reduction":return i(()=>_Vt(a,o,l));case"slice_join":return i(()=>wVt(a,o,l));case"sparse":return i(()=>TVt(a,o,l));case"spectral":return i(()=>EVt(a,o,l));case"string":return i(()=>CVt(a,o,l));case"transformation":return i(()=>AVt(a,o,l));case"hash_table":return gVt(a,o,l,s);case"custom":const c=GX(a.op);if(c&&c.customExecutor)return c.customExecutor(new eVt(a,o,l));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return Tg(r)?r.then(a=>[].concat(a)):[].concat(r)}class uP{constructor(t={},e={},s={},i={},r){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=s,this.functionMap=i,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const s=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(s))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hP(n,t,e,s){const i=new Set,r=[];let a=null,o=null;const l=new Set,c=new Set(Object.keys(n).map(p=>qo(p)[0]));s=s||[];const h=new Set(s.map(p=>qo(p.name)[0])),f=[...t];for(;f.length>0;){const p=f.pop();if((Pm(p)||$Vt(p)||LVt(p))&&a==null&&(a=p,o=a.children.map(g=>g.name).filter(g=>i.has(g))),i.add(p.name),e[p.name]==null&&!c.has(p.name)&&!h.has(p.name)){if(p.inputs.length===0){r.push(p.name);continue}p.inputs.forEach(g=>{l.has(g.name)||(l.add(g.name),f.push(g))})}}return{inputs:n,outputs:t,usedNodes:i,missingInputs:r,dynamicNode:a,syncInputs:o}}function NVt(n,t){const{usedNodes:e,inputs:s}=t,i=Object.keys(s).map(S=>qo(S)[0]).map(S=>n.nodes[S]),r=n.initNodes||[],a=S=>e.has(typeof S=="string"?S:S.name);function o(S){return[...new Map(S.map(b=>[b.name,b])).values()]}const l=o([...i,...n.weights,...r]).filter(a),c=o([...l,...Object.values(n.nodes)]).filter(a),h=new Map(c.map(S=>[S.name,S])),f={};for(const S of c){f[S.name]=f[S.name]||0;for(const b of S.children)a(b)||(f[b.name]=Number.POSITIVE_INFINITY),f[b.name]=(f[b.name]||0)+1}const p=Object.entries(f).filter(([,S])=>S===0).map(([S])=>S),g=[...p];for(;p.length>0;){const S=p.pop(),b=h.get(S);for(const T of b.children.filter(a))--f[T.name]===0&&(g.push(T.name),p.push(T.name))}const v=g.map(S=>h.get(S)),_=MVt(v,l);return IVt(_,l),_}function MVt(n,t){const e=new Map(n.map(a=>[a.name,a])),s=t.map(a=>a.name),i=new Set(s);for(;s.length>0;){const a=s.pop(),o=e.get(a);for(const l of o.children)!e.has(l.name)||i.has(l.name)||(i.add(l.name),s.push(l.name))}return n.filter(a=>i.has(a.name))}class nE extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}function IVt(n,t){const e=new Map(n.map((o,l)=>[o.name,l])),s=new Set(t.map(o=>o.name)),i=o=>s.has(typeof o=="string"?o:o.name),r=new Set(n.map(o=>o.name)),a=o=>r.has(typeof o=="string"?o:o.name);for(const o of n){for(const l of o.children.filter(a)){if(!e.has(l.name))throw new nE(`Child ${l.name} of node ${o.name} is unreachable.`);if(e.get(o.name)>e.get(l.name))throw new nE(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!i(o))for(const l of o.inputs){if(!e.has(l.name))throw new nE(`Input ${l.name} of node ${o.name} is unreachable.`);if(e.get(l.name)>e.get(o.name))throw new nE(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function RVt(n){const t=new Map(n.map((o,l)=>[o.name,l])),e=Number.MAX_SAFE_INTEGER,s=n.map((o,l)=>Pm(o)?e:l),i=o=>{const l=s[t.get(o.name)];return l??-1},r=n.map((o,l)=>o.children.map(i).reduce((c,h)=>Math.max(c,h),s[l])),a=new Map;for(let o=0;o<n.length;++o){const l=r[o];if(l===e)continue;const c=n[o],h=n[l];a.has(h.name)||a.set(h.name,[]),a.get(h.name).push(c)}return a}const DVt=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),kVt=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),OVt=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Pm(n){return DVt.has(n.op)}function $Vt(n){return kVt.has(n.op)}function LVt(n){return OVt.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iC{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(s=>t[s].map(i=>i.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(s=>{this._functionExecutorMap[s]=new iC(t.functions[s],this)})}getCompilationKey(t,e){const s=t.map(r=>r.name).sort(),i=e.map(r=>r.name).sort();return s.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(t,e){const s=hP(t,e,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:r,syncInputs:a}=s;if(r!=null)throw new Error(`This execution contains the node '${r.name}', which has the dynamic op '${r.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(i.length>0){const c=e.map(f=>f.name),h=Object.keys(t);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${h}]. Missing the following inputs: [${i}]`)}const o=NVt(this.graph,s),l=RVt(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;const e=t.clone();return ih(e),e}cloneTensorList(t){return t?t.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,s])=>[e,this.cloneTensorList(s)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const s=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const i=s.map(p=>this.graph.nodes[qo(p)[0]]),r=e.map(p=>qo(p)[0]),a=new Set(r);let o=r.map(p=>this.graph.nodes[p]);o.length===0&&(o=this._outputs);const l=this.getCompilationKey(i,o);let c=this.compiledMap.get(l);c==null&&(c=this.compile(t,o),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=An().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const h={},f={};return Jn(()=>{const p=new uP(this.weightMap,h,f,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(b=>{const[T,C]=qo(b,p),A=[];A[C]=t[b],g[T]=A,this.keepIntermediateTensors&&(this.clonedTensorsMap[T]=this.cloneTensorList(A))});const v=this.getFrozenTensorIds(g),{orderedNodes:_,nodeLiveUntilMap:S}=c;for(const b of _){if(g[b.name])continue;const T=cP(b,g,p,this._resourceManager);if(Tg(T))throw new Error(`The execution of the op '${b.op}' returned a promise. Please use model.executeAsync() instead.`);g[b.name]=T,this.keepIntermediateTensors&&(this.clonedTensorsMap[b.name]=this.cloneTensorList(T)),this.checkTensorForDisposalWithNodeLiveUntilInfo(b,g,p,v,a,S.get(b.name))}return this.parent==null&&p.dispose(v),e.map(b=>Zr(b,g,p))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(s=>t[s]).map(s=>s.map(i=>i.id)));return new Set(e)}checkTensorForDisposal(t,e,s,i,r,a,o){if(!(Pm(e)||a.has(t))){for(const l of s[t])l!=null&&(o[l.id]=(o[l.id]||0)+e.children.length);for(const l of e.inputs){if(Pm(l))continue;const c=iP(l.name,s,i);if(c!=null)for(const h of c){if(!h||h.kept||r.has(h.id))continue;const f=o[h.id];f===1?(h.dispose(),delete o[h.id]):f!=null&&o[h.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,s,i,r,a){function o(l){return Pm(l)||r.has(l.name)}if(!(Pm(t)||a==null))for(const l of a){if(o(l))continue;const c=iP(l.name,e,s);for(const h of c)!h||h.kept||i.has(h.id)||h.dispose()}}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,e,s=!1,i={},r={}){this.disposeIntermediateTensors(),s||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepIntermediateTensors=An().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const a=new uP(this.weightMap,i,r,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(t,a,e,s),l=e.map(p=>Zr(p,o,a)),c=l.map(p=>p.id),h=Object.keys(t).map(p=>t[p].id),f=new Set([...c,...h,...this.weightIds]);return Object.values(o).forEach(p=>{p.forEach(g=>{g&&!g.isDisposed&&!f.has(g.id)&&g.dispose()})}),this.parent==null&&a.dispose(f),l}async executeFunctionAsync(t,e,s){const i=t.reduce((r,a,o)=>(r[this.inputs[o].name]=a,r),{});return this._executeAsync(i,this.outputNodes,!0,e,s)}async executeWithControlFlow(t,e,s,i){const r=Object.keys(t),a=r.map(A=>this.graph.nodes[qo(A)[0]]),o=s.map(A=>qo(A)[0]),l=new Set(o);let c=o.map(A=>this.graph.nodes[A]);c.length===0&&(c=this._outputs);const{usedNodes:h,missingInputs:f,dynamicNode:p,syncInputs:g}=hP(t,c,this.weightMap,this._initNodes),v=[...a,...this.graph.weights,...this._initNodes||[]].map(A=>({node:A,contexts:e.currentContext})),_=Object.assign({},this.weightMap);Object.keys(t).forEach(A=>{const[I,D]=qo(A),F=[];F[D]=t[A],_[I]=F});const S={},b=this.getFrozenTensorIds(_),T={};for(;v.length>0;){const A=this.processStack(a,v,e,_,T,b,l,S,h);await Promise.all(A)}p==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const C=c.filter(A=>!Pm(A)&&!Zr(A.name,_,e)).map(A=>A.name);if(C.length>0){let A="";throw p!=null&&(A=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${C}] from the provided inputs [${r}]. Consider providing the following inputs: [${f}]. ${A}`)}return _}processStack(t,e,s,i,r,a,o,l,c){const h=[];for(;e.length>0;){const f=e.pop();s.currentContext=f.contexts;let p="";if(f.node.op==="Enter"&&B("isConstant",f.node,i,s)&&([p]=pf(f.node.name,s)),i[f.node.name]==null){const g=cP(f.node,i,s,this._resourceManager);p||([p]=pf(f.node.name,s));const v=s.currentContext;Tg(g)?h.push(g.then(_=>(i[p]=_,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(_)),s.currentContext=v,this.checkTensorForDisposal(p,f.node,i,s,a,o,l),this.processChildNodes(f.node,e,s,i,r,c),_))):(i[p]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(g)),this.checkTensorForDisposal(p,f.node,i,s,a,o,l),this.processChildNodes(f.node,e,s,i,r,c))}else this.processChildNodes(f.node,e,s,i,r,c)}return h}processChildNodes(t,e,s,i,r,a){t.children.forEach(o=>{const[l]=pf(o.name,s);r[l]||!a.has(o.name)||(o.op==="Merge"?o.inputNames.some(c=>!!Zr(c,i,s))&&(r[l]=!0,e.push({contexts:s.currentContext,node:o})):o.inputNames.every(c=>!!Zr(c,i,s))&&(r[l]=!0,e.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const s=t[e],[i]=qo(e),r=this.graph.nodes[i];if(r.attrParams.shape&&r.attrParams.shape.value){const a=r.attrParams.shape.value,o=a.length===s.shape.length&&s.shape.every((l,c)=>a[c]===-1||a[c]===l);lt(o,()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${a}], but was [${s.shape}]`)}r.attrParams.dtype&&r.attrParams.dtype.value&&lt(s.dtype===r.attrParams.dtype.value,()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(t){var e,s;const i={};for(const r in t){const a=(s=(e=this._signature)===null||e===void 0?void 0:e.inputs)===null||s===void 0?void 0:s[r];a!=null?i[a.name]=t[r]:i[r]=t[r]}return i}checkInputs(t){const e=Object.keys(t).filter(s=>{const[i]=qo(s);return this.graph.nodes[i]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var s,i;const r=(i=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||i===void 0?void 0:i[e];return r!=null?r.name:e},{})}checkOutputs(t){t.forEach(e=>{const[s]=qo(e);if(!this.graph.nodes[s])throw new Error(`The output '${e}' is not found in the graph`)})}}class FVt{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zVt="?tfjs-format=file",UVt="model.json";class BVt{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},s=VX){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=s,e==null&&(this.loadOptions={}),this.resourceManager=new FVt}findIOHandler(){const t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(e.length===0)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return Tg(t)?t.then(e=>e.getWeightStream==null?this.loadSync(e):this.loadStreaming(e)):this.loadSync(t)}loadSync(t){const e=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,e)}async loadStreaming(t){if(t.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const e=await Gq(t.getWeightStream(),t.weightSpecs);return this.loadWithWeightMap(t,e)}loadWithWeightMap(t,e){this.artifacts=t;const s=this.artifacts.modelTopology;let i=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const r=this.artifacts.userDefinedMetadata;r.signature!=null&&(i=r.signature),r.structuredOutputKeys!=null&&(this.structuredOutputKeys=r.structuredOutputKeys)}if(this.signature=i,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new iC(rP.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(e),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){const r=rP.Instance.transformGraph(t.modelInitializer);this.initializer=new iC(r),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,e){if(typeof t=="string"){const s=this.io.getSaveHandlers(t);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const e=t instanceof Kr?[t]:t,s={};return e.forEach((i,r)=>s[this.structuredOutputKeys[r]]=i),s}return t}predict(t,e){const s=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(t,e){const s=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(t){var e;if(!(t instanceof Kr)&&!Array.isArray(t)){const r=(e=this.signature)===null||e===void 0?void 0:e.inputs;if(r!=null)for(const a in r){const o=r[a];o.resourceId!=null&&(t[a]=this.resourceIdToCapturedInput[o.resourceId])}return t}t=Array.isArray(t)?t:[t];const s=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${t.length} input tensors provided.`);let i=0;return this.inputNodes.reduce((r,a)=>{var o,l,c;const h=(c=(l=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||l===void 0?void 0:l[a])===null||c===void 0?void 0:c.resourceId;return h!=null?r[a]=this.resourceIdToCapturedInput[h]:r[a]=t[i++],r},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,s=Object.keys(e);for(let i=0;i<s.length;i++){const r=s[i],a=e[r];this.resourceIdToCapturedInput[a.resourceId]=t[i]}}}execute(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const s=this.executor.execute(t,e);return s.length>1?s:s[0]}async executeAsync(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const s=await this.executor.executeAsync(t,e);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,s)=>(e[s]=[t[s]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&wo(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function qX(n,t={},e=VX){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof n=="string"&&(n=PVt(n));const s=new BVt(n,t,e);return await s.load(),s}function PVt(n){return n.endsWith("/")||(n=n+"/"),`${n}${UVt}${zVt}`}/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */function rp(n,t,e,s){return new(e||(e=Promise))((function(i,r){function a(c){try{l(s.next(c))}catch(h){r(h)}}function o(c){try{l(s.throw(c))}catch(h){r(h)}}function l(c){var h;c.done?i(c.value):(h=c.value,h instanceof e?h:new e((function(f){f(h)}))).then(a,o)}l((s=s.apply(n,[])).next())}))}function ap(n,t){var e,s,i,r,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return r={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(r[Symbol.iterator]=function(){return this}),r;function o(l){return function(c){return(function(h){if(e)throw new TypeError("Generator is already executing.");for(;r&&(r=0,h[0]&&(a=0)),a;)try{if(e=1,s&&(i=2&h[0]?s.return:h[0]?s.throw||((i=s.return)&&i.call(s),0):s.next)&&!(i=i.call(s,h[1])).done)return i;switch(s=0,i&&(h=[2&h[0],i.value]),h[0]){case 0:case 1:i=h;break;case 4:return a.label++,{value:h[1],done:!1};case 5:a.label++,s=h[1],h=[0];continue;case 7:h=a.ops.pop(),a.trys.pop();continue;default:if(i=a.trys,!((i=i.length>0&&i[i.length-1])||h[0]!==6&&h[0]!==2)){a=0;continue}if(h[0]===3&&(!i||h[1]>i[0]&&h[1]<i[3])){a.label=h[1];break}if(h[0]===6&&a.label<i[1]){a.label=i[1],i=h;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(h);break}i[2]&&a.ops.pop(),a.trys.pop();continue}h=t.call(n,a)}catch(f){h=[6,f],s=0}finally{e=i=0}if(5&h[0])throw h[1];return{value:h[0]?h[1]:void 0,done:!0}})([l,c])}}}function Iy(n,t,e){if(e||arguments.length===2)for(var s,i=0,r=t.length;i<r;i++)!s&&i in t||(s||(s=Array.prototype.slice.call(t,0,i)),s[i]=t[i]);return n.concat(s||Array.prototype.slice.call(t))}function B$(n){return[Math.abs(n.endPoint[0]-n.startPoint[0]),Math.abs(n.endPoint[1]-n.startPoint[1])]}function rC(n){return[n.startPoint[0]+(n.endPoint[0]-n.startPoint[0])/2,n.startPoint[1]+(n.endPoint[1]-n.startPoint[1])/2]}function fP(n,t){t===void 0&&(t=1.5);var e=rC(n),s=B$(n),i=[t*s[0]/2,t*s[1]/2];return{startPoint:[e[0]-i[0],e[1]-i[1]],endPoint:[e[0]+i[0],e[1]+i[1]],palmLandmarks:n.palmLandmarks}}function dP(n){var t=rC(n),e=B$(n),s=Math.max.apply(Math,e)/2;return{startPoint:[t[0]-s,t[1]-s],endPoint:[t[0]+s,t[1]+s],palmLandmarks:n.palmLandmarks}}function pP(n,t){var e=[n.endPoint[0]-n.startPoint[0],n.endPoint[1]-n.startPoint[1]],s=[e[0]*t[0],e[1]*t[1]];return{startPoint:[n.startPoint[0]+s[0],n.startPoint[1]+s[1]],endPoint:[n.endPoint[0]+s[0],n.endPoint[1]+s[1]],palmLandmarks:n.palmLandmarks}}var VVt=(function(){function n(t,e,s,i,r,a){this.model=t,this.width=e,this.height=s,this.iouThreshold=r,this.scoreThreshold=a,this.anchors=i.map((function(o){return[o.x_center,o.y_center]})),this.anchorsTensor=Yy(this.anchors),this.inputSizeTensor=Qo([e,s]),this.doubleInputSizeTensor=Qo([2*e,2*s])}return n.prototype.normalizeBoxes=function(t){var e=this;return Jn((function(){var s=bs(t,[0,0],[-1,2]),i=bs(t,[0,2],[-1,2]),r=yn(ks(s,e.inputSizeTensor),e.anchorsTensor),a=ks(i,e.doubleInputSizeTensor),o=Re(Vn(r,a),e.inputSizeTensor),l=Re(yn(r,a),e.inputSizeTensor);return iX([o,l],1)}))},n.prototype.normalizeLandmarks=function(t,e){var s=this;return Jn((function(){var i=yn(ks(oe(t,[-1,7,2]),s.inputSizeTensor),s.anchors[e]);return Re(i,s.inputSizeTensor)}))},n.prototype.getBoundingBoxes=function(t){return rp(this,void 0,void 0,(function(){var e,s,i,r,a,o,l,c,h,f,p,g,v,_,S,b=this;return ap(this,(function(T){switch(T.label){case 0:return e=Jn((function(){return Re(Vn(t,.5),2)})),b$()==="webgl"?(i=An().get("WEBGL_PACK_DEPTHWISECONV"),An().set("WEBGL_PACK_DEPTHWISECONV",!0),s=this.model.predict(e),An().set("WEBGL_PACK_DEPTHWISECONV",i)):s=this.model.predict(e),r=Q1(s),a=Jn((function(){return Q1(sg(bs(r,[0,0],[-1,1])))})),o=bs(r,[0,1],[-1,4]),l=this.normalizeBoxes(o),c=console.warn,console.warn=function(){},h=J1.nonMaxSuppression(l,a,1,this.iouThreshold,this.scoreThreshold),console.warn=c,[4,h.array()];case 1:return f=T.sent(),p=[e,s,h,r,l,o,a],f.length===0?(p.forEach((function(C){return C.dispose()})),[2,null]):(g=f[0],v=bs(l,[g,0],[1,-1]),_=bs(r,[g,5],[1,14]),S=Jn((function(){return oe(b.normalizeLandmarks(_,g),[-1,2])})),p.push(_),p.forEach((function(C){return C.dispose()})),[2,{boxes:v,palmLandmarks:S}])}}))}))},n.prototype.estimateHandBounds=function(t){return rp(this,void 0,void 0,(function(){var e,s,i,r,a,o,l,c,h=this;return ap(this,(function(f){switch(f.label){case 0:return e=t.shape[1],s=t.shape[2],i=Jn((function(){return ks(J1.resizeBilinear(t,[h.width,h.height]),255)})),[4,this.getBoundingBoxes(i)];case 1:return(r=f.sent())===null?(i.dispose(),[2,null]):(a=r.boxes.arraySync(),o=a[0].slice(0,2),l=a[0].slice(2,4),c=r.palmLandmarks.arraySync(),i.dispose(),r.boxes.dispose(),r.palmLandmarks.dispose(),[2,(p={startPoint:o,endPoint:l,palmLandmarks:c},g=[s/this.width,e/this.height],{startPoint:[p.startPoint[0]*g[0],p.startPoint[1]*g[1]],endPoint:[p.endPoint[0]*g[0],p.endPoint[1]*g[1]],palmLandmarks:p.palmLandmarks.map((function(v){return[v[0]*g[0],v[1]*g[1]]}))})])}var p,g}))}))},n})(),KI={thumb:[1,2,3,4],indexFinger:[5,6,7,8],middleFinger:[9,10,11,12],ringFinger:[13,14,15,16],pinky:[17,18,19,20],palmBase:[0]};function GVt(n,t){var e,s=Math.PI/2-Math.atan2(-(t[1]-n[1]),t[0]-n[0]);return(e=s)-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}var mP=function(n,t){return[[1,0,n],[0,1,t],[0,0,1]]};function Ym(n,t){for(var e=0,s=0;s<n.length;s++)e+=n[s]*t[s];return e}function HVt(n,t){for(var e=[],s=0;s<n.length;s++)e.push(n[s][t]);return e}function gP(n,t){for(var e=[],s=n.length,i=0;i<s;i++){e.push([]);for(var r=0;r<s;r++)e[i].push(Ym(n[i],HVt(t,r)))}return e}function yP(n,t){var e=Math.cos(n),s=Math.sin(n),i=[[e,-s,0],[s,e,0],[0,0,1]],r=gP(mP(t[0],t[1]),i);return gP(r,mP(-t[0],-t[1]))}function xP(n,t){return[Ym(n,t[0]),Ym(n,t[1])]}var WVt=[0,-.4],qVt=[0,-.1],vP=[0,5,9,13,17,1,2],XVt=(function(){function n(t,e,s,i,r,a){this.boundingBoxDetector=t,this.meshDetector=e,this.meshWidth=s,this.meshHeight=i,this.maxContinuousChecks=r,this.detectionConfidence=a,this.regionsOfInterest=[],this.runsWithoutHandDetector=0,this.maxHandsNumber=1}return n.prototype.getBoxForPalmLandmarks=function(t,e){var s=t.map((function(i){return xP(Iy(Iy([],i,!0),[1],!1),e)}));return fP(dP(pP(this.calculateLandmarksBoundingBox(s),WVt)),3)},n.prototype.getBoxForHandLandmarks=function(t){for(var e=fP(dP(pP(this.calculateLandmarksBoundingBox(t),qVt)),1.65),s=[],i=0;i<vP.length;i++)s.push(t[vP[i]].slice(0,2));return e.palmLandmarks=s,e},n.prototype.transformRawCoords=function(t,e,s,i){var r,a,o,l,c=this,h=B$(e),f=[h[0]/this.meshWidth,h[1]/this.meshHeight],p=t.map((function(T){return[f[0]*(T[0]-c.meshWidth/2),f[1]*(T[1]-c.meshHeight/2),T[2]]})),g=yP(s,[0,0]),v=p.map((function(T){return Iy(Iy([],xP(T,g),!0),[T[2]],!1)})),_=(a=[[(r=i)[0][0],r[1][0]],[r[0][1],r[1][1]]],o=[r[0][2],r[1][2]],l=[-Ym(a[0],o),-Ym(a[1],o)],[a[0].concat(l[0]),a[1].concat(l[1]),[0,0,1]]),S=Iy(Iy([],rC(e),!0),[1],!1),b=[Ym(S,_[0]),Ym(S,_[1])];return v.map((function(T){return[T[0]+b[0],T[1]+b[1],T[2]]}))},n.prototype.estimateHand=function(t){return rp(this,void 0,void 0,(function(){var e,s,i,r,a,o,l,c,h,f,p,g,v,_,S,b,T,C,A,I;return ap(this,(function(D){switch(D.label){case 0:return(e=this.shouldUpdateRegionsOfInterest())!==!0?[3,2]:[4,this.boundingBoxDetector.estimateHandBounds(t)];case 1:return(s=D.sent())===null?(t.dispose(),this.regionsOfInterest=[],[2,null]):(this.updateRegionsOfInterest(s,!0),this.runsWithoutHandDetector=0,[3,3]);case 2:this.runsWithoutHandDetector++,D.label=3;case 3:return i=this.regionsOfInterest[0],r=GVt(i.palmLandmarks[0],i.palmLandmarks[2]),a=rC(i),o=[a[0]/t.shape[2],a[1]/t.shape[1]],l=J1.rotateWithOffset(t,r,0,o),c=yP(-r,a),h=e===!0?this.getBoxForPalmLandmarks(i.palmLandmarks,c):i,f=(function(F,z,k){var O=z.shape[1],L=z.shape[2],H=[[F.startPoint[1]/O,F.startPoint[0]/L,F.endPoint[1]/O,F.endPoint[0]/L]];return J1.cropAndResize(z,H,[0],k)})(h,l,[this.meshWidth,this.meshHeight]),p=ks(f,255),f.dispose(),l.dispose(),b$()==="webgl"?(v=An().get("WEBGL_PACK_DEPTHWISECONV"),An().set("WEBGL_PACK_DEPTHWISECONV",!0),g=this.meshDetector.predict(p),An().set("WEBGL_PACK_DEPTHWISECONV",v)):g=this.meshDetector.predict(p),_=g[0],S=g[1],p.dispose(),b=_.dataSync()[0],_.dispose(),b<this.detectionConfidence?(S.dispose(),this.regionsOfInterest=[],[2,null]):(T=oe(S,[-1,3]),C=T.arraySync(),S.dispose(),T.dispose(),A=this.transformRawCoords(C,h,r,c),I=this.getBoxForHandLandmarks(A),this.updateRegionsOfInterest(I,!1),[2,{landmarks:A,handInViewConfidence:b,boundingBox:{topLeft:I.startPoint,bottomRight:I.endPoint}}])}}))}))},n.prototype.calculateLandmarksBoundingBox=function(t){var e=t.map((function(i){return i[0]})),s=t.map((function(i){return i[1]}));return{startPoint:[Math.min.apply(Math,e),Math.min.apply(Math,s)],endPoint:[Math.max.apply(Math,e),Math.max.apply(Math,s)]}},n.prototype.updateRegionsOfInterest=function(t,e){if(e)this.regionsOfInterest=[t];else{var s=this.regionsOfInterest[0],i=0;if(s!=null&&s.startPoint!=null){var r=t.startPoint,a=r[0],o=r[1],l=t.endPoint,c=l[0],h=l[1],f=s.startPoint,p=f[0],g=f[1],v=s.endPoint,_=v[0],S=v[1],b=Math.max(a,p),T=Math.max(o,g),C=(Math.min(c,_)-b)*(Math.min(h,S)-T);i=C/((c-a)*(h-o)+(_-p)*(S-o)-C)}this.regionsOfInterest[0]=i>.8?s:t}},n.prototype.shouldUpdateRegionsOfInterest=function(){return this.regionsOfInterest.length!==this.maxHandsNumber||this.runsWithoutHandDetector>=this.maxContinuousChecks},n})();function jVt(){return rp(this,void 0,void 0,(function(){return ap(this,(function(n){return[2,qX("https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1",{fromTFHub:!0})]}))}))}function KVt(){return rp(this,void 0,void 0,(function(){return ap(this,(function(n){return[2,qX("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1",{fromTFHub:!0})]}))}))}function YVt(){return rp(this,void 0,void 0,(function(){return ap(this,(function(n){return[2,X3t("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1/anchors.json?tfjs-format=file").then((function(t){return t.json()}))]}))}))}function ZVt(n){var t={},e=t.maxContinuousChecks,s=e===void 0?1/0:e,i=t.detectionConfidence,r=i===void 0?.8:i,a=t.iouThreshold,o=a===void 0?.3:a,l=t.scoreThreshold,c=l===void 0?.5:l;return rp(this,void 0,void 0,(function(){var h,f,p,g,v,_;return ap(this,(function(S){switch(S.label){case 0:return[4,Promise.all([YVt(),jVt(),KVt()])];case 1:return h=S.sent(),f=h[0],p=h[1],g=h[2],v=new VVt(p,256,256,f,o,c),_=new XVt(v,g,256,256,s,r),[2,new QVt(_)]}}))}))}var QVt=(function(){function n(t){this.pipeline=t}return n.getAnnotations=function(){return KI},n.prototype.estimateHands=function(t,e){return e===void 0&&(e=!1),rp(this,void 0,void 0,(function(){var s,i,r,a,o,l,c,h,f;return ap(this,(function(p){switch(p.label){case 0:return s=(function(g){return g instanceof Kr?[g.shape[0],g.shape[1]]:[g.height,g.width]})(t),i=s[1],r=Jn((function(){return t instanceof Kr||(t=d4t(t)),df(qi(t,"float32"))})),[4,this.pipeline.estimateHand(r)];case 1:if(a=p.sent(),r.dispose(),a===null)return[2,[]];for(o=a,e===!0&&(o=(function(g,v){var _=g.handInViewConfidence,S=g.landmarks,b=g.boundingBox;return{handInViewConfidence:_,landmarks:S.map((function(T){return[v-1-T[0],T[1],T[2]]})),boundingBox:{topLeft:[v-1-b.topLeft[0],b.topLeft[1]],bottomRight:[v-1-b.bottomRight[0],b.bottomRight[1]]}}})(a,i)),l={},c=0,h=Object.keys(KI);c<h.length;c++)f=h[c],l[f]=KI[f].map((function(g){return o.landmarks[g]}));return[2,[{handInViewConfidence:o.handInViewConfidence,boundingBox:o.boundingBox,landmarks:o.landmarks,annotations:l}]]}}))}))},n})();const JVt=({onStateChange:n,currentState:t,onPhotoUpload:e,onManualInteract:s,photoCount:i})=>{const[r,a]=be.useState(!1),[o,l]=be.useState(!1),[c,h]=be.useState(0),[f,p]=be.useState(!1),[g,v]=be.useState(!1),_=be.useRef(null),S=be.useRef(0),b=be.useRef(null),T=be.useRef(null),C=()=>{if(!T.current){v(!0),T.current=new Audio("./3311088699.aac"),T.current.loop=!0,T.current.volume=.8,T.current.addEventListener("canplaythrough",()=>{v(!1),T.current&&T.current.play().then(()=>p(!0)).catch(z=>{console.error("Autoplay prevented:",z),p(!1)})}),T.current.load();return}f?(T.current.pause(),p(!1)):(T.current.play().catch(z=>console.error("Play failed:",z)),p(!0))},A=z=>{z.target.files&&z.target.files.length>0&&e(z.target.files)},I=async()=>{if(!b.current)try{await Zrt();const z=await ZVt();b.current=z,l(!0),console.log("Handpose model loaded")}catch(z){console.error("Failed to load handpose",z);return}D(b.current)},D=async z=>{if(typeof _.current<"u"&&_.current!==null&&_.current.video&&_.current.video.readyState===4){const k=_.current.video,O=_.current.video.videoWidth,L=_.current.video.videoHeight;_.current.video.width=O,_.current.video.height=L;const H=await z.estimateHands(k);if(H.length>0){const q=H[0].landmarks,[K,Y]=q[0],P=1-K/O,W=Y/L,j=new MouseEvent("mousemove",{clientX:P*window.innerWidth,clientY:W*window.innerHeight,bubbles:!0});window.dispatchEvent(j);const st=q[0],ot=q[12],X=q[9],it=Math.sqrt(Math.pow(ot[0]-st[0],2)+Math.pow(ot[1]-st[1],2)),ct=Math.sqrt(Math.pow(X[0]-st[0],2)+Math.pow(X[1]-st[1],2)),yt=it/ct;h(yt),yt>1.5?s(!0):yt<1.35&&s(!1)}}S.current=requestAnimationFrame(()=>D(z))},F=()=>{const z=!r;a(z),z?setTimeout(()=>{I()},1e3):S.current&&cancelAnimationFrame(S.current)};return be.useEffect(()=>()=>{S.current&&cancelAnimationFrame(S.current),T.current&&T.current.pause()},[]),ge.jsxs("div",{className:"absolute inset-0 pointer-events-none flex flex-col justify-between p-6 z-10",children:[ge.jsxs("div",{className:"flex w-full justify-end items-start pointer-events-auto gap-4",children:[ge.jsxs("button",{onClick:C,disabled:g,className:`px-4 py-3 rounded border transition-all flex items-center gap-2 
              ${f?"bg-yellow-600/80 text-white border-white animate-pulse":"bg-black/50 text-yellow-500 border-yellow-600"}
              ${g?"opacity-50 cursor-not-allowed":""}
            `,children:[ge.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-5 w-5",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:ge.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"})}),ge.jsx("span",{children:g?"Loading...":f?"Music Playing":"Play Music"})]}),ge.jsxs("label",{className:"cursor-pointer group",children:[ge.jsx("input",{type:"file",multiple:!0,accept:"image/*",className:"hidden",onChange:A}),ge.jsxs("div",{className:"bg-emerald-900/80 hover:bg-emerald-800 text-yellow-400 border border-yellow-600 px-6 py-3 rounded shadow-[0_0_15px_rgba(255,215,0,0.3)] transition-all flex items-center gap-2",children:[ge.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-5 w-5",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:ge.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"})}),ge.jsx("span",{children:"Add Memories"})]})]}),ge.jsxs("button",{onClick:F,className:`px-6 py-3 rounded border transition-all flex items-center gap-2 ${r?"bg-yellow-600/80 text-white border-white":"bg-black/50 text-yellow-500 border-yellow-600"}`,children:[ge.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-5 w-5",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:ge.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"})}),r?"Disable Gestures":"Enable Gestures"]})]}),r&&ge.jsxs("div",{className:"absolute top-32 right-6 w-52 h-auto bg-black border-2 border-yellow-600 rounded overflow-hidden shadow-2xl pointer-events-auto",children:[ge.jsxs("div",{className:"h-36 relative",children:[ge.jsx($it,{ref:_,audio:!1,screenshotFormat:"image/jpeg",videoConstraints:{facingMode:"user"},className:"w-full h-full object-cover transform scale-x-[-1]"}),o&&ge.jsxs("div",{className:"absolute top-2 left-2 bg-black/60 px-2 py-1 rounded text-[10px] text-green-400 font-mono",children:["Val: ",c.toFixed(2)]})]}),ge.jsx("div",{className:"w-full bg-gray-900 p-3 text-xs text-yellow-100 border-t border-yellow-800",children:o?ge.jsxs("div",{className:"flex flex-col gap-1",children:[ge.jsxs("div",{className:"flex justify-between",children:[ge.jsx("span",{children:" Open Hand:"}),ge.jsxs("span",{className:c>1.5?"text-green-400 font-bold":"text-gray-500",children:["CHAOS (",">1.5",")"]})]}),ge.jsxs("div",{className:"flex justify-between",children:[ge.jsx("span",{children:" Fist:"}),ge.jsxs("span",{className:c<1.35?"text-green-400 font-bold":"text-gray-500",children:["TREE (","<1.35",")"]})]})]}):ge.jsxs("div",{className:"flex items-center gap-2",children:[ge.jsx("div",{className:"w-3 h-3 rounded-full bg-yellow-500 animate-pulse"}),"Loading AI Model..."]})})]}),ge.jsxs("div",{className:"flex flex-col items-center pointer-events-auto pb-10",children:[ge.jsxs("div",{className:"relative group cursor-pointer",onMouseDown:()=>s(!0),onMouseUp:()=>s(!1),onTouchStart:()=>s(!0),onTouchEnd:()=>s(!1),children:[ge.jsx("div",{className:`
                w-24 h-24 rounded-full border-4 flex items-center justify-center transition-all duration-500
                ${t===tu.CHAOS?"bg-red-900/80 border-red-500 scale-110":"bg-emerald-900/80 border-yellow-500"}
                shadow-[0_0_30px_rgba(255,215,0,0.4)]
             `,children:ge.jsx("span",{className:"text-3xl filter drop-shadow-lg",children:t===tu.CHAOS?"":""})}),ge.jsx("div",{className:"absolute -top-12 left-1/2 transform -translate-x-1/2 w-64 text-center",children:ge.jsx("p",{className:"text-yellow-200 text-sm font-bold uppercase tracking-widest bg-black/60 px-2 py-1 rounded",children:t===tu.CHAOS?"Releasing...":"Hold / Open Hand"})})]}),ge.jsxs("p",{className:"mt-4 text-gray-400 text-xs text-center max-w-md",children:["Use Camera Gestures or Hold Button to control. ",ge.jsx("br",{}),ge.jsx("span",{className:"text-yellow-500 font-bold",children:i})," Photos on Tree"]})]})]})},tGt=()=>{const[n,t]=be.useState(tu.FORMED),[e,s]=be.useState([]),[i,r]=be.useState({x:.5,y:.5}),a=be.useCallback(c=>{r({x:c.clientX/window.innerWidth,y:c.clientY/window.innerHeight})},[]);be.useEffect(()=>(window.addEventListener("mousemove",a),()=>window.removeEventListener("mousemove",a)),[a]);const o=c=>{const h=Array.from(c).map(f=>({id:Math.random().toString(36).substr(2,9),url:URL.createObjectURL(f),aspectRatio:1}));s(f=>[...f,...h])},l=c=>{t(c?tu.CHAOS:tu.FORMED)};return ge.jsxs("div",{className:"w-full h-screen bg-black overflow-hidden relative",children:[ge.jsxs(Bnt,{shadows:!0,camera:{position:_l.CAMERA_POS,fov:40},gl:{antialias:!1,toneMappingExposure:1.2},children:[ge.jsx("color",{attach:"background",args:["#050f0a"]}),ge.jsx("ambientLight",{intensity:1.5}),ge.jsx("spotLight",{position:[15,10,20],angle:.6,penumbra:1,intensity:1500,color:"#fff0dd",castShadow:!0}),ge.jsx("spotLight",{position:[-15,10,-15],angle:.6,penumbra:1,intensity:1500,color:"#e6f2ff"}),ge.jsx("spotLight",{position:[15,5,-10],intensity:1e3,color:"#ffd700"}),ge.jsx(Cit,{radius:100,depth:50,count:7e3,factor:4,saturation:0,fade:!0,speed:.5}),ge.jsx(wit,{enableZoom:!0,enableRotate:!1,enablePan:!1,minDistance:10,maxDistance:60}),ge.jsx(Rit,{state:n,photos:e,mousePos:i}),ge.jsxs(cit,{disableNormalPass:!0,children:[ge.jsx(hit,{luminanceThreshold:.4,mipmapBlur:!0,intensity:1.8,radius:.5}),ge.jsx(fit,{eskil:!1,offset:.1,darkness:.5})]})]}),ge.jsx(JVt,{currentState:n,onStateChange:t,onPhotoUpload:o,onManualInteract:l,photoCount:e.length})]})},XX=document.getElementById("root");if(!XX)throw new Error("Could not find root element to mount to");const eGt=Yj.createRoot(XX);eGt.render(ge.jsx(OD.StrictMode,{children:ge.jsx(tGt,{})}));
